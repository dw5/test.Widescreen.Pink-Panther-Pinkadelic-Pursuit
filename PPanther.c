/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

int __cdecl sub_401000(int a1, char a2, int a3, int a4);
char __cdecl sub_401050(unsigned int a1);
void __cdecl __noreturn sub_401080(char a1);
char sub_401140();
void *sub_4011B0();
unsigned int __cdecl sub_4011E0(int *a1);
int __cdecl sub_401250(int a1);
char __cdecl sub_401380(unsigned int a1);
int sub_401500();
char __cdecl sub_401520(int a1, unsigned int a2, unsigned int a3);
int __cdecl sub_401580(char a1);
_DWORD *__cdecl sub_4015B0(_DWORD *a1, _DWORD *a2);
unsigned int __cdecl sub_4015D0(unsigned int a1, int a2, int a3, int a4, int a5, unsigned int a6);
int __cdecl sub_401870(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6);
_BYTE *__cdecl sub_4019D0(_BYTE *a1, unsigned int a2, unsigned int a3);
int __cdecl sub_401A80(char *a1);
char __cdecl sub_401AB0(int a1, int a2, int a3, char *j);
int sub_401D10();
AGLFILE *__cdecl sub_401D60(int a1);
int __cdecl sub_401DB0(unsigned __int8 *a1, char a2, unsigned int a3, unsigned int a4, unsigned __int16 a5, unsigned __int16 a6);
int __cdecl sub_401E20(int a1, int a2, int a3);
char __cdecl sub_401E40(unsigned int a1);
int __cdecl sub_401E50(signed int a1, signed int a2, int a3, int a4, int a5);
int __cdecl sub_401F30(__int16 a1, int a2, int a3, int a4);
int __cdecl sub_402080(int a1);
int __cdecl sub_402100(int a1);
int __cdecl sub_4021A0(int a1);
int __cdecl sub_4022E0(int a1);
int __cdecl sub_402380(_DWORD *a1);
int __cdecl sub_402430(int a1);
int __cdecl sub_4024D0(int a1);
int __cdecl sub_402570(int a1);
int __cdecl sub_402610(int a1);
int __cdecl sub_4026B0(int a1);
int __cdecl sub_4027D0(int a1);
_DWORD *__cdecl sub_402980(_DWORD *a1, int a2);
_DWORD *__cdecl sub_4029B0(int a1, int a2);
int __cdecl sub_4029E0(_DWORD *a1);
int __cdecl sub_402A40(_DWORD *a1);
int __cdecl sub_402A60(int a1, int a2, _DWORD *a3, int a4);
void *sub_402A90();
char sub_402B00();
int __cdecl sub_402B20(int a1, unsigned int a2);
char sub_402B40();
void sub_402E60();
int __cdecl sub_402EB0(int a1);
int __cdecl sub_402EC0(int a1, int a2, int a3, int a4);
struct AGLIMAGE *__cdecl sub_402EE0(unsigned int a1, unsigned int a2);
void __cdecl sub_402F20(unsigned __int16 *a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5, int a6, int a7);
void *__cdecl sub_403070(unsigned __int16 *a1, unsigned int a2, int a3, int a4);
void *__cdecl sub_403120(unsigned __int16 *a1, unsigned int a2, int a3, int a4);
int __cdecl sub_4031D0(AGLIMAGE *, int, int, int, int, int, int, int, int); // idb
int __cdecl sub_403360(_DWORD *a1, _DWORD *a2);
char sub_4033A0();
int sub_4034F0();
struct AGLFILE *__cdecl sub_403630(int a1, char a2);
int __cdecl sub_403690(AGLFILE *); // idb
unsigned int __cdecl sub_4036A0(AGLFILE *a1, void *a2, unsigned int a3);
unsigned int __cdecl sub_4036D0(AGLFILE *a1, void *a2, unsigned int a3);
unsigned int __cdecl sub_403700(AGLFILE *a1);
void __stdcall sub_403710(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int); // idb
int __cdecl sub_403730(unsigned int a1);
LCID sub_403750();
char __cdecl sub_4037C0(int a1, LPCSTR lpWindowName, int a3, int a4, char a5);
LRESULT __cdecl sub_403990(LPCSTR lpText);
char *__cdecl sub_403A00(char *a1, int a2);
char *__cdecl sub_403A90(char *a1, char *a2);
int __stdcall sub_403AF0(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam); // idb
signed int __cdecl sub_403D10(int a1, char a2);
signed int sub_403E00();
int __stdcall sub_403F10(int, int); // weak
signed int __stdcall sub_403F40(int a1, int a2);
int sub_404000();
char __cdecl sub_404250(unsigned __int8 a1, unsigned __int8 a2);
int __cdecl sub_404340(unsigned __int8 a1);
int sub_404370();
char sub_4043C0();
int __cdecl sub_404450(int a1);
char sub_404470();
int __cdecl sub_404510(int a1);
char sub_404530();
char sub_4045A0();
int sub_404680();
int __cdecl sub_404730(int, LPSTR lpMultiByteStr); // idb
signed __int16 __cdecl sub_4047E0(char a1);
int sub_404900();
int __cdecl sub_404910(int a1, int a2);
int __cdecl sub_404930(int a1, int a2);
int __cdecl sub_404950(signed int a1, int a2, char a3);
int __cdecl sub_404D30(unsigned __int16 a1);
__int16 sub_404DD0();
char __cdecl sub_404ED0(unsigned __int8 a1);
char __cdecl sub_404F50(unsigned __int8 a1);
int sub_404FD0();
char __cdecl sub_405260(char a1);
char __cdecl sub_405550(char a1);
char __cdecl sub_405570(char a1);
AGLFILE *sub_4056A0();
int sub_405750();
// char __usercall sub_405830@<al>(int a1@<ebp>);
char sub_405DD0();
// char __usercall sub_405E10@<al>(int a1@<ebp>);
char __cdecl sub_405F60(unsigned __int8 a1);
unsigned int __cdecl sub_406AC0(int a1, int a2, char a3);
int __cdecl sub_406AF0(int a1, int a2);
int __cdecl sub_406D10(unsigned __int8 a1, int a2, int a3);
char sub_406E20();
char sub_407560();
signed __int64 sub_4078A0();
int sub_407920();
unsigned int __cdecl sub_407930(unsigned int a1, int a2, int a3);
unsigned int __cdecl sub_407A80(int a1);
int __cdecl sub_407AE0(int a1, int a2, int a3);
char __cdecl sub_407B60(char a1);
__int16 __cdecl sub_407B70(__int16 a1);
char __cdecl sub_407BB0(int a1);
char sub_407C10();
char sub_407C30();
int __cdecl sub_407C50(int a1, int a2, int a3);
char __cdecl sub_407CB0(int a1, int a2, float a3);
int __cdecl sub_407E00(int a1);
unsigned __int8 __cdecl sub_407E30(AGLSOUNDBUFFER **a1);
int __cdecl sub_407E50(AGLSOUNDBUFFER **a1);
int sub_407E60();
char __cdecl sub_407E80(char a1);
char *sub_407F70();
int sub_407FD0();
int __cdecl sub_407FF0(_DWORD *a1, _DWORD *a2);
int __cdecl sub_408010(__int16 a1, int a2);
int __cdecl sub_408060(__int16 a1, int a2);
int __cdecl sub_4080B0(__int16 a1, int a2);
float *__cdecl sub_408100(float *a1, float *a2, float *a3);
float *__cdecl sub_4081F0(float *a1, float *a2, float *a3);
double __cdecl sub_408330(float *a1, float *a2);
double __cdecl sub_4083C0(_DWORD); // weak
void __cdecl sub_4083F0(int *a1);
int __cdecl sub_408530(int, int, float, int); // idb
float *__cdecl sub_408600(float a1, int a2, int a3);
char __cdecl sub_408670(float a1, int a2, int a3);
_DWORD *__cdecl sub_408800(_DWORD *a1);
_DWORD *__cdecl sub_408830(_DWORD *a1);
__int16 __cdecl sub_408850(int a1, unsigned __int16 a2);
int __cdecl sub_408890(int a1, int a2);
char __cdecl sub_4088E0(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3);
int __cdecl sub_408930(int a1);
int __cdecl sub_408940(int a1, int a2);
_BYTE *__cdecl sub_4089F0(int a1);
unsigned int *__cdecl sub_408A30(unsigned int *a1);
int __cdecl sub_408A50(int a1);
int __cdecl sub_408B40(float *a1, int a2);
int __cdecl sub_408C50(unsigned int *a1);
char __cdecl sub_408C80(int a1);
int sub_408D30();
_DWORD *sub_408D80();
signed int sub_408DB0();
char __cdecl sub_408DC0(int *a1, unsigned int a2);
int __cdecl sub_408E20(float *a1, unsigned int a2, int a3);
void *__cdecl sub_408F60(float *a1, int a2, int a3);
char __cdecl sub_409070(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_4090E0(int a1);
char __cdecl sub_409100(unsigned __int16 a1, unsigned __int16 a2);
char __cdecl sub_409190(int a1, unsigned __int16 a2, unsigned __int16 a3);
int __cdecl sub_4091C0(int a1, int a2, int a3, int a4);
int __cdecl sub_409400(int a1, int a2, int a3, int a4);
int __cdecl sub_4096F0(int a1, int a2, int a3, int a4);
int __cdecl sub_4099B0(int a1, int a2, int a3, int a4);
int *__cdecl sub_409C80(int a1, char a2);
int *__cdecl sub_409CF0(char a1, int a2, int a3);
int __cdecl sub_409D20(int a1);
void __cdecl sub_409D30(_DWORD *a1, int a2, int a3, int a4);
char __cdecl sub_409F10(int a1, unsigned int a2);
char sub_409FA0();
char __cdecl sub_40A000(int a1);
void __cdecl sub_40A060(_DWORD *a1, _DWORD *a2, int a3, int a4);
char __cdecl sub_40A0B0(int a1, int a2);
char __cdecl sub_40A170(int a1, int a2);
char __cdecl sub_40A1B0(int a1, int a2);
char __cdecl sub_40A200(int a1, int a2);
char __cdecl sub_40A240(int a1, unsigned int a2);
signed int __cdecl sub_40A5E0(int a1);
char __cdecl sub_40A610(int a1);
char sub_40A6E0();
char __cdecl sub_40A730(int a1);
int __cdecl sub_40A790(int a1, __int16 a2, int a3);
char __cdecl sub_40A830(int a1);
char sub_40A890();
int __cdecl sub_40A8F0(int a1, int a2);
float *__cdecl sub_40A940(_DWORD *a1, int a2, float *a3);
float *__cdecl sub_40A9D0(int a1, int a2);
// float __usercall sub_40A9F0@<eax>(float *a1);
void __cdecl sub_40AB10(const void *a1);
char __cdecl sub_40AB30(int a1, int a2);
char __cdecl sub_40AB70(int a1);
char sub_40ABD0();
_BYTE *__cdecl sub_40AC20(unsigned int a1, int a2);
int sub_40AC80();
char __cdecl sub_40ACA0(int a1);
int __cdecl sub_40AD00(int, float); // idb
__int16 sub_40ADE0();
bool __cdecl sub_40B140(int a1, int a2, float a3);
int sub_40B1E0();
char sub_40B560();
char __cdecl sub_40B5B0(int a1);
char __cdecl sub_40B610(int a1, int a2, int a3);
int sub_40B660();
_DWORD *sub_40B8D0();
char *sub_40B900();
int __cdecl sub_40B920(int, float, float, float); // idb
int __cdecl sub_40B9B0(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, unsigned __int8 a5, unsigned __int8 a6, unsigned __int8 a7);
// void __usercall sub_40BA70(int a1@<ebx>);
// void __usercall sub_40BAB0(int a1@<ebx>, int a2);
char sub_40BD60();
int __cdecl sub_40BE40(int, float, int, int); // idb
int __cdecl sub_40BE60(int, float, int, int); // idb
int __cdecl sub_40BE80(int, float, int, int); // idb
int __cdecl sub_40BEA0(int, float, int, int); // idb
int __cdecl sub_40BEC0(int, float, int, int); // idb
int __cdecl sub_40BEE0(int, float, int, int); // idb
int __cdecl sub_40BF00(int, float, int, int, __int16); // idb
__int16 __cdecl sub_40BF30(_WORD *a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int16 a5);
int __cdecl sub_40BF90(_WORD *a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int16 a5);
_DWORD *sub_40BFD0();
int sub_40C1F0();
int __cdecl sub_40C270(float, float, float, int, int); // idb
int __cdecl sub_40C370(int a1, int a2);
__int16 __cdecl sub_40C3E0(int a1, int a2);
int __cdecl sub_40C520(int a1, int a2);
__int16 __cdecl sub_40C580(float a1, float a2);
__int16 __cdecl sub_40C730(int a1, int a2);
_DWORD *__cdecl sub_40C9D0(float a1, float a2, float a3, char a4, int a5, int a6);
_DWORD *__cdecl sub_40CA50(float a1, float a2, float a3, char a4, int a5, int a6);
int __cdecl sub_40CAD0(int a1);
__int16 __cdecl sub_40CB10(int a1, int a2);
int __cdecl sub_40CD50(int a1);
int __cdecl sub_40CD90(int a1, int a2);
int sub_40CFD0();
int __cdecl sub_40CFF0(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4, char a5, char a6, char a7);
char sub_40E6D0();
void __cdecl sub_40EA90(float a1, float a2, char a3);
unsigned int sub_40EC50();
int sub_40EC80();
char sub_40ECA0();
char sub_40F890();
char __cdecl sub_40F8B0(int a1, char a2);
char __cdecl sub_40FAF0(int a1);
bool __cdecl sub_410AC0(int a1, unsigned __int8 a2);
char __cdecl sub_410B10(int a1);
char sub_410E20();
char sub_410EC0();
int __cdecl sub_411010(int a1, int a2);
int __cdecl sub_411060(int a1, int a2);
int __cdecl sub_4111C0(int a1, float *a2);
__int16 __cdecl sub_411230(int a1, int a2);
char __cdecl sub_411420(int a1);
int __cdecl sub_411FD0(int a1, int a2, int a3);
bool __cdecl sub_412010(int a1);
void __cdecl sub_412040(int a1);
int __cdecl sub_4121D0(unsigned __int8 a1);
char __cdecl sub_4122C0(unsigned __int8 a1, char a2, unsigned __int8 a3);
char __cdecl sub_4124E0(int a1);
bool sub_412830();
int __cdecl sub_412850(int a1, float *a2, _WORD *a3);
char __cdecl sub_412900(int a1);
char *__cdecl sub_4129F0(int a1);
int __cdecl sub_412A40(int a1, _WORD *a2);
int __cdecl sub_412AA0(int, float, int, float, int); // idb
char __cdecl sub_412AF0(int a1);
char __cdecl sub_413790(int a1, char a2);
int __cdecl sub_413AD0(int a1);
int __cdecl sub_413B20(int a1, int a2);
char sub_413D10();
char __cdecl sub_413D30(int a1, char a2);
int __cdecl sub_413F90(int a1);
char __cdecl sub_4141C0(int a1);
void __cdecl sub_4151B0(int a1, float a2, char a3, int a4, int a5);
char __cdecl sub_415360(int a1, float a2, int a3, int a4);
char __cdecl sub_4155C0(int a1);
char __cdecl sub_415610(int a1, float a2, int a3);
char __cdecl sub_4157C0(int a1, float a2, int a3, int a4);
int __cdecl sub_415890(int a1, int a2);
void __cdecl sub_4158D0(int a1);
bool __cdecl sub_415990(int a1, float *a2);
int __cdecl sub_4159D0(int a1);
void __cdecl sub_415A20(int a1);
void __cdecl sub_415B50(int a1);
void __cdecl sub_415C00(int a1);
void __cdecl sub_415C80(int a1);
char __cdecl sub_415E20(float a1, float a2);
void __cdecl sub_416130(int a1);
void __cdecl sub_416160(int a1);
int sub_416610(); // weak
int __cdecl sub_416680(int a1);
unsigned int *__cdecl sub_4166E0(int a1);
int __cdecl sub_416710(int a1);
char __cdecl sub_416760(int a1);
char __cdecl sub_416790(int a1, float a2);
double __cdecl sub_4167F0(int a1);
char __cdecl sub_416840(int a1);
// bool __thiscall std::codecvt_base::do_always_noconv(std::codecvt_base *__hidden this); idb
char __cdecl sub_4168A0(int a1, char a2);
char __cdecl sub_416950(float *a1);
// bool __thiscall std::codecvt_base::do_always_noconv(std::codecvt_base *__hidden this); idb
int __cdecl sub_416990(int a1);
int __cdecl sub_4169B0(_DWORD *a1);
void sub_416A10();
char sub_416E40();
int sub_416FB0();
char __cdecl sub_416FD0(int a1);
char __cdecl sub_417040(int a1);
char sub_4170A0();
char __cdecl sub_417100(int a1, int a2);
char __cdecl sub_417140(int a1);
int sub_4171A0();
__int16 sub_4171C0();
char sub_417240();
__int16 __cdecl sub_4173E0(__int16 a1);
int __cdecl sub_417400(__int16 a1, int *a2, int a3);
int *__cdecl sub_417460(int a1);
// char __usercall sub_4174D0@<al>(char *a1@<ebx>, int a2);
char __cdecl sub_417680(int a1);
char __cdecl sub_417950(float a1);
char __cdecl sub_417B00(float a1);
char __cdecl sub_418020(char a1, char a2);
char __cdecl sub_4181C0(int a1);
char __cdecl sub_418B90(int a1);
char __cdecl sub_418D40(int a1);
char __cdecl sub_419200(int a1);
int *sub_419450();
char __cdecl sub_4194A0(int *a1, int *a2, __int16 a3, _BYTE *a4);
unsigned int *sub_419520();
char __cdecl sub_419630(int a1);
int __cdecl sub_419640(int a1, char a2);
unsigned int *__cdecl sub_419660(int a1);
int sub_419690();
int __cdecl sub_419700(int, int, int, int, int, int, int, int, float, int, float); // idb
char __cdecl sub_419760(int a1);
bool __cdecl sub_419A00(int a1);
char __cdecl sub_419A30(float a1);
char __cdecl sub_419D60(int a1, float *a2, unsigned int a3);
char __cdecl sub_419EC0(int a1, char a2);
int sub_41A010(); // weak
void sub_41A540();
void sub_41A640();
void sub_41A720();
void __cdecl sub_41AB30(float *a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4);
char __cdecl sub_41ABD0(char a1);
char __cdecl sub_41AC70(int a1, char a2, float *a3);
int sub_41AD70();
int sub_41ADA0();
_DWORD *sub_41AE60();
char __cdecl sub_41AEA0(int a1);
char __cdecl sub_41AF60(float a1);
_DWORD *sub_41BAF0();
bool sub_41BB30();
char __cdecl sub_41BB60(char a1);
char sub_41BB80();
void sub_41BBD0();
char __cdecl sub_41BBF0(unsigned __int8 a1);
char sub_41BE80();
void sub_41BF80();
char __cdecl sub_41CE10(int a1);
void sub_41CE90();
signed int __cdecl sub_41DD10(signed int a1);
int sub_41DD40();
int __cdecl sub_41E780(int a1);
__int16 __cdecl sub_41E7B0(float *a1, int a2, int a3);
__int16 sub_41E960();
char __cdecl sub_41EAE0(float *a1);
int sub_41EB70(); // weak
char __cdecl sub_41ED70(unsigned __int8 a1);
char sub_41EE40();
int __cdecl sub_41EF70(int a1);
int sub_41EFC0();
int __cdecl sub_41F120(int *a1);
int sub_41F160();
bool sub_41F2C0();
char sub_41F2E0();
int *sub_41F320();
int sub_41F350();
void sub_41F400();
double __cdecl sub_41F420(float *a1, float *a2);
int sub_41F470();
char __cdecl sub_41F530(unsigned __int16 a1);
char sub_41F5D0();
int __cdecl sub_41F610(int a1);
// float __usercall sub_41F740@<eax>(int a1);
bool __cdecl sub_41F7E0(int a1);
// float __usercall sub_41F870@<eax>();
char __cdecl sub_41F8D0(int a1);
int sub_41F920();
void __cdecl sub_41F940(int a1);
void sub_41FA40();
void sub_41FB00();
// float __usercall sub_41FBC0@<eax>();
char *sub_41FC40();
int sub_41FC90();
char __cdecl sub_41FCE0(char a1);
char sub_41FDB0();
char sub_41FE80();
char sub_41FEC0();
int __cdecl sub_41FEF0(int a1, unsigned __int16 a2);
int __cdecl sub_4206D0(int a1);
char sub_420710();
char __cdecl sub_420750(int a1);
char __cdecl sub_420CE0(char *a1, unsigned int a2);
signed int sub_420DF0();
signed int __cdecl sub_420E50(float *a1, unsigned __int16 a2);
int __cdecl sub_420EC0(int a1, int a2, char a3);
float *__cdecl sub_421110(unsigned __int8 *a1, float *a2);
double __cdecl sub_4212B0(float a1);
signed int __cdecl sub_4212F0(int a1, unsigned __int16 a2);
int __cdecl sub_421470(unsigned __int16 a1);
int __cdecl sub_421510(int a1, int a2, char a3);
float *__cdecl sub_421730(unsigned __int8 *a1, float *a2);
int __cdecl sub_421890(int a1, int a2, char a3);
float *__cdecl sub_421B30(unsigned __int8 *a1, float *a2);
__int16 __cdecl sub_421CD0(unsigned __int16 a1);
char __cdecl sub_421E80(unsigned __int16 a1);
char __cdecl sub_421FE0(int a1);
char __cdecl sub_422050(unsigned __int16 a1);
int __cdecl sub_4220F0(unsigned __int16 a1);
__int16 __cdecl sub_422160(unsigned __int16 a1);
char __cdecl sub_4221E0(unsigned __int16 a1);
char __cdecl sub_422270(unsigned __int16 a1, int a2, int a3);
signed int __cdecl sub_4225B0(int a1, unsigned __int16 a2);
int __cdecl sub_4226C0(int a1, unsigned __int16 a2);
signed int __cdecl sub_422750(int a1, unsigned __int16 a2);
__int16 __cdecl sub_4227F0(int a1, unsigned __int16 a2);
char __cdecl sub_422890(int a1);
int sub_4228E0();
char __cdecl sub_422900(int a1);
int sub_422950();
char __cdecl sub_422970(int a1);
int sub_4229D0();
double __cdecl sub_4229F0(float *a1, float *a2);
char __cdecl sub_422A10(float a1, int a2, int a3);
char __cdecl sub_422AC0(float *a1, int a2, int a3);
bool __cdecl sub_422E60(float *a1, float *a2);
bool __cdecl sub_422EC0(float a1, int a2, int a3, char a4);
char __cdecl sub_423120(float *a1, int a2);
char __cdecl sub_423300(float *a1, int a2, float *a3);
int __cdecl sub_4234A0(unsigned __int16 *a1, int a2);
void sub_423580();
char __cdecl sub_423630(int a1, int a2, __int16 a3, __int16 a4);
int sub_423CE0();
char __cdecl sub_423CF0(int a1, __int16 a2);
char __cdecl sub_423E90(int a1);
char sub_423F10();
int __cdecl sub_424E30(__int16 a1, unsigned __int16 a2, float *a3);
char sub_424F80();
int __cdecl sub_425A50(__int16 a1, unsigned __int16 a2, unsigned __int8 a3, unsigned __int8 a4, char a5, char a6, char a7, char a8);
int sub_425E80();
int sub_425ED0();
char __cdecl sub_425F30(char a1);
char sub_4263E0();
char sub_4266A0();
char sub_4266C0();
// float __usercall sub_426880@<eax>(char a1);
unsigned int __cdecl sub_426970(char a1);
char sub_426DF0();
char __fastcall sub_426E10(int a1);
// float __usercall sub_4270A0@<eax>();
char sub_4270F0();
int sub_428550();
// int __usercall sub_428920@<eax>(int a1@<edi>, int a2, unsigned __int16 a3, unsigned __int16 a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8);
int __cdecl sub_428C70(__int16 a1, unsigned __int16 a2, unsigned __int8 a3, unsigned __int8 a4, __int16 a5, unsigned __int8 a6, char a7);
int __cdecl sub_429280(__int16 a1, unsigned __int16 a2, unsigned __int8 a3, unsigned __int8 a4, char a5);
int __cdecl sub_429580(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3);
int sub_429770();
char sub_429CB0();
unsigned __int8 sub_429CD0();
int sub_429F80();
int __cdecl sub_42A870(unsigned __int16 a1, unsigned __int16 a2);
char sub_42AFC0();
int sub_42B670();
char __cdecl sub_42C0B0(int a1);
char __cdecl sub_42C1E0(int a1);
char __cdecl sub_42C510(int a1);
char __cdecl sub_42C570(int a1);
char __cdecl sub_42C5F0(char a1);
// int __usercall sub_42C650@<eax>(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, HWND hWnd, int a5);
void sub_42C8C0();
void sub_42C920();
int sub_42CBA0();
int __cdecl sub_42CBE0(int a1, char a2);
int __cdecl sub_42CC10(int a1);
int __cdecl sub_42CC70(int a1);
int __cdecl sub_42CCD0(int a1);
int __cdecl sub_42CCF0(int, float); // idb
int __cdecl sub_42CD30(int, float); // idb
char __cdecl sub_42CD40(int a1, float a2);
int __cdecl sub_42CDC0(int, float); // idb
char __cdecl sub_42CDE0(int a1);
int __cdecl sub_42CEF0(int a1, __int16 a2);
void __cdecl sub_42CF10(int a1);
// int __usercall sub_42D090@<eax>(int a1@<ebx>, int a2, __int16 a3);
int __cdecl sub_42D0F0(int a1);
int __cdecl sub_42D130(int a1, int a2);
char __cdecl sub_42D1A0(float a1);
void __cdecl sub_42D3D0(int a1);
void __cdecl sub_42D4A0(int a1, int a2, float a3);
char __cdecl sub_42DAD0(int a1, float a2, float a3, float a4);
int __cdecl sub_42DB20(int a1, int a2, int a3, int a4);
double __cdecl sub_42DCD0(int a1, float *a2);
bool __cdecl sub_42DD10(int a1, _DWORD *a2, int *a3, int *a4, int *a5);
double __cdecl sub_42DFF0(float *a1, _DWORD *a2, int *a3, int *a4, float *a5);
double __cdecl sub_42E1F0(int a1, int a2, float *a3, float *a4);
char __cdecl sub_42E3E0(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
char __cdecl sub_42E490(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
double __cdecl sub_42E530(int a1, int a2, float *a3, unsigned int *a4, float *a5);
char sub_42E5A0();
_WORD *sub_42E690();
char __cdecl sub_42E6C0(unsigned __int16 a1, unsigned __int16 a2, int a3, _BYTE *a4);
char sub_42E8E0();
char sub_42E960();
char sub_42E9D0();
int __cdecl sub_42EA40(int a1, _BYTE *a2);
int sub_42EAA0(); // weak
void sub_42EC80();
char __cdecl sub_42F360(int a1, int a2, float a3, float a4);
char sub_42FC40();
char sub_42FEC0();
char sub_42FF60();
void __cdecl sub_42FFA0(float a1);
char __cdecl sub_42FFD0(char a1, char a2);
int __cdecl sub_430050(float); // idb
int sub_4300B0();
void __cdecl sub_430130(_DWORD *a1);
int sub_430210();
unsigned __int8 __cdecl sub_430230(int a1, float a2, char a3);
void __cdecl sub_430420(float a1);
void __cdecl sub_430630(float a1, float a2);
void sub_4307E0();
bool __cdecl sub_430C80(int a1, float a2, int a3, float a4);
double __cdecl sub_430D30(int a1, int a2, float a3);
void sub_430DD0();
char __cdecl sub_430F60(char a1, char a2, float *a3);
void sub_430FD0();
_DWORD *sub_4314E0();
int sub_4315A0();
int __cdecl sub_431610(int a1);
int sub_431920();
__int16 __cdecl sub_431960(float *a1, char a2, char *a3);
char sub_431B50();
bool sub_431B70();
bool sub_431BB0();
char sub_431C40();
char __cdecl sub_431C80(int a1);
char __cdecl sub_431CC0(char a1, char a2);
// float __usercall sub_431E70@<eax>(char a1, char a2);
char __cdecl sub_431F50(int a1);
int sub_431FC0();
char sub_432020();
int sub_432130();
char sub_432250();
int __cdecl sub_432980(__int16 a1);
int sub_4329B0();
char sub_4329E0();
char __cdecl sub_432A80(unsigned __int8 a1);
int __cdecl sub_432BA0(int a1, int a2);
__int16 __cdecl sub_432BF0(int a1, int a2);
int __cdecl sub_432C50(int a1, int a2);
__int16 __cdecl sub_432CA0(int a1, int a2);
int __cdecl sub_432D00(int a1);
__int16 __cdecl sub_432D70(int a1, int a2);
int __cdecl sub_432F40(int a1, float *a2, char a3);
int __cdecl sub_432FF0(int, float); // idb
unsigned int __cdecl sub_433180(_DWORD *a1, char a2);
int __cdecl sub_433210(char a1);
void __cdecl sub_433340(unsigned __int8 a1, char a2);
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd);
_DWORD __cdecl sub_433490(_DWORD); // weak
int sub_433620(void); // weak
__int16 sub_433640();
// float __usercall sub_433660@<eax>();
// int __inc_tmpoff(); weak
int sub_4336A0();
int __cdecl sub_4336F0(__int16 a1);
int sub_433720();
void sub_433750();
void *__cdecl sub_433760(int a1, unsigned int a2);
char __cdecl sub_4338A0(int a1);
int __cdecl sub_433900(unsigned int a1, char a2, char a3);
int sub_434400();
char *sub_434490();
char __cdecl sub_434500(unsigned __int8 a1);
char sub_434530();
char sub_434550();
int sub_434560();
int __cdecl sub_434580(__int16 a1, __int16 a2);
__int16 sub_4345A0();
int sub_4345F0();
int __cdecl sub_434690(unsigned __int8 a1, char a2);
char sub_4346F0();
bool sub_4348E0();
bool sub_434900();
bool sub_434920();
int __cdecl nullsub_1(_DWORD); // weak
int __cdecl sub_434E10(int a1);
int sub_434E30();
// int _cfltcvt_init_27(void); weak
// void *__cdecl malloc(size_t);
// void __cdecl free(void *);
// int __cdecl atol(const char *);
int __cdecl sub_434FDF(char *); // idb
// int __cdecl toupper(int);
// int sprintf(char *, const char *, ...);
// char *__cdecl strstr(const char *, const char *);
// int __cdecl strncmp(const char *, const char *, size_t);
// int __cdecl rand();
int __cdecl sub_435281(int a1, int a2);
// int _setdefaultprecision(void); weak
// int _ms_p5_mp_test_fdiv(void); weak
// int __cdecl _output(FILE *, int, int); idb
// _DWORD __cdecl _lock_file2(_DWORD, _DWORD); weak
// _DWORD __cdecl _unlock_file2(_DWORD, _DWORD); weak
// _DWORD __cdecl _stbuf(_DWORD); weak
// _DWORD __cdecl _ftbuf(_DWORD, _DWORD); weak
// _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_43841A(int a1, int a2);
int __cdecl sub_438430(int a1, int a2);
int __cdecl sub_438446(int a1, int a2);
int __cdecl sub_438473(int a1, int a2);
int sub_43988D();
// _DWORD __cdecl flsall(_DWORD); weak
// _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _strcmpi(const char *, const char *);
// int __stdcall DirectInput8Create(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __thiscall AGLSCREEN::Flip(AGLSCREEN *this, int, int); idb
// struct AGLIMAGE *__thiscall AGLSCREEN::CreateImage(AGLSCREEN *this, unsigned int, unsigned int, unsigned __int8, unsigned __int16); idb
// int __thiscall AGLSCREEN::SetDisplayMode(AGLSCREEN *this, unsigned int, unsigned int, unsigned __int8, unsigned __int8); idb
// int __cdecl AGLGetLastError(); idb
// struct AGLSCREEN *__cdecl AGLCreateScreen(HWND, unsigned __int8); idb
// struct AGLIMAGE *__thiscall AGLSCREEN::GetBackImage(AGLSCREEN *this); idb
// int __thiscall AGLIMAGE::ReleaseSurface(AGLIMAGE *this); idb
// unsigned __int8 *__thiscall AGLIMAGE::GetSurface(AGLIMAGE *this); idb
// int __thiscall AGLFILE::Close(AGLFILE *this); idb
// struct AGLFILE *__cdecl AGLOpenFile(char *, unsigned int, unsigned int); idb
// int __thiscall AGLFILE::Read(AGLFILE *this, void *, unsigned int, unsigned int *); idb
// int __thiscall AGLFILE::Write(AGLFILE *this, void *, unsigned int, unsigned int *); idb
// unsigned int __thiscall AGLFILE::GetSize(AGLFILE *this); idb
// int __thiscall AGLTIMER::SetDelay(AGLTIMER *this, int); idb
// int __thiscall AGLTIMER::Start(AGLTIMER *this, void (__stdcall *)(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int)); idb
// struct AGLTIMER *__cdecl AGLCreateTimer(); idb
// int __thiscall AGLTIMER::Delete(AGLTIMER *this); idb
// int __thiscall AGLTIMER::Stop(AGLTIMER *this); idb
// int __thiscall AGLSCREEN::PlayCDAudioTrack(AGLSCREEN *this, unsigned __int8); idb
// int __thiscall AGLSCREEN::StopCDAudio(AGLSCREEN *this); idb
// int __thiscall AGLSCREEN::RestoreAllImages(AGLSCREEN *this, int (__cdecl *)(struct AGLSCREEN *, struct AGLIMAGE *)); idb
// struct AGLFILE *__cdecl AGLCreateFile(char *, unsigned int); idb
// int __thiscall AGLSCREEN::EnableSoundManager(AGLSCREEN *this, unsigned int, char *); idb
// int __thiscall AGLSCREEN::DisableSoundManager(AGLSCREEN *this); idb
// int __thiscall AGLSOUNDBUFFER::SetVolume(AGLSOUNDBUFFER *this, int); idb
// int __thiscall AGLSOUNDBUFFER::SetPan(AGLSOUNDBUFFER *this, int); idb
// int __thiscall AGLSOUNDBUFFER::SetData(AGLSOUNDBUFFER *this, unsigned __int8 *, unsigned int); idb
// struct AGLSOUNDBUFFER *__thiscall AGLSCREEN::CreateSoundBuffer(AGLSCREEN *this, unsigned __int8, unsigned int, unsigned int); idb
// int __thiscall AGLSCREEN::SetCDAudioVolume(AGLSCREEN *this, int); idb
// int __thiscall AGLSCREEN::PauseCDAudio(AGLSCREEN *this); idb
// float __cdecl AGLSqrt(float); idb
// int __thiscall AGLSOUNDBUFFER::Play(AGLSOUNDBUFFER *this, unsigned __int8); idb
// unsigned __int8 __thiscall AGLSOUNDBUFFER::IsPlaying(AGLSOUNDBUFFER *this); idb
// int __thiscall AGLSOUNDBUFFER::Stop(AGLSOUNDBUFFER *this); idb
// int __thiscall AGLSCREEN::SetViewport(AGLSCREEN *this, unsigned int, unsigned int, unsigned int, unsigned int); idb
// void __thiscall AGLVECTOR::CrossProduct(AGLVECTOR *this, struct AGLVECTOR *, struct AGLVECTOR *); idb
// float __thiscall AGLVECTOR::Normalize(AGLVECTOR *this); idb
// HANDLE __stdcall CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName);
// DWORD __stdcall GetLastError();
// int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// HRSRC __stdcall FindResourceA(HMODULE hModule, LPCSTR lpName, LPCSTR lpType);
// HGLOBAL __stdcall LoadResource(HMODULE hModule, HRSRC hResInfo);
// LPVOID __stdcall LockResource(HGLOBAL hResData);
// LCID __stdcall GetUserDefaultLCID();
// LPSTR __stdcall GetCommandLineA();
// UINT __stdcall SetErrorMode(UINT uMode);
// BOOL __stdcall GetVolumeInformationA(LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize);
// BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect);
// BOOL __stdcall AdjustWindowRectEx(LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle);
// HWND __stdcall CreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// HICON __stdcall LoadIconA(HINSTANCE hInstance, LPCSTR lpIconName);
// int __stdcall ShowCursor(BOOL bShow);
// ATOM __stdcall RegisterClassA(const WNDCLASSA *lpWndClass);
// HCURSOR __stdcall LoadCursorA(HINSTANCE hInstance, LPCSTR lpCursorName);
// BOOL __stdcall UnregisterClassA(LPCSTR lpClassName, HINSTANCE hInstance);
// BOOL __stdcall DestroyWindow(HWND hWnd);
// LRESULT __stdcall SendMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// int __stdcall MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
// LRESULT __stdcall DefWindowProcA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// BOOL __stdcall EndPaint(HWND hWnd, const PAINTSTRUCT *lpPaint);
// HDC __stdcall BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint);
// void __stdcall PostQuitMessage(int nExitCode);
// LRESULT __stdcall DispatchMessageA(const MSG *lpMsg);
// BOOL __stdcall PeekMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
// BOOL __stdcall WaitMessage();
// HRESULT __stdcall CoCreateInstance(const IID *const rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, const IID *const riid, LPVOID *ppv);
// HRESULT __stdcall CoInitialize(LPVOID pvReserved);
// void __stdcall CoUninitialize();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_43D888; // weak
_UNKNOWN unk_43D938; // weak
_UNKNOWN unk_43D948; // weak
_UNKNOWN unk_43D9F8; // weak
_UNKNOWN unk_43E3B8; // weak
_UNKNOWN unk_43E3C8; // weak
_UNKNOWN unk_43E3D8; // weak
_UNKNOWN unk_43E3E8; // weak
_UNKNOWN unk_43E3F8; // weak
IID rclsid = { 3828804531u, 21071u, 4558u, { 159u, 83u, 0u, 32u, 175u, 11u, 167u, 112u } }; // idb
IID riid = { 1453877417u, 2772u, 4558u, { 176u, 58u, 0u, 32u, 175u, 11u, 167u, 112u } }; // idb
_UNKNOWN unk_43E614; // weak
_UNKNOWN unk_43E81C; // weak
CHAR Text[] = "ERROR_NOT_ENOUGH_MEMORY"; // idb
int dword_440180 = 1; // weak
int dword_440184[] = { 0 }; // weak
char aInvalidPrimiti[27] = "Invalid Primitive type !!!"; // weak
char aErrorCanTCreat_0[39] = "ERROR : Can't create Texture Page #%d\n"; // weak
CHAR aErrorVideoMem[] = "ERROR_VIDEO_MEM"; // idb
CHAR aErrorNo3dAccel[] = "ERROR_NO_3D_ACCEL"; // idb
char aTotalVideoMemD[24] = "\tTotal Video Mem : %d\n\n"; // weak
char aAgpEnabledS[24] = "\tAGP Enabled     : %s\n\n"; // weak
char a3dAcceleration[23] = "\t3D Acceleration : %s\n"; // weak
char aVideoInitialis[29] = "Video Initialisation done :\n"; // weak
char aErrorCanTCreat[34] = "ERROR : Can't create Screen : %d\n"; // weak
char aSS[] = "%s%s"; // idb
char aPpanther[] = "PPanther"; // idb
char asc_4402E8[] = ".\\"; // idb
char aIco[5] = ".ico"; // weak
CHAR WindowName[] = "Pinky"; // idb
char aPathS[10] = "Path %s \n"; // weak
char asc_44030C[2] = "\\"; // weak
char aRelease_0[9] = "\\release"; // weak
char aRelease[] = "\\Release"; // idb
void *off_440328 = &unk_440354; // weak
char aErrorCanTRegis[30] = "ERROR : Can't Register Class\n"; // weak
CHAR ClassName[] = "PinkyClass"; // idb
CHAR Caption[] = "PPANTHER"; // idb
CHAR Type[] = "ERROR_STRING"; // idb
char aSS_0[] = "%s_%s"; // idb
char off_4403A8[] = { 'E', 'N', 'D', '\0' }; // idb
char aRetourRestaura[29] = "Retour restauration app %d \n"; // weak
char aFocusRetrouver[17] = "Focus retrouver\n"; // weak
char aPerteDuFocus[16] = "Perte du Focus\n"; // weak
_UNKNOWN unk_4403F0; // weak
_UNKNOWN unk_440400; // weak
char aLoadPadD[13] = "Load PAD %d\n"; // weak
char aDataSavePinkyC[] = "Data\\Save\\Pinky.cfg"; // idb
char aCreationFichie[21] = "Création Fichier %d\n"; // weak
char aSauvegardeD[15] = "Sauvegarde %d\n"; // weak
char aLjoyminyDLjoym[34] = "    lJoyMinY : %d\t\tlJoyMaxY : %d\n"; // weak
char aLjoyminxDLjoym[34] = "    lJoyMinX : %d\t\tlJoyMaxX : %d\n"; // weak
char aFoundJoystickS[19] = "Found Joystick %s\n"; // weak
char aFoundKeyboardS[19] = "Found Keyboard %s\n"; // weak
char byte_440D6C = '\n'; // weak
int dword_440D84[8] = { 16, 4096, 128, 32768, 32, 8192, 64, 4096 }; // idb
char aSSS_0[9] = "%s %s %s"; // weak
char aSSS[8] = "%s%s %s"; // weak
char aSSSSS[12] = "%s%s%s%s %s"; // weak
char aDataLocalDPsk[] = "data/local/%d.psk"; // idb
char aDataLocalIcone[] = "data/local/icone%d.psk"; // idb
char aSaveOptionsD[17] = "Save Options %d\n"; // weak
char aDataGraphBack2[23] = "data/Graph/back256.tex"; // weak
char aS[3] = "%s"; // weak
char aSD[6] = "%s %d"; // weak
char aDSD[9] = "%d %s %d"; // weak
char aTooMuchGt4ForO[30] = "Too much GT4 for objects !!!\n"; // weak
char aTooMuchGt3ForO[30] = "Too much GT3 for objects !!!\n"; // weak
char byte_440E72[] = { '\0' }; // weak
char byte_440E73[] = { '\0' }; // weak
char byte_440E74[] = { '\0' }; // weak
char byte_440E75[19] =
{
  '¼',
  ' ',
  '¼',
  '@',
  '¼',
  '`',
  '¼',
  '€',
  '¼',
  ' ',
  '¼',
  'À',
  '¼',
  'à',
  '¼',
  '\0',
  'Ü',
  ' ',
  'Ü'
}; // idb
char byte_440E88 = '\x01'; // weak
char byte_440E89 = '\x14'; // weak
char aValueD[10] = "Value %d\n"; // weak
char aDeplacementNeg[21] = "Deplacement Négatif\n"; // weak
char aDeplacementPos[21] = "Deplacement Positif\n"; // weak
char aLratioD[11] = "lratio %d\n"; // weak
char aDataSoundSound[21] = "data/Sound/Sound.psk"; // weak
char aDataGraphImage[21] = "data/graph/image.psk"; // weak
int dword_440F04 = 1; // weak
char byte_440FB8[5] = { '\x19', '\x0F', '\x1E', '\x19', '\x19' }; // idb
char byte_440FBD = '\x12'; // weak
char byte_440FC8[] = { '\x7F' }; // weak
char byte_440FC9[] = { '\x7F' }; // weak
char byte_440FCA[] = { '\x7F' }; // weak
char byte_440FCB[] = { '\0' }; // weak
char byte_440FCC[55] =
{
  '®',
  '\x7F',
  '\x7F',
  '\x7F',
  '\0',
  '®',
  '\x7F',
  '\x7F',
  '\x7F',
  '(',
  '®',
  '\x7F',
  '\x7F',
  '\x7F',
  '(',
  '®',
  'p',
  '\x7F',
  '\x7F',
  'P',
  '®',
  'p',
  '\x7F',
  '\x7F',
  'P',
  '®',
  '\x7F',
  '\x7F',
  '\x7F',
  'x',
  '®',
  '\x7F',
  '\x7F',
  '\x7F',
  'x',
  '®',
  '\x7F',
  '\x7F',
  '\x7F',
  ' ',
  '®',
  '\x7F',
  '\x7F',
  '\x7F',
  ' ',
  '®',
  '\x7F',
  '\x7F',
  '\x7F',
  'È',
  '®',
  '\x7F',
  '\x7F',
  '\x7F',
  'È'
}; // idb
__int16 word_441004 = 110; // weak
int dword_441008[] = { 265 }; // weak
char aVD[6] = "v:%d\n"; // weak
char asc_441214[3] = "+\n"; // weak
char aFlagsD[15] = ">> flags : %d\n"; // weak
char aBoom[9] = " BOOM !\n"; // weak
char asc_441234[31] = "+++++++++++++++++++++++++++++\n"; // weak
char byte_441254[] = { '\x7F' }; // weak
char byte_441255[] = { '\x7F' }; // weak
char byte_441256[] = { '\x7F' }; // weak
char byte_441257[] = { '\0' }; // weak
char byte_441258[20] =
{
  '\x10',
  '\x7F',
  '\x7F',
  '_',
  '0',
  '\x10',
  'p',
  '_',
  '?',
  '`',
  '\x10',
  'a',
  'A',
  '\x1F',
  '\x90',
  '\x10',
  '/',
  '\n',
  '\0',
  'À'
}; // idb
char byte_441270[] = { '\x7F' }; // weak
char byte_441271[] = { '\x7F' }; // weak
char byte_441272[] = { '\x7F' }; // weak
char byte_441273[] = { '8' }; // weak
char byte_441274[40] =
{
  '@',
  '\x7F',
  '\x7F',
  '\x7F',
  'X',
  '@',
  '\x7F',
  '\x7F',
  '\x7F',
  'x',
  '@',
  '\x7F',
  '\x7F',
  '\x7F',
  '˜',
  '@',
  'p',
  '\x7F',
  '\x7F',
  '¸',
  '@',
  'p',
  '\x7F',
  '\x7F',
  'Ø',
  '@',
  '\x7F',
  '\x7F',
  '\x7F',
  '\0',
  '`',
  '\x7F',
  '\x7F',
  '\x7F',
  ' ',
  '`',
  '\x7F',
  '\x7F',
  '\x7F',
  '@'
}; // idb
__int16 word_44129C[4] = { 32608, 32639, 24672, 0 }; // idb
int dword_4412A4 = 1135542272; // weak
int dword_4412A8 = 3280568320; // weak
char aDataSavePinkyP[20] = "Data\\Save\\Pinky.pnk"; // weak
char aNbclutD[12] = "\tNbClut %d\n"; // weak
char aNbtpageD[13] = "\tNbTPage %d\n"; // weak
char asc_4412E4[39] = "-------------------------------------\n"; // weak
char aOpeningS[12] = "Opening %s\n"; // weak
char asc_441318[2] = "\n"; // weak
char aLoadingObjectS[19] = "Loading Object %s\n"; // weak
char aLoadingBlocD[17] = "Loading Bloc %d\n"; // weak
char aItemDLoadingMe[29] = "Item : %d - Loading Mesh %s\n"; // weak
char aDD[5] = "%d%d"; // weak
char aRetry[7] = "retry\n"; // weak
char aDataGraphGaler[] = "data/graph/galerie/%d.tex"; // idb
char aDebugVideoEcGr[32] = "Debug Video : EC_GRAPH_CHANGED\n"; // weak
char aDebugVideoEcSn_0[34] = "Debug Video : EC_SNDDEV_IN_ERROR\n"; // weak
char aDebugVideoEcSn[35] = "Debug Video : EC_SNDDEV_OUT_ERROR\n"; // weak
char aDebugVideoUnko[26] = "Debug Video : unkown %d \n"; // weak
char aDebugVideoEcSt_4[32] = "Debug Video : EC_STEP_COMPLETE\n"; // weak
char aDebugVideoEcWi[35] = "Debug Video : EC_WINDOW_DESTROYED\n"; // weak
char aDebugVideoEcVi[37] = "Debug Video : EC_VIDEO_SIZE_CHANGED\n"; // weak
char aDebugVideoEcUs[28] = "Debug Video : EC_USERABORT\n"; // weak
char aDebugVideoEcSt_3[39] = "Debug Video : EC_STREAM_ERROR_STOPPED\n"; // weak
char aDebugVideoEcSt_2[44] = "Debug Video : EC_STREAM_ERROR_STILLPLAYING\n"; // weak
char aDebugVideoEcSt_1[41] = "Debug Video : EC_STREAM_CONTROL_STOPPED\n"; // weak
char aDebugVideoEcSt_0[41] = "Debug Video : EC_STREAM_CONTROL_STARTED\n"; // weak
char aDebugVideoEcSt[29] = "Debug Video : EC_STARVATION\n"; // weak
char aDebugVideoEcSh[32] = "Debug Video : EC_SHUTTING_DOWN\n"; // weak
char aDebugVideoEcSe[34] = "Debug Video : EC_SEGMENT_STARTED\n"; // weak
char aDebugVideoEcRe[26] = "Debug Video : EC_REPAINT\n"; // weak
char aDebugVideoEcQu[33] = "Debug Video : EC_QUALITY_CHANGE\n"; // weak
char aDebugVideoEcPa_0[25] = "Debug Video : EC_PAUSED\n"; // weak
char aDebugVideoEcPa[34] = "Debug Video : EC_PALETTE_CHANGED\n"; // weak
char aDebugVideoEcOp[31] = "Debug Video : EC_OPENING_FILE\n"; // weak
char aDebugVideoEcOl[28] = "Debug Video : EC_OLE_EVENT\n"; // weak
char aDebugVideoEcNo[32] = "Debug Video : EC_NOTIFY_WINDOW\n"; // weak
char aDebugVideoEcNe[31] = "Debug Video : EC_NEED_RESTART\n"; // weak
char aDebugVideoEcFu[34] = "Debug Video : EC_FULLSCREEN_LOST\n"; // weak
char aDebugVideoEcEr_0[29] = "Debug Video : EC_ERRORABORT\n"; // weak
char aDebugVideoEcEr[37] = "Debug Video : EC_ERROR_STILLPLAYING\n"; // weak
char aDebugVideoEcEn[33] = "Debug Video : EC_END_OF_SEGMENT\n"; // weak
char aDebugVideoEcDi[34] = "Debug Video : EC_DISPLAY_CHANGED\n"; // weak
char aDebugVideoEcDe[30] = "Debug Video : EC_DEVICE_LOST\n"; // weak
char aDebugVideoEcCo[27] = "Debug Video : EC_COMPLETE\n"; // weak
char aDebugVideoEcCl[32] = "Debug Video : EC_CLOCK_CHANGED\n"; // weak
char aDebugVideoEcBu[33] = "Debug Video : EC_BUFFERING_DATA\n"; // weak
char aDebugVideoEcAc[27] = "Debug Video : EC_ACTIVATE\n"; // weak
char aTuyau11[10] = "TUYAU 11\n"; // weak
char aFindalgoInitia_0[32] = "FindAlgo initialization failed\n"; // weak
char aFindalgoInitia[22] = "FindAlgo initialized\n"; // weak
char aStartingFindal[34] = "Starting FindAlgo Initialization\n"; // weak
_UNKNOWN unk_441CA0; // weak
_UNKNOWN unk_441CA4; // weak
_UNKNOWN unk_441CB8; // weak
_UNKNOWN unk_441CCC; // weak
_UNKNOWN unk_441CE0; // weak
_UNKNOWN unk_441CF4; // weak
_UNKNOWN unk_441CF8; // weak
_UNKNOWN unk_441CFC; // weak
_UNKNOWN unk_441D00; // weak
_UNKNOWN unk_441D08; // weak
_UNKNOWN unk_441D0C; // weak
_UNKNOWN unk_441D14; // weak
_UNKNOWN unk_441D18; // weak
_UNKNOWN unk_441D1C; // weak
void *off_441D24 = &loc_404040; // weak
_UNKNOWN unk_441D28; // weak
_UNKNOWN unk_441D30; // weak
_UNKNOWN unk_441D38; // weak
_UNKNOWN unk_441D40; // weak
_UNKNOWN unk_441D48; // weak
_UNKNOWN unk_441D50; // weak
_UNKNOWN unk_441D54; // weak
_UNKNOWN unk_441D58; // weak
_UNKNOWN unk_441D6C; // weak
_UNKNOWN unk_441D80; // weak
_UNKNOWN unk_441D94; // weak
_UNKNOWN unk_441DA8; // weak
_UNKNOWN unk_441DAC; // weak
_UNKNOWN unk_441DB0; // weak
_UNKNOWN unk_441DB4; // weak
_UNKNOWN unk_441DBC; // weak
_UNKNOWN unk_441DC0; // weak
_UNKNOWN unk_441DC8; // weak
_UNKNOWN unk_441DCC; // weak
_UNKNOWN unk_441DD0; // weak
void *off_441DD8 = &loc_404040; // weak
_UNKNOWN unk_441DDC; // weak
_UNKNOWN unk_441DE4; // weak
_UNKNOWN unk_441DEC; // weak
_UNKNOWN unk_441DF4; // weak
_UNKNOWN unk_441DFC; // weak
_UNKNOWN unk_441E04; // weak
_UNKNOWN unk_441E08; // weak
_UNKNOWN unk_441E0C; // weak
_UNKNOWN unk_441E20; // weak
_UNKNOWN unk_441E34; // weak
_UNKNOWN unk_441E48; // weak
_UNKNOWN unk_441E5C; // weak
_UNKNOWN unk_441E60; // weak
_UNKNOWN unk_441E64; // weak
_UNKNOWN unk_441E68; // weak
_UNKNOWN unk_441E70; // weak
_UNKNOWN unk_441E74; // weak
_UNKNOWN unk_441E7C; // weak
_UNKNOWN unk_441E80; // weak
_UNKNOWN unk_441E84; // weak
void *off_441E8C = &loc_404040; // weak
_UNKNOWN unk_441E90; // weak
_UNKNOWN unk_441E98; // weak
_UNKNOWN unk_441EA0; // weak
_UNKNOWN unk_441EA8; // weak
_UNKNOWN unk_441EB0; // weak
_UNKNOWN unk_441EB8; // weak
_UNKNOWN unk_441EBC; // weak
_UNKNOWN unk_441EC0; // weak
_UNKNOWN unk_441ED4; // weak
_UNKNOWN unk_441EE8; // weak
_UNKNOWN unk_441EFC; // weak
_UNKNOWN unk_441F10; // weak
_UNKNOWN unk_441F14; // weak
_UNKNOWN unk_441F18; // weak
_UNKNOWN unk_441F1C; // weak
_UNKNOWN unk_441F24; // weak
_UNKNOWN unk_441F28; // weak
_UNKNOWN unk_441F30; // weak
_UNKNOWN unk_441F34; // weak
void *off_441F38 = &loc_404040; // weak
_UNKNOWN unk_441F3C; // weak
_UNKNOWN unk_441F44; // weak
_UNKNOWN unk_441F4C; // weak
_UNKNOWN unk_441F54; // weak
_UNKNOWN unk_441F5C; // weak
_UNKNOWN unk_441F64; // weak
_UNKNOWN unk_441F68; // weak
_UNKNOWN unk_441F6C; // weak
_UNKNOWN unk_441F80; // weak
_UNKNOWN unk_441F94; // weak
_UNKNOWN unk_441FA8; // weak
_UNKNOWN unk_441FBC; // weak
_UNKNOWN unk_441FC0; // weak
_UNKNOWN unk_441FC4; // weak
_UNKNOWN unk_441FC8; // weak
_UNKNOWN unk_441FD0; // weak
_UNKNOWN unk_441FD4; // weak
_UNKNOWN unk_441FDC; // weak
_UNKNOWN unk_441FE0; // weak
void *off_441FE8 = &loc_404040; // weak
_UNKNOWN unk_441FEC; // weak
_UNKNOWN unk_441FF4; // weak
_UNKNOWN unk_441FFC; // weak
_UNKNOWN unk_442004; // weak
_UNKNOWN unk_44200C; // weak
_UNKNOWN unk_442014; // weak
_UNKNOWN unk_442018; // weak
_UNKNOWN unk_44201C; // weak
_UNKNOWN unk_442030; // weak
_UNKNOWN unk_442044; // weak
_UNKNOWN unk_442058; // weak
_UNKNOWN unk_44206C; // weak
_UNKNOWN unk_442070; // weak
_UNKNOWN unk_442074; // weak
_UNKNOWN unk_442078; // weak
_UNKNOWN unk_442080; // weak
_UNKNOWN unk_442084; // weak
_UNKNOWN unk_44208C; // weak
_UNKNOWN unk_442090; // weak
_UNKNOWN unk_442094; // weak
_UNKNOWN unk_44209C; // weak
void *off_4420A0 = &loc_404040; // weak
_UNKNOWN unk_4420A4; // weak
_UNKNOWN unk_4420AC; // weak
_UNKNOWN unk_4420B4; // weak
_UNKNOWN unk_4420BC; // weak
_UNKNOWN unk_4420C4; // weak
_UNKNOWN unk_4420CC; // weak
_UNKNOWN unk_4420D0; // weak
_UNKNOWN unk_4420D4; // weak
_UNKNOWN unk_4420E8; // weak
char aEcec[5] = "ÈçÈç"; // weak
_UNKNOWN unk_442110; // weak
_UNKNOWN unk_442124; // weak
_UNKNOWN unk_442128; // weak
_UNKNOWN unk_442130; // weak
_UNKNOWN unk_442134; // weak
_UNKNOWN unk_44213C; // weak
_UNKNOWN unk_442140; // weak
_UNKNOWN unk_442144; // weak
_UNKNOWN unk_442148; // weak
_UNKNOWN unk_442150; // weak
_UNKNOWN unk_442158; // weak
_UNKNOWN unk_442160; // weak
_UNKNOWN unk_442168; // weak
_UNKNOWN unk_442170; // weak
char aTrackerDReady[18] = "Tracker %d ready\n"; // weak
char aTrackersInitia[22] = "Trackers Initialized\n"; // weak
char aNotEnouthMemor[19] = "Not Enouth Memory\n"; // weak
char aNoTrackerIniti[38] = "No Tracker : Initialization Canceled\n"; // weak
char aStartingTracke[34] = "Starting Trackers Initialization\n"; // weak
char byte_442200[] = { 'i' }; // weak
char byte_442201[23] =
{
  'r',
  '{',
  '}',
  '\x7F',
  '\x81',
  '‡',
  '\x8D',
  '“',
  '•',
  '—',
  '›',
  'Ÿ',
  '£',
  '¦',
  '¨',
  'ª',
  '¬',
  '²',
  '´',
  '¸',
  '\0',
  '\0',
  '\0'
}; // idb
char aDataLocalParam[21] = "data/local/param.elb"; // weak
char aDataLocalDElb[] = "data/local/%d.elb"; // idb
CHAR Name[] = "PINK PANTHER"; // idb
__int16 word_442380 = 255; // weak
__int16 word_442382 = 8; // weak
char byte_442388[] = { 'd' }; // weak
char byte_442391[11] = { 'l', '/', 'N', 'i', 'v', 'e', 'a', 'u', '0', '1', '.' }; // idb
char byte_44239C[] = { 'p' }; // weak
char byte_44239D[] = { 'i' }; // weak
char byte_44239E[] = { 'n' }; // weak
int dword_4423A0[] = { 2 }; // weak
char *off_4423A8 = "data/Sound/Amb01PC.psk"; // weak
char byte_4423AC[] = { '\x01' }; // weak
_UNKNOWN unk_4423B0; // weak
_UNKNOWN unk_4425C0; // weak
int dword_442674 = 973078332; // weak
int dword_442678 = 3419459016; // weak
int dword_44267C = 2637569322; // weak
int dword_442680 = 1263553864; // weak
int dword_442684 = 4294967295; // weak
int dword_442688 = 4294967295; // weak
int dword_44268C = 67502079; // weak
int dword_442690 = 16777731; // weak
char *off_442694[11] =
{
  "DATA\\VIDEO\\INTRO_0.mpg",
  "DATA\\VIDEO\\INTRO_1.mpg",
  "DATA\\VIDEO\\INTRO_2.mpg",
  "DATA\\VIDEO\\INTRO_3.mpg",
  "DATA\\VIDEO\\INTRO_4.mpg",
  "DATA\\VIDEO\\CREDITS.mpg",
  "DATA\\VIDEO\\LOGO1.mpg",
  "DATA\\VIDEO\\LOGO2.mpg",
  "DATA\\VIDEO\\END.mpg",
  "DATA\\VIDEO\\DEMO.mpg",
  "DATA\\VIDEO\\LOGO3.mpg"
}; // weak
char *off_442698[10] =
{
  "DATA\\VIDEO\\INTRO_1.mpg",
  "DATA\\VIDEO\\INTRO_2.mpg",
  "DATA\\VIDEO\\INTRO_3.mpg",
  "DATA\\VIDEO\\INTRO_4.mpg",
  "DATA\\VIDEO\\CREDITS.mpg",
  "DATA\\VIDEO\\LOGO1.mpg",
  "DATA\\VIDEO\\LOGO2.mpg",
  "DATA\\VIDEO\\END.mpg",
  "DATA\\VIDEO\\DEMO.mpg",
  "DATA\\VIDEO\\LOGO3.mpg"
}; // weak
int off_44269C = 4466640; // idb
char *off_4426A0[8] =
{
  "DATA\\VIDEO\\INTRO_3.mpg",
  "DATA\\VIDEO\\INTRO_4.mpg",
  "DATA\\VIDEO\\CREDITS.mpg",
  "DATA\\VIDEO\\LOGO1.mpg",
  "DATA\\VIDEO\\LOGO2.mpg",
  "DATA\\VIDEO\\END.mpg",
  "DATA\\VIDEO\\DEMO.mpg",
  "DATA\\VIDEO\\LOGO3.mpg"
}; // weak
char *off_4426A4[7] =
{
  "DATA\\VIDEO\\INTRO_4.mpg",
  "DATA\\VIDEO\\CREDITS.mpg",
  "DATA\\VIDEO\\LOGO1.mpg",
  "DATA\\VIDEO\\LOGO2.mpg",
  "DATA\\VIDEO\\END.mpg",
  "DATA\\VIDEO\\DEMO.mpg",
  "DATA\\VIDEO\\LOGO3.mpg"
}; // weak
int off_4426A8 = 4466568; // idb
char aTotalMemD[16] = "Total mem : %d\n"; // weak
char aDataLevelItems[23] = "data/Level/itemsel.pin"; // weak
char aDataDemosItem0[] = "data/Demos/item%02d.pin"; // idb
char aDataLevelItem0[24] = "data/Level/item%02d.pin"; // weak
char aDataGraphPlanN_4[29] = "data/graph/plan/niveau11.tex"; // weak
char aDataGraphPlanN_3[29] = "data/graph/plan/niveau08.tex"; // weak
char aDataGraphPlanN_2[29] = "data/graph/plan/niveau06.tex"; // weak
char aDataGraphPlanN_1[29] = "data/graph/plan/niveau04.tex"; // weak
char aDataGraphPlanN_0[29] = "data/graph/plan/niveau03.tex"; // weak
char aDataGraphPlanN[29] = "data/graph/plan/niveau01.tex"; // weak
char aDataGraphDemol[23] = "data/graph/DemoLev.tex"; // weak
char aDataGraphTitle[22] = "data/graph/title0.tex"; // weak
char aDataGraphQuitt[23] = "data/graph/quitter.tex"; // weak
char aDataGraphGameo[24] = "data/graph/GameOver.tex"; // weak
char aDataGraphNextl[23] = "data/graph/NextLev.tex"; // weak
FILE stru_442FB8 = { NULL, 0, NULL, 2, 1, 0, 0, NULL }; // idb
_UNKNOWN unk_443368; // weak
_UNKNOWN unk_443380; // weak
int dword_443AD8 = 0; // weak
int dword_443AE0 = 0; // weak
int dword_443AE4 = 0; // weak
int dword_443AE8 = 0; // weak
int dword_443AEC = 0; // weak
char byte_443AF0 = '\0'; // weak
char byte_443AF1 = '\0'; // weak
char byte_443AF2 = '\0'; // weak
int dword_443AF8 = 0; // weak
int dword_443AFC = 0; // weak
int dword_443B00 = 0; // weak
int dword_443B04 = 0; // weak
void *dword_443B08 = NULL; // idb
int dword_443B0C = 0; // weak
__int16 word_443B12 = 0; // weak
char byte_443B14 = '\0'; // weak
int dword_443C18 = 0; // weak
char byte_443C1C = '\0'; // weak
char byte_443C1D = '\0'; // weak
char byte_443C1E = '\0'; // weak
int dword_443C28[42] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
_UNKNOWN unk_443CD0; // weak
AGLSCREEN *dword_443D24 = NULL; // idb
int dword_443D28 = 0; // weak
void *dword_443D2C = NULL; // idb
int dword_443D30 = 0; // weak
char byte_443D34 = '\0'; // weak
int dword_443D38 = 0; // weak
char byte_443D3C = '\0'; // weak
int dword_443D40 = 0; // weak
void *dword_443D44 = NULL; // idb
int dword_443D48 = 0; // weak
int dword_443D4C = 0; // weak
int dword_443D50 = 0; // weak
char byte_443D54 = '\0'; // weak
char byte_443D58 = '\0'; // idb
char byte_443D59 = '\0'; // weak
_UNKNOWN unk_443E5C; // weak
char byte_443F60[260] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  
}; // idb
char byte_444064[260]; // idb
int dword_444168; // weak
char byte_44416C; // weak
char byte_44416D; // weak
char byte_44416E; // weak
char byte_44416F; // weak
AGLTIMER *dword_4441B0; // idb
int (*dword_4441C8)(void); // weak
HWND hWnd; // idb
char byte_444228[1088]; // idb
char byte_444668; // weak
char byte_444669; // weak
HINSTANCE hInstance; // idb
int dword_444670; // weak
int dword_444674; // weak
int dword_444678; // weak
int dword_44467C; // weak
int dword_444680; // weak
int dword_444688; // weak
int dword_44468C; // weak
int dword_444690; // weak
int dword_444694; // weak
int dword_444698; // weak
int dword_44469C; // weak
int dword_4446A0; // weak
int dword_4446A4; // weak
int dword_4446A8; // weak
int dword_4446AC; // weak
int dword_4446B0; // weak
int dword_4446B4; // weak
int dword_4446B8; // weak
int dword_4446BC; // weak
int dword_4446C0; // weak
char byte_4446C4[]; // weak
int dword_4446C8; // weak
int dword_4446CC; // weak
char byte_4446D4; // weak
char byte_4446D5; // weak
char byte_4446D6; // weak
char byte_4446D7; // weak
int dword_4446D8; // weak
int dword_4446DC; // weak
int dword_4446E0; // weak
int dword_4446E4; // weak
int dword_4446E8; // weak
int dword_4446EC; // weak
int dword_4446F0; // weak
char byte_4446F4; // weak
int dword_4446F8; // weak
int dword_4446FC; // weak
int dword_444704; // weak
int dword_444708; // weak
int dword_44470C; // weak
int dword_444710; // weak
int dword_444718; // weak
int dword_44471C; // weak
int dword_444720; // weak
int dword_444724; // weak
int dword_444728; // weak
int dword_44472C; // weak
int dword_444730; // weak
int dword_444734; // weak
int dword_444738; // weak
int dword_44473C; // weak
char byte_444740; // weak
int dword_444744; // weak
char byte_444748; // weak
char byte_444755; // weak
char byte_444756; // weak
int dword_444758; // idb
_UNKNOWN unk_444764; // weak
_UNKNOWN unk_444770; // weak
_UNKNOWN unk_44477C; // weak
_UNKNOWN unk_444788; // weak
_UNKNOWN unk_4447A0; // weak
_UNKNOWN unk_4447AC; // weak
_UNKNOWN unk_4447B8; // weak
_UNKNOWN unk_4447C4; // weak
_UNKNOWN unk_4447D0; // weak
_UNKNOWN unk_4447DC; // weak
_UNKNOWN unk_4447E8; // weak
_UNKNOWN unk_4447F4; // weak
_UNKNOWN unk_444800; // weak
_UNKNOWN unk_44480C; // weak
_UNKNOWN unk_444818; // weak
_UNKNOWN unk_444824; // weak
_UNKNOWN unk_444830; // weak
_UNKNOWN unk_44483C; // weak
_UNKNOWN unk_44486C; // weak
_UNKNOWN unk_444878; // weak
_UNKNOWN unk_444884; // weak
_UNKNOWN unk_444890; // weak
_UNKNOWN unk_44489C; // weak
_UNKNOWN unk_4448CC; // weak
_UNKNOWN unk_4448E4; // weak
_UNKNOWN unk_4448F0; // weak
_UNKNOWN unk_4448FC; // weak
int dword_444908; // weak
int dword_444914; // weak
int dword_444920; // weak
_UNKNOWN unk_44492C; // weak
int dword_444938; // weak
int dword_444944; // weak
_UNKNOWN unk_444950; // weak
_UNKNOWN unk_44495C; // weak
_UNKNOWN unk_444968; // weak
_UNKNOWN unk_444974; // weak
_UNKNOWN unk_444980; // weak
_UNKNOWN unk_444998; // weak
int dword_4449A4[11]; // idb
int dword_4449D0; // weak
std::codecvt_base *dword_4449D4; // idb
void *dword_4449D8; // idb
int dword_4449DC; // weak
_UNKNOWN unk_4449E0; // weak
_UNKNOWN unk_4449E8; // weak
int dword_4489E0[]; // weak
int dword_4489E4; // weak
int dword_4489E8[]; // weak
int dword_4489EC; // weak
int dword_4489F0; // weak
int dword_4489F4; // weak
int dword_4489F8; // weak
int dword_4489FC; // weak
int dword_448A00; // weak
int dword_448A04; // weak
int dword_448A08; // weak
int dword_448A0C; // weak
int dword_448A10; // weak
int dword_448A18; // weak
int dword_448AAC; // weak
int dword_448AB0; // weak
int dword_448AB4; // weak
int dword_448AB8; // weak
int dword_448ABC; // weak
__int16 word_448AC0; // weak
__int16 word_448AC2; // weak
int dword_448AC4; // weak
int dword_448AC8; // weak
int dword_448ACC; // weak
int dword_448AD0; // weak
int dword_448AD4; // weak
_UNKNOWN unk_448ADC; // weak
int dword_448AE0; // weak
int dword_448AE4; // weak
int dword_448AE8; // weak
float flt_448AF0; // weak
float flt_448AF4; // weak
float flt_448AF8; // weak
float flt_448AFC; // weak
float flt_448B00; // weak
float flt_448B04; // weak
float flt_448B08; // weak
float flt_448B0C; // weak
float flt_448B10; // weak
float flt_448B14; // weak
float flt_448B18; // weak
float flt_448B1C; // weak
float flt_448B34; // weak
float flt_448B38; // weak
int dword_448B3C; // weak
float flt_448B40; // weak
float flt_448B44; // weak
char byte_448B48; // weak
double dbl_448B50; // weak
__int16 word_448B58; // weak
__int16 word_448B5A; // weak
_UNKNOWN unk_448B60; // weak
_UNKNOWN unk_44952C; // weak
_UNKNOWN unk_449530; // weak
float flt_44B300; // weak
float flt_44B304; // weak
float flt_44B308; // weak
int dword_44B30C; // weak
__int16 word_44B310; // weak
char byte_44B312; // weak
int dword_44B318; // weak
int dword_44B31C; // weak
int dword_44B320; // weak
_UNKNOWN unk_44B324; // weak
_UNKNOWN unk_44B325; // weak
_UNKNOWN unk_44B326; // weak
char byte_44B327; // weak
int dword_44B328; // weak
char byte_44B330; // weak
char byte_44B331; // weak
int dword_44B334[]; // weak
int dword_44B338[]; // weak
int dword_44B33C[]; // weak
char byte_44B358; // weak
char byte_44B359; // weak
int dword_44B35C; // weak
int dword_44B360; // weak
int dword_44B364; // weak
char byte_44B380; // weak
int dword_44B384; // weak
char byte_44B388; // weak
char byte_44B389; // weak
char byte_44B38A; // weak
char byte_44B38B; // weak
int dword_44B38C; // weak
int dword_44B390; // weak
int dword_44B394; // weak
int dword_44B398; // weak
char byte_44B39C; // weak
char byte_44B39D; // weak
int dword_44B3A0; // weak
char byte_44B3A4; // weak
int dword_44B3A8; // weak
char byte_44B3AC; // weak
int dword_44B3B0; // weak
int dword_44B3B4; // weak
int dword_44B3B8; // weak
int dword_44B3BC; // weak
int dword_44B3C0; // weak
char byte_44B3C4; // weak
char byte_44B3D3; // weak
char byte_44B3D4; // weak
int dword_44B3D8; // weak
int dword_44B3DC; // idb
__int16 word_44B3E0; // weak
char byte_44B3E2; // weak
int dword_44B3E4; // weak
int dword_44B3E8; // weak
int dword_44B3F0; // idb
int dword_44B3FC; // weak
__int16 word_44B406; // weak
_UNKNOWN unk_44B408; // weak
char byte_44B40A; // weak
int dword_44B40C; // weak
int dword_44B410; // weak
char byte_44B414; // weak
char byte_44B415; // weak
int dword_44B418; // weak
int dword_44B41C[4]; // idb
int dword_44B42C; // weak
int dword_44B430; // weak
int dword_44B43C; // idb
int dword_44B440; // idb
char byte_44B448; // weak
int dword_44B44C; // weak
int dword_44B450; // weak
int dword_44B454; // weak
int dword_44B458; // weak
int dword_44B45C[4]; // idb
int dword_44B46C; // weak
int dword_44B47C; // weak
int dword_44B480; // weak
int dword_44B484; // weak
char byte_44B488; // weak
char byte_44B489; // weak
char byte_44B48A; // weak
char byte_44B48B; // weak
int dword_44B48C; // weak
char byte_44B4AC; // weak
float flt_44B4B0; // weak
float flt_44B4B4; // weak
int dword_44B4B8; // weak
char byte_44B4BC; // weak
int dword_44B4C0; // weak
int dword_44B4C4; // weak
int dword_44B4C8; // weak
char byte_44B4CC; // weak
float flt_44B4D0; // idb
int dword_44B4D4; // weak
int dword_44B4D8; // weak
int dword_44B4DC; // weak
char byte_44B4E0; // weak
int dword_44B4E8[]; // weak
_UNKNOWN unk_44B4EC; // weak
_UNKNOWN unk_44B4F0; // weak
char byte_44B506[288]; // idb
int dword_44B628; // weak
int dword_44B62C[]; // weak
int dword_44B630[]; // weak
int dword_44B63C; // weak
int dword_44B640[]; // weak
int dword_44B64C; // weak
int dword_44B650; // weak
__int16 word_44B654; // weak
char byte_44B656; // weak
int dword_44B658; // weak
int dword_44B65C; // weak
int dword_44B660; // weak
char byte_44B664[]; // weak
float flt_44B668[9]; // idb
char byte_44B68C[]; // weak
_WORD word_44B690[6]; // idb
float flt_44B69C; // weak
int dword_44B6A0; // weak
int dword_44B6A8; // weak
float flt_44B6AC; // weak
int dword_44B6B0; // weak
__int16 word_44B6B4; // weak
__int16 word_44B6F8; // weak
float dword_44B700; // idb
float dword_44B704; // idb
float dword_44B708; // idb
int dword_44B714; // weak
float dword_44B71C; // idb
int dword_44B720; // weak
int dword_44B724; // weak
int dword_44B728; // weak
int dword_44B72C; // weak
int dword_44B730; // weak
int dword_44B734; // weak
int dword_44B738; // idb
float dword_44B73C; // idb
float dword_44B740; // idb
float dword_44B744; // idb
float flt_44B748; // weak
float flt_44B74C; // weak
float flt_44B750; // weak
_UNKNOWN unk_44B754; // weak
float dword_44B760; // idb
int dword_44B764; // weak
int dword_44B768; // weak
int dword_44B76C; // weak
float flt_44B770; // idb
int dword_44B774; // weak
int dword_44B778; // weak
int dword_44B77C; // weak
int dword_44B784; // weak
int dword_44B788; // weak
char byte_44B78C; // weak
char byte_44B78D; // weak
char byte_44B78E; // weak
char byte_44B78F; // weak
char byte_44B790; // weak
char byte_44B791; // weak
char byte_44B792; // weak
char byte_44B793; // weak
char byte_44B794; // weak
char byte_44B795; // weak
char byte_44B796; // weak
char byte_44B797; // weak
int dword_44B798; // weak
int dword_44B79C; // weak
int dword_44B7A0; // weak
float dword_44B7A4; // idb
float flt_44B7A8; // weak
int dword_44B7AC; // weak
int dword_44B7B0; // weak
int dword_44B7B4; // weak
int dword_44B7B8; // weak
int dword_44B7BC; // weak
int dword_44B7C0; // weak
int dword_44B7C4; // weak
int dword_44B7C8; // weak
int dword_44B7CC; // weak
int dword_44B7D0; // weak
int dword_44B7D4; // weak
float flt_44B7D8; // weak
int dword_44B7DC; // weak
float flt_44B7E0; // weak
float dword_44B7E4; // idb
float flt_44B7E8; // weak
__int16 word_44B7EC; // weak
__int16 word_44B7EE; // weak
__int16 word_44B7F0; // weak
__int16 word_44B7F2; // weak
__int16 word_44B7F4; // weak
__int16 word_44B7F6; // weak
__int16 word_44B7F8; // weak
char byte_44B7FA; // weak
__int16 word_44B7FC; // weak
__int16 word_44B7FE; // weak
__int16 word_44B800; // weak
char byte_44B802; // weak
char byte_44B803; // weak
int dword_44B804; // weak
int dword_44B808; // weak
int dword_44B80C; // weak
char byte_44B810; // weak
char byte_44B811; // weak
char byte_44B812; // weak
char byte_44B813; // weak
int dword_44B814; // weak
char byte_44B818; // weak
char byte_44B819; // weak
int dword_44B81A; // weak
int dword_44B81E; // weak
int dword_44B822; // weak
int dword_44B828; // weak
int dword_44B82C; // weak
int dword_44B830; // weak
int dword_44B834; // weak
int dword_44B838; // weak
int dword_44B83C; // weak
int dword_44B840; // weak
int dword_44B844; // weak
char byte_44B848; // weak
int dword_44B850; // weak
int dword_44B85C; // idb
int dword_44B860; // weak
int dword_44B864; // weak
int dword_44B868; // weak
__int16 word_44B86C; // weak
int dword_44B900; // weak
int dword_44B950; // idb
int dword_44B954; // idb
char byte_44B962; // weak
char byte_44B963; // weak
int dword_44B964; // weak
char byte_44B969; // weak
int dword_44B970; // weak
int dword_44B974; // weak
int dword_44B978; // weak
int dword_44B97C; // weak
__int16 word_44B980; // weak
char byte_44B982; // weak
char byte_44B984; // weak
char byte_44B988; // weak
int dword_44B98C; // weak
int dword_44B990; // weak
char byte_44B994; // weak
int dword_44B998; // weak
__int16 word_44B99C[12]; // idb
_UNKNOWN unk_44B9B4; // weak
int dword_44B9B8; // weak
char byte_44B9BC[12]; // idb
int dword_44B9C8; // weak
char byte_44B9CC[12]; // idb
int dword_44B9D8; // weak
__int16 word_44B9DC[12]; // idb
int dword_44B9F4; // weak
int dword_44B9F8; // weak
char byte_44B9FC; // weak
char byte_44B9FE; // weak
char byte_44B9FF; // weak
char byte_44BA00; // weak
char byte_44BA01; // weak
int dword_44BA08; // weak
int dword_44BA10; // weak
char byte_44BA14[132]; // idb
AGLFILE *dword_44BA98; // idb
int (__cdecl *dword_44BA9C)(_DWORD, _DWORD); // weak
int dword_44BAA0; // weak
void *dword_44BAA4; // idb
int dword_44BAAC; // weak
__int16 word_44BAB0; // weak
__int16 word_44BAB2; // weak
char byte_44BAB4; // weak
char byte_44BAE4; // weak
char byte_44C6F9; // weak
int dword_44C708; // weak
char byte_44C70E; // weak
char byte_44C718; // weak
int dword_44C720; // weak
int dword_44C72C; // weak
char byte_44C748; // weak
char byte_44C749; // weak
char byte_44D33D; // weak
char byte_44D376; // weak
int dword_44D384; // weak
int dword_44D38C; // weak
int dword_44D394; // weak
float flt_44D3A8; // weak
float flt_44D3AC; // weak
int dword_44D3B0; // weak
int dword_44D3B4; // weak
__int16 word_44D3BC; // weak
__int16 word_44D3BE; // weak
char byte_44D3C0; // weak
char byte_44D402; // weak
char byte_44D403; // weak
LPVOID ppv; // idb
int dword_44D40C; // weak
int dword_44D410; // weak
int dword_44D414; // weak
int dword_44D418; // weak
int dword_44D41C; // weak
int dword_44D420; // weak
int dword_44D424; // weak
char byte_44D428; // weak
int dword_44D42C; // weak
int dword_44D430; // weak
int dword_44D438; // weak
int dword_44D440[]; // weak
__int16 word_44D444; // weak
int dword_44D448; // weak
int dword_44D44C; // weak
int dword_44DB80; // weak
int dword_44DB84; // weak
int dword_44DB88; // weak
__int16 word_44DB8C; // weak
int dword_44DB90; // weak
int dword_44DB94; // weak
int dword_44DB98; // weak
int dword_44DB9C; // weak
int dword_44DBA0; // weak
int dword_44DBA4; // weak
int dword_44DBA8; // weak
int dword_44DBAC; // weak
__int16 word_44DBB0; // weak
int dword_44DBB4; // weak
int dword_44DBB8; // weak
__int16 word_44E9D2; // weak
float flt_44E9D8; // weak
float flt_44E9DC; // weak
float flt_44E9E0; // weak
float flt_44E9E4; // weak
float flt_44E9E8; // weak
int dword_44E9EC; // weak
int dword_44E9F4; // weak
int dword_44EA88; // weak
int dword_44EA8C; // weak
int dword_44EA90; // weak
__int16 word_44EA94; // weak
char byte_44EA98; // weak
char byte_44EA99; // weak
char byte_44EA9A; // weak
char byte_44EA9B; // weak
char byte_44EA9C; // weak
char byte_44EA9D; // weak
char byte_44EA9E; // weak
char byte_44EA9F; // weak
char byte_44EAA0; // weak
char byte_44EAA1; // weak
char byte_44EAA2; // weak
char byte_44EAA3; // weak
int dword_44EAA4; // weak
int dword_44EAA8; // weak
int dword_44EAAC; // idb
float dword_44EAB0; // idb
int dword_44EAB4; // weak
int dword_44EAB8; // weak
_UNKNOWN unk_44EABC; // weak
_UNKNOWN unk_44EAC0; // weak
_UNKNOWN unk_44EAC4; // weak
_UNKNOWN unk_44EAC8; // weak
_UNKNOWN unk_44EACC; // weak
_UNKNOWN unk_44EAD0; // weak
_UNKNOWN unk_44EAD4; // weak
_UNKNOWN unk_44EAD8; // weak
_UNKNOWN unk_44EAE0; // weak
_UNKNOWN unk_44EAE4; // weak
_UNKNOWN unk_44EAE8; // weak
_UNKNOWN unk_44EAEC; // weak
_UNKNOWN unk_44EAF0; // weak
_UNKNOWN unk_44EAF4; // weak
_UNKNOWN unk_44EAF8; // weak
_UNKNOWN unk_44EAFC; // weak
_UNKNOWN unk_44EB00; // weak
_UNKNOWN unk_44EB08; // weak
int dword_44EB0C; // weak
int dword_44EB10; // weak
int dword_44EB14; // weak
int dword_44EB18; // weak
int dword_44EB1C; // weak
int dword_44EB20; // weak
int dword_44EB24; // weak
int dword_44EB28; // weak
int dword_44EB2C; // weak
int dword_44EB30; // weak
int dword_44EB34; // weak
int dword_44EB38; // weak
int dword_44EB3C; // weak
int dword_44EB40; // weak
int dword_44EB44; // weak
int dword_44EB48; // weak
int dword_44EB4C; // weak
int dword_44EB50; // weak
int dword_44EB54; // weak
int dword_44EB58; // weak
int dword_44EB5C; // weak
int dword_44EB60; // weak
int dword_44EB64; // weak
int dword_44EB68[]; // weak
int dword_44EBC0; // weak
__int16 word_44EBC4[44]; // idb
int dword_44EC20; // weak
int dword_44EC28; // weak
int dword_44EC30; // weak
int dword_44EC38; // weak
int dword_44EC44; // weak
int dword_44EC4C; // weak
int dword_44EDAC; // weak
int dword_44EDB4; // weak
int dword_44EDBC; // weak
_UNKNOWN unk_44F3B4; // weak
char byte_4541D8; // weak
_UNKNOWN unk_4541E0; // weak
_UNKNOWN unk_4541EC; // weak
int dword_4543D8; // weak
float flt_4543DC; // weak
int dword_4543E0; // weak
int dword_454FE4; // weak
__int16 word_454FEC; // weak
int dword_454FF0; // weak
int dword_454FF4; // weak
int dword_454FF8; // weak
int dword_455004; // weak
int dword_455BDC; // weak
int dword_455BE0; // weak
int dword_455BE4; // weak
int dword_455BE8; // weak
int dword_455BEC; // weak
int dword_455BF0; // weak
int dword_455BF8; // weak
int dword_455BFC; // weak
int dword_455C00; // weak
float flt_455C08; // weak
float flt_455C0C; // weak
__int16 word_455C10; // weak
char byte_455C12; // weak
char byte_455C13; // weak
char byte_455C14; // weak
char byte_455C15; // weak
int dword_455C18; // weak
int dword_455C1C; // weak
int dword_455C20; // weak
int dword_455C24; // weak
int dword_455C28; // idb
int dword_455C2C; // weak
int dword_455C30; // weak
char byte_455C34; // weak
char byte_455C35; // weak
int dword_455C38; // weak
int dword_455C3C; // weak
int dword_455C40; // weak
int dword_455C44; // weak
int dword_455C48; // weak
int dword_455C4C; // weak
int dword_455C50; // weak
int dword_455C54; // weak
int dword_455C58; // weak
int dword_455C5C; // weak
int dword_455C60; // weak
int dword_455C64; // weak
int dword_455C68; // weak
int dword_455C6C; // weak
int dword_455C70; // weak
int dword_455C74; // weak
int dword_455C78; // weak
int dword_455C7C; // weak
int dword_455C80; // weak
int dword_455C84; // weak
int dword_455C88; // weak
int dword_455C8C; // weak
int dword_455C90; // weak
int dword_455C94; // weak
int dword_455C98; // weak
char byte_455CA2; // weak
char byte_455CA3; // weak
char byte_455CA4; // weak
char byte_455CA5; // weak
char byte_455CA6; // weak
char byte_455CA7; // weak
char byte_455CA8; // weak
char byte_455CA9; // weak
char byte_455CAA; // weak
char byte_455CAB; // weak
int dword_455CAC; // weak
int dword_455CB0; // weak
char byte_455CB4; // weak
char byte_455CB5; // weak
char byte_455CB6; // weak
__int16 word_455CB7; // weak
_UNKNOWN unk_455CB9; // weak
_UNKNOWN unk_455CBA; // weak
_UNKNOWN unk_455CBB; // weak
int dword_455CBC; // weak
int dword_455CC4; // weak
char byte_455CCC; // weak
char byte_455CCD; // weak
int dword_455CD0; // weak
int dword_455CD8; // weak
int dword_455CEC; // weak


//----- (00401000) --------------------------------------------------------
int __cdecl sub_401000(int a1, char a2, int a3, int a4)
{
  unsigned __int16 v4; // ax

  LOBYTE(v4) = 0;
  HIBYTE(v4) = a2 & 3;
  return (unsigned __int16)(a3 / 64 + 21 * (a4 / 256)) | v4;
}

//----- (00401050) --------------------------------------------------------
char __cdecl sub_401050(unsigned int a1)
{
  if ( a1 >= (unsigned int)dword_443B08 && a1 <= dword_443B0C )
    return 1;
  if ( a1 )
    sub_401080(1);
  return 0;
}
// 443B0C: using guessed type int dword_443B0C;

//----- (00401080) --------------------------------------------------------
void __cdecl __noreturn sub_401080(char a1)
{
  _DWORD *v1; // ecx
  int v2; // eax
  double v3; // st7
  double v4; // st7

  while ( 1 )
  {
    while ( 1 )
    {
      v1 = dword_443D2C;
      v2 = *((_DWORD *)dword_443D2C + 16032);
      *((_DWORD *)dword_443D2C + 16032) = v2 + 88;
      *(_DWORD *)(v2 + 4) = 0;
      *(_DWORD *)v2 = v1[30];
      v1[30] = v2;
      *(_DWORD *)(v2 + 4) = 3;
      *(_DWORD *)(v2 + 8) = 0;
      *(_DWORD *)(v2 + 12) = 0;
      v3 = (double)*((signed int *)dword_443D44 + 2);
      *(_DWORD *)(v2 + 32) = 0;
      *(_DWORD *)(v2 + 48) = 0;
      *(float *)(v2 + 28) = v3;
      *(float *)(v2 + 52) = (double)*((signed int *)dword_443D44 + 3);
      *(float *)(v2 + 68) = (double)*((signed int *)dword_443D44 + 2);
      v4 = (double)*((signed int *)dword_443D44 + 3);
      *(_DWORD *)(v2 + 16) = 0;
      *(_DWORD *)(v2 + 20) = 1065353216;
      *(_DWORD *)(v2 + 36) = 0;
      *(_DWORD *)(v2 + 40) = 1065353216;
      *(float *)(v2 + 72) = v4;
      *(_DWORD *)(v2 + 56) = 0;
      *(_DWORD *)(v2 + 60) = 1065353216;
      *(_DWORD *)(v2 + 76) = 0;
      *(_DWORD *)(v2 + 80) = 1065353216;
      if ( a1 )
        break;
      *(_BYTE *)(v2 + 26) = -1;
      *(_BYTE *)(v2 + 25) = 0;
      *(_BYTE *)(v2 + 24) = 0;
LABEL_5:
      sub_402A90();
    }
    if ( a1 != 1 )
      goto LABEL_5;
    *(_BYTE *)(v2 + 26) = 0;
    *(_BYTE *)(v2 + 25) = -1;
    *(_BYTE *)(v2 + 24) = 0;
    sub_402A90();
  }
}

//----- (00401140) --------------------------------------------------------
char sub_401140()
{
  char *v0; // eax

  if ( !dword_443B08 )
  {
    dword_443B00 = 0;
    dword_443AF8 = 0x800000;
    dword_443AFC = 0x800000;
    dword_443B04 = 0;
    v0 = (char *)malloc(0x800000u);
    dword_443B08 = v0;
    if ( !v0 )
    {
      sub_403990(Text);
      return 0;
    }
    dword_443B0C = (int)&v0[dword_443AF8 - 1];
  }
  return 1;
}
// 443AF8: using guessed type int dword_443AF8;
// 443AFC: using guessed type int dword_443AFC;
// 443B00: using guessed type int dword_443B00;
// 443B04: using guessed type int dword_443B04;
// 443B0C: using guessed type int dword_443B0C;

//----- (004011B0) --------------------------------------------------------
void *sub_4011B0()
{
  void *result; // eax

  result = dword_443B08;
  if ( dword_443B08 )
  {
    free(dword_443B08);
    result = 0;
    memset(&dword_443AF8, 0, 0x18u);
  }
  return result;
}
// 443AF8: using guessed type int dword_443AF8;

//----- (004011E0) --------------------------------------------------------
unsigned int __cdecl sub_4011E0(int *a1)
{
  unsigned int v1; // edi
  int v2; // ebp
  unsigned int i; // esi
  unsigned int v4; // eax

  if ( (unsigned int)dword_443AFC < 0x10 )
  {
    v1 = 0;
    v2 = 0;
  }
  else
  {
    v1 = dword_443AFC - 16;
    v2 = dword_443AFC - 16;
  }
  for ( i = dword_443B00; sub_401050(i); i = *(_DWORD *)(i + 4) )
  {
    if ( *(_BYTE *)(i + 12) & 1 )
    {
      v4 = *(_DWORD *)(i + 8);
      if ( v4 > v1 )
        v1 = *(_DWORD *)(i + 8);
      v2 += v4;
    }
  }
  if ( a1 )
    *a1 = v2;
  return v1;
}
// 443AFC: using guessed type int dword_443AFC;
// 443B00: using guessed type int dword_443B00;

//----- (00401250) --------------------------------------------------------
int __cdecl sub_401250(int a1)
{
  unsigned int v1; // ebp
  unsigned int v2; // edi
  _DWORD *v3; // esi
  unsigned int v4; // eax
  _DWORD *v5; // esi
  int result; // eax
  unsigned int v7; // ecx
  _DWORD *v8; // edx
  _DWORD *v9; // eax
  int v10; // ecx

  v1 = dword_443B00;
  v2 = (a1 + 3) & 0xFFFFFFFC;
  dword_443C18 += v2;
  v3 = 0;
  if ( !sub_401050(dword_443B00) )
    goto LABEL_22;
  do
  {
    if ( *(_BYTE *)(v1 + 12) & 1 )
    {
      v4 = *(_DWORD *)(v1 + 8);
      if ( v4 >= v2 && (!v3 || v4 < v3[2]) )
        v3 = (_DWORD *)v1;
    }
    v1 = *(_DWORD *)(v1 + 4);
  }
  while ( sub_401050(v1) );
  if ( v3 )
  {
    v7 = v3[2] - v2;
    if ( v7 >= 0x10 )
    {
      v8 = (_DWORD *)v3[1];
      v3[2] = v2;
      v9 = (_DWORD *)((char *)v3 + v2 + 16);
      if ( v8 )
        *v8 = v9;
      *(_DWORD *)((char *)v3 + v2 + 20) = v3[1];
      v3[1] = v9;
      *(_DWORD *)((char *)v3 + v2 + 24) = v7 - 16;
      v10 = *(_DWORD *)((char *)v3 + v2 + 28) | 1;
      *v9 = v3;
      *(_DWORD *)((char *)v3 + v2 + 28) = v10;
    }
    v3[3] = 0;
    result = (int)(v3 + 4);
  }
  else
  {
LABEL_22:
    if ( dword_443AFC < v2 + 16 )
      sub_401080(0);
    if ( dword_443B04 )
    {
      v5 = (_DWORD *)(*(_DWORD *)(dword_443B04 + 8) + dword_443B04 + 16);
      *(_DWORD *)(dword_443B04 + 4) = v5;
      *v5 = dword_443B04;
    }
    else
    {
      v5 = dword_443B08;
      *(_DWORD *)dword_443B08 = 0;
      dword_443B00 = (int)v5;
    }
    dword_443B04 = (int)v5;
    dword_443AFC += -16 - v2;
    v5[1] = 0;
    v5[2] = v2;
    v5[3] = 0;
    result = (int)(v5 + 4);
  }
  return result;
}
// 443AFC: using guessed type int dword_443AFC;
// 443B00: using guessed type int dword_443B00;
// 443B04: using guessed type int dword_443B04;
// 443C18: using guessed type int dword_443C18;

//----- (00401380) --------------------------------------------------------
char __cdecl sub_401380(unsigned int a1)
{
  int *v1; // eax
  int v2; // esi
  int v3; // ebx
  unsigned int v4; // edi
  _DWORD *v5; // ebp
  int v6; // edx
  int v7; // eax
  int v8; // ecx

  LOBYTE(v1) = sub_401050(a1);
  if ( (_BYTE)v1 )
  {
    LOBYTE(v1) = dword_443B00;
    if ( dword_443B00 )
    {
      v2 = a1 - 16;
      *(_DWORD *)(a1 - 16 + 12) = *(_DWORD *)(a1 - 4) | 1;
      v3 = 0;
      if ( sub_401050(*(_DWORD *)(a1 - 16)) )
      {
        do
        {
          if ( !(*(_BYTE *)(v2 + 12) & 1) )
            break;
          v2 = *(_DWORD *)v2;
        }
        while ( sub_401050(*(_DWORD *)v2) );
      }
      if ( sub_401050(v2) )
      {
        v4 = *(_DWORD *)(v2 + 4);
        v5 = 0;
        if ( sub_401050(*(_DWORD *)(v2 + 4)) )
        {
          while ( *(_BYTE *)(v4 + 12) & 1 )
          {
            v6 = *(_DWORD *)(v4 + 8);
            v4 = *(_DWORD *)(v4 + 4);
            v3 += v6 + 16;
            if ( !sub_401050(v4) )
              goto LABEL_13;
          }
          v5 = (_DWORD *)v4;
        }
LABEL_13:
        if ( *(_BYTE *)(v2 + 12) & 1 )
        {
          if ( sub_401050((unsigned int)v5) )
          {
            v7 = *(_DWORD *)(v2 + 8);
            *(_DWORD *)(v2 + 4) = v5;
            v1 = (int *)(v3 + v7);
            *(_DWORD *)(v2 + 8) = v1;
            *v5 = v2;
          }
          else
          {
            dword_443B00 = 0;
            dword_443B04 = 0;
            LOBYTE(v1) = dword_443AF8;
            dword_443AFC = dword_443AF8;
          }
        }
        else
        {
          *(_DWORD *)(v2 + 4) = v5;
          if ( sub_401050((unsigned int)v5) )
          {
            v8 = *(_DWORD *)(v2 + 8);
            *(_DWORD *)(v8 + v2 + 28) = 1;
            *(_DWORD *)(v8 + v2 + 24) = v3 - 16;
            v1 = (int *)(v8 + v2 + 16);
            *v1 = v2;
            v1[1] = (int)v5;
            *(_DWORD *)(v2 + 4) = v1;
            *v5 = v1;
          }
          else
          {
            dword_443B04 = v2;
            LOBYTE(v1) = v3 + dword_443AFC;
            dword_443AFC += v3;
          }
        }
      }
      else
      {
        LOBYTE(v1) = sub_401500();
      }
    }
  }
  return (char)v1;
}
// 443AF8: using guessed type int dword_443AF8;
// 443AFC: using guessed type int dword_443AFC;
// 443B00: using guessed type int dword_443B00;
// 443B04: using guessed type int dword_443B04;

//----- (00401500) --------------------------------------------------------
int sub_401500()
{
  int result; // eax

  dword_443B04 = 0;
  dword_443B00 = 0;
  result = dword_443AF8;
  dword_443AFC = dword_443AF8;
  return result;
}
// 443AF8: using guessed type int dword_443AF8;
// 443AFC: using guessed type int dword_443AFC;
// 443B00: using guessed type int dword_443B00;
// 443B04: using guessed type int dword_443B04;

//----- (00401520) --------------------------------------------------------
char __cdecl sub_401520(int a1, unsigned int a2, unsigned int a3)
{
  char result; // al

  dword_443AD8 = sub_401DB0((unsigned __int8 *)a1, 1, a2, a3, 0, 0);
  dword_443AEC = sub_401E20(a1, a2, *(unsigned __int16 *)(a1 + 4) + a3 - 1);
  result = 60;
  word_443B12 = 0;
  byte_443AF2 = 60;
  byte_443AF1 = 60;
  byte_443AF0 = 60;
  return result;
}
// 443AD8: using guessed type int dword_443AD8;
// 443AEC: using guessed type int dword_443AEC;
// 443AF0: using guessed type char byte_443AF0;
// 443AF1: using guessed type char byte_443AF1;
// 443AF2: using guessed type char byte_443AF2;
// 443B12: using guessed type __int16 word_443B12;

//----- (00401580) --------------------------------------------------------
int __cdecl sub_401580(char a1)
{
  int result; // eax

  if ( word_443B12 )
    sub_401D10();
  result = (unsigned __int8)dword_443AD8 | ((a1 & 3) << 8);
  dword_443AD8 = (unsigned __int8)dword_443AD8 | ((a1 & 3) << 8);
  return result;
}
// 443AD8: using guessed type int dword_443AD8;
// 443B12: using guessed type __int16 word_443B12;

//----- (004015B0) --------------------------------------------------------
_DWORD *__cdecl sub_4015B0(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax

  *a1 = (unsigned __int16)dword_443AE4;
  result = a2;
  *a2 = HIWORD(dword_443AE4);
  return result;
}
// 443AE4: using guessed type int dword_443AE4;

//----- (004015D0) --------------------------------------------------------
unsigned int __cdecl sub_4015D0(unsigned int a1, int a2, int a3, int a4, int a5, unsigned int a6)
{
  __int16 v6; // dx
  unsigned int result; // eax
  unsigned int v8; // ebp
  unsigned int v9; // ecx
  int v10; // esi
  int v11; // edi
  bool v12; // zf
  _DWORD *v13; // eax
  int v14; // ecx
  unsigned int v15; // eax
  int v16; // esi
  int v17; // ST34_4
  unsigned __int8 v18; // al
  unsigned __int8 v19; // cl
  _DWORD *v20; // [esp+10h] [ebp-2Ch]
  __int16 v21; // [esp+14h] [ebp-28h]
  _WORD *v22; // [esp+18h] [ebp-24h]
  unsigned __int8 v23; // [esp+44h] [ebp+8h]
  unsigned int v24; // [esp+54h] [ebp+18h]

  v6 = *((_WORD *)dword_443D44 + 4);
  result = a6;
  v21 = *((_WORD *)dword_443D44 + 4);
  if ( a6 < (unsigned __int16)dword_44EBC0 )
  {
    if ( a1 == 0x10000000 )
      v8 = (signed __int16)((v6 - a3 * (unsigned int)(unsigned __int16)word_44EBC4[4 * a6]) >> 1);
    else
      v8 = a1 & 0x20000000 ? (signed __int16)(v6 - a3 * word_44EBC4[4 * a6] - 10) : (signed int)(signed __int16)a1;
    LOWORD(v9) = a2;
    if ( a2 == 0x10000000 )
    {
      v10 = a4;
      v9 = (unsigned int)(*((signed __int16 *)dword_443D44 + 6) - a4) >> 1;
    }
    else
    {
      v10 = a4;
    }
    v24 = (signed __int16)v9;
    v23 = 0;
    v22 = (_WORD *)(8 * result + 4516804);
    if ( word_44EBC4[4 * result] )
    {
      v20 = (_DWORD *)(8 * result + 4516808);
      do
      {
        v11 = *(unsigned __int16 *)(*v20 + 2 * v23);
        v12 = (unsigned __int16)v11 == 1;
        if ( (unsigned __int16)v11 > 1u )
        {
          v13 = dword_443D2C;
          v14 = *((_DWORD *)dword_443D2C + 16032);
          *((_DWORD *)dword_443D2C + 16032) = v14 + 124;
          *(_DWORD *)(v14 + 4) = 0;
          *(_DWORD *)v14 = v13[30];
          v13[30] = v14;
          *(_DWORD *)(v14 + 4) = 10;
          if ( v11 == *(unsigned __int16 *)dword_44EC20 )
          {
            *(_BYTE *)(v14 + 30) = 0;
            *(_BYTE *)(v14 + 29) = 30;
            *(_BYTE *)(v14 + 28) = 110;
          }
          else if ( v11 == *(unsigned __int16 *)dword_44EC28 )
          {
            *(_BYTE *)(v14 + 30) = -66;
            *(_BYTE *)(v14 + 29) = 0;
            *(_BYTE *)(v14 + 28) = 0;
          }
          else if ( v11 == *(unsigned __int16 *)dword_44EC30 )
          {
            *(_BYTE *)(v14 + 30) = 0;
            *(_BYTE *)(v14 + 29) = 110;
            *(_BYTE *)(v14 + 28) = 0;
          }
          else if ( v11 == *(unsigned __int16 *)dword_44EC38 )
          {
            *(_BYTE *)(v14 + 30) = -1;
            *(_BYTE *)(v14 + 29) = 0;
            *(_BYTE *)(v14 + 28) = -76;
          }
          else
          {
            *(_BYTE *)(v14 + 30) = byte_443AF2;
            *(_BYTE *)(v14 + 29) = byte_443AF1;
            *(_BYTE *)(v14 + 28) = byte_443AF0;
          }
          *(float *)(v14 + 12) = (double)v8;
          *(_DWORD *)(v14 + 20) = 0;
          *(_DWORD *)(v14 + 4) = a5 != 0 ? 266 : 10;
          *(float *)(v14 + 16) = (double)v24;
          *(_DWORD *)(v14 + 24) = 1065353216;
          *(_WORD *)(v14 + 8) = a3;
          *(_WORD *)(v14 + 10) = v10;
          v15 = (v11 - 2) / (unsigned int)(unsigned __int16)dword_443AE8;
          v16 = HIWORD(dword_443AE4);
          v6 = v21;
          *(float *)(v14 + 32) = (double)((unsigned __int16)dword_443AE4
                                        * (v11 - v15 * (unsigned __int16)dword_443AE8 - 2))
                               * 0.0039215689;
          v17 = v15 * v16;
          v10 = a4;
          v12 = v11 == 1;
          *(float *)(v14 + 36) = (double)(unsigned int)v17 * 0.0039215689;
        }
        if ( !v12 )
        {
          v8 += a3;
          if ( v8 >= v6 )
          {
            v8 = a1;
            v24 += v10;
          }
        }
        v18 = v23 + 1;
        v23 = v18;
        v19 = v18;
        result = (unsigned int)v22;
      }
      while ( (unsigned __int16)v19 < *v22 );
    }
  }
  return result;
}
// 443AE4: using guessed type int dword_443AE4;
// 443AE8: using guessed type int dword_443AE8;
// 443AF0: using guessed type char byte_443AF0;
// 443AF1: using guessed type char byte_443AF1;
// 443AF2: using guessed type char byte_443AF2;
// 44EBC0: using guessed type int dword_44EBC0;
// 44EC20: using guessed type int dword_44EC20;
// 44EC28: using guessed type int dword_44EC28;
// 44EC30: using guessed type int dword_44EC30;
// 44EC38: using guessed type int dword_44EC38;

//----- (00401870) --------------------------------------------------------
int __cdecl sub_401870(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6)
{
  __int16 v6; // bp
  __int16 v7; // di
  int v8; // esi
  int v9; // edi
  int result; // eax
  int v11; // ecx
  unsigned int v12; // [esp+10h] [ebp-Ch]
  char v13[8]; // [esp+14h] [ebp-8h]
  unsigned int v14; // [esp+34h] [ebp+18h]

  v6 = *((_WORD *)dword_443D44 + 4);
  v7 = *((_WORD *)dword_443D44 + 6);
  sub_4019D0(v13, a6, 0xAu);
  v8 = a1;
  v12 = sub_401A80(v13);
  if ( a1 == 0x10000000 )
  {
    v8 = (unsigned int)(v6 - a3 * sub_401A80(v13)) >> 1;
  }
  else if ( a1 & 0x20000000 )
  {
    v8 = v6 - a3 * sub_401A80(v13) - 10;
  }
  if ( a2 == 0x10000000 )
    v9 = (unsigned int)(v7 - a4) >> 1;
  else
    v9 = a2;
  result = 0;
  v14 = 0;
  if ( v12 )
  {
    v11 = a3;
    do
    {
      switch ( v13[result] )
      {
        case 48:
          sub_4015D0(v8, v9, v11, a4, a5, 0);
          break;
        case 49:
          sub_4015D0(v8, v9, v11, a4, a5, 1u);
          break;
        case 50:
          sub_4015D0(v8, v9, v11, a4, a5, 2u);
          break;
        case 51:
          sub_4015D0(v8, v9, v11, a4, a5, 3u);
          break;
        case 52:
          sub_4015D0(v8, v9, v11, a4, a5, 4u);
          break;
        case 53:
          sub_4015D0(v8, v9, v11, a4, a5, 5u);
          break;
        case 54:
          sub_4015D0(v8, v9, v11, a4, a5, 6u);
          break;
        case 55:
          sub_4015D0(v8, v9, v11, a4, a5, 7u);
          break;
        case 56:
          sub_4015D0(v8, v9, v11, a4, a5, 8u);
          break;
        case 57:
          sub_4015D0(v8, v9, v11, a4, a5, 9u);
          break;
        default:
          break;
      }
      v11 = a3;
      v8 += a3 + 5;
      if ( v8 >= v6 )
      {
        v8 = a1;
        v9 += a4;
      }
      result = v14++ + 1;
    }
    while ( v14 < v12 );
  }
  return result;
}
// 401870: using guessed type char var_8[8];

//----- (004019D0) --------------------------------------------------------
_BYTE *__cdecl sub_4019D0(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // esi
  int v4; // edi
  _BYTE *result; // eax
  bool v6; // zf
  char v7; // bl
  int v8; // ecx
  bool v9; // sf
  char v10; // cl
  signed int v11; // ecx
  int i; // edi
  char v13; // dl
  char v14[36]; // [esp+8h] [ebp-24h]
  signed int v15; // [esp+34h] [ebp+8h]

  v3 = a2;
  v4 = 0;
  if ( !a2 )
  {
    result = a1;
    *a1 = 48;
    a1[1] = 0;
    return result;
  }
  v15 = 0;
  if ( a3 == 10 )
  {
    v6 = v3 == 0;
    if ( (v3 & 0x80000000) == 0 )
      goto LABEL_7;
    v3 = -v3;
    v15 = 1;
  }
  v6 = v3 == 0;
LABEL_7:
  if ( !v6 )
  {
    v7 = (char)a1;
    do
    {
      v8 = v3 % a3;
      v9 = (v3 % a3 & 0x80000000) != 0;
      v3 /= a3;
      if ( v9 || v8 > 9 )
      {
        if ( v8 < 10 || v8 > 36 )
          goto LABEL_16;
        v10 = v8 + 87;
      }
      else
      {
        v10 = v8 + 48;
      }
      v7 = v10;
LABEL_16:
      v14[v4++] = v7;
    }
    while ( v3 );
  }
  result = a1;
  if ( v15 )
  {
    *a1 = 45;
    v11 = 1;
  }
  else
  {
    v11 = 0;
  }
  for ( i = v4 - 1; i >= 0; ++v11 )
  {
    v13 = v14[i--];
    a1[v11] = v13;
  }
  a1[v11] = 0;
  return result;
}
// 4019D0: using guessed type char var_24[36];

//----- (00401A80) --------------------------------------------------------
int __cdecl sub_401A80(char *a1)
{
  char *v1; // ecx
  int result; // eax
  char v3; // dl
  char v4; // dl

  v1 = a1;
  result = 0;
  if ( a1 )
  {
    v3 = *a1;
    if ( *a1 )
    {
      do
      {
        if ( v3 == 37 )
        {
          v4 = (v1++)[1];
          if ( v4 == 97 )
            v1 += 2;
        }
        else
        {
          ++result;
          ++v1;
        }
        v3 = *v1;
      }
      while ( *v1 );
    }
  }
  return result;
}

//----- (00401AB0) --------------------------------------------------------
char __cdecl sub_401AB0(int a1, int a2, int a3, char *j)
{
  __int16 v4; // bx
  char *v5; // edi
  char *v6; // esi
  char v7; // al
  char **v8; // ebp
  char v9; // al
  unsigned int v10; // ecx
  char v11; // al
  int v12; // esi
  char v13; // al
  unsigned __int16 v14; // di
  char *i; // ebp
  int v16; // ecx
  int v17; // eax
  char result; // al
  int v19; // ebp
  char v20; // bl
  int v21; // edi
  int v22; // ecx
  char *v23; // eax
  __int16 v24; // [esp+10h] [ebp-Ch]
  char v25[8]; // [esp+14h] [ebp-8h]
  int v26; // [esp+24h] [ebp+8h]

  v4 = *((_WORD *)dword_443D44 + 4);
  v5 = j;
  v24 = *((_WORD *)dword_443D44 + 6);
  v6 = &byte_443B14;
  v7 = *j;
  if ( *j )
  {
    v8 = &j;
    while ( 1 )
    {
      if ( v7 != 37 )
      {
        if ( v7 == 32 )
          *v6++ = 32;
        goto LABEL_14;
      }
      v9 = (v5++)[1];
      j = v5;
      if ( v9 == 100 )
        break;
      if ( v9 == 115 )
        goto LABEL_8;
LABEL_9:
      if ( *v6 )
      {
        do
          v11 = (v6++)[1];
        while ( v11 );
      }
LABEL_14:
      *v6 = -93;
      v7 = v5[1];
      ++v6;
      ++v5;
      if ( !v7 )
        goto LABEL_15;
    }
    *v6++ = -89;
LABEL_8:
    v10 = (unsigned int)v8[1];
    ++v8;
    sub_4019D0(v6, v10, 0xAu);
    goto LABEL_9;
  }
LABEL_15:
  *v6 = 0;
  v12 = a1;
  if ( a1 == 0x10000000 )
  {
    v13 = byte_443B14;
    v12 = (int)j;
    v14 = 0;
    for ( i = &byte_443B14; v13; ++i )
    {
      if ( v13 == -93 )
      {
        v25[v14] = 0;
        v12 = (v4 - ((unsigned __int16)dword_443AE4 + 5) * (unsigned __int16)word_44EBC4[4 * sub_434FDF(v25)]) / 2;
      }
      else
      {
        v16 = v14++;
        v25[v16] = v13;
      }
      v13 = i[1];
    }
  }
  v17 = a2;
  if ( a2 == 0x10000000 )
    v17 = (v24 - HIWORD(dword_443AE4)) / 2;
  v26 = v17;
  result = byte_443B14;
  LOWORD(v19) = 0;
  v20 = 0;
  for ( j = &byte_443B14; result; result = *v23 )
  {
    if ( result != -93 )
    {
      if ( result == -89 )
      {
        v20 = 1;
      }
      else
      {
        v22 = (unsigned __int16)v19;
        LOWORD(v19) = v19 + 1;
        v25[v22] = result;
      }
      goto LABEL_35;
    }
    v19 = (unsigned __int16)v19;
    v25[(unsigned __int16)v19] = 0;
    v21 = sub_434FDF(v25);
    if ( (v25[0] != 48 || v21) && !v20 )
    {
      if ( v21 )
      {
        sub_4015D0(v12, v26, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), a3, v21);
        v12 += (unsigned __int16)dword_443AE4 * (unsigned __int16)word_44EBC4[4 * v21];
        LOWORD(v19) = 0;
        v20 = 0;
        goto LABEL_35;
      }
    }
    else
    {
      sub_401870(v12, v26, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), a3, v21);
    }
    v12 += v19 * (unsigned __int16)dword_443AE4;
    LOWORD(v19) = 0;
    v20 = 0;
LABEL_35:
    v23 = j + 1;
    j = v23;
  }
  return result;
}
// 443AE4: using guessed type int dword_443AE4;
// 443B14: using guessed type char byte_443B14;
// 401AB0: using guessed type char var_8[8];

//----- (00401D10) --------------------------------------------------------
int sub_401D10()
{
  _DWORD *v0; // ecx
  _DWORD *v1; // eax
  int result; // eax

  v0 = dword_443D2C;
  v1 = (_DWORD *)*((_DWORD *)dword_443D2C + 16032);
  *((_DWORD *)dword_443D2C + 16032) = v1 + 3;
  v1[1] = 0;
  *v1 = v0[30];
  v0[30] = v1;
  result = sub_402EC0((int)v1, 0, 0, dword_443AD8);
  word_443B12 = 0;
  return result;
}
// 443AD8: using guessed type int dword_443AD8;
// 443B12: using guessed type __int16 word_443B12;

//----- (00401D60) --------------------------------------------------------
AGLFILE *__cdecl sub_401D60(int a1)
{
  AGLFILE *result; // eax
  AGLFILE *v2; // esi
  unsigned int v3; // edi
  void *v4; // ebx

  result = sub_403630(a1, 2);
  v2 = result;
  if ( result )
  {
    v3 = sub_403700(result);
    v4 = (void *)sub_401250(v3);
    sub_4036A0(v2, v4, v3);
    sub_403690(v2);
    result = (AGLFILE *)v4;
  }
  return result;
}

//----- (00401DB0) --------------------------------------------------------
int __cdecl sub_401DB0(unsigned __int8 *a1, char a2, unsigned int a3, unsigned int a4, unsigned __int16 a5, unsigned __int16 a6)
{
  unsigned __int16 v7; // ax
  unsigned __int16 v8; // cx
  int v9; // edx

  if ( !a1 )
    return 0;
  v7 = a5;
  if ( !a5 )
    v7 = *((_WORD *)a1 + 1);
  v8 = a6;
  if ( !a6 )
    v8 = *((_WORD *)a1 + 2);
  sub_402F20((unsigned __int16 *)a1 + 6, *a1, a3, a4, v7, v8, (int)&a1[*((_DWORD *)a1 + 2)]);
  LOBYTE(v9) = *a1;
  return sub_401000(v9, a2, a3, a4);
}

//----- (00401E20) --------------------------------------------------------
int __cdecl sub_401E20(int a1, int a2, int a3)
{
  return (a3 << 6) | (a2 >> 4);
}

//----- (00401E40) --------------------------------------------------------
char __cdecl sub_401E40(unsigned int a1)
{
  return sub_401380(a1);
}

//----- (00401E50) --------------------------------------------------------
int __cdecl sub_401E50(signed int a1, signed int a2, int a3, int a4, int a5)
{
  _DWORD *v5; // edx
  int result; // eax
  int v7; // ecx
  double v8; // st7
  double v9; // st6
  double v10; // st7
  float v11; // [esp+10h] [ebp+4h]

  if ( a5 )
  {
    v5 = dword_443D2C;
    result = *((_DWORD *)dword_443D2C + 16032);
    *((_DWORD *)dword_443D2C + 16032) = result + 88;
    *(_DWORD *)(result + 4) = 0;
    v7 = -(a5 != 1);
    *(_DWORD *)result = v5[30];
    LOBYTE(v7) = 0;
    v5[30] = result;
    *(_DWORD *)(result + 4) = 3;
    v8 = (double)a1;
    *(_DWORD *)(result + 4) = v7 + 259;
    *(_BYTE *)(result + 26) = byte_443C1D;
    *(_BYTE *)(result + 25) = byte_443C1E;
    LOBYTE(v7) = byte_443C1C;
    *(float *)(result + 8) = v8;
    *(_BYTE *)(result + 24) = v7;
    *(_DWORD *)(result + 16) = 0;
    v9 = (double)a2;
    *(float *)(result + 12) = v9;
    v11 = (double)(unsigned int)(a3 + a1);
    *(float *)(result + 28) = v11;
    *(_DWORD *)(result + 20) = 1065353216;
    *(float *)(result + 32) = v9;
    *(float *)(result + 68) = v11;
    *(_DWORD *)(result + 36) = 0;
    *(float *)(result + 48) = v8;
    v10 = (double)(unsigned int)(a4 + a2);
    *(_DWORD *)(result + 40) = 1065353216;
    *(_DWORD *)(result + 56) = 0;
    *(_DWORD *)(result + 60) = 1065353216;
    *(_DWORD *)(result + 76) = 0;
    *(float *)(result + 52) = v10;
    *(float *)(result + 72) = v10;
    *(_DWORD *)(result + 80) = 1065353216;
  }
  return result;
}
// 443C1C: using guessed type char byte_443C1C;
// 443C1D: using guessed type char byte_443C1D;
// 443C1E: using guessed type char byte_443C1E;

//----- (00401F30) --------------------------------------------------------
int __cdecl sub_401F30(__int16 a1, int a2, int a3, int a4)
{
  int *v4; // esi
  int v5; // eax
  int v6; // edx
  char v7; // dl
  int v8; // ecx
  char *v9; // eax
  int result; // eax
  int v11; // [esp+1Ch] [ebp-10h]

  v4 = (int *)*((_DWORD *)dword_443D24 + 88);
  if ( dword_443D48 || a1 & 0x100 )
    (*(void (__stdcall **)(int *, signed int, signed int))(*v4 + 80))(v4, 27, 1);
  else
    (*(void (__stdcall **)(int *, signed int, _DWORD))(*v4 + 80))(v4, 27, 0);
  if ( (a1 & 0x100) == dword_443D50 && !byte_443D54 )
    goto LABEL_19;
  dword_443D50 = a1 & 0x100;
  if ( !(a1 & 0x100) )
  {
    (*(void (__stdcall **)(int *, signed int, signed int, int))(*v4 + 80))(v4, 19, 5, v11);
    (*(void (__stdcall **)(int *, signed int, signed int))(*v4 + 80))(v4, 20, 6);
    goto LABEL_17;
  }
  v5 = dword_443D4C;
  if ( (unsigned int)dword_443D4C > 0x200 )
  {
    if ( dword_443D4C != 768 )
      goto LABEL_20;
LABEL_15:
    (*(void (__stdcall **)(int *, signed int, signed int, int))(*v4 + 80))(v4, 19, 5, v11);
    (*(void (__stdcall **)(int *, signed int, signed int))(*v4 + 80))(v4, 20, 6);
    v6 = *v4;
LABEL_18:
    (*(void (__stdcall **)(int *, _DWORD, signed int))(v6 + 148))(v4, 0, 4);
LABEL_19:
    v5 = dword_443D4C;
    goto LABEL_20;
  }
  switch ( dword_443D4C )
  {
    case 512:
      (*(void (__stdcall **)(int *, signed int, signed int, int))(*v4 + 80))(v4, 19, 1, v11);
      (*(void (__stdcall **)(int *, signed int, signed int))(*v4 + 80))(v4, 20, 4);
      goto LABEL_17;
    case 0:
      goto LABEL_15;
    case 256:
      (*(void (__stdcall **)(int *, signed int, signed int, int))(*v4 + 80))(v4, 19, 2, v11);
      (*(void (__stdcall **)(int *, signed int, signed int))(*v4 + 80))(v4, 20, 2);
LABEL_17:
      v6 = *v4;
      goto LABEL_18;
  }
LABEL_20:
  if ( a2 && a1 & 0x100 && (v5 == 768 || !v5) )
  {
    v7 = 127;
    if ( v5 == 768 )
      v7 = 63;
    v8 = a4;
    if ( a4 )
    {
      v9 = (char *)(a2 + 19);
      do
      {
        *v9 = v7;
        v9 += a3;
        --v8;
      }
      while ( v8 );
    }
  }
  result = a1 & 0x80;
  if ( result != dword_440180 )
  {
    dword_440180 = a1 & 0x80;
    if ( a1 & 0x80 )
      result = (*(int (__stdcall **)(int *, signed int, signed int))(*v4 + 80))(v4, 9, 2);
    else
      result = (*(int (__stdcall **)(int *, signed int, signed int))(*v4 + 80))(v4, 9, 1);
  }
  return result;
}
// 440180: using guessed type int dword_440180;
// 443D48: using guessed type int dword_443D48;
// 443D4C: using guessed type int dword_443D4C;
// 443D50: using guessed type int dword_443D50;
// 443D54: using guessed type char byte_443D54;

//----- (00402080) --------------------------------------------------------
int __cdecl sub_402080(int a1)
{
  int v1; // edi
  int v2; // esi
  int v3; // ecx
  int *v4; // eax
  int v5; // edx
  int v6; // edi
  bool v7; // zf

  v1 = *(_DWORD *)(a1 + 8);
  v2 = (unsigned __int8)*(_DWORD *)(a1 + 8);
  if ( v2 != dword_443D48 )
  {
    v3 = dword_443C28[v2];
    v4 = (int *)*((_DWORD *)dword_443D24 + 88);
    v5 = *v4;
    if ( v3 )
      (*(void (__stdcall **)(int *, _DWORD, _DWORD))(v5 + 140))(v4, 0, *(_DWORD *)(v3 + 108));
    else
      (*(void (__stdcall **)(int *, _DWORD, _DWORD))(v5 + 140))(v4, 0, 0);
    dword_443D48 = v2;
  }
  v6 = v1 & 0x300;
  v7 = v6 == dword_443D4C;
  dword_443D4C = v6;
  byte_443D54 = !v7;
  return sub_401F30(*(_DWORD *)(a1 + 4), 0, 0, 0);
}
// 443D48: using guessed type int dword_443D48;
// 443D4C: using guessed type int dword_443D4C;
// 443D54: using guessed type char byte_443D54;

//----- (00402100) --------------------------------------------------------
int __cdecl sub_402100(int a1)
{
  int v1; // eax
  int v2; // esi
  int v3; // ebx
  __int16 v4; // di
  int v5; // ecx
  int *v6; // eax
  int v7; // edx

  v1 = dword_443D4C;
  v2 = (unsigned __int8)dword_443D4C;
  v3 = a1 + 8;
  v4 = dword_443D4C;
  if ( (unsigned __int8)dword_443D4C != dword_443D48 )
  {
    v5 = dword_443C28[(unsigned __int8)dword_443D4C];
    v6 = (int *)*((_DWORD *)dword_443D24 + 88);
    v7 = *v6;
    if ( v5 )
      (*(void (__stdcall **)(int *, _DWORD, _DWORD))(v7 + 140))(v6, 0, *(_DWORD *)(v5 + 108));
    else
      (*(void (__stdcall **)(int *, _DWORD, _DWORD))(v7 + 140))(v6, 0, 0);
    v1 = dword_443D4C;
    dword_443D48 = v2;
  }
  dword_443D4C = v4 & 0x300;
  byte_443D54 = (v4 & 0x300) != v1;
  sub_401F30(*(_DWORD *)(a1 + 4), v3, 20, 3);
  return (*(int (__stdcall **)(_DWORD, signed int, signed int, int, signed int, _DWORD))(**((_DWORD **)dword_443D24 + 88)
                                                                                       + 100))(
           *((_DWORD *)dword_443D24 + 88),
           4,
           68,
           v3,
           3,
           0);
}
// 443D48: using guessed type int dword_443D48;
// 443D4C: using guessed type int dword_443D4C;
// 443D54: using guessed type char byte_443D54;

//----- (004021A0) --------------------------------------------------------
int __cdecl sub_4021A0(int a1)
{
  int v1; // ecx
  int v2; // esi
  int v3; // ebp
  __int16 v4; // bx
  int v5; // eax
  int *v6; // ecx
  int v7; // edx
  char v8; // al
  char v9; // al
  char v10; // al
  int v12; // [esp+3Ch] [ebp-4h]
  int v13; // [esp+44h] [ebp+4h]

  v1 = dword_443D4C;
  v2 = a1;
  v3 = a1 + 8;
  v4 = dword_443D4C;
  v13 = (unsigned __int8)dword_443D4C;
  if ( (unsigned __int8)dword_443D4C != dword_443D48 )
  {
    v5 = dword_443C28[(unsigned __int8)dword_443D4C];
    v6 = (int *)*((_DWORD *)dword_443D24 + 88);
    v7 = *v6;
    if ( v5 )
      (*(void (__stdcall **)(int *, _DWORD, _DWORD))(v7 + 140))(v6, 0, *(_DWORD *)(v5 + 108));
    else
      (*(void (__stdcall **)(int *, _DWORD, _DWORD))(v7 + 140))(v6, 0, 0);
    v1 = dword_443D4C;
    dword_443D48 = v13;
  }
  dword_443D4C = v4 & 0x300;
  byte_443D54 = (v4 & 0x300) != v1;
  sub_401F30(*(_DWORD *)(v2 + 4), v3, 20, 4);
  v8 = *(_BYTE *)(v2 + 24);
  *(_DWORD *)(v2 + 16) = 0;
  *(_BYTE *)(v2 + 44) = v8;
  *(_BYTE *)(v2 + 64) = v8;
  *(_BYTE *)(v2 + 84) = v8;
  v9 = *(_BYTE *)(v2 + 26);
  *(_BYTE *)(v2 + 46) = v9;
  *(_BYTE *)(v2 + 66) = v9;
  *(_BYTE *)(v2 + 86) = v9;
  v10 = *(_BYTE *)(v2 + 25);
  *(_BYTE *)(v2 + 45) = v10;
  *(_BYTE *)(v2 + 65) = v10;
  *(_BYTE *)(v2 + 85) = v10;
  *(_DWORD *)(v2 + 36) = 0;
  *(_DWORD *)(v2 + 56) = 0;
  *(_DWORD *)(v2 + 76) = 0;
  *(_DWORD *)(v2 + 20) = 0;
  *(_DWORD *)(v2 + 40) = 0;
  *(_DWORD *)(v2 + 60) = 0;
  *(_DWORD *)(v2 + 80) = 0;
  (*(void (__stdcall **)(_DWORD, signed int, int *))(**((_DWORD **)dword_443D24 + 88) + 84))(
    *((_DWORD *)dword_443D24 + 88),
    136,
    &v12);
  (*(void (__stdcall **)(_DWORD, signed int, _DWORD))(**((_DWORD **)dword_443D24 + 88) + 80))(
    *((_DWORD *)dword_443D24 + 88),
    136,
    0);
  (*(void (__stdcall **)(_DWORD, signed int, signed int, int, signed int, _DWORD))(**((_DWORD **)dword_443D24 + 88) + 100))(
    *((_DWORD *)dword_443D24 + 88),
    5,
    68,
    v3,
    4,
    0);
  return (*(int (__stdcall **)(_DWORD, signed int, int))(**((_DWORD **)dword_443D24 + 88) + 80))(
           *((_DWORD *)dword_443D24 + 88),
           136,
           v12);
}
// 443D48: using guessed type int dword_443D48;
// 443D4C: using guessed type int dword_443D4C;
// 443D54: using guessed type char byte_443D54;

//----- (004022E0) --------------------------------------------------------
int __cdecl sub_4022E0(int a1)
{
  int v1; // esi
  int v2; // ebx
  int v3; // edi
  int v4; // ecx
  int *v5; // eax
  int v6; // edx
  int v7; // esi
  bool v8; // zf

  v1 = *(_DWORD *)(a1 + 8);
  v2 = a1 + 12;
  v3 = (unsigned __int8)*(_DWORD *)(a1 + 8);
  if ( v3 != dword_443D48 )
  {
    v4 = dword_443C28[v3];
    v5 = (int *)*((_DWORD *)dword_443D24 + 88);
    v6 = *v5;
    if ( v4 )
      (*(void (__stdcall **)(int *, _DWORD, _DWORD))(v6 + 140))(v5, 0, *(_DWORD *)(v4 + 108));
    else
      (*(void (__stdcall **)(int *, _DWORD, _DWORD))(v6 + 140))(v5, 0, 0);
    dword_443D48 = v3;
  }
  v7 = v1 & 0x300;
  v8 = v7 == dword_443D4C;
  dword_443D4C = v7;
  byte_443D54 = !v8;
  sub_401F30(*(_DWORD *)(a1 + 4), v2, 28, 3);
  return (*(int (__stdcall **)(_DWORD, signed int, signed int, int, signed int, _DWORD))(**((_DWORD **)dword_443D24 + 88)
                                                                                       + 100))(
           *((_DWORD *)dword_443D24 + 88),
           4,
           324,
           v2,
           3,
           0);
}
// 443D48: using guessed type int dword_443D48;
// 443D4C: using guessed type int dword_443D4C;
// 443D54: using guessed type char byte_443D54;

//----- (00402380) --------------------------------------------------------
int __cdecl sub_402380(_DWORD *a1)
{
  int v1; // edi
  int v2; // ebp
  int v3; // ebx
  int v4; // ecx
  int *v5; // eax
  int v6; // edx
  int v7; // edi
  bool v8; // zf
  int v9; // eax

  v1 = a1[2];
  v2 = (int)(a1 + 4);
  v3 = (unsigned __int8)a1[2];
  if ( v3 != dword_443D48 )
  {
    v4 = dword_443C28[v3];
    v5 = (int *)*((_DWORD *)dword_443D24 + 88);
    v6 = *v5;
    if ( v4 )
      (*(void (__stdcall **)(int *, _DWORD, _DWORD))(v6 + 140))(v5, 0, *(_DWORD *)(v4 + 108));
    else
      (*(void (__stdcall **)(int *, _DWORD, _DWORD))(v6 + 140))(v5, 0, 0);
    dword_443D48 = v3;
  }
  v7 = v1 & 0x300;
  v8 = v7 == dword_443D4C;
  dword_443D4C = v7;
  byte_443D54 = !v8;
  sub_401F30(a1[1], v2, 28, 4);
  v9 = a1[8];
  a1[15] = v9;
  a1[22] = v9;
  a1[29] = v9;
  return (*(int (__stdcall **)(_DWORD, signed int, signed int, int, signed int, _DWORD))(**((_DWORD **)dword_443D24 + 88)
                                                                                       + 100))(
           *((_DWORD *)dword_443D24 + 88),
           5,
           324,
           v2,
           4,
           0);
}
// 443D48: using guessed type int dword_443D48;
// 443D4C: using guessed type int dword_443D4C;
// 443D54: using guessed type char byte_443D54;

//----- (00402430) --------------------------------------------------------
int __cdecl sub_402430(int a1)
{
  int v1; // eax
  int v2; // esi
  int v3; // ebx
  __int16 v4; // di
  int v5; // ecx
  int *v6; // eax
  int v7; // edx

  v1 = dword_443D4C;
  v2 = (unsigned __int8)dword_443D4C;
  v3 = a1 + 8;
  v4 = dword_443D4C;
  if ( (unsigned __int8)dword_443D4C != dword_443D48 )
  {
    v5 = dword_443C28[(unsigned __int8)dword_443D4C];
    v6 = (int *)*((_DWORD *)dword_443D24 + 88);
    v7 = *v6;
    if ( v5 )
      (*(void (__stdcall **)(int *, _DWORD, _DWORD))(v7 + 140))(v6, 0, *(_DWORD *)(v5 + 108));
    else
      (*(void (__stdcall **)(int *, _DWORD, _DWORD))(v7 + 140))(v6, 0, 0);
    v1 = dword_443D4C;
    dword_443D48 = v2;
  }
  dword_443D4C = v4 & 0x300;
  byte_443D54 = (v4 & 0x300) != v1;
  sub_401F30(*(_DWORD *)(a1 + 4), v3, 20, 3);
  return (*(int (__stdcall **)(_DWORD, signed int, signed int, int, signed int, _DWORD))(**((_DWORD **)dword_443D24 + 88)
                                                                                       + 100))(
           *((_DWORD *)dword_443D24 + 88),
           4,
           68,
           v3,
           3,
           0);
}
// 443D48: using guessed type int dword_443D48;
// 443D4C: using guessed type int dword_443D4C;
// 443D54: using guessed type char byte_443D54;

//----- (004024D0) --------------------------------------------------------
int __cdecl sub_4024D0(int a1)
{
  int v1; // eax
  int v2; // esi
  int v3; // ebx
  __int16 v4; // di
  int v5; // ecx
  int *v6; // eax
  int v7; // edx

  v1 = dword_443D4C;
  v2 = (unsigned __int8)dword_443D4C;
  v3 = a1 + 8;
  v4 = dword_443D4C;
  if ( (unsigned __int8)dword_443D4C != dword_443D48 )
  {
    v5 = dword_443C28[(unsigned __int8)dword_443D4C];
    v6 = (int *)*((_DWORD *)dword_443D24 + 88);
    v7 = *v6;
    if ( v5 )
      (*(void (__stdcall **)(int *, _DWORD, _DWORD))(v7 + 140))(v6, 0, *(_DWORD *)(v5 + 108));
    else
      (*(void (__stdcall **)(int *, _DWORD, _DWORD))(v7 + 140))(v6, 0, 0);
    v1 = dword_443D4C;
    dword_443D48 = v2;
  }
  dword_443D4C = v4 & 0x300;
  byte_443D54 = (v4 & 0x300) != v1;
  sub_401F30(*(_DWORD *)(a1 + 4), v3, 20, 4);
  return (*(int (__stdcall **)(_DWORD, signed int, signed int, int, signed int, _DWORD))(**((_DWORD **)dword_443D24 + 88)
                                                                                       + 100))(
           *((_DWORD *)dword_443D24 + 88),
           5,
           68,
           v3,
           4,
           0);
}
// 443D48: using guessed type int dword_443D48;
// 443D4C: using guessed type int dword_443D4C;
// 443D54: using guessed type char byte_443D54;

//----- (00402570) --------------------------------------------------------
int __cdecl sub_402570(int a1)
{
  int v1; // esi
  int v2; // ebx
  int v3; // edi
  int v4; // ecx
  int *v5; // eax
  int v6; // edx
  int v7; // esi
  bool v8; // zf

  v1 = *(_DWORD *)(a1 + 8);
  v2 = a1 + 12;
  v3 = (unsigned __int8)*(_DWORD *)(a1 + 8);
  if ( v3 != dword_443D48 )
  {
    v4 = dword_443C28[v3];
    v5 = (int *)*((_DWORD *)dword_443D24 + 88);
    v6 = *v5;
    if ( v4 )
      (*(void (__stdcall **)(int *, _DWORD, _DWORD))(v6 + 140))(v5, 0, *(_DWORD *)(v4 + 108));
    else
      (*(void (__stdcall **)(int *, _DWORD, _DWORD))(v6 + 140))(v5, 0, 0);
    dword_443D48 = v3;
  }
  v7 = v1 & 0x300;
  v8 = v7 == dword_443D4C;
  dword_443D4C = v7;
  byte_443D54 = !v8;
  sub_401F30(*(_DWORD *)(a1 + 4), v2, 28, 3);
  return (*(int (__stdcall **)(_DWORD, signed int, signed int, int, signed int, _DWORD))(**((_DWORD **)dword_443D24 + 88)
                                                                                       + 100))(
           *((_DWORD *)dword_443D24 + 88),
           4,
           324,
           v2,
           3,
           0);
}
// 443D48: using guessed type int dword_443D48;
// 443D4C: using guessed type int dword_443D4C;
// 443D54: using guessed type char byte_443D54;

//----- (00402610) --------------------------------------------------------
int __cdecl sub_402610(int a1)
{
  int v1; // esi
  int v2; // ebx
  int v3; // edi
  int v4; // ecx
  int *v5; // eax
  int v6; // edx
  int v7; // esi
  bool v8; // zf

  v1 = *(_DWORD *)(a1 + 8);
  v2 = a1 + 12;
  v3 = (unsigned __int8)*(_DWORD *)(a1 + 8);
  if ( v3 != dword_443D48 )
  {
    v4 = dword_443C28[v3];
    v5 = (int *)*((_DWORD *)dword_443D24 + 88);
    v6 = *v5;
    if ( v4 )
      (*(void (__stdcall **)(int *, _DWORD, _DWORD))(v6 + 140))(v5, 0, *(_DWORD *)(v4 + 108));
    else
      (*(void (__stdcall **)(int *, _DWORD, _DWORD))(v6 + 140))(v5, 0, 0);
    dword_443D48 = v3;
  }
  v7 = v1 & 0x300;
  v8 = v7 == dword_443D4C;
  dword_443D4C = v7;
  byte_443D54 = !v8;
  sub_401F30(*(_DWORD *)(a1 + 4), v2, 28, 4);
  return (*(int (__stdcall **)(_DWORD, signed int, signed int, int, signed int, _DWORD))(**((_DWORD **)dword_443D24 + 88)
                                                                                       + 100))(
           *((_DWORD *)dword_443D24 + 88),
           5,
           324,
           v2,
           4,
           0);
}
// 443D48: using guessed type int dword_443D48;
// 443D4C: using guessed type int dword_443D4C;
// 443D54: using guessed type char byte_443D54;

//----- (004026B0) --------------------------------------------------------
int __cdecl sub_4026B0(int a1)
{
  int v1; // esi
  int v2; // edi
  double v3; // st7
  double v4; // st6
  double v5; // st5
  signed int v6; // eax
  float v7; // ST20_4
  float v8; // ST24_4
  double v9; // st4
  float v10; // ST28_4
  float v11; // ST2C_4
  float v12; // ST30_4
  float v14; // [esp+20h] [ebp+4h]

  v1 = a1;
  v2 = a1 + 12;
  sub_401F30(*(_DWORD *)(a1 + 4), a1 + 12, 28, 4);
  v3 = *(float *)(a1 + 12);
  v4 = *(float *)(a1 + 16);
  v5 = (double)*(signed __int16 *)(a1 + 8);
  v6 = *(signed __int16 *)(a1 + 10);
  v7 = *(float *)(a1 + 32);
  v8 = v5 + v3;
  v9 = (double)v6;
  v14 = *(float *)(a1 + 36);
  *(float *)(v1 + 40) = v8;
  *(_DWORD *)(v1 + 52) = 1065353216;
  *(_DWORD *)(v1 + 80) = 1065353216;
  *(_DWORD *)(v1 + 108) = 1065353216;
  *(_DWORD *)(v1 + 48) = 0;
  v10 = v9 + v4;
  *(_DWORD *)(v1 + 76) = 0;
  *(_DWORD *)(v1 + 104) = 0;
  v11 = v5 * 0.0039215689 + v7;
  *(float *)(v1 + 60) = v11;
  *(float *)(v1 + 64) = v14;
  *(_BYTE *)(v1 + 58) = *(_BYTE *)(v1 + 30);
  *(_BYTE *)(v1 + 57) = *(_BYTE *)(v1 + 29);
  *(_BYTE *)(v1 + 56) = *(_BYTE *)(v1 + 28);
  *(_BYTE *)(v1 + 59) = *(_BYTE *)(v1 + 31);
  *(float *)(v1 + 72) = v10;
  v12 = (double)(v6 - 1) * 0.0039215689 + v14;
  *(float *)(v1 + 88) = v7;
  *(float *)(v1 + 44) = v4;
  *(float *)(v1 + 92) = v12;
  *(float *)(v1 + 68) = v3;
  *(float *)(v1 + 96) = v8;
  *(float *)(v1 + 100) = v10;
  *(float *)(v1 + 116) = v11;
  *(float *)(v1 + 120) = v12;
  return (*(int (__stdcall **)(_DWORD, signed int, signed int, int, signed int, _DWORD))(**((_DWORD **)dword_443D24 + 88)
                                                                                       + 100))(
           *((_DWORD *)dword_443D24 + 88),
           5,
           324,
           v2,
           4,
           0);
}

//----- (004027D0) --------------------------------------------------------
int __cdecl sub_4027D0(int a1)
{
  int v1; // ebx
  int v2; // eax
  int v3; // esi
  __int16 v4; // di
  int v5; // ecx
  int *v6; // eax
  int v7; // edx
  char v8; // cl
  char v9; // dl
  char v10; // al
  int v12; // [esp+Ch] [ebp-4h]

  v1 = a1;
  v12 = *(_DWORD *)(a1 + 4) & 0x80;
  switch ( *(_DWORD *)(a1 + 4) & 0x7F )
  {
    case 0xB:
    case 0x8E:
      a1 = 2;
      break;
    case 0xC:
    case 0x8F:
      a1 = 3;
      break;
    case 0xD:
    case 0x90:
      a1 = 4;
      break;
    default:
      break;
  }
  v2 = dword_443D4C;
  v3 = (unsigned __int8)dword_443D4C;
  v4 = dword_443D4C;
  if ( (unsigned __int8)dword_443D4C != dword_443D48 )
  {
    v5 = dword_443C28[(unsigned __int8)dword_443D4C];
    v6 = (int *)*((_DWORD *)dword_443D24 + 88);
    v7 = *v6;
    if ( v5 )
      (*(void (__stdcall **)(int *, _DWORD, _DWORD))(v7 + 140))(v6, 0, *(_DWORD *)(v5 + 108));
    else
      (*(void (__stdcall **)(int *, _DWORD, _DWORD))(v7 + 140))(v6, 0, 0);
    v2 = dword_443D4C;
    dword_443D48 = v3;
  }
  dword_443D4C = v4 & 0x300;
  byte_443D54 = (v4 & 0x300) != v2;
  sub_401F30(*(_DWORD *)(v1 + 4), v1 + 8, 20, a1);
  if ( !v12 )
  {
    v8 = *(_BYTE *)(v1 + 25);
    v9 = *(_BYTE *)(v1 + 24);
    *(_BYTE *)(v1 + 46) = *(_BYTE *)(v1 + 26);
    v10 = *(_BYTE *)(v1 + 27);
    *(_BYTE *)(v1 + 45) = v8;
    *(_BYTE *)(v1 + 44) = v9;
    *(_BYTE *)(v1 + 47) = v10;
  }
  return (*(int (__stdcall **)(_DWORD, signed int, signed int, int, int, _DWORD))(**((_DWORD **)dword_443D24 + 88) + 100))(
           *((_DWORD *)dword_443D24 + 88),
           3,
           68,
           v1 + 8,
           a1,
           0);
}
// 443D48: using guessed type int dword_443D48;
// 443D4C: using guessed type int dword_443D4C;
// 443D54: using guessed type char byte_443D54;

//----- (00402980) --------------------------------------------------------
_DWORD *__cdecl sub_402980(_DWORD *a1, int a2)
{
  int v2; // edx
  _DWORD *result; // eax

  v2 = a2 - 1;
  if ( a2 == 1 )
  {
    result = a1;
    *a1 = 0;
    a1[1] = 0;
  }
  else
  {
    result = a1;
    do
    {
      result[1] = 0;
      *result = result + 2;
      --v2;
      result += 2;
    }
    while ( v2 );
    *result = 0;
    result[1] = 0;
  }
  return result;
}

//----- (004029B0) --------------------------------------------------------
_DWORD *__cdecl sub_4029B0(int a1, int a2)
{
  int v2; // edx
  _DWORD *result; // eax

  v2 = a2 - 1;
  result = (_DWORD *)(a1 + 8 * (a2 - 1));
  if ( a2 == 1 )
  {
    *result = 0;
    result[1] = 0;
  }
  else
  {
    do
    {
      result[1] = 0;
      *result = result - 2;
      --v2;
      result -= 2;
    }
    while ( v2 );
    *result = 0;
    result[1] = 0;
  }
  return result;
}

//----- (004029E0) --------------------------------------------------------
int __cdecl sub_4029E0(_DWORD *a1)
{
  int result; // eax
  _DWORD *i; // esi
  unsigned int v3; // eax
  void (__cdecl *v4)(_DWORD *); // eax

  result = (*(int (__stdcall **)(_DWORD))(**((_DWORD **)dword_443D24 + 88) + 20))(*((_DWORD *)dword_443D24 + 88));
  if ( !result )
  {
    for ( i = a1; i; i = (_DWORD *)*i )
    {
      v3 = i[1] & 0x7F;
      if ( v3 < 0x11 )
      {
        v4 = (void (__cdecl *)(_DWORD *))dword_440184[v3];
        if ( v4 )
          v4(i);
      }
      else
      {
        nullsub_1(aInvalidPrimiti);
      }
    }
    result = (*(int (__stdcall **)(_DWORD))(**((_DWORD **)dword_443D24 + 88) + 24))(*((_DWORD *)dword_443D24 + 88));
  }
  return result;
}
// 434B40: using guessed type int __cdecl nullsub_1(_DWORD);
// 440184: using guessed type int dword_440184[];

//----- (00402A40) --------------------------------------------------------
int __cdecl sub_402A40(_DWORD *a1)
{
  int result; // eax

  sub_402980(a1, 16);
  result = (int)(a1 + 32);
  a1[16032] = a1 + 32;
  return result;
}

//----- (00402A60) --------------------------------------------------------
int __cdecl sub_402A60(int a1, int a2, _DWORD *a3, int a4)
{
  int result; // eax

  result = 16 - a4;
  *a3 = *(_DWORD *)(a1 + 8 * (16 - a4));
  *(_DWORD *)(a1 + 8 * (16 - a4)) = a2;
  return result;
}

//----- (00402A90) --------------------------------------------------------
void *sub_402A90()
{
  void *result; // eax

  result = dword_443D2C;
  if ( dword_443D2C && dword_443D24 )
  {
    sub_4029E0(dword_443D2C);
    AGLSCREEN::Flip(dword_443D24, 0, 0);
    sub_402A40(dword_443D2C);
    result = (void *)dword_444168;
    while ( dword_444168 - dword_444168 < (unsigned int)dword_443D30 )
      ;
    byte_443D34 ^= 1u;
  }
  byte_443D3C = 0;
  return result;
}
// 443D30: using guessed type int dword_443D30;
// 443D34: using guessed type char byte_443D34;
// 443D3C: using guessed type char byte_443D3C;
// 444168: using guessed type int dword_444168;

//----- (00402B00) --------------------------------------------------------
char sub_402B00()
{
  char result; // al

  for ( result = byte_443D34; byte_443D34; result = byte_443D34 )
    sub_402A90();
  return result;
}
// 443D34: using guessed type char byte_443D34;

//----- (00402B20) --------------------------------------------------------
int __cdecl sub_402B20(int a1, unsigned int a2)
{
  int result; // eax

  result = a2 & 0x3FF;
  dword_443D40 = a2 & 0x3FF;
  dword_443D28 = (a2 >> 10) & 0x3FF;
  return result;
}
// 443D28: using guessed type int dword_443D28;
// 443D40: using guessed type int dword_443D40;

//----- (00402B40) --------------------------------------------------------
char sub_402B40()
{
  void *v0; // eax
  void *v1; // eax
  unsigned int v2; // esi
  unsigned int v3; // edi
  AGLSCREEN *v4; // eax
  int v6; // ST3C_4
  int *v7; // eax
  unsigned int v8; // ebx
  int v9; // ebp
  unsigned int v10; // edi
  _DWORD *v11; // esi
  struct AGLIMAGE *v12; // eax
  struct AGLIMAGE *v13; // eax
  int *v14; // [esp+58h] [ebp-18h]
  struct tagRECT Rect; // [esp+60h] [ebp-10h]

  if ( !dword_443D2C )
  {
    byte_443D34 = 0;
    v0 = malloc(0xFA84u);
    dword_443D2C = v0;
    memset(v0, 0, 0xFA84u);
    sub_402A40(dword_443D2C);
    v1 = malloc(0x1Cu);
    dword_443D44 = v1;
    memset(v1, 0, 0x1Cu);
    dword_443D38 = (int)dword_443D44;
    GetClientRect(hWnd, &Rect);
    v2 = Rect.right - Rect.left;
    v3 = Rect.bottom - Rect.top;
    v4 = AGLCreateScreen(hWnd, byte_44416C);
    dword_443D24 = v4;
    if ( !v4 )
    {
      AGLGetLastError();
      nullsub_1(aErrorCanTCreat);
      return 0;
    }
    AGLSCREEN::SetDisplayMode(v4, v2, v3, 0x10u, 0);
    *((_DWORD *)dword_443D44 + 4) = dword_443D24;
    *((_DWORD *)dword_443D44 + 2) = v2;
    *((_DWORD *)dword_443D44 + 3) = v3;
    nullsub_1(aVideoInitialis);
    *((_BYTE *)dword_443D24 + 54);
    nullsub_1(a3dAcceleration);
    *((_BYTE *)dword_443D24 + 55);
    nullsub_1(aAgpEnabledS);
    v6 = *((_DWORD *)dword_443D24 + 18);
    nullsub_1(aTotalVideoMemD);
    if ( !*((_BYTE *)dword_443D24 + 54) )
    {
      sub_403990(aErrorNo3dAccel);
      return 0;
    }
    if ( *((_DWORD *)dword_443D24 + 18) < 0x3CCCCCu )
    {
      sub_403990(aErrorVideoMem);
      return 0;
    }
    (*(void (__stdcall **)(_DWORD, _DWORD, signed int, signed int))(**((_DWORD **)dword_443D24 + 88) + 148))(
      *((_DWORD *)dword_443D24 + 88),
      0,
      12,
      3);
    (*(void (__stdcall **)(_DWORD, signed int, signed int, signed int))(**((_DWORD **)dword_443D24 + 88) + 148))(
      *((_DWORD *)dword_443D24 + 88),
      1,
      12,
      3);
    (*(void (__stdcall **)(_DWORD, signed int, signed int))(**((_DWORD **)dword_443D24 + 88) + 80))(
      *((_DWORD *)dword_443D24 + 88),
      26,
      1);
    (*(void (__stdcall **)(_DWORD, signed int, _DWORD))(**((_DWORD **)dword_443D24 + 88) + 80))(
      *((_DWORD *)dword_443D24 + 88),
      15,
      0);
    LOBYTE(dword_455CBC) = *((_BYTE *)dword_443D24 + 56);
    *((float *)dword_443D44 + 5) = *((float *)dword_443D24 + 33) * 0.5;
    v7 = dword_443C28;
    v14 = dword_443C28;
    *((float *)dword_443D44 + 6) = *((float *)dword_443D24 + 34) * 0.5;
    v8 = (unsigned int)dword_443D28 >> 6;
    v9 = 0;
    while ( 2 )
    {
      v10 = 0;
      v11 = v7;
      do
      {
        *v11 = 0;
        if ( v10 >= v8 )
        {
          if ( (signed int)v7 >= (signed int)&unk_443CD0 )
          {
            if ( v10 - v8 < 6 )
            {
              v13 = AGLSCREEN::CreateImage(dword_443D24, 0x100u, 0x100u, 0x10u, 5u);
              *v11 = v13;
              if ( !v13 )
              {
                nullsub_1(aErrorCanTCreat_0);
                return 0;
              }
            }
          }
          else
          {
            v12 = AGLSCREEN::CreateImage(dword_443D24, 0x100u, 0x100u, 0x10u, 5u);
            *v11 = v12;
            if ( !v12 )
            {
              nullsub_1(aErrorCanTCreat_0);
              return 0;
            }
          }
        }
        v7 = v14;
        ++v10;
        ++v11;
      }
      while ( v10 < 0x15 );
      v7 = v14 + 21;
      v9 += 21;
      v14 = v7;
      if ( (signed int)v7 < (signed int)&dword_443D24 )
        continue;
      break;
    }
  }
  return 1;
}
// 434B40: using guessed type int __cdecl nullsub_1(_DWORD);
// 443D28: using guessed type int dword_443D28;
// 443D34: using guessed type char byte_443D34;
// 443D38: using guessed type int dword_443D38;
// 44416C: using guessed type char byte_44416C;
// 455CBC: using guessed type int dword_455CBC;

//----- (00402E60) --------------------------------------------------------
void sub_402E60()
{
  free(dword_443D2C);
  dword_443D2C = 0;
  free(dword_443D44);
  dword_443D38 = 0;
  dword_443D44 = 0;
  if ( dword_443D24 )
    (**(void (***)(void))dword_443D24)();
  dword_443D24 = 0;
}
// 443D38: using guessed type int dword_443D38;

//----- (00402EB0) --------------------------------------------------------
int __cdecl sub_402EB0(int a1)
{
  int result; // eax

  result = a1;
  dword_443D30 = a1;
  return result;
}
// 443D30: using guessed type int dword_443D30;

//----- (00402EC0) --------------------------------------------------------
int __cdecl sub_402EC0(int a1, int a2, int a3, int a4)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 4) = 1;
  *(_DWORD *)(a1 + 8) = a4;
  return result;
}

//----- (00402EE0) --------------------------------------------------------
struct AGLIMAGE *__cdecl sub_402EE0(unsigned int a1, unsigned int a2)
{
  struct AGLIMAGE *result; // eax
  unsigned int v3; // eax

  if ( a1 < dword_443D28 )
    return AGLSCREEN::GetBackImage(dword_443D24);
  v3 = (a1 >> 6) + 21 * (a2 >> 8);
  if ( v3 < 0x3F )
    result = (struct AGLIMAGE *)dword_443C28[v3];
  else
    result = 0;
  return result;
}
// 443D28: using guessed type int dword_443D28;

//----- (00402F20) --------------------------------------------------------
void __cdecl sub_402F20(unsigned __int16 *a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5, int a6, int a7)
{
  void *v7; // ecx
  void *v8; // eax
  unsigned int v9; // ebx
  unsigned __int16 *v10; // esi
  struct AGLIMAGE *v11; // ebp
  int v12; // ecx
  unsigned int v13; // edi
  unsigned int v14; // eax
  unsigned int v15; // esi
  unsigned __int16 *v16; // esi
  void *v17; // [esp+0h] [ebp-4h]

  v17 = v7;
  if ( a2 )
  {
    if ( a2 == 1 )
    {
      v8 = sub_403120(a1, a5, a6, a7);
    }
    else
    {
      if ( a2 != 2 )
        goto LABEL_8;
      v8 = a1;
    }
  }
  else
  {
    v8 = sub_403070(a1, a5, a6, a7);
  }
  v17 = v8;
LABEL_8:
  v9 = a3;
  v10 = (unsigned __int16 *)a4;
  v11 = sub_402EE0(a3, a4);
  a7 = v9;
  a1 = v10;
  sub_403360(&a7, &a1);
  v12 = a7;
  if ( a7 + a5 > *((_DWORD *)v11 + 12) )
  {
    v13 = 0;
    while ( 1 )
    {
      v14 = *((_DWORD *)v11 + 12);
      v15 = a5 - v13;
      if ( a5 - v13 > v14 )
        v15 = v14 - v12;
      sub_4031D0(v11, v12, (int)a1, (int)v17, v13, 0, v15, 2 * a5, a6);
      v13 += v15;
      v9 += v15 >> 2;
      v16 = (unsigned __int16 *)a4;
      v11 = sub_402EE0(v9, a4);
      a7 = v9;
      a1 = v16;
      sub_403360(&a7, &a1);
      if ( v13 >= a5 )
        break;
      v12 = a7;
    }
  }
  else
  {
    sub_4031D0(v11, a7, (int)a1, (int)v17, 0, 0, a5, 2 * a5, a6);
  }
  if ( a2 < 2 )
    free(v17);
}

//----- (00403070) --------------------------------------------------------
void *__cdecl sub_403070(unsigned __int16 *a1, unsigned int a2, int a3, int a4)
{
  void *result; // eax
  void *v5; // ecx
  unsigned int v6; // ebp
  _WORD *v7; // esi
  unsigned __int16 *v8; // eax
  signed int v9; // edi
  unsigned int v10; // edx
  int v11; // ecx
  unsigned int v12; // ebp
  int v13; // [esp+Ch] [ebp-8h]
  void *v14; // [esp+10h] [ebp-4h]
  unsigned int v15; // [esp+1Ch] [ebp+8h]
  unsigned int v16; // [esp+20h] [ebp+Ch]

  result = malloc(2 * a3 * a2);
  v5 = result;
  v6 = a2 >> 2;
  v14 = result;
  v7 = result;
  v15 = a2 >> 2;
  if ( a3 )
  {
    v8 = a1;
    v13 = a3;
    do
    {
      if ( v6 )
      {
        v16 = v6;
        do
        {
          v9 = 4;
          v10 = *v8;
          v11 = 0;
          do
          {
            ++v7;
            v12 = v10 >> v11;
            v11 += 4;
            --v9;
            *(v7 - 1) = *(_WORD *)(a4 + 2 * (v12 & 0xF)) & 0x7FFF;
          }
          while ( v9 );
          ++v8;
          --v16;
        }
        while ( v16 );
        v6 = v15;
        v5 = v14;
      }
      --v13;
    }
    while ( v13 );
    result = v5;
  }
  return result;
}

//----- (00403120) --------------------------------------------------------
void *__cdecl sub_403120(unsigned __int16 *a1, unsigned int a2, int a3, int a4)
{
  void *result; // eax
  void *v5; // ecx
  unsigned int v6; // ebp
  _WORD *v7; // esi
  unsigned __int16 *v8; // eax
  signed int v9; // edi
  unsigned int v10; // edx
  int v11; // ecx
  unsigned int v12; // ebp
  int v13; // [esp+Ch] [ebp-8h]
  void *v14; // [esp+10h] [ebp-4h]
  unsigned int v15; // [esp+1Ch] [ebp+8h]
  unsigned int v16; // [esp+20h] [ebp+Ch]

  result = malloc(2 * a3 * a2);
  v5 = result;
  v6 = a2 >> 1;
  v14 = result;
  v7 = result;
  v15 = a2 >> 1;
  if ( a3 )
  {
    v8 = a1;
    v13 = a3;
    do
    {
      if ( v6 )
      {
        v16 = v6;
        do
        {
          v9 = 2;
          v10 = *v8;
          v11 = 0;
          do
          {
            ++v7;
            v12 = v10 >> v11;
            v11 += 8;
            --v9;
            *(v7 - 1) = *(_WORD *)(a4 + 2 * (unsigned __int8)v12) & 0x7FFF;
          }
          while ( v9 );
          ++v8;
          --v16;
        }
        while ( v16 );
        v5 = v14;
        v6 = v15;
      }
      --v13;
    }
    while ( v13 );
    result = v5;
  }
  return result;
}

//----- (004031D0) --------------------------------------------------------
int __cdecl sub_4031D0(AGLIMAGE *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  AGLIMAGE *v9; // esi
  unsigned __int8 *v10; // eax
  int v11; // edx
  int v12; // ecx
  int v13; // ebx
  unsigned int v14; // eax
  int v15; // ebx
  _WORD *v16; // edi
  int v17; // edx
  int v18; // ebp
  unsigned int v19; // edx
  int v20; // eax
  int v21; // eax
  int v22; // eax
  __int16 v23; // ST14_2
  bool v24; // zf
  char v26; // [esp+Bh] [ebp-9h]
  int v27; // [esp+10h] [ebp-4h]
  unsigned __int8 v28; // [esp+18h] [ebp+4h]
  int v29; // [esp+1Ch] [ebp+8h]
  int v30; // [esp+20h] [ebp+Ch]
  int v31; // [esp+2Ch] [ebp+18h]
  int v32; // [esp+38h] [ebp+24h]

  v26 = 0;
  v9 = a1;
  if ( a1 == AGLSCREEN::GetBackImage(dword_443D24) )
    v26 = 1;
  v10 = AGLIMAGE::GetSurface(a1);
  v11 = *((_DWORD *)a1 + 14);
  v27 = *((_DWORD *)a1 + 14);
  if ( a9 )
  {
    v12 = a8 * a6;
    v13 = a2;
    v31 = a8 * a6;
    v29 = a9;
    v14 = (unsigned int)&v10[2 * v13 + a3 * v11];
    v30 = v14;
    do
    {
      HIWORD(v15) = HIWORD(a7);
      v16 = (_WORD *)v14;
      if ( a7 )
      {
        v32 = a7;
        v17 = 2 * a5 - v14;
        HIWORD(v14) = HIWORD(a4);
        v18 = v12 + v17 + a4;
        do
        {
          LOWORD(v14) = *(_WORD *)((char *)v16 + v18);
          v19 = v14 >> 5;
          LOBYTE(v19) = 8 * (v14 >> 5);
          LOBYTE(v15) = 8 * (unsigned __int16)(*(_WORD *)((char *)v16 + v18) >> 10);
          v28 = 8 * *(_WORD *)((char *)v16 + v18);
          v20 = (unsigned __int8)-((_WORD)v14 != 0);
          if ( v26 )
          {
            LOWORD(v15) = (unsigned __int8)((unsigned __int8)v15 >> *((_BYTE *)v9 + 103));
            LOWORD(v19) = (unsigned __int8)((unsigned __int8)v19 >> *((_BYTE *)v9 + 101));
            LOWORD(v20) = (unsigned __int8)(v28 >> *((_BYTE *)v9 + 99));
            v15 = (v20 << *((_BYTE *)v9 + 98)) | (v19 << *((_BYTE *)v9 + 100)) | (v15 << *((_BYTE *)v9 + 102));
            *v16 = v15;
          }
          else
          {
            LOWORD(v20) = (unsigned __int8)((unsigned __int8)v20 >> *((_BYTE *)v9 + 97));
            v21 = v20 << *((_BYTE *)v9 + 96);
            LOWORD(v21) = *((_WORD *)v9 + 52) & v21;
            LOWORD(v15) = (unsigned __int8)((unsigned __int8)v15 >> *((_BYTE *)v9 + 103));
            v15 <<= *((_BYTE *)v9 + 102);
            LOWORD(v19) = (unsigned __int8)((unsigned __int8)v19 >> *((_BYTE *)v9 + 101));
            v22 = (v19 << *((_BYTE *)v9 + 100)) | v15 | v21;
            v23 = v22;
            LOWORD(v22) = (unsigned __int8)(v28 >> *((_BYTE *)v9 + 99));
            *v16 = (v22 << *((_BYTE *)v9 + 98)) | v23;
          }
          ++v16;
          v14 = v32-- - 1;
        }
        while ( v32 );
        v11 = v27;
        v12 = v31;
        v14 = v30;
      }
      v12 += a8;
      v14 += v11;
      v24 = v29 == 1;
      v31 = v12;
      v30 = v14;
      --v29;
    }
    while ( !v24 );
  }
  return AGLIMAGE::ReleaseSurface(v9);
}

//----- (00403360) --------------------------------------------------------
int __cdecl sub_403360(_DWORD *a1, _DWORD *a2)
{
  int v2; // eax
  int result; // eax

  v2 = -(*a2 >> 8);
  *a1 = 4 * (*a1 + 1073741760 * (*a1 >> 6));
  result = v2 << 8;
  *a2 += result;
  return result;
}

//----- (004033A0) --------------------------------------------------------
char sub_4033A0()
{
  AGLFILE *v0; // eax
  unsigned int v1; // eax
  char *v2; // edi
  CHAR *v3; // esi
  char v4; // cl
  char result; // al
  CHAR RootPathName[8]; // [esp+Ch] [ebp-318h]
  DWORD FileSystemFlags; // [esp+14h] [ebp-310h]
  char v8; // [esp+18h] [ebp-30Ch]
  CHAR VolumeNameBuffer; // [esp+11Ch] [ebp-208h]
  char v10; // [esp+220h] [ebp-104h]

  strcpy(&v8, WindowName);
  strcat(&v8, aIco);
  SetErrorMode(1u);
  sprintf(RootPathName, asc_4402E8, 99);
  GetVolumeInformationA(RootPathName, &VolumeNameBuffer, 0x104u, 0, 0, &FileSystemFlags, 0, 0);
  _strcmpi(&VolumeNameBuffer, aPpanther);
  sprintf(&v10, aSS, RootPathName, &v8);
  v0 = AGLOpenFile(&v10, 1u, 0);
  AGLFILE::Close(v0);
  v1 = strlen(RootPathName) + 1;
  qmemcpy(byte_443F60, RootPathName, 4 * (v1 >> 2));
  v3 = &RootPathName[4 * (v1 >> 2)];
  v2 = &byte_443F60[4 * (v1 >> 2)];
  v4 = v1;
  result = 1;
  qmemcpy(v2, v3, v4 & 3);
  return result;
}
// 4033A0: using guessed type CHAR RootPathName[8];

//----- (004034F0) --------------------------------------------------------
int sub_4034F0()
{
  char *v0; // esi
  char v1; // al
  char v2; // al
  signed int i; // edx

  strcpy(&byte_443D58, GetCommandLineA());
  v0 = &byte_443D58;
  if ( !&byte_443D58 || !byte_443D58 )
    goto LABEL_18;
  if ( byte_443D58 != 34 )
  {
    do
      v2 = (v0++)[1];
    while ( v2 );
LABEL_8:
    while ( v0 > &byte_443D58 )
    {
      if ( *v0 == 92 )
        break;
      if ( *v0 == 47 )
        break;
      --v0;
    }
    goto LABEL_12;
  }
  if ( byte_443D59 )
  {
    do
    {
      *v0 = v0[1];
      v1 = (v0++)[2];
    }
    while ( v1 );
    goto LABEL_8;
  }
LABEL_12:
  if ( strstr(&byte_443D58, aRelease) )
  {
    for ( i = 0; i < (signed int)strlen(aRelease_0); ++i )
      --v0;
  }
  if ( *v0 == 92 || *v0 == 47 )
    *v0 = 0;
LABEL_18:
  strcat(&byte_443D58, asc_44030C);
  strcpy((char *)&unk_443E5C, &byte_443D58);
  return nullsub_1(aPathS);
}
// 434B40: using guessed type int __cdecl nullsub_1(_DWORD);
// 443D59: using guessed type char byte_443D59;

//----- (00403630) --------------------------------------------------------
struct AGLFILE *__cdecl sub_403630(int a1, char a2)
{
  signed int v2; // esi

  if ( a2 & 2 )
    v2 = (a2 & 4 | 2u) >> 1;
  else
    v2 = 2;
  if ( a2 & 0x10 )
    v2 |= 0x10u;
  sprintf(byte_444064, aSS, &byte_443D58, a1);
  return AGLOpenFile(byte_444064, v2, 0);
}

//----- (00403690) --------------------------------------------------------
int __cdecl sub_403690(AGLFILE *a1)
{
  int result; // eax

  if ( a1 )
    result = AGLFILE::Close(a1);
  return result;
}

//----- (004036A0) --------------------------------------------------------
unsigned int __cdecl sub_4036A0(AGLFILE *a1, void *a2, unsigned int a3)
{
  unsigned int result; // eax
  unsigned int v4; // [esp+Ch] [ebp-4h]

  result = 0;
  v4 = 0;
  if ( a1 )
  {
    AGLFILE::Read(a1, a2, a3, &v4);
    result = v4;
  }
  return result;
}

//----- (004036D0) --------------------------------------------------------
unsigned int __cdecl sub_4036D0(AGLFILE *a1, void *a2, unsigned int a3)
{
  unsigned int result; // eax
  unsigned int v4; // [esp+Ch] [ebp-4h]

  result = 0;
  v4 = 0;
  if ( a1 )
  {
    AGLFILE::Write(a1, a2, a3, &v4);
    result = v4;
  }
  return result;
}

//----- (00403700) --------------------------------------------------------
unsigned int __cdecl sub_403700(AGLFILE *a1)
{
  return AGLFILE::GetSize(a1);
}

//----- (00403710) --------------------------------------------------------
void __stdcall sub_403710(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  ++dword_444168;
  if ( dword_4441C8 )
    dword_4441C8();
}
// 444168: using guessed type int dword_444168;
// 4441C8: using guessed type int (*dword_4441C8)(void);

//----- (00403730) --------------------------------------------------------
int __cdecl sub_403730(unsigned int a1)
{
  int result; // eax

  if ( dword_4441B0 )
    result = AGLTIMER::SetDelay(dword_4441B0, 0x3E8 / a1);
  return result;
}

//----- (00403750) --------------------------------------------------------
LCID sub_403750()
{
  LCID result; // eax

  result = GetUserDefaultLCID() & 0x3FF;
  switch ( result )
  {
    case 7u:
      byte_444669 = 2;
      break;
    case 0xAu:
      byte_444669 = 4;
      break;
    case 0xCu:
      byte_444669 = 0;
      break;
    case 0x10u:
      byte_444669 = 3;
      break;
    default:
      byte_444669 = 1;
      break;
  }
  return result;
}
// 444669: using guessed type char byte_444669;

//----- (004037C0) --------------------------------------------------------
char __cdecl sub_4037C0(int a1, LPCSTR lpWindowName, int a3, int a4, char a5)
{
  char result; // al
  signed int v6; // ebp
  DWORD v7; // ebx
  int v8; // ebp
  __int16 v9; // si
  __int16 v10; // di
  AGLTIMER *v11; // eax
  struct tagRECT Rect; // [esp+Ch] [ebp-38h]
  WNDCLASSA WndClass; // [esp+1Ch] [ebp-28h]

  memset(&WndClass, 0, sizeof(WndClass));
  hInstance = (HINSTANCE)a1;
  WndClass.lpszClassName = ClassName;
  WndClass.lpfnWndProc = sub_403AF0;
  WndClass.style = 32;
  WndClass.hCursor = LoadCursorA(0, (LPCSTR)0x7F00);
  WndClass.hInstance = (HINSTANCE)a1;
  WndClass.hIcon = LoadIconA(hInstance, (LPCSTR)0x67);
  if ( RegisterClassA(&WndClass) )
  {
    byte_44416C = a5;
    if ( a5 )
    {
      v6 = 2147483648;
      v7 = 8;
      ShowCursor(0);
    }
    else
    {
      v6 = 12582912;
      v7 = 0;
    }
    v8 = v6 | 0x10000000;
    Rect.top = 0;
    Rect.left = 0;
    Rect.right = (unsigned __int16)a3;
    Rect.bottom = (unsigned __int16)a4;
    AdjustWindowRectEx(&Rect, v8, 0, v7);
    v9 = LOWORD(Rect.right) - LOWORD(Rect.left);
    v10 = LOWORD(Rect.bottom) - LOWORD(Rect.top);
    hWnd = CreateWindowExA(
             v7,
             ClassName,
             lpWindowName,
             v8,
             0,
             0,
             (unsigned __int16)(LOWORD(Rect.right) - LOWORD(Rect.left)),
             (unsigned __int16)(LOWORD(Rect.bottom) - LOWORD(Rect.top)),
             0,
             0,
             hInstance,
             0);
    v11 = AGLCreateTimer();
    dword_4441B0 = v11;
    if ( v11 )
    {
      AGLTIMER::SetDelay(v11, 20);
      AGLTIMER::Start(dword_4441B0, sub_403710);
    }
    sub_407F70();
    HIWORD(dword_455BE4) = v10;
    LOWORD(dword_455BE4) = v9;
    result = 1;
  }
  else
  {
    nullsub_1(aErrorCanTRegis);
    result = 0;
  }
  return result;
}
// 434B40: using guessed type int __cdecl nullsub_1(_DWORD);
// 44416C: using guessed type char byte_44416C;
// 455BE4: using guessed type int dword_455BE4;

//----- (00403990) --------------------------------------------------------
LRESULT __cdecl sub_403990(LPCSTR lpText)
{
  HRSRC v1; // eax
  HGLOBAL v2; // eax
  char *v3; // eax
  const CHAR *v4; // eax

  sub_402E60();
  v1 = FindResourceA(0, (LPCSTR)0x65, Type);
  v2 = LoadResource(0, v1);
  v3 = (char *)LockResource(v2);
  if ( v3 )
    v4 = sub_403A00(v3, (int)lpText);
  else
    v4 = lpText;
  MessageBoxA(hWnd, v4, Caption, 0);
  return SendMessageA(hWnd, 0x10u, 0, 0);
}

//----- (00403A00) --------------------------------------------------------
char *__cdecl sub_403A00(char *a1, int a2)
{
  char *v2; // eax
  char v4; // cl
  char v5; // cl
  char *v6; // eax
  int v7; // edx
  char v8; // [esp+4h] [ebp-80h]

  sprintf(&v8, aSS_0, a2, *(&off_440328 + (unsigned __int8)byte_444669));
  v2 = sub_403A90(a1, &v8);
  if ( !v2 )
    return (char *)a2;
  if ( *v2 != 34 )
  {
    do
      v4 = (v2++)[1];
    while ( v4 != 34 );
  }
  v5 = v2[1];
  v6 = v2 + 1;
  v7 = 0;
  if ( v5 != 34 )
  {
    do
    {
      ++v6;
      byte_444228[v7++] = v5;
      v5 = *v6;
    }
    while ( *v6 != 34 );
  }
  byte_444228[v7] = 0;
  return byte_444228;
}
// 440328: using guessed type void *off_440328;
// 444669: using guessed type char byte_444669;

//----- (00403A90) --------------------------------------------------------
char *__cdecl sub_403A90(char *a1, char *a2)
{
  char *v2; // esi
  unsigned int v3; // kr04_4

  v2 = a1;
  v3 = strlen(a2) + 1;
  if ( !strncmp(a1, off_4403A8, 3u) )
    return 0;
  while ( strncmp(v2, a2, v3 - 1) )
  {
    if ( !strncmp(++v2, off_4403A8, 3u) )
      return 0;
  }
  return v2;
}

//----- (00403AF0) --------------------------------------------------------
int __stdcall sub_403AF0(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  int result; // eax
  struct tagPAINTSTRUCT Paint; // [esp+0h] [ebp-40h]

  if ( Msg > 0x1C )
  {
    if ( Msg > 0x3B9 )
    {
      if ( Msg != 32769 )
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
      sub_42C920();
    }
    else
    {
      switch ( Msg )
      {
        case 0x3B9u:
          if ( dword_443D24 )
          {
            if ( wParam == 1 )
            {
              if ( *((_BYTE *)dword_443D24 + 377) )
              {
                AGLSCREEN::PlayCDAudioTrack(dword_443D24, *((_BYTE *)dword_443D24 + 379));
                return 0;
              }
            }
            else if ( wParam == 8 )
            {
              AGLSCREEN::StopCDAudio(dword_443D24);
              return 0;
            }
          }
          break;
        case 0x7Eu:
          if ( dword_443D24 && !*((_BYTE *)dword_443D24 + 52) )
          {
            AGLSCREEN::RestoreAllImages(dword_443D24, 0);
            return 0;
          }
          break;
        case 0x100u:
          return 0;
        default:
          return DefWindowProcA(hWnd, Msg, wParam, lParam);
      }
    }
LABEL_36:
    result = 0;
  }
  else
  {
    if ( Msg != 28 )
    {
      switch ( Msg )
      {
        case 1u:
          goto LABEL_36;
        case 2u:
          PostQuitMessage(0);
          return 0;
        case 7u:
          dword_444724 = dword_455BE0;
          nullsub_1(aFocusRetrouver);
          if ( byte_443D34 )
            sub_402A90();
          if ( byte_44416F )
          {
            sub_407B70((unsigned __int8)byte_44416D);
            byte_44416F = 0;
          }
          byte_444668 = 1;
          return 0;
        case 8u:
          byte_444668 = 0;
          byte_44416D = HIBYTE(word_455CB7);
          byte_44416F = 1;
          if ( BYTE2(dword_455CBC) )
            sub_407B70(0);
          nullsub_1(aPerteDuFocus);
          return 0;
        case 0xFu:
          BeginPaint(hWnd, &Paint);
          EndPaint(hWnd, &Paint);
          return 0;
        default:
          return DefWindowProcA(hWnd, Msg, wParam, lParam);
      }
      return DefWindowProcA(hWnd, Msg, wParam, lParam);
    }
    if ( wParam && dword_443D24 && *((_BYTE *)dword_443D24 + 52) )
    {
      AGLSCREEN::RestoreAllImages(dword_443D24, 0);
      nullsub_1(aRetourRestaura);
    }
    byte_44416E = wParam;
    result = 0;
  }
  return result;
}
// 434B40: using guessed type int __cdecl nullsub_1(_DWORD);
// 443D34: using guessed type char byte_443D34;
// 44416D: using guessed type char byte_44416D;
// 44416E: using guessed type char byte_44416E;
// 44416F: using guessed type char byte_44416F;
// 444668: using guessed type char byte_444668;
// 444724: using guessed type int dword_444724;
// 455BE0: using guessed type int dword_455BE0;
// 455CB7: using guessed type __int16 word_455CB7;
// 455CBC: using guessed type int dword_455CBC;

//----- (00403D10) --------------------------------------------------------
signed int __cdecl sub_403D10(int a1, char a2)
{
  AGLFILE *v2; // esi

  v2 = sub_403630((int)aDataSavePinkyC, 2);
  nullsub_1(aLoadPadD);
  if ( !v2 )
    return 1;
  sub_403700(v2);
  sub_4036A0(v2, &dword_444678, 4u);
  sub_4036A0(v2, &dword_444688, 0x20u);
  if ( a2 )
  {
    dword_442684 = dword_444688;
    dword_442688 = dword_44468C;
    dword_44268C = dword_444690;
    dword_442690 = dword_444694;
  }
  else
  {
    dword_442674 = dword_444698;
    dword_442678 = dword_44469C;
    dword_44267C = dword_4446A0;
    dword_442680 = dword_4446A4;
  }
  sub_403690(v2);
  return 0;
}
// 434B40: using guessed type int __cdecl nullsub_1(_DWORD);
// 442674: using guessed type int dword_442674;
// 442678: using guessed type int dword_442678;
// 44267C: using guessed type int dword_44267C;
// 442680: using guessed type int dword_442680;
// 442684: using guessed type int dword_442684;
// 442688: using guessed type int dword_442688;
// 44268C: using guessed type int dword_44268C;
// 442690: using guessed type int dword_442690;
// 444678: using guessed type int dword_444678;
// 444688: using guessed type int dword_444688;
// 44468C: using guessed type int dword_44468C;
// 444690: using guessed type int dword_444690;
// 444694: using guessed type int dword_444694;
// 444698: using guessed type int dword_444698;
// 44469C: using guessed type int dword_44469C;
// 4446A0: using guessed type int dword_4446A0;
// 4446A4: using guessed type int dword_4446A4;

//----- (00403E00) --------------------------------------------------------
signed int sub_403E00()
{
  struct AGLFILE *v0; // esi

  v0 = sub_403630((int)aDataSavePinkyC, 4);
  nullsub_1(aSauvegardeD);
  if ( !v0 )
  {
    v0 = AGLCreateFile(aDataSavePinkyC, 0);
    nullsub_1(aCreationFichie);
    if ( !v0 )
      return 0;
  }
  sub_403700(v0);
  LOWORD(dword_444678) = word_455CB7;
  BYTE2(dword_444678) = unk_455CB9;
  dword_444698 = dword_442674;
  dword_44469C = dword_442678;
  dword_4446A0 = dword_44267C;
  dword_4446A4 = dword_442680;
  dword_444688 = dword_442684;
  dword_44468C = dword_442688;
  dword_444690 = dword_44268C;
  dword_444694 = dword_442690;
  sub_4036D0(v0, &dword_444678, 4u);
  sub_4036D0(v0, &dword_444688, 0x20u);
  sub_403690(v0);
  return 1;
}
// 434B40: using guessed type int __cdecl nullsub_1(_DWORD);
// 442674: using guessed type int dword_442674;
// 442678: using guessed type int dword_442678;
// 44267C: using guessed type int dword_44267C;
// 442680: using guessed type int dword_442680;
// 442684: using guessed type int dword_442684;
// 442688: using guessed type int dword_442688;
// 44268C: using guessed type int dword_44268C;
// 442690: using guessed type int dword_442690;
// 444678: using guessed type int dword_444678;
// 444688: using guessed type int dword_444688;
// 44468C: using guessed type int dword_44468C;
// 444690: using guessed type int dword_444690;
// 444694: using guessed type int dword_444694;
// 444698: using guessed type int dword_444698;
// 44469C: using guessed type int dword_44469C;
// 4446A0: using guessed type int dword_4446A0;
// 4446A4: using guessed type int dword_4446A4;
// 455CB7: using guessed type __int16 word_455CB7;

//----- (00403F40) --------------------------------------------------------
signed int __stdcall sub_403F40(int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-18h]
  int v4; // [esp+10h] [ebp-14h]
  int v5; // [esp+14h] [ebp-10h]
  int v6; // [esp+18h] [ebp-Ch]
  int v7; // [esp+1Ch] [ebp-8h]
  int v8; // [esp+20h] [ebp-4h]

  if ( !memcmp((const void *)(a1 + 4), &unk_43D938, 0x10u) || !memcmp((const void *)(a1 + 4), &unk_43D948, 0x10u) )
  {
    v5 = *(_DWORD *)(a1 + 24);
    v3 = 24;
    v4 = 16;
    v6 = 2;
    if ( !(*(int (__stdcall **)(int, signed int, int *))(*(_DWORD *)dword_444674 + 20))(dword_444674, 4, &v3) )
    {
      if ( !memcmp((const void *)(a1 + 4), &unk_43D938, 0x10u) )
      {
        dword_4446C0 = v7;
        dword_4446B4 = v8;
      }
      if ( !memcmp((const void *)(a1 + 4), &unk_43D948, 0x10u) )
      {
        dword_4446BC = v7;
        dword_4446B0 = v8;
      }
    }
  }
  return 1;
}
// 444674: using guessed type int dword_444674;
// 4446B0: using guessed type int dword_4446B0;
// 4446B4: using guessed type int dword_4446B4;
// 4446BC: using guessed type int dword_4446BC;
// 4446C0: using guessed type int dword_4446C0;

//----- (00404000) --------------------------------------------------------
int sub_404000()
{
  double v0; // st7
  signed __int64 v1; // rax
  double v2; // st7
  int v4; // [esp+74h] [ebp-244h]

  DirectInput8Create(hInstance, 2048, &unk_43D888, &dword_444680, 0);
  if ( dword_444680 )
  {
    dword_444670 = 0;
    (*(void (__stdcall **)(int, void *, int *, _DWORD))(*(_DWORD *)dword_444680 + 12))(
      dword_444680,
      &unk_43D9F8,
      &dword_444670,
      0);
    if ( dword_444670 )
    {
      v4 = 580;
      (*(void (__stdcall **)(int, int *))(*(_DWORD *)dword_444670 + 60))(dword_444670, &v4);
      nullsub_1(aFoundKeyboardS);
      (*(void (__stdcall **)(int, void *))(*(_DWORD *)dword_444670 + 44))(dword_444670, &unk_43E81C);
      (*(void (__stdcall **)(int, HWND, signed int))(*(_DWORD *)dword_444670 + 52))(dword_444670, hWnd, 6);
      (*(void (__stdcall **)(int))(*(_DWORD *)dword_444670 + 28))(dword_444670);
    }
    dword_444674 = 0;
    (*(void (__stdcall **)(int, signed int, int (__stdcall *)(int, int), _DWORD, signed int))(*(_DWORD *)dword_444680
                                                                                            + 16))(
      dword_444680,
      4,
      sub_403F10,
      0,
      1);
    if ( dword_444674 )
    {
      v4 = 580;
      (*(void (__stdcall **)(int, int *))(*(_DWORD *)dword_444674 + 60))(dword_444674, &v4);
      nullsub_1(aFoundJoystickS);
      (*(void (__stdcall **)(int, void *))(*(_DWORD *)dword_444674 + 44))(dword_444674, &unk_43E614);
      (*(void (__stdcall **)(int, HWND, signed int))(*(_DWORD *)dword_444674 + 52))(dword_444674, hWnd, 5);
      (*(void (__stdcall **)(int, signed int (__stdcall *)(int, int), _DWORD, signed int))(*(_DWORD *)dword_444674 + 16))(
        dword_444674,
        sub_403F40,
        0,
        3);
      v0 = (double)(dword_4446B4 + dword_4446C0) * 0.5;
      dword_4446C0 -= 12 * (unsigned __int64)(signed __int64)(((double)dword_4446C0 - v0) * 0.050000001);
      v1 = (signed __int64)(((double)dword_4446B4 - v0) * 0.050000001);
      v2 = (double)(dword_4446B0 + dword_4446BC) * 0.5;
      dword_4446B4 -= 12 * v1;
      dword_4446BC -= 12 * (unsigned __int64)(signed __int64)(((double)dword_4446BC - v2) * 0.050000001);
      dword_4446B0 -= 12 * (unsigned __int64)(signed __int64)(((double)dword_4446B0 - v2) * 0.050000001);
      nullsub_1(aLjoyminxDLjoym);
      nullsub_1(aLjoyminyDLjoym);
    }
  }
  sub_404510(0);
  return sub_404450(0);
}
// 403F10: using guessed type int __stdcall sub_403F10(int, int);
// 434B40: using guessed type int __cdecl nullsub_1(_DWORD);
// 43C990: using guessed type int __stdcall DirectInput8Create(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 444670: using guessed type int dword_444670;
// 444674: using guessed type int dword_444674;
// 444680: using guessed type int dword_444680;
// 4446B0: using guessed type int dword_4446B0;
// 4446B4: using guessed type int dword_4446B4;
// 4446BC: using guessed type int dword_4446BC;
// 4446C0: using guessed type int dword_4446C0;

//----- (00404250) --------------------------------------------------------
char __cdecl sub_404250(unsigned __int8 a1, unsigned __int8 a2)
{
  int v2; // eax
  int v4; // [esp+8h] [ebp-44h]
  int v5; // [esp+Ch] [ebp-40h]
  int v6; // [esp+10h] [ebp-3Ch]
  int v7; // [esp+14h] [ebp-38h]
  int v8; // [esp+18h] [ebp-34h]
  int v9; // [esp+30h] [ebp-1Ch]
  int *v10; // [esp+38h] [ebp-14h]
  int v11; // [esp+3Ch] [ebp-10h]
  int v12; // [esp+40h] [ebp-Ch]
  int *v13; // [esp+44h] [ebp-8h]
  int v14; // [esp+48h] [ebp-4h]

  v5 = 0;
  v6 = 0;
  if ( a1 >= 2u )
    a1 = 0;
  memset(&v7, 0, 0x38u);
  v7 = 56;
  v8 = 18;
  v11 = 0;
  v12 = 4;
  v14 = 0;
  v13 = &v4;
  v2 = dword_4446B8;
  v4 = 10000 * a2 / 255;
  v9 = (unsigned __int8)dword_4446A8;
  v10 = &v5;
  if ( dword_4446B8 )
  {
    if ( !byte_4446C4[a1] )
    {
      (*(void (__stdcall **)(int, _DWORD, _DWORD))(*(_DWORD *)dword_4446B8 + 28))(dword_4446B8, 0, 0);
      v2 = dword_4446B8;
    }
    (*(void (__stdcall **)(int, int *, signed int))(*(_DWORD *)v2 + 24))(v2, &v7, 536871232);
  }
  byte_4446C4[a1] = a2;
  return 1;
}
// 4446A8: using guessed type int dword_4446A8;
// 4446B8: using guessed type int dword_4446B8;

//----- (00404340) --------------------------------------------------------
int __cdecl sub_404340(unsigned __int8 a1)
{
  int result; // eax

  if ( a1 >= 2u )
    a1 = 0;
  result = dword_4446B8;
  if ( dword_4446B8 )
    result = (*(int (__stdcall **)(int))(*(_DWORD *)dword_4446B8 + 32))(dword_4446B8);
  LOBYTE(result) = 1;
  byte_4446C4[a1] = 0;
  return result;
}
// 4446B8: using guessed type int dword_4446B8;

//----- (00404370) --------------------------------------------------------
int sub_404370()
{
  int result; // eax

  if ( dword_444670 )
  {
    (*(void (__stdcall **)(int))(*(_DWORD *)dword_444670 + 32))(dword_444670);
    (*(void (__stdcall **)(int))(*(_DWORD *)dword_444670 + 8))(dword_444670);
  }
  if ( dword_444674 )
  {
    (*(void (__stdcall **)(int))(*(_DWORD *)dword_444674 + 32))(dword_444674);
    (*(void (__stdcall **)(int))(*(_DWORD *)dword_444674 + 8))(dword_444674);
  }
  result = dword_444680;
  if ( dword_444680 )
    result = (*(int (__stdcall **)(int))(*(_DWORD *)dword_444680 + 8))(dword_444680);
  return result;
}
// 444670: using guessed type int dword_444670;
// 444674: using guessed type int dword_444674;
// 444680: using guessed type int dword_444680;

//----- (004043C0) --------------------------------------------------------
char sub_4043C0()
{
  int v0; // eax
  bool v1; // sf
  int v2; // edx
  char v4; // [esp+4h] [ebp-110h]
  char v5[224]; // [esp+34h] [ebp-E0h]

  if ( !dword_444674 )
    goto LABEL_12;
  if ( dword_4446AC )
  {
    sub_404530();
    LOBYTE(v0) = -1;
    return v0;
  }
  v1 = (*(int (__stdcall **)(int))(*(_DWORD *)dword_444674 + 100))(dword_444674) < 0;
  v2 = *(_DWORD *)dword_444674;
  if ( v1 )
  {
    if ( (*(int (__stdcall **)(int))(v2 + 28))(dword_444674) == -2147024866 )
    {
      while ( (*(int (__stdcall **)(int))(*(_DWORD *)dword_444674 + 28))(dword_444674) == -2147024866 )
        ;
      LOBYTE(v0) = -1;
      return v0;
    }
LABEL_12:
    LOBYTE(v0) = -1;
    return v0;
  }
  if ( (*(int (__stdcall **)(int, signed int, char *))(v2 + 36))(dword_444674, 272, &v4) < 0 )
    goto LABEL_12;
  v0 = 0;
  while ( !v5[v0] )
  {
    if ( (unsigned int)++v0 >= 0x80 )
      goto LABEL_12;
  }
  return v0;
}
// 444674: using guessed type int dword_444674;
// 4446AC: using guessed type int dword_4446AC;
// 4043C0: using guessed type char var_E0[224];

//----- (00404450) --------------------------------------------------------
int __cdecl sub_404450(int a1)
{
  int result; // eax

  result = a1;
  dword_4446C8 = a1;
  if ( !a1 )
    dword_4446C8 = (int)&unk_440400;
  return result;
}
// 4446C8: using guessed type int dword_4446C8;

//----- (00404470) --------------------------------------------------------
char sub_404470()
{
  int v0; // eax
  bool v1; // sf
  int v2; // ecx
  char v4[256]; // [esp+18h] [ebp-100h]

  if ( !dword_444670 )
    goto LABEL_12;
  if ( dword_4446AC )
  {
    sub_404530();
    LOBYTE(v0) = -1;
    return v0;
  }
  v1 = (*(int (__stdcall **)(int, signed int, char *))(*(_DWORD *)dword_444670 + 36))(dword_444670, 256, v4) < 0;
  v2 = *(_DWORD *)dword_444670;
  if ( v1 )
  {
    if ( (*(int (__stdcall **)(int))(v2 + 28))(dword_444670) == -2147024866 )
    {
      while ( (*(int (__stdcall **)(int))(*(_DWORD *)dword_444670 + 28))(dword_444670) == -2147024866 )
        ;
      LOBYTE(v0) = -1;
      return v0;
    }
LABEL_12:
    LOBYTE(v0) = -1;
    return v0;
  }
  if ( (*(int (__stdcall **)(int, signed int, char *))(v2 + 36))(dword_444670, 256, v4) < 0 )
    goto LABEL_12;
  v0 = 0;
  while ( !(v4[v0] & 0x80) )
  {
    if ( (unsigned int)++v0 >= 0xFF )
      goto LABEL_12;
  }
  return v0;
}
// 444670: using guessed type int dword_444670;
// 4446AC: using guessed type int dword_4446AC;
// 404470: using guessed type char var_100[256];

//----- (00404510) --------------------------------------------------------
int __cdecl sub_404510(int a1)
{
  int result; // eax

  result = a1;
  dword_44467C = a1;
  if ( !a1 )
    dword_44467C = (int)&unk_4403F0;
  return result;
}
// 44467C: using guessed type int dword_44467C;

//----- (00404530) --------------------------------------------------------
char sub_404530()
{
  signed int v0; // eax
  int v1; // ebx
  int v2; // eax
  int v3; // ebx
  int v4; // esi
  int v5; // ecx
  signed int v6; // edx

  LOBYTE(v0) = byte_444668;
  dword_4446CC = 0;
  if ( byte_444668 )
  {
    v1 = sub_404680();
    LOBYTE(v2) = sub_4045A0();
    v3 = v2 | v1;
    if ( (v3 & 0x80u) != 0 && v3 & 0x20 )
      LOBYTE(v3) = v3 & 0x7F;
    v4 = dword_4446CC;
    v5 = dword_4446AC;
    v0 = 1;
    v6 = 16;
    do
    {
      if ( v0 & v3 )
      {
        if ( !(v5 & v0) )
          v4 |= v0;
      }
      else
      {
        v5 &= ~v0;
      }
      v0 *= 2;
      --v6;
    }
    while ( v6 );
    dword_4446CC = v4;
    dword_4446AC = v5;
  }
  return v0;
}
// 444668: using guessed type char byte_444668;
// 4446AC: using guessed type int dword_4446AC;
// 4446CC: using guessed type int dword_4446CC;

//----- (004045A0) --------------------------------------------------------
char sub_4045A0()
{
  char result; // al
  bool v1; // sf
  int v2; // edx
  char v3; // si
  unsigned int v4; // edx
  int v5; // [esp+10h] [ebp-110h]
  int v6; // [esp+14h] [ebp-10Ch]
  char v7[224]; // [esp+40h] [ebp-E0h]

  result = dword_444674;
  if ( dword_444674 )
  {
    v1 = (*(int (__stdcall **)(int))(*(_DWORD *)dword_444674 + 100))(dword_444674) < 0;
    v2 = *(_DWORD *)dword_444674;
    if ( v1 )
    {
      if ( (*(int (__stdcall **)(int))(v2 + 28))(dword_444674) == -2147024866 )
      {
        while ( (*(int (__stdcall **)(int))(*(_DWORD *)dword_444674 + 28))(dword_444674) == -2147024866 )
          ;
      }
      result = 0;
    }
    else if ( (*(int (__stdcall **)(int, signed int, int *))(v2 + 36))(dword_444674, 272, &v5) >= 0 )
    {
      result = 0;
      if ( v5 <= dword_4446C0 )
        result = -128;
      if ( v5 >= dword_4446B4 )
        result |= 0x20u;
      if ( v6 <= dword_4446BC )
        result |= 0x10u;
      if ( v6 >= dword_4446B0 )
        result |= 0x40u;
      v3 = 1;
      v4 = 0;
      do
      {
        if ( *(_BYTE *)(dword_4446C8 + v4) != -1 && v7[*(unsigned __int8 *)(dword_4446C8 + v4)] )
          result |= v3;
        v3 *= 2;
        ++v4;
      }
      while ( v4 < 0x10 );
    }
    else
    {
      result = 0;
    }
  }
  return result;
}
// 444674: using guessed type int dword_444674;
// 4446B0: using guessed type int dword_4446B0;
// 4446B4: using guessed type int dword_4446B4;
// 4446BC: using guessed type int dword_4446BC;
// 4446C0: using guessed type int dword_4446C0;
// 4446C8: using guessed type int dword_4446C8;
// 4045A0: using guessed type char var_E0[224];

//----- (00404680) --------------------------------------------------------
int sub_404680()
{
  int result; // eax
  signed int v1; // esi
  unsigned int v2; // edx
  char v3; // [esp+Ch] [ebp-100h]
  char v4; // [esp+Dh] [ebp-FFh]
  char v5; // [esp+28h] [ebp-E4h]

  result = dword_444670;
  if ( dword_444670 )
  {
    if ( (*(int (__stdcall **)(int, signed int, char *))(*(_DWORD *)dword_444670 + 36))(dword_444670, 256, &v3) >= 0 )
    {
      result = 0;
      v1 = 1;
      v2 = 0;
      do
      {
        if ( *(_BYTE *)(dword_44467C + v2) != -1 && *(&v3 + *(unsigned __int8 *)(dword_44467C + v2)) & 0x80 )
          result |= v1;
        v1 *= 2;
        ++v2;
      }
      while ( v2 < 0x10 );
      if ( v5 & 0x80 )
        BYTE1(result) |= 0x40u;
      if ( v4 < 0 )
        BYTE1(result) |= 0x10u;
    }
    else
    {
      while ( (*(int (__stdcall **)(int))(*(_DWORD *)dword_444670 + 28))(dword_444670) == -2147024866 )
        ;
      result = 0;
    }
  }
  return result;
}
// 444670: using guessed type int dword_444670;
// 44467C: using guessed type int dword_44467C;

//----- (00404730) --------------------------------------------------------
int __cdecl sub_404730(int a1, LPSTR lpMultiByteStr)
{
  int v3; // [esp+10h] [ebp-354h]
  int v4; // [esp+14h] [ebp-350h]
  int v5; // [esp+18h] [ebp-34Ch]
  int v6; // [esp+1Ch] [ebp-348h]
  WCHAR WideCharStr; // [esp+20h] [ebp-344h]
  int v8; // [esp+228h] [ebp-13Ch]
  int v9; // [esp+240h] [ebp-124h]

  *lpMultiByteStr = 0;
  v8 = 316;
  if ( (*(int (__stdcall **)(int, int *, int, signed int))(*(_DWORD *)dword_444670 + 56))(dword_444670, &v8, a1, 1) < 0 )
    return 0;
  v5 = v9;
  v3 = 536;
  v4 = 16;
  v6 = 2;
  if ( (*(int (__stdcall **)(int, signed int, int *))(*(_DWORD *)dword_444670 + 20))(dword_444670, 20, &v3) < 0 )
    return 0;
  WideCharToMultiByte(0, 0, &WideCharStr, -1, lpMultiByteStr, 64, 0, 0);
  return 1;
}
// 444670: using guessed type int dword_444670;

//----- (004047E0) --------------------------------------------------------
signed __int16 __cdecl sub_4047E0(char a1)
{
  signed __int16 result; // ax

  switch ( a1 )
  {
    case 192:
    case 193:
    case 194:
    case 195:
    case 196:
    case 224:
    case 225:
    case 226:
    case 227:
    case 228:
      result = 200;
      break;
    case 199:
    case 231:
      result = 202;
      break;
    case 200:
    case 201:
    case 202:
    case 203:
    case 232:
    case 233:
    case 234:
    case 235:
      result = 204;
      break;
    case 204:
    case 205:
    case 206:
    case 207:
    case 236:
    case 237:
    case 238:
    case 239:
      result = 208;
      break;
    case 210:
    case 211:
    case 212:
    case 213:
    case 242:
    case 243:
    case 244:
    case 245:
      result = 214;
      break;
    case 217:
    case 218:
    case 219:
    case 220:
    case 249:
    case 250:
    case 251:
    case 252:
      result = 220;
      break;
    case 33:
      result = 247;
      break;
    case 40:
      result = 242;
      break;
    case 41:
      result = 243;
      break;
    case 44:
      result = 246;
      break;
    case 46:
      result = 244;
      break;
    case 58:
      result = 196;
      break;
    case 59:
      result = 245;
      break;
    default:
      result = 10;
      break;
  }
  return result;
}

//----- (00404900) --------------------------------------------------------
int sub_404900()
{
  return dword_4446CC;
}
// 4446CC: using guessed type int dword_4446CC;

//----- (00404910) --------------------------------------------------------
int __cdecl sub_404910(int a1, int a2)
{
  int result; // eax

  result = a2;
  dword_4446AC |= a2;
  return result;
}
// 4446A8: using guessed type int dword_4446A8;
// 4446AC: using guessed type int dword_4446AC;

//----- (00404930) --------------------------------------------------------
int __cdecl sub_404930(int a1, int a2)
{
  int result; // eax

  result = ~a2;
  dword_4446AC &= ~a2;
  return result;
}
// 4446AC: using guessed type int dword_4446AC;

//----- (00404950) --------------------------------------------------------
int __cdecl sub_404950(signed int a1, int a2, char a3)
{
  char v3; // cl
  int v4; // ebx
  int v5; // eax
  unsigned int v6; // edi
  _DWORD *v7; // eax
  double v8; // st7
  int v9; // esi
  double v10; // st6
  double v11; // st7
  int v12; // ebx
  _DWORD *v13; // eax
  double v14; // st7
  int v15; // esi
  double v16; // st6
  double v17; // st7
  int v18; // esi
  unsigned __int16 v19; // si
  int v20; // esi
  unsigned __int16 v21; // bx
  int v23; // [esp+10h] [ebp-Ch]
  int v24; // [esp+14h] [ebp-8h]
  int v25; // [esp+18h] [ebp-4h]
  float v26; // [esp+20h] [ebp+4h]
  float v27; // [esp+20h] [ebp+4h]

  sub_401580(1);
  byte_443AF2 = 40;
  byte_443AF1 = 40;
  byte_443AF0 = 40;
  sub_4015B0(&v23, &v25);
  v3 = a3;
  v4 = a1;
  v5 = a1;
  v6 = (unsigned int)(16 - v25) >> 1;
  v24 = a1;
  if ( a3 & 2 )
  {
    v7 = dword_443D2C;
    v8 = (double)a1;
    v9 = *((_DWORD *)dword_443D2C + 16032);
    *((_DWORD *)dword_443D2C + 16032) = v9 + 128;
    *(_DWORD *)(v9 + 4) = 0;
    *(_DWORD *)v9 = v7[30];
    v7[30] = v9;
    *(float *)(v9 + 16) = v8;
    v10 = (double)(a2 - 8);
    *(_BYTE *)(v9 + 34) = -1;
    *(float *)(v9 + 20) = v10;
    *(_DWORD *)(v9 + 28) = 1065353216;
    *(_DWORD *)(v9 + 56) = 1065353216;
    *(_DWORD *)(v9 + 84) = 1065353216;
    *(_DWORD *)(v9 + 112) = 1065353216;
    v26 = (double)(a1 + 32);
    *(float *)(v9 + 44) = v26;
    *(float *)(v9 + 48) = v10;
    *(float *)(v9 + 100) = v26;
    *(_DWORD *)(v9 + 36) = 1060945085;
    *(float *)(v9 + 72) = v8;
    v11 = (double)(a2 + 23);
    *(_DWORD *)(v9 + 92) = 1060945085;
    *(_BYTE *)(v9 + 33) = -1;
    *(float *)(v9 + 76) = v11;
    *(float *)(v9 + 104) = v11;
    *(_BYTE *)(v9 + 32) = -1;
    *(_DWORD *)(v9 + 4) = 5;
    *(_DWORD *)(v9 + 24) = 0;
    *(_DWORD *)(v9 + 52) = 0;
    *(_DWORD *)(v9 + 80) = 0;
    *(_DWORD *)(v9 + 108) = 0;
    *(_DWORD *)(v9 + 40) = 0;
    *(_DWORD *)(v9 + 64) = 1062918875;
    *(_DWORD *)(v9 + 68) = 0;
    *(_DWORD *)(v9 + 96) = 1038674153;
    *(_DWORD *)(v9 + 120) = 1062918875;
    *(_DWORD *)(v9 + 124) = 1038674153;
    *(_DWORD *)(v9 + 8) = sub_401000(0, 0, 1263, 0);
    v12 = v4 + 2 * v23;
    byte_443AF2 = 40;
    byte_443AF1 = 40;
    byte_443AF0 = 40;
    sub_4015D0(v12 + 10, v6 + a2, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x3Du);
    v4 = v23 * ((unsigned __int16)dword_44EDAC + 4) + v12;
    a1 = v4;
    sub_401D10();
    v3 = a3;
    v5 = v24;
  }
  if ( v3 & 1 )
  {
    v13 = dword_443D2C;
    v14 = (double)a1;
    v15 = *((_DWORD *)dword_443D2C + 16032);
    *((_DWORD *)dword_443D2C + 16032) = v15 + 128;
    *(_DWORD *)(v15 + 4) = 0;
    *(_DWORD *)v15 = v13[30];
    v13[30] = v15;
    *(float *)(v15 + 16) = v14;
    v16 = (double)(a2 - 8);
    *(float *)(v15 + 20) = v16;
    *(_DWORD *)(v15 + 28) = 1065353216;
    *(_DWORD *)(v15 + 56) = 1065353216;
    *(_DWORD *)(v15 + 84) = 1065353216;
    *(_DWORD *)(v15 + 112) = 1065353216;
    v27 = (double)(v4 + 32);
    *(float *)(v15 + 44) = v27;
    *(float *)(v15 + 48) = v16;
    *(float *)(v15 + 100) = v27;
    *(_DWORD *)(v15 + 40) = 1039726841;
    *(float *)(v15 + 72) = v14;
    v17 = (double)(a2 + 23);
    *(_DWORD *)(v15 + 68) = 1039726841;
    *(float *)(v15 + 76) = v17;
    *(float *)(v15 + 104) = v17;
    *(_BYTE *)(v15 + 34) = -1;
    *(_BYTE *)(v15 + 33) = -1;
    *(_BYTE *)(v15 + 32) = -1;
    *(_DWORD *)(v15 + 4) = 5;
    *(_DWORD *)(v15 + 24) = 0;
    *(_DWORD *)(v15 + 52) = 0;
    *(_DWORD *)(v15 + 80) = 0;
    *(_DWORD *)(v15 + 108) = 0;
    *(_DWORD *)(v15 + 36) = 1060945085;
    *(_DWORD *)(v15 + 64) = 1062918875;
    *(_DWORD *)(v15 + 92) = 1060945085;
    *(_DWORD *)(v15 + 96) = 1047589105;
    *(_DWORD *)(v15 + 120) = 1062918875;
    *(_DWORD *)(v15 + 124) = 1047589105;
    *(_DWORD *)(v15 + 8) = sub_401000(0, 0, 1263, 31);
    byte_443AF2 = 40;
    byte_443AF1 = 40;
    byte_443AF0 = 40;
    sub_4015D0(v4 + 2 * v23 + 10, v6 + a2, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x40u);
    sub_401D10();
    v3 = a3;
    v5 = v24;
  }
  v18 = v5;
  if ( v3 & 0x14 )
  {
    v19 = dword_44EDB4;
    if ( v3 & 0x10 )
    {
      if ( v3 & 4 )
      {
        sub_401AB0(v5, v6 + a2 - 30, 1, aSSSSS);
        v20 = v19 + 6;
LABEL_13:
        v3 = a3;
        v18 = v24 + v23 * v20;
        goto LABEL_14;
      }
    }
    else if ( v3 & 4 )
    {
      sub_401AB0(v5, v6 + a2 - 30, 1, aSSS);
LABEL_12:
      v20 = v19 + 4;
      goto LABEL_13;
    }
    sub_401AB0(v5, v6 + a2 - 30, 1, aSSS_0);
    goto LABEL_12;
  }
LABEL_14:
  if ( v3 & 8 )
  {
    v21 = dword_44EDBC;
    sub_401AB0((unsigned __int16)dword_44EDB4 + v18 + 50, v6 + a2 - 30, 1, aSSS);
    v3 = a3;
    v18 += v23 * (v21 + 4);
  }
  if ( v3 & 0x20 )
    sub_401AB0(v18, v6 + a2 - 30, 1, aSSSSS);
  return sub_401D10();
}
// 443AE4: using guessed type int dword_443AE4;
// 443AF0: using guessed type char byte_443AF0;
// 443AF1: using guessed type char byte_443AF1;
// 443AF2: using guessed type char byte_443AF2;
// 44EDAC: using guessed type int dword_44EDAC;
// 44EDB4: using guessed type int dword_44EDB4;
// 44EDBC: using guessed type int dword_44EDBC;

//----- (00404D30) --------------------------------------------------------
int __cdecl sub_404D30(unsigned __int16 a1)
{
  sub_401580(1);
  byte_443AF2 = 90;
  byte_443AF1 = 90;
  byte_443AF0 = 90;
  if ( a1 == 80 )
    sub_4015D0((unsigned __int16)dword_455BE4 - 120, 46, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x50u);
  else
    sub_4015D0((unsigned __int16)dword_455BE4 - 150, 46, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, a1);
  return sub_401D10();
}
// 443AE4: using guessed type int dword_443AE4;
// 443AF0: using guessed type char byte_443AF0;
// 443AF1: using guessed type char byte_443AF1;
// 443AF2: using guessed type char byte_443AF2;
// 455BE4: using guessed type int dword_455BE4;

//----- (00404DD0) --------------------------------------------------------
__int16 sub_404DD0()
{
  _DWORD *v0; // eax
  int v1; // esi
  signed int v2; // ecx
  unsigned __int16 v3; // dx

  v0 = dword_443D2C;
  v1 = *((_DWORD *)dword_443D2C + 16032);
  *((_DWORD *)dword_443D2C + 16032) = v1 + 128;
  *(_DWORD *)(v1 + 4) = 0;
  *(_DWORD *)v1 = v0[26];
  v0[26] = v1;
  *(_DWORD *)(v1 + 4) = 5;
  *(_DWORD *)(v1 + 8) = sub_401000(1, 0, 640, 256);
  *(_BYTE *)(v1 + 34) = -46;
  *(_BYTE *)(v1 + 33) = -46;
  *(_BYTE *)(v1 + 32) = -46;
  *(_DWORD *)(v1 + 36) = 0;
  *(_DWORD *)(v1 + 40) = 0;
  *(_DWORD *)(v1 + 64) = 1065353216;
  *(_DWORD *)(v1 + 68) = 0;
  *(_DWORD *)(v1 + 92) = 0;
  *(_DWORD *)(v1 + 96) = 1065353216;
  *(_DWORD *)(v1 + 120) = 1065353216;
  *(_DWORD *)(v1 + 124) = 1065353216;
  *(_DWORD *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 20) = 0;
  v2 = (unsigned __int16)dword_455BE4;
  *(_DWORD *)(v1 + 48) = 0;
  *(_DWORD *)(v1 + 72) = 0;
  *(float *)(v1 + 44) = (double)v2;
  *(float *)(v1 + 76) = (double)(HIWORD(dword_455BE4) + 2);
  *(float *)(v1 + 100) = (double)(unsigned __int16)dword_455BE4;
  v3 = HIWORD(dword_455BE4);
  *(_DWORD *)(v1 + 24) = 0;
  *(_DWORD *)(v1 + 28) = 1065353216;
  *(_DWORD *)(v1 + 52) = 0;
  *(_DWORD *)(v1 + 56) = 1065353216;
  *(_DWORD *)(v1 + 80) = 0;
  *(_DWORD *)(v1 + 84) = 1065353216;
  *(_DWORD *)(v1 + 108) = 0;
  *(float *)(v1 + 104) = (double)(v3 + 2);
  *(_DWORD *)(v1 + 112) = 1065353216;
  return sub_4345A0();
}
// 455BE4: using guessed type int dword_455BE4;

//----- (00404ED0) --------------------------------------------------------
char __cdecl sub_404ED0(unsigned __int8 a1)
{
  AGLFILE *v1; // eax
  AGLFILE *v2; // edi
  unsigned int v3; // ebx
  void *v4; // esi
  char v6; // [esp+4h] [ebp-40h]

  sprintf(&v6, aDataLocalDPsk, a1);
  v1 = sub_403630((int)&v6, 2);
  v2 = v1;
  if ( v1 )
  {
    v3 = sub_403700(v1);
    v4 = (void *)sub_401250(v3);
    sub_4036A0(v2, v4, v3);
    sub_403690(v2);
    sub_401520((int)v4 + 8, 0x3C0u, 0x100u);
    LOBYTE(v1) = sub_401380((unsigned int)v4);
  }
  return (char)v1;
}

//----- (00404F50) --------------------------------------------------------
char __cdecl sub_404F50(unsigned __int8 a1)
{
  AGLFILE *v1; // eax
  AGLFILE *v2; // edi
  unsigned int v3; // ebx
  unsigned __int8 *v4; // esi
  char v6; // [esp+4h] [ebp-40h]

  sprintf(&v6, aDataLocalIcone, a1);
  v1 = sub_403630((int)&v6, 2);
  v2 = v1;
  if ( v1 )
  {
    v3 = sub_403700(v1);
    v4 = (unsigned __int8 *)sub_401250(v3);
    sub_4036A0(v2, v4, v3);
    sub_403690(v2);
    sub_401DB0(v4 + 8, 0, 0x4D8u, 0, 0, 0);
    LOBYTE(v1) = sub_401380((unsigned int)v4);
  }
  return (char)v1;
}

//----- (00404FD0) --------------------------------------------------------
int sub_404FD0()
{
  int result; // eax
  _DWORD *v1; // eax
  int v2; // esi
  int v3; // eax
  signed int v4; // edx
  int *v5; // ecx
  unsigned __int16 *v6; // eax
  int v7; // eax

  result = LODWORD(dword_44B700);
  if ( LODWORD(dword_44B700) )
  {
    sub_408D80();
    dword_448A08 = -1014235136;
    dword_448A0C = -1014890496;
    dword_448A10 = 0;
    dword_4489FC = -1011941376;
    dword_448A00 = -1013579776;
    dword_448A04 = -1004699648;
    sub_40A9F0((float *)&dword_4489FC);
    v1 = (_DWORD *)(LODWORD(dword_44B71C) + 56);
    *v1 = 1065353216;
    v1[1] = 0;
    v1[2] = 0;
    v1[3] = 0;
    v1[4] = 1065353216;
    v1[5] = 0;
    v1[6] = 0;
    v1[7] = 0;
    v1[8] = 1065353216;
    v1[9] = 0;
    v1[10] = 0;
    v1[11] = 0;
    sub_408060(2300, LODWORD(dword_44B71C) + 56);
    if ( (unsigned __int8)byte_440D6C <= 0u )
    {
      if ( (_BYTE)dword_4446EC == 10 )
      {
        v3 = rand();
        v4 = (signed int)(4 * v3 + ((unsigned __int64)(-8589672436i64 * v3) >> 32)) >> 14;
        LOBYTE(dword_4446EC) = (v4 < 0) + v4;
      }
      switch ( (unsigned __int8)dword_4446EC )
      {
        case 0u:
          LOWORD(v2) = 15;
          sub_408670(dword_44B71C, 15, 0);
          word_44B7F6 = 15;
          sub_408670(dword_44B700, 15, 0);
          break;
        case 1u:
          v2 = 16;
          sub_408670(dword_44B71C, 16, 0);
          goto LABEL_12;
        case 2u:
          LOWORD(v2) = 17;
          sub_408670(dword_44B71C, 17, 0);
          word_44B7F6 = 17;
          sub_408670(dword_44B700, 17, 0);
          break;
        case 3u:
          LOWORD(v2) = 18;
          sub_408670(dword_44B71C, 18, 0);
          word_44B7F6 = 18;
          sub_408670(dword_44B700, 18, 0);
          break;
        default:
          v2 = 14;
          sub_408670(dword_44B71C, 14, 0);
LABEL_12:
          word_44B7F6 = v2;
          sub_408670(dword_44B700, v2, 0);
          break;
      }
    }
    else
    {
      LOWORD(v2) = 14;
      sub_408670(dword_44B71C, 14, 0);
      word_44B7F6 = 14;
      sub_408670(dword_44B700, 14, 0);
    }
    v5 = (int *)LODWORD(dword_44B71C);
    word_44B7F4 = v2;
    if ( LODWORD(dword_44B71C) )
    {
      v6 = *(unsigned __int16 **)(LODWORD(dword_44B71C) + 184);
      if ( v6 )
      {
        if ( *(unsigned __int16 *)(LODWORD(dword_44B71C) + 174) == *v6 - 1 )
        {
          if ( (unsigned __int8)byte_440D6C <= 0u )
          {
            v7 = rand();
            LOBYTE(dword_4446EC) = 10;
            v5 = (int *)LODWORD(dword_44B71C);
            byte_440D6C = 10 * v7 / 0x7FFF + 10;
          }
          else
          {
            --byte_440D6C;
          }
        }
      }
    }
    sub_4083F0(v5);
    sub_4083F0((int *)LODWORD(dword_44B700));
    sub_408A50(SLODWORD(dword_44B71C));
    sub_408A50(SLODWORD(dword_44B700));
    sub_408A50(dword_44B720);
    result = sub_402A60((int)dword_443D2C, dword_4489E8[dword_4489F8], (_DWORD *)dword_4489E0[dword_4489F8], 1);
  }
  return result;
}
// 440D6C: using guessed type char byte_440D6C;
// 4446EC: using guessed type int dword_4446EC;
// 4489E0: using guessed type int dword_4489E0[];
// 4489E8: using guessed type int dword_4489E8[];
// 4489F8: using guessed type int dword_4489F8;
// 4489FC: using guessed type int dword_4489FC;
// 448A00: using guessed type int dword_448A00;
// 448A04: using guessed type int dword_448A04;
// 448A08: using guessed type int dword_448A08;
// 448A0C: using guessed type int dword_448A0C;
// 448A10: using guessed type int dword_448A10;
// 44B720: using guessed type int dword_44B720;
// 44B7F4: using guessed type __int16 word_44B7F4;
// 44B7F6: using guessed type __int16 word_44B7F6;

//----- (00405260) --------------------------------------------------------
char __cdecl sub_405260(char a1)
{
  unsigned __int8 v1; // al
  _DWORD *v2; // eax
  int v3; // esi
  char result; // al
  unsigned __int8 v5; // [esp+Ch] [ebp-14h]
  unsigned __int8 v6; // [esp+10h] [ebp-10h]
  char v7; // [esp+15h] [ebp-Bh]
  char v8; // [esp+18h] [ebp-8h]
  char v9; // [esp+1Ch] [ebp-4h]

  sub_404530();
  sub_4015B0(&v9, &v8);
  v6 = unk_455CB9;
  v5 = unk_455CB9;
  sub_434560();
  v7 = BYTE1(dword_455BEC);
  if ( (dword_455BEC & 0x80u) == 0 )
  {
    if ( !(dword_455BEC & 0x20) )
      goto LABEL_11;
    if ( v6 == LOBYTE(dword_44EB68[0]) - 1 )
      v5 = 0;
    else
      v5 = v6 + 1;
    sub_404910(0, 32);
  }
  else
  {
    v1 = v6;
    if ( !v6 )
      v1 = dword_44EB68[0];
    v5 = v1 - 1;
    sub_404910(0, 128);
  }
  sub_407E00((int)&unk_444764);
LABEL_11:
  unk_455CB9 = v5;
  sub_404ED0(v5);
  sub_404F50(unk_455CB9);
  sub_432A80(unk_455CB9);
  sub_404D30(0x42u);
  v2 = dword_443D2C;
  v3 = *((_DWORD *)dword_443D2C + 16032);
  *((_DWORD *)dword_443D2C + 16032) = v3 + 128;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)v3 = v2[30];
  v2[30] = v3;
  *(_DWORD *)(v3 + 44) = 1128136704;
  *(_DWORD *)(v3 + 16) = 1120403456;
  *(_DWORD *)(v3 + 20) = 1120403456;
  *(_DWORD *)(v3 + 48) = 1120403456;
  *(_DWORD *)(v3 + 72) = 1120403456;
  *(_DWORD *)(v3 + 100) = 1128136704;
  *(_DWORD *)(v3 + 76) = 1128431616;
  *(_DWORD *)(v3 + 104) = 1128431616;
  *(_DWORD *)(v3 + 28) = 1065353216;
  *(_DWORD *)(v3 + 56) = 1065353216;
  *(_DWORD *)(v3 + 84) = 1065353216;
  *(_DWORD *)(v3 + 112) = 1065353216;
  *(_DWORD *)(v3 + 4) = 5;
  *(_DWORD *)(v3 + 36) = 1052819649;
  *(_DWORD *)(v3 + 92) = 1052819649;
  *(_BYTE *)(v3 + 34) = -1;
  *(_BYTE *)(v3 + 33) = -1;
  *(_BYTE *)(v3 + 32) = -1;
  *(_DWORD *)(v3 + 24) = 0;
  *(_DWORD *)(v3 + 52) = 0;
  *(_DWORD *)(v3 + 80) = 0;
  *(_DWORD *)(v3 + 108) = 0;
  *(_DWORD *)(v3 + 40) = 0;
  *(_DWORD *)(v3 + 64) = 1058773916;
  *(_DWORD *)(v3 + 68) = 0;
  *(_DWORD *)(v3 + 96) = 1048115449;
  *(_DWORD *)(v3 + 120) = 1058773916;
  *(_DWORD *)(v3 + 124) = 1048115449;
  *(_DWORD *)(v3 + 8) = sub_401000(0, 0, 1240, 0);
  sub_4015D0(0x46u, 115, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x5Fu);
  sub_401D10();
  sub_4015D0(0xCCu, 115, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x60u);
  sub_401D10();
  sub_401580(0);
  if ( a1 )
    sub_404950(20, 450, 17);
  else
    sub_404950(20, 450, 19);
  sub_404FD0();
  sub_404DD0();
  sub_401D10();
  sub_402A90();
  if ( !(v7 & 0x10) || a1 )
  {
    if ( v7 & 0x40 )
    {
      sub_407E00((int)&unk_444770);
      sub_404910(0, 0x4000);
      unk_455CB9 = v5;
      sub_404ED0(v5);
      sub_432A80(v5);
      sub_407BB0(16);
      sub_405750();
      if ( a1 )
        result = sub_434E10(0);
      else
        result = sub_405550(0);
    }
    else
    {
      result = sub_404530();
    }
  }
  else
  {
    sub_407E00((int)&dword_444758);
    sub_404910(0, 4096);
    unk_455CB9 = v6;
    sub_404ED0(v6);
    sub_404F50(unk_455CB9);
    sub_432A80(unk_455CB9);
    sub_407BB0(16);
    result = sub_405550(0);
  }
  return result;
}
// 443AE4: using guessed type int dword_443AE4;
// 44EB68: using guessed type int dword_44EB68[];
// 455BEC: using guessed type int dword_455BEC;

//----- (00405550) --------------------------------------------------------
char __cdecl sub_405550(char a1)
{
  char result; // al

  result = a1;
  byte_4446D6 = a1;
  dword_444724 = dword_455BE0;
  return result;
}
// 4446D6: using guessed type char byte_4446D6;
// 444724: using guessed type int dword_444724;
// 455BE0: using guessed type int dword_455BE0;

//----- (00405570) --------------------------------------------------------
char __cdecl sub_405570(char a1)
{
  char result; // al
  int *v2; // eax
  signed int v3; // ecx

  if ( sub_42C5F0(1) )
    return 0;
  sub_404910(0, 0xFFFF);
  dword_455BF8 = 16;
  LODWORD(dword_44B73C) = dword_444718;
  LODWORD(dword_44B740) = dword_44471C;
  LODWORD(dword_44B744) = dword_444720;
  dword_44B7CC = dword_444718;
  dword_44B7D0 = dword_44471C;
  dword_44B7D4 = dword_444720;
  sub_41E7B0((float *)&dword_444718, 1, 1);
  dword_44B764 = 0;
  if ( a1 == 1 )
  {
    dword_455BF0 = 0;
    word_44B7FE = 0;
    sub_434E10(1);
    sub_41FC40();
    sub_407E00((int)&unk_444770);
    sub_407BB0(dword_455BF8);
    result = 1;
  }
  else
  {
    sub_434E10(1);
    sub_41FC90();
    v2 = &dword_44B81A;
    v3 = 12;
    do
    {
      if ( *(_BYTE *)v2 & 1 )
        LOBYTE(dword_44B804) = dword_44B804 + 1;
      v2 = (int *)((char *)v2 + 1);
      --v3;
    }
    while ( v3 );
    if ( dword_44B81E & 1 )
    {
      LOBYTE(dword_44B808) = 5;
      HIBYTE(dword_44B804) = 10;
    }
    if ( dword_44B822 & 1 )
    {
      LOBYTE(dword_44B808) = 6;
      HIBYTE(dword_44B804) = 12;
    }
    sub_407BB0(dword_455BF8);
    sub_407E00((int)&unk_444770);
    result = 1;
  }
  return result;
}
// 444718: using guessed type int dword_444718;
// 44471C: using guessed type int dword_44471C;
// 444720: using guessed type int dword_444720;
// 44B764: using guessed type int dword_44B764;
// 44B7CC: using guessed type int dword_44B7CC;
// 44B7D0: using guessed type int dword_44B7D0;
// 44B7D4: using guessed type int dword_44B7D4;
// 44B7FE: using guessed type __int16 word_44B7FE;
// 44B804: using guessed type int dword_44B804;
// 44B808: using guessed type int dword_44B808;
// 44B81A: using guessed type int dword_44B81A;
// 44B81E: using guessed type int dword_44B81E;
// 44B822: using guessed type int dword_44B822;
// 455BF0: using guessed type int dword_455BF0;
// 455BF8: using guessed type int dword_455BF8;

//----- (004056A0) --------------------------------------------------------
AGLFILE *sub_4056A0()
{
  AGLFILE *result; // eax
  AGLFILE *v1; // esi

  result = sub_403630((int)aDataSavePinkyC, 2);
  v1 = result;
  if ( result )
  {
    sub_403700(result);
    if ( sub_4036A0(v1, &dword_444678, 4u) )
    {
      word_455CB7 = dword_444678;
      BYTE1(dword_455CBC) = HIBYTE(dword_444678);
      unk_455CB9 = BYTE2(dword_444678);
    }
    else
    {
      word_455CB7 = 778;
      unk_455CB9 = -1;
      BYTE1(dword_455CBC) = 0;
    }
    result = (AGLFILE *)sub_403690(v1);
  }
  else
  {
    word_455CB7 = 778;
    unk_455CB9 = -1;
    BYTE1(dword_455CBC) = 0;
  }
  return result;
}
// 444678: using guessed type int dword_444678;
// 455CB7: using guessed type __int16 word_455CB7;
// 455CBC: using guessed type int dword_455CBC;

//----- (00405750) --------------------------------------------------------
int sub_405750()
{
  AGLFILE *v0; // esi
  int result; // eax

  v0 = sub_403630((int)aDataSavePinkyC, 20);
  result = nullsub_1(aSaveOptionsD);
  if ( v0 )
  {
    sub_403700(v0);
    LOWORD(dword_444678) = word_455CB7;
    BYTE2(dword_444678) = unk_455CB9;
    HIBYTE(dword_444678) = BYTE1(dword_455CBC);
    dword_444698 = dword_442674;
    dword_44469C = dword_442678;
    dword_4446A0 = dword_44267C;
    dword_4446A4 = dword_442680;
    dword_444688 = dword_442684;
    dword_44468C = dword_442688;
    dword_444690 = dword_44268C;
    dword_444694 = dword_442690;
    sub_4036D0(v0, &dword_444678, 4u);
    sub_4036D0(v0, &dword_444688, 0x20u);
    result = sub_403690(v0);
  }
  return result;
}
// 434B40: using guessed type int __cdecl nullsub_1(_DWORD);
// 442674: using guessed type int dword_442674;
// 442678: using guessed type int dword_442678;
// 44267C: using guessed type int dword_44267C;
// 442680: using guessed type int dword_442680;
// 442684: using guessed type int dword_442684;
// 442688: using guessed type int dword_442688;
// 44268C: using guessed type int dword_44268C;
// 442690: using guessed type int dword_442690;
// 444678: using guessed type int dword_444678;
// 444688: using guessed type int dword_444688;
// 44468C: using guessed type int dword_44468C;
// 444690: using guessed type int dword_444690;
// 444694: using guessed type int dword_444694;
// 444698: using guessed type int dword_444698;
// 44469C: using guessed type int dword_44469C;
// 4446A0: using guessed type int dword_4446A0;
// 4446A4: using guessed type int dword_4446A4;
// 455CB7: using guessed type __int16 word_455CB7;
// 455CBC: using guessed type int dword_455CBC;

//----- (00405830) --------------------------------------------------------
char __usercall sub_405830@<al>(int a1@<ebp>)
{
  unsigned int v1; // esi
  int v2; // ebx
  unsigned int v3; // ebp
  char result; // al
  unsigned int v5; // esi
  int v6; // ecx
  int v7; // ebp
  int v8; // esi
  char *v9; // eax
  int v10; // [esp-14h] [ebp-48h]
  int v11; // [esp-10h] [ebp-44h]
  unsigned int v12; // [esp-8h] [ebp-3Ch]
  int v13; // [esp-4h] [ebp-38h]
  int v14; // [esp+Ch] [ebp-28h]
  int v15; // [esp+10h] [ebp-24h]
  int v16; // [esp+14h] [ebp-20h]
  char v17; // [esp+18h] [ebp-1Ch]
  __int16 v18; // [esp+1Ch] [ebp-18h]
  int v19; // [esp+20h] [ebp-14h]
  __int16 v20; // [esp+24h] [ebp-10h]
  int v21; // [esp+28h] [ebp-Ch]
  __int16 v22; // [esp+2Ch] [ebp-8h]
  int v23; // [esp+30h] [ebp-4h]

  sub_404530();
  sub_4015B0(&v17, &v15);
  v1 = dword_444708;
  v14 = dword_444708;
  sub_434560();
  v2 = dword_455BEC;
  v16 = dword_455BEC;
  if ( dword_455BEC )
  {
    dword_444724 = dword_455BE0;
  }
  else if ( (unsigned int)(dword_455BE0 - dword_444724) > 0x7D0 )
  {
    byte_44BAE4 = 1;
    sub_4345F0();
    sub_407C30();
    sub_434E10(9);
    return 0;
  }
  v13 = a1;
  v3 = 7;
  if ( !byte_455CAB )
    v3 = 6;
  if ( dword_455BEC & 0x10 )
  {
    if ( v1 )
    {
      v14 = --v1;
    }
    else
    {
      v14 = v3 - 1;
      v1 = v3 - 1;
    }
    sub_404910(0, 16);
    sub_407E00((int)&unk_444764);
  }
  if ( v2 & 0x40 )
  {
    if ( v1 >= v3 - 1 )
      v14 = 0;
    else
      v14 = v1 + 1;
    sub_404910(0, 64);
    sub_407E00((int)&unk_444764);
  }
  if ( v2 & dword_440D84[dword_444710] )
  {
    sub_404910(0, v2 & dword_440D84[dword_444710]);
    if ( ++dword_444710 == 8 )
    {
      byte_455CAB ^= 1u;
      if ( !byte_455CAB )
        dword_455CAC = 0;
    }
  }
  else if ( v2 )
  {
    dword_444710 = 0;
  }
  sub_401580(1);
  v5 = 0;
  if ( v3 > 0 )
  {
    do
    {
      if ( v5 == v14 )
      {
        byte_443AF0 = 0;
        byte_443AF2 = word_442380;
        byte_443AF1 = word_442380;
      }
      else
      {
        byte_443AF2 = -112;
        byte_443AF1 = 66;
        byte_443AF0 = 78;
      }
      switch ( v5 )
      {
        case 0u:
          sub_4015D0(0x28u, 66, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x45u);
          break;
        case 1u:
          sub_4015D0(0x28u, v15 + 66, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x44u);
          break;
        case 2u:
          sub_4015D0(0x28u, 2 * v15 + 66, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x48u);
          break;
        case 3u:
          sub_4015D0(0x28u, 3 * v15 + 66, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x42u);
          break;
        case 4u:
          v12 = 79;
          v11 = HIWORD(dword_443AE4);
          v10 = (unsigned __int16)dword_443AE4;
          v6 = 4 * v15 + 66;
          goto LABEL_35;
        case 5u:
          v12 = 61;
          v11 = HIWORD(dword_443AE4);
          v10 = (unsigned __int16)dword_443AE4;
          v6 = 5 * v15 + 66;
          goto LABEL_35;
        case 6u:
          v12 = 80;
          v11 = HIWORD(dword_443AE4);
          v10 = (unsigned __int16)dword_443AE4;
          v6 = 2 * (3 * v15 + 33);
LABEL_35:
          sub_4015D0(0x28u, v6, v10, v11, 1, v12);
          break;
        default:
          break;
      }
      sub_401D10();
      ++v5;
    }
    while ( v5 < v3 );
    v2 = v16;
  }
  sub_404950(20, 450, 5);
  sub_404FD0();
  sub_404DD0();
  sub_401D10();
  sub_402A90();
  v7 = v13;
  if ( v2 & 0x4000 )
  {
    sub_407E00((int)&unk_444770);
    sub_404910(0, v2 & 0x4000);
    v8 = v14;
    switch ( v14 )
    {
      case 0:
        sub_434490();
        sub_41FE80();
        sub_407C30();
        switch ( unk_455CB9 )
        {
          case 0u:
            sub_42C650(v2, v7, 0, hWnd, (int)off_442694[0]);
            break;
          case 1u:
            sub_42C650(v2, v7, 0, hWnd, (int)off_442698[0]);
            break;
          case 2u:
            v9 = (char *)off_44269C;
            goto LABEL_47;
          case 3u:
            sub_42C650(v2, v7, 0, hWnd, (int)off_4426A0[0]);
            break;
          case 4u:
            sub_42C650(v2, v7, 0, hWnd, (int)off_4426A4[0]);
            break;
          default:
            v9 = off_442694[0];
LABEL_47:
            sub_42C650(v2, v7, 0, hWnd, (int)v9);
            break;
        }
        sub_42CBA0();
        sub_405550(1);
        dword_444744 = 0;
        sub_404530();
        dword_444708 = v14;
        result = 0;
        break;
      case 1:
        sub_434490();
        if ( sub_41FE80() )
        {
          sub_405550(2);
          dword_444744 = 0;
        }
        else
        {
          v18 = -1;
          v19 = 0;
          v20 = 58;
          v21 = 0x10000000;
          v22 = 64;
          v23 = 0x10000000;
          sub_41FEF0((int)&v18, 0x4000u);
        }
        sub_404530();
        dword_444708 = v14;
        result = 0;
        break;
      case 2:
        sub_405550(3);
        dword_4446F0 = 0;
        byte_444740 = HIBYTE(word_455CB7);
        byte_4446F4 = word_455CB7;
        sub_404530();
        dword_444708 = v14;
        result = 0;
        break;
      case 3:
        sub_405550(4);
        dword_4446F8 = unk_455CB9;
        byte_4446D4 = unk_455CB9;
        sub_404530();
        dword_444708 = v14;
        result = 0;
        break;
      case 4:
        sub_407C30();
        sub_42C650(v2, v7, 0, hWnd, off_4426A8);
        sub_42CBA0();
        sub_405550(8);
        dword_444738 = dword_455BE0;
        dword_455BEC = 0;
        sub_404530();
        dword_444708 = v14;
        result = 0;
        break;
      case 5:
        BYTE2(dword_455CBC) = 0;
        SendMessageA(hWnd, 0x10u, 0, 0);
        sub_404530();
        dword_444708 = v14;
        result = 0;
        break;
      case 6:
        sub_405550(5);
        sub_404530();
        dword_444708 = v14;
        result = 0;
        break;
      default:
        goto LABEL_59;
    }
  }
  else
  {
    v8 = v14;
LABEL_59:
    sub_404530();
    dword_444708 = v8;
    result = 0;
  }
  return result;
}
// 405830: could not find valid save-restore pair for ebp
// 442380: using guessed type __int16 word_442380;
// 442694: using guessed type char *off_442694[11];
// 442698: using guessed type char *off_442698[10];
// 4426A0: using guessed type char *off_4426A0[8];
// 4426A4: using guessed type char *off_4426A4[7];
// 443AE4: using guessed type int dword_443AE4;
// 443AF0: using guessed type char byte_443AF0;
// 443AF1: using guessed type char byte_443AF1;
// 443AF2: using guessed type char byte_443AF2;
// 4446D4: using guessed type char byte_4446D4;
// 4446F0: using guessed type int dword_4446F0;
// 4446F4: using guessed type char byte_4446F4;
// 4446F8: using guessed type int dword_4446F8;
// 444708: using guessed type int dword_444708;
// 444710: using guessed type int dword_444710;
// 444724: using guessed type int dword_444724;
// 444738: using guessed type int dword_444738;
// 444740: using guessed type char byte_444740;
// 444744: using guessed type int dword_444744;
// 44BAE4: using guessed type char byte_44BAE4;
// 455BE0: using guessed type int dword_455BE0;
// 455BEC: using guessed type int dword_455BEC;
// 455CAB: using guessed type char byte_455CAB;
// 455CAC: using guessed type int dword_455CAC;
// 455CB7: using guessed type __int16 word_455CB7;
// 455CBC: using guessed type int dword_455CBC;

//----- (00405DD0) --------------------------------------------------------
char sub_405DD0()
{
  unsigned __int8 *v0; // esi

  v0 = (unsigned __int8 *)sub_401D60((int)aDataGraphBack2);
  sub_401DB0(v0, 0, 0x280u, 0x100u, 0, 0);
  sub_401E20((int)v0, 896, 255);
  return sub_401E40((unsigned int)v0);
}

//----- (00405E10) --------------------------------------------------------
char __usercall sub_405E10@<al>(int a1@<ebp>)
{
  char result; // al

  if ( *(_DWORD *)(dword_455CD8 + 4) )
  {
    *(_DWORD *)(dword_455CD8 + 4) = 0;
    dword_44B720 = (int)sub_4089F0(dword_455C8C);
    sub_405550(0);
  }
  result = byte_4446D6;
  switch ( byte_4446D6 )
  {
    case 0:
      result = sub_405830(a1);
      break;
    case 1:
      result = sub_405570(1);
      break;
    case 2:
      result = sub_405570(0);
      break;
    case 3:
      result = sub_406E20();
      break;
    case 4:
      result = sub_405260(0);
      break;
    case 5:
      result = sub_407560();
      break;
    case 6:
      dword_444728 = dword_442684;
      dword_44472C = dword_442688;
      dword_444730 = dword_44268C;
      dword_444734 = dword_442690;
      result = sub_405F60(0);
      break;
    case 7:
      dword_4446DC = dword_442674;
      dword_4446E0 = dword_442678;
      dword_4446E4 = dword_44267C;
      dword_4446E8 = dword_442680;
      result = sub_405F60(1u);
      break;
    case 8:
      result = dword_455BE0 - dword_444738;
      if ( (unsigned int)(dword_455BE0 - dword_444738) > 0x96 )
      {
        result = sub_42C5F0(1);
        if ( !result )
        {
          sub_407BB0(16);
          sub_405550(0);
          result = sub_404910(0, 0x4000);
        }
      }
      break;
    default:
      return result;
  }
  return result;
}
// 442674: using guessed type int dword_442674;
// 442678: using guessed type int dword_442678;
// 44267C: using guessed type int dword_44267C;
// 442680: using guessed type int dword_442680;
// 442684: using guessed type int dword_442684;
// 442688: using guessed type int dword_442688;
// 44268C: using guessed type int dword_44268C;
// 442690: using guessed type int dword_442690;
// 4446D6: using guessed type char byte_4446D6;
// 4446DC: using guessed type int dword_4446DC;
// 4446E0: using guessed type int dword_4446E0;
// 4446E4: using guessed type int dword_4446E4;
// 4446E8: using guessed type int dword_4446E8;
// 444728: using guessed type int dword_444728;
// 44472C: using guessed type int dword_44472C;
// 444730: using guessed type int dword_444730;
// 444734: using guessed type int dword_444734;
// 444738: using guessed type int dword_444738;
// 44B720: using guessed type int dword_44B720;
// 455BE0: using guessed type int dword_455BE0;
// 455C8C: using guessed type int dword_455C8C;
// 455CD8: using guessed type int dword_455CD8;

//----- (00405F60) --------------------------------------------------------
char __cdecl sub_405F60(unsigned __int8 a1)
{
  unsigned int v1; // esi
  char v2; // al
  char v3; // al
  int v4; // ecx
  _DWORD *v5; // eax
  int v6; // esi
  _DWORD *v7; // eax
  int v8; // esi
  _DWORD *v9; // eax
  int v10; // esi
  _DWORD *v11; // eax
  int v12; // esi
  _DWORD *v13; // eax
  int v14; // esi
  _DWORD *v15; // eax
  int v16; // esi
  unsigned int v17; // esi
  char result; // al
  int v19; // [esp-1Ch] [ebp-48h]
  int v20; // [esp-18h] [ebp-44h]
  int v21; // [esp-14h] [ebp-40h]
  unsigned int v22; // [esp-Ch] [ebp-38h]
  int v23; // [esp+8h] [ebp-24h]
  __int16 v24; // [esp+Ch] [ebp-20h]
  unsigned int v25; // [esp+10h] [ebp-1Ch]
  __int16 v26; // [esp+14h] [ebp-18h]
  int v27; // [esp+18h] [ebp-14h]
  __int16 v28; // [esp+1Ch] [ebp-10h]
  int v29; // [esp+20h] [ebp-Ch]
  __int16 v30; // [esp+24h] [ebp-8h]
  int v31; // [esp+28h] [ebp-4h]

  sub_404530();
  v1 = dword_4446FC;
  v23 = dword_4446FC;
  dword_4446D8 = 0;
  sub_434560();
  v2 = dword_455BEC;
  v24 = dword_455BEC;
  if ( byte_4446D5 )
  {
    dword_4446D8 = 1;
    if ( a1 )
      v3 = sub_4043C0();
    else
      v3 = sub_404470();
    if ( v3 != -1 )
    {
      if ( a1 )
      {
        sub_406AC0((int)&dword_442684, v1 + 8, v3);
        byte_4446D5 = 0;
        sub_404910(0, 20480);
      }
      else if ( v3 == 57 || v3 == 60 || v3 == 28 || v3 == -53 || v3 == -51 || v3 == -56 || v3 == -48 )
      {
        sub_404910(0, 0x4000);
        v26 = -1;
        v27 = 0;
        v28 = 241;
        v29 = 0x10000000;
        v30 = 64;
        v31 = 0x10000000;
        sub_41FEF0((int)&v26, 0x4000u);
        dword_4446D8 = 0;
        byte_4446D5 = 0;
      }
      else
      {
        if ( v3 != 1 )
          sub_406AC0((int)&dword_442674, v1 + 8, v3);
        dword_4446D8 = 0;
        byte_4446D5 = 0;
        sub_404910(0, 20480);
      }
      v24 = 0;
    }
  }
  else
  {
    if ( dword_455BEC & 0x10 )
    {
      if ( v1 )
        v23 = v1 - 1;
      else
        v23 = 9;
      sub_404910(0, 16);
      sub_407E00((int)&unk_444764);
      v2 = v24;
      v1 = v23;
    }
    if ( v2 & 0x40 )
    {
      if ( v1 >= 9 )
        v23 = 0;
      else
        v23 = v1 + 1;
      sub_404910(0, 64);
      sub_407E00((int)&unk_444764);
      v1 = v23;
    }
  }
  sub_401580(1);
  v4 = 0;
  v25 = 0;
  while ( 1 )
  {
    if ( v4 == v1 )
    {
      if ( dword_4446D8 )
      {
        byte_443AF2 = -1;
        byte_443AF1 = -1;
        byte_443AF0 = 0;
      }
      else
      {
        byte_443AF0 = 0;
        byte_443AF2 = word_442380;
        byte_443AF1 = word_442380;
      }
    }
    else
    {
      byte_443AF2 = -112;
      byte_443AF1 = 66;
      byte_443AF0 = 78;
    }
    switch ( v4 )
    {
      case 0:
        sub_4015D0(0x50u, 110, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0xE7u);
        break;
      case 1:
        sub_4015D0(0x50u, 140, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0xF0u);
        break;
      case 2:
        v5 = dword_443D2C;
        v6 = *((_DWORD *)dword_443D2C + 16032);
        *((_DWORD *)dword_443D2C + 16032) = v6 + 128;
        *(_DWORD *)(v6 + 4) = 0;
        *(_DWORD *)v6 = v5[30];
        v5[30] = v6;
        *(_DWORD *)(v6 + 20) = 1126825984;
        *(_DWORD *)(v6 + 16) = 1109393408;
        *(_DWORD *)(v6 + 72) = 1109393408;
        *(_DWORD *)(v6 + 48) = 1126825984;
        *(_DWORD *)(v6 + 76) = 1128857600;
        *(_DWORD *)(v6 + 104) = 1128857600;
        *(_DWORD *)(v6 + 36) = 1063050461;
        *(_DWORD *)(v6 + 92) = 1063050461;
        *(_BYTE *)(v6 + 34) = -1;
        *(_BYTE *)(v6 + 33) = -1;
        *(_BYTE *)(v6 + 32) = -1;
        *(_DWORD *)(v6 + 4) = 5;
        *(_DWORD *)(v6 + 44) = 1116733440;
        *(_DWORD *)(v6 + 100) = 1116733440;
        *(_DWORD *)(v6 + 24) = 0;
        *(_DWORD *)(v6 + 28) = 1065353216;
        *(_DWORD *)(v6 + 52) = 0;
        *(_DWORD *)(v6 + 56) = 1065353216;
        *(_DWORD *)(v6 + 80) = 0;
        *(_DWORD *)(v6 + 84) = 1065353216;
        *(_DWORD *)(v6 + 108) = 0;
        *(_DWORD *)(v6 + 112) = 1065353216;
        *(_DWORD *)(v6 + 40) = 0;
        *(_DWORD *)(v6 + 64) = 1065024251;
        *(_DWORD *)(v6 + 68) = 0;
        *(_DWORD *)(v6 + 96) = 1038674153;
        *(_DWORD *)(v6 + 120) = 1065024251;
        *(_DWORD *)(v6 + 124) = 1038674153;
        *(_DWORD *)(v6 + 8) = sub_401000(0, 0, 1271, 0);
        sub_4015D0(0x50u, 170, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0xEAu);
        break;
      case 3:
        sub_4015D0(0x50u, 200, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0xEBu);
        break;
      case 4:
        v7 = dword_443D2C;
        v8 = *((_DWORD *)dword_443D2C + 16032);
        *((_DWORD *)dword_443D2C + 16032) = v8 + 128;
        *(_DWORD *)(v8 + 4) = 0;
        *(_DWORD *)v8 = v7[30];
        v7[30] = v8;
        *(_DWORD *)(v8 + 20) = 1130758144;
        *(_DWORD *)(v8 + 16) = 1109393408;
        *(_DWORD *)(v8 + 72) = 1109393408;
        *(_DWORD *)(v8 + 48) = 1130758144;
        *(_DWORD *)(v8 + 76) = 1132625920;
        *(_DWORD *)(v8 + 104) = 1132625920;
        *(_DWORD *)(v8 + 36) = 1060945085;
        *(_DWORD *)(v8 + 92) = 1060945085;
        *(_BYTE *)(v8 + 34) = -1;
        *(_BYTE *)(v8 + 33) = -1;
        *(_BYTE *)(v8 + 32) = -1;
        *(_DWORD *)(v8 + 4) = 5;
        *(_DWORD *)(v8 + 44) = 1116733440;
        *(_DWORD *)(v8 + 100) = 1116733440;
        *(_DWORD *)(v8 + 24) = 0;
        *(_DWORD *)(v8 + 28) = 1065353216;
        *(_DWORD *)(v8 + 52) = 0;
        *(_DWORD *)(v8 + 56) = 1065353216;
        *(_DWORD *)(v8 + 80) = 0;
        *(_DWORD *)(v8 + 84) = 1065353216;
        *(_DWORD *)(v8 + 108) = 0;
        *(_DWORD *)(v8 + 112) = 1065353216;
        *(_DWORD *)(v8 + 40) = 0;
        *(_DWORD *)(v8 + 64) = 1062918875;
        *(_DWORD *)(v8 + 68) = 0;
        *(_DWORD *)(v8 + 96) = 1038674153;
        *(_DWORD *)(v8 + 120) = 1062918875;
        *(_DWORD *)(v8 + 124) = 1038674153;
        *(_DWORD *)(v8 + 8) = sub_401000(0, 0, 1263, 0);
        sub_4015D0(0x50u, 230, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0xEFu);
        break;
      case 5:
        v9 = dword_443D2C;
        v10 = *((_DWORD *)dword_443D2C + 16032);
        *((_DWORD *)dword_443D2C + 16032) = v10 + 128;
        *(_DWORD *)(v10 + 4) = 0;
        *(_DWORD *)v10 = v9[30];
        v9[30] = v10;
        *(_DWORD *)(v10 + 16) = 1109393408;
        *(_DWORD *)(v10 + 72) = 1109393408;
        *(_DWORD *)(v10 + 20) = 1132593152;
        *(_DWORD *)(v10 + 76) = 1133608960;
        *(_DWORD *)(v10 + 104) = 1133608960;
        *(_DWORD *)(v10 + 48) = 1132593152;
        *(_DWORD *)(v10 + 36) = 1058839709;
        *(_DWORD *)(v10 + 92) = 1058839709;
        *(_BYTE *)(v10 + 34) = -1;
        *(_BYTE *)(v10 + 33) = -1;
        *(_BYTE *)(v10 + 32) = -1;
        *(_DWORD *)(v10 + 4) = 5;
        *(_DWORD *)(v10 + 44) = 1116733440;
        *(_DWORD *)(v10 + 100) = 1116733440;
        *(_DWORD *)(v10 + 24) = 0;
        *(_DWORD *)(v10 + 28) = 1065353216;
        *(_DWORD *)(v10 + 52) = 0;
        *(_DWORD *)(v10 + 56) = 1065353216;
        *(_DWORD *)(v10 + 80) = 0;
        *(_DWORD *)(v10 + 84) = 1065353216;
        *(_DWORD *)(v10 + 108) = 0;
        *(_DWORD *)(v10 + 112) = 1065353216;
        *(_DWORD *)(v10 + 40) = 1039726841;
        *(_DWORD *)(v10 + 64) = 1060813499;
        *(_DWORD *)(v10 + 68) = 1039726841;
        *(_DWORD *)(v10 + 96) = 1047589105;
        *(_DWORD *)(v10 + 120) = 1060813499;
        *(_DWORD *)(v10 + 124) = 1047589105;
        *(_DWORD *)(v10 + 8) = sub_401000(0, 0, 1255, 31);
        sub_4015D0(0x50u, 260, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0xE9u);
        break;
      case 6:
        v11 = dword_443D2C;
        v12 = *((_DWORD *)dword_443D2C + 16032);
        *((_DWORD *)dword_443D2C + 16032) = v12 + 128;
        *(_DWORD *)(v12 + 4) = 0;
        *(_DWORD *)v12 = v11[30];
        v11[30] = v12;
        *(_DWORD *)(v12 + 20) = 1133576192;
        *(_DWORD *)(v12 + 16) = 1109393408;
        *(_DWORD *)(v12 + 72) = 1109393408;
        *(_DWORD *)(v12 + 48) = 1133576192;
        *(_DWORD *)(v12 + 76) = 1134592000;
        *(_DWORD *)(v12 + 104) = 1134592000;
        *(_DWORD *)(v12 + 36) = 1060945085;
        *(_DWORD *)(v12 + 92) = 1060945085;
        *(_BYTE *)(v12 + 34) = -1;
        *(_BYTE *)(v12 + 33) = -1;
        *(_BYTE *)(v12 + 32) = -1;
        *(_DWORD *)(v12 + 4) = 5;
        *(_DWORD *)(v12 + 44) = 1116733440;
        *(_DWORD *)(v12 + 100) = 1116733440;
        *(_DWORD *)(v12 + 24) = 0;
        *(_DWORD *)(v12 + 28) = 1065353216;
        *(_DWORD *)(v12 + 52) = 0;
        *(_DWORD *)(v12 + 56) = 1065353216;
        *(_DWORD *)(v12 + 80) = 0;
        *(_DWORD *)(v12 + 84) = 1065353216;
        *(_DWORD *)(v12 + 108) = 0;
        *(_DWORD *)(v12 + 112) = 1065353216;
        *(_DWORD *)(v12 + 40) = 1039726841;
        *(_DWORD *)(v12 + 64) = 1062918875;
        *(_DWORD *)(v12 + 68) = 1039726841;
        *(_DWORD *)(v12 + 96) = 1047589105;
        *(_DWORD *)(v12 + 120) = 1062918875;
        *(_DWORD *)(v12 + 124) = 1047589105;
        *(_DWORD *)(v12 + 8) = sub_401000(0, 0, 1263, 31);
        sub_4015D0(0x50u, 290, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0xE8u);
        break;
      case 7:
        v13 = dword_443D2C;
        v14 = *((_DWORD *)dword_443D2C + 16032);
        *((_DWORD *)dword_443D2C + 16032) = v14 + 128;
        *(_DWORD *)(v14 + 4) = 0;
        *(_DWORD *)v14 = v13[30];
        v13[30] = v14;
        *(_DWORD *)(v14 + 16) = 1109393408;
        *(_DWORD *)(v14 + 72) = 1109393408;
        *(_DWORD *)(v14 + 20) = 1134559232;
        *(_DWORD *)(v14 + 76) = 1135575040;
        *(_DWORD *)(v14 + 104) = 1135575040;
        *(_DWORD *)(v14 + 48) = 1134559232;
        *(_DWORD *)(v14 + 36) = 1058839709;
        *(_DWORD *)(v14 + 92) = 1058839709;
        *(_BYTE *)(v14 + 34) = -1;
        *(_BYTE *)(v14 + 33) = -1;
        *(_BYTE *)(v14 + 32) = -1;
        *(_DWORD *)(v14 + 4) = 5;
        *(_DWORD *)(v14 + 44) = 1116733440;
        *(_DWORD *)(v14 + 100) = 1116733440;
        *(_DWORD *)(v14 + 24) = 0;
        *(_DWORD *)(v14 + 28) = 1065353216;
        *(_DWORD *)(v14 + 52) = 0;
        *(_DWORD *)(v14 + 56) = 1065353216;
        *(_DWORD *)(v14 + 80) = 0;
        *(_DWORD *)(v14 + 84) = 1065353216;
        *(_DWORD *)(v14 + 108) = 0;
        *(_DWORD *)(v14 + 112) = 1065353216;
        *(_DWORD *)(v14 + 40) = 0;
        *(_DWORD *)(v14 + 64) = 1060813499;
        *(_DWORD *)(v14 + 68) = 0;
        *(_DWORD *)(v14 + 96) = 1038674153;
        *(_DWORD *)(v14 + 120) = 1060813499;
        *(_DWORD *)(v14 + 124) = 1038674153;
        *(_DWORD *)(v14 + 8) = sub_401000(0, 0, 1255, 0);
        sub_4015D0(0x50u, 320, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0xECu);
        break;
      case 8:
        v22 = 61;
        v21 = HIWORD(dword_443AE4);
        v20 = (unsigned __int16)dword_443AE4;
        v19 = 350;
        goto LABEL_48;
      case 9:
        v22 = 64;
        v21 = HIWORD(dword_443AE4);
        v20 = (unsigned __int16)dword_443AE4;
        v19 = 380;
LABEL_48:
        sub_4015D0(0x28u, v19, v20, v21, 1, v22);
        break;
      default:
        break;
    }
    sub_401D10();
    v4 = v25++ + 1;
    if ( v25 >= 0xA )
      break;
    v1 = v23;
  }
  sub_406AF0(v23, a1);
  v15 = dword_443D2C;
  v16 = *((_DWORD *)dword_443D2C + 16032);
  *((_DWORD *)dword_443D2C + 16032) = v16 + 128;
  *(_DWORD *)(v16 + 4) = 0;
  *(_DWORD *)v16 = v15[30];
  v15[30] = v16;
  *(_DWORD *)(v16 + 20) = 1138556928;
  *(_DWORD *)(v16 + 48) = 1138556928;
  *(_DWORD *)(v16 + 16) = 1128792064;
  *(_DWORD *)(v16 + 76) = 1139572736;
  *(_DWORD *)(v16 + 104) = 1139572736;
  *(_DWORD *)(v16 + 44) = 1130889216;
  *(_DWORD *)(v16 + 72) = 1128792064;
  *(_DWORD *)(v16 + 100) = 1130889216;
  *(_DWORD *)(v16 + 36) = 1063050461;
  *(_DWORD *)(v16 + 92) = 1063050461;
  *(_BYTE *)(v16 + 34) = -1;
  *(_BYTE *)(v16 + 33) = -1;
  *(_BYTE *)(v16 + 32) = -1;
  *(_DWORD *)(v16 + 4) = 5;
  *(_DWORD *)(v16 + 24) = 0;
  *(_DWORD *)(v16 + 28) = 1065353216;
  *(_DWORD *)(v16 + 52) = 0;
  *(_DWORD *)(v16 + 56) = 1065353216;
  *(_DWORD *)(v16 + 80) = 0;
  *(_DWORD *)(v16 + 84) = 1065353216;
  *(_DWORD *)(v16 + 108) = 0;
  *(_DWORD *)(v16 + 112) = 1065353216;
  *(_DWORD *)(v16 + 40) = 1039726841;
  *(_DWORD *)(v16 + 64) = 1065024251;
  *(_DWORD *)(v16 + 68) = 1039726841;
  *(_DWORD *)(v16 + 96) = 1047589105;
  *(_DWORD *)(v16 + 120) = 1065024251;
  *(_DWORD *)(v16 + 124) = 1047589105;
  *(_DWORD *)(v16 + 8) = sub_401000(0, 0, 1271, 31);
  sub_404950(20, 450, 6);
  byte_443AF2 = -112;
  byte_443AF1 = 66;
  byte_443AF0 = 78;
  sub_4015D0(0x50u, 50, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x1Eu);
  sub_406D10(0x3Cu, 300, 50);
  byte_443AF2 = -112;
  byte_443AF1 = 66;
  byte_443AF0 = 78;
  sub_4015D0(0x50u, 80, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x12u);
  sub_406D10(0x39u, 300, 80);
  sub_401D10();
  sub_404DD0();
  sub_401D10();
  sub_402A90();
  if ( byte_4446D5 )
  {
    if ( v24 & 0x1000 )
    {
      sub_404910(0, v24 & 0x5000);
      byte_4446D5 = 0;
    }
    v17 = v23;
  }
  else if ( v24 & 0x1000 || (v17 = v23, HIBYTE(v24) & 0x40) && v23 == 10 )
  {
    sub_407E00((int)&dword_444758);
    sub_404910(0, v24 & 0x5000);
    if ( a1 )
    {
      dword_442684 = dword_444728;
      dword_442688 = dword_44472C;
      dword_44268C = dword_444730;
      dword_442690 = dword_444734;
    }
    else
    {
      dword_442674 = dword_4446DC;
      dword_442678 = dword_4446E0;
      dword_44267C = dword_4446E4;
      dword_442680 = dword_4446E8;
    }
    return sub_405550(3);
  }
  if ( sub_404470() == 28 && v17 >= 8 )
  {
    sub_404910(0, 0x4000);
    if ( v17 == 9 )
    {
      sub_403E00();
      if ( a1 )
        sub_404450((int)&dword_442684);
      else
        sub_404510((int)&dword_442674);
LABEL_71:
      sub_404910(0, 20480);
      sub_407E00((int)&unk_444770);
      return sub_405550(3);
    }
    if ( v17 == 8 )
    {
      if ( a1 )
      {
        dword_442684 = dword_444728;
        dword_442688 = dword_44472C;
        dword_44268C = dword_444730;
        dword_442690 = dword_444734;
      }
      else
      {
        dword_442674 = dword_4446DC;
        dword_442678 = dword_4446E0;
        dword_44267C = dword_4446E4;
        dword_442680 = dword_4446E8;
      }
      goto LABEL_71;
    }
  }
  sub_401580(1);
  byte_443AF2 = 40;
  byte_443AF1 = 40;
  byte_443AF0 = 40;
  sub_4015D0(0xFAu, 442, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x40u);
  sub_401D10();
  if ( !byte_4446D5 && sub_404470() == 28 && v17 != 9 && v17 != 8 )
  {
    byte_4446D5 = 1;
    sub_404910(0, 0x4000);
  }
  result = sub_404530();
  dword_4446FC = v17;
  return result;
}
// 442380: using guessed type __int16 word_442380;
// 442674: using guessed type int dword_442674;
// 442678: using guessed type int dword_442678;
// 44267C: using guessed type int dword_44267C;
// 442680: using guessed type int dword_442680;
// 442684: using guessed type int dword_442684;
// 442688: using guessed type int dword_442688;
// 44268C: using guessed type int dword_44268C;
// 442690: using guessed type int dword_442690;
// 443AE4: using guessed type int dword_443AE4;
// 443AF0: using guessed type char byte_443AF0;
// 443AF1: using guessed type char byte_443AF1;
// 443AF2: using guessed type char byte_443AF2;
// 4446D5: using guessed type char byte_4446D5;
// 4446D8: using guessed type int dword_4446D8;
// 4446DC: using guessed type int dword_4446DC;
// 4446E0: using guessed type int dword_4446E0;
// 4446E4: using guessed type int dword_4446E4;
// 4446E8: using guessed type int dword_4446E8;
// 4446FC: using guessed type int dword_4446FC;
// 444728: using guessed type int dword_444728;
// 44472C: using guessed type int dword_44472C;
// 444730: using guessed type int dword_444730;
// 444734: using guessed type int dword_444734;
// 455BEC: using guessed type int dword_455BEC;

//----- (00406AC0) --------------------------------------------------------
unsigned int __cdecl sub_406AC0(int a1, int a2, char a3)
{
  unsigned int result; // eax

  result = 0;
  *(_BYTE *)(a1 + a2) = a3;
  do
  {
    if ( result != a2 && *(_BYTE *)(result + a1) == a3 )
      *(_BYTE *)(result + a1) = -1;
    ++result;
  }
  while ( result < 0x10 );
  return result;
}

//----- (00406AF0) --------------------------------------------------------
int __cdecl sub_406AF0(int a1, int a2)
{
  signed int v2; // ebx
  int v3; // esi
  int v4; // ST14_4
  signed int v5; // ebp
  int v6; // ebx
  int v7; // eax
  int v8; // eax
  int result; // eax
  signed int v10; // [esp+0h] [ebp-54h]
  int *v11; // [esp+4h] [ebp-50h]
  int v12; // [esp+8h] [ebp-4Ch]
  char v13; // [esp+Ch] [ebp-48h]
  CHAR MultiByteStr[68]; // [esp+10h] [ebp-44h]

  byte_443AF2 = 90;
  byte_443AF1 = 90;
  byte_443AF0 = 90;
  v11 = &dword_442684;
  if ( !a2 )
    v11 = &dword_442674;
  v2 = 240;
  v3 = 0;
  v10 = 240;
  v12 = 0;
  do
  {
    if ( *((_BYTE *)v11 + v3 + 8) == -1 )
    {
      byte_443AF2 = -1;
      byte_443AF1 = 0;
      byte_443AF0 = 0;
      sub_401AB0(300, v2 - 130, 1, aS);
    }
    else
    {
      byte_443AF2 = 90;
      byte_443AF1 = 90;
      byte_443AF0 = 90;
      if ( a2 )
      {
        v4 = *((unsigned __int8 *)&dword_44268C + v3);
        sub_401AB0(300, v2 - 130, 1, aSD);
      }
      else
      {
        sub_404730(*((unsigned __int8 *)&dword_44267C + v3), MultiByteStr);
        if ( MultiByteStr )
        {
          v5 = 0;
          if ( (signed int)strlen(MultiByteStr) > 0 )
          {
            v6 = 300;
            do
            {
              v13 = MultiByteStr[v5];
              if ( toupper(v13) < 65 || toupper(v13) > 90 )
              {
                if ( toupper(v13) < 48 || toupper(v13) > 57 )
                  sub_4047E0(v13);
                else
                  v8 = toupper(v13) - 48;
              }
              else
              {
                v7 = toupper(v13) + 135;
              }
              sub_401AB0(v6, v10 - 130, 1, aS);
              ++v5;
              v6 += 17;
            }
            while ( v5 < (signed int)strlen(MultiByteStr) );
            v3 = v12;
            v2 = v10;
          }
        }
        else
        {
          byte_443AF2 = -1;
          byte_443AF1 = 0;
          byte_443AF0 = 0;
          sub_401AB0(300, v2 - 130, 1, aS);
        }
      }
    }
    result = sub_401D10();
    ++v3;
    v2 += 30;
    v12 = v3;
    v10 = v2;
  }
  while ( (unsigned int)(v3 + 8) <= 0xF );
  return result;
}
// 442674: using guessed type int dword_442674;
// 44267C: using guessed type int dword_44267C;
// 442684: using guessed type int dword_442684;
// 44268C: using guessed type int dword_44268C;
// 443AF0: using guessed type char byte_443AF0;
// 443AF1: using guessed type char byte_443AF1;
// 443AF2: using guessed type char byte_443AF2;
// 406AF0: using guessed type CHAR MultiByteStr[68];

//----- (00406D10) --------------------------------------------------------
int __cdecl sub_406D10(unsigned __int8 a1, int a2, int a3)
{
  signed int v3; // ebp
  int v4; // ebx
  int v5; // esi
  int v6; // eax
  int v7; // eax
  CHAR MultiByteStr[68]; // [esp+8h] [ebp-44h]
  char v10; // [esp+50h] [ebp+4h]

  byte_443AF2 = 90;
  byte_443AF1 = 90;
  byte_443AF0 = 90;
  sub_404730(a1, MultiByteStr);
  if ( MultiByteStr )
  {
    v3 = 0;
    if ( (signed int)strlen(MultiByteStr) > 0 )
    {
      v4 = a2;
      do
      {
        v5 = MultiByteStr[v3];
        v10 = MultiByteStr[v3];
        if ( toupper(v5) < 65 || toupper(v5) > 90 )
        {
          if ( toupper(v5) < 48 || toupper(v5) > 57 )
            sub_4047E0(v10);
          else
            v7 = toupper(v5) - 48;
        }
        else
        {
          v6 = toupper(v5) + 135;
        }
        sub_401AB0(v4, a3, 1, aS);
        ++v3;
        v4 += 17;
      }
      while ( v3 < (signed int)strlen(MultiByteStr) );
    }
  }
  return sub_401D10();
}
// 443AF0: using guessed type char byte_443AF0;
// 443AF1: using guessed type char byte_443AF1;
// 443AF2: using guessed type char byte_443AF2;
// 406D10: using guessed type CHAR MultiByteStr[68];

//----- (00406E20) --------------------------------------------------------
char sub_406E20()
{
  unsigned int v0; // ebp
  char v1; // bl
  int v2; // esi
  unsigned int v3; // esi
  int v4; // edx
  char result; // al
  int v6; // [esp-10h] [ebp-30h]
  int v7; // [esp-Ch] [ebp-2Ch]
  unsigned int v8; // [esp-4h] [ebp-24h]
  __int16 v9; // [esp+Fh] [ebp-11h]
  char v10; // [esp+11h] [ebp-Fh]
  char v11; // [esp+12h] [ebp-Eh]
  char v12; // [esp+13h] [ebp-Dh]
  int v13; // [esp+14h] [ebp-Ch]
  int v14; // [esp+18h] [ebp-8h]
  char v15; // [esp+1Ch] [ebp-4h]

  sub_404530();
  sub_4015B0(&v15, &v13);
  v0 = dword_44470C;
  v9 = word_455CB7;
  byte_4446D7 = 0;
  v10 = byte_455CB5;
  v11 = byte_455CB6;
  v12 = unk_455CBA;
  sub_434560();
  v1 = dword_455BEC;
  v14 = dword_455BEC;
  v2 = dword_455BEC & 0x10;
  if ( dword_455BEC & 0x10 && !(dword_455BEC & 0xA0) )
  {
    if ( byte_4446D7 )
    {
      if ( (unsigned __int8)byte_455CB6 > 2u )
        --byte_455CB6;
      nullsub_1(dword_443D44);
      nullsub_1(dword_443D38);
      sub_404910(0, 16);
    }
    else
    {
      if ( v0 )
        --v0;
      else
        v0 = 5;
      sub_404910(0, 16);
    }
    sub_407E00((int)&unk_444764);
  }
  if ( v1 & 0x40 && !(v1 & 0xA0) )
  {
    if ( byte_4446D7 )
    {
      if ( (unsigned __int8)byte_455CB6 < 0x16u )
        ++byte_455CB6;
      nullsub_1(dword_443D44);
      nullsub_1(dword_443D38);
      sub_404910(0, 64);
    }
    else
    {
      if ( v0 >= 5 )
        v0 = 0;
      else
        ++v0;
      sub_404910(0, 64);
    }
    sub_407E00((int)&unk_444764);
  }
  if ( v1 < 0 && !v2 && !(v1 & 0x40) )
  {
    switch ( v0 )
    {
      case 0u:
        if ( (_BYTE)word_455CB7 )
        {
          LOBYTE(word_455CB7) = word_455CB7 - 1;
          sub_407B60(word_455CB7);
        }
        break;
      case 1u:
        if ( HIBYTE(word_455CB7) )
        {
          --HIBYTE(word_455CB7);
          sub_407B70(HIBYTE(word_455CB7));
        }
        break;
      case 2u:
      case 3u:
        sub_404910(0, 16);
        sub_404910(0, 64);
        break;
      case 4u:
        if ( (_BYTE)dword_455CBC )
          BYTE1(dword_455CBC) = 0;
        break;
      default:
        break;
    }
    sub_404910(0, 128);
    sub_407E00((int)&unk_444764);
  }
  if ( v1 & 0x20 && !v2 && !(v1 & 0x40) )
  {
    switch ( v0 )
    {
      case 0u:
        if ( (unsigned __int8)word_455CB7 < 0xAu )
        {
          LOBYTE(word_455CB7) = word_455CB7 + 1;
          sub_407B60(word_455CB7);
        }
        break;
      case 1u:
        if ( HIBYTE(word_455CB7) < 0xAu )
        {
          ++HIBYTE(word_455CB7);
          sub_407B70(HIBYTE(word_455CB7));
        }
        break;
      case 2u:
      case 3u:
        sub_404910(0, 16);
        sub_404910(0, 64);
        break;
      case 4u:
        if ( (_BYTE)dword_455CBC )
          BYTE1(dword_455CBC) = 1;
        break;
      default:
        break;
    }
    sub_404910(0, 32);
    sub_407E00((int)&unk_444764);
  }
  sub_404FD0();
  switch ( v0 )
  {
    case 0u:
    case 1u:
    case 4u:
      sub_404950(20, 450, 14);
      break;
    case 2u:
    case 3u:
    case 5u:
      sub_404950(20, 450, 7);
      break;
    default:
      break;
  }
  sub_404D30(0x48u);
  sub_401580(1);
  v3 = 0;
  do
  {
    if ( v3 == v0 )
    {
      byte_443AF0 = 0;
      byte_443AF2 = word_442380;
      byte_443AF1 = word_442380;
    }
    else
    {
      byte_443AF2 = -112;
      byte_443AF1 = 66;
      byte_443AF0 = 78;
    }
    switch ( v3 )
    {
      case 0u:
        sub_4015D0(0x28u, 66, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x49u);
        break;
      case 1u:
        sub_4015D0(0x28u, v13 + 66, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x4Au);
        break;
      case 2u:
        sub_4015D0(0x28u, 2 * v13 + 66, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0xE6u);
        break;
      case 3u:
        sub_4015D0(0x28u, 3 * v13 + 66, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0xE5u);
        break;
      case 4u:
        v8 = 41;
        v7 = HIWORD(dword_443AE4);
        v6 = (unsigned __int16)dword_443AE4;
        v4 = 4 * v13 + 66;
        goto LABEL_61;
      case 5u:
        v8 = 64;
        v7 = HIWORD(dword_443AE4);
        v6 = (unsigned __int16)dword_443AE4;
        v4 = 5 * v13 + 66;
LABEL_61:
        sub_4015D0(0x28u, v4, v6, v7, 1, v8);
        break;
      default:
        break;
    }
    sub_401D10();
    if ( v3 )
    {
      if ( v3 == 1 )
      {
        sub_401AB0(350, v13 + 66, 1, aDSD);
      }
      else
      {
        if ( v3 != 4 )
          goto LABEL_69;
        sub_401AB0(350, 4 * v13 + 66, 1, aS);
      }
    }
    else
    {
      sub_401AB0(350, 66, 1, aDSD);
    }
    sub_401D10();
LABEL_69:
    ++v3;
  }
  while ( v3 < 6 );
  sub_404DD0();
  sub_401D10();
  sub_402A90();
  if ( v14 & 0x1000 )
  {
    sub_407E00((int)&dword_444758);
    sub_404910(0, 4096);
    word_455CB7 = v9;
    byte_455CB5 = v10;
    byte_455CB6 = v11;
    unk_455CBA = v12;
    sub_407B60(v9);
    sub_407B70(HIBYTE(word_455CB7));
    return sub_405550(0);
  }
  if ( !(v14 & 0x4000) )
    goto LABEL_85;
  switch ( v0 )
  {
    case 2u:
      sub_407E00((int)&unk_444770);
      sub_404910(0, 0x4000);
      if ( dword_44473C )
        sub_434530();
      dword_444728 = dword_442684;
      dword_44472C = dword_442688;
      dword_444730 = dword_44268C;
      dword_444734 = dword_442690;
      result = sub_405550(7);
      break;
    case 3u:
      sub_407E00((int)&unk_444770);
      sub_404910(0, 0x4000);
      if ( dword_44473C )
        sub_434530();
      dword_4446DC = dword_442674;
      dword_4446E0 = dword_442678;
      dword_4446E4 = dword_44267C;
      dword_4446E8 = dword_442680;
      result = sub_405550(6);
      break;
    case 5u:
      sub_407E00((int)&unk_444770);
      sub_404910(0, 0x4000);
      if ( dword_44473C )
        sub_434530();
      sub_405750();
      return sub_405550(0);
    default:
LABEL_85:
      result = sub_404530();
      dword_44470C = v0;
      return result;
  }
  return result;
}
// 434B40: using guessed type int __cdecl nullsub_1(_DWORD);
// 442380: using guessed type __int16 word_442380;
// 442674: using guessed type int dword_442674;
// 442678: using guessed type int dword_442678;
// 44267C: using guessed type int dword_44267C;
// 442680: using guessed type int dword_442680;
// 442684: using guessed type int dword_442684;
// 442688: using guessed type int dword_442688;
// 44268C: using guessed type int dword_44268C;
// 442690: using guessed type int dword_442690;
// 443AE4: using guessed type int dword_443AE4;
// 443AF0: using guessed type char byte_443AF0;
// 443AF1: using guessed type char byte_443AF1;
// 443AF2: using guessed type char byte_443AF2;
// 443D38: using guessed type int dword_443D38;
// 4446D7: using guessed type char byte_4446D7;
// 4446DC: using guessed type int dword_4446DC;
// 4446E0: using guessed type int dword_4446E0;
// 4446E4: using guessed type int dword_4446E4;
// 4446E8: using guessed type int dword_4446E8;
// 44470C: using guessed type int dword_44470C;
// 444728: using guessed type int dword_444728;
// 44472C: using guessed type int dword_44472C;
// 444730: using guessed type int dword_444730;
// 444734: using guessed type int dword_444734;
// 44473C: using guessed type int dword_44473C;
// 455BEC: using guessed type int dword_455BEC;
// 455CB5: using guessed type char byte_455CB5;
// 455CB6: using guessed type char byte_455CB6;
// 455CB7: using guessed type __int16 word_455CB7;
// 455CBC: using guessed type int dword_455CBC;

//----- (00407560) --------------------------------------------------------
char sub_407560()
{
  unsigned int v0; // edi
  char v1; // bl
  int v2; // ecx
  unsigned int v3; // esi
  int v4; // edx
  char result; // al
  int v6; // [esp-10h] [ebp-28h]
  int v7; // [esp-Ch] [ebp-24h]
  unsigned int v8; // [esp-4h] [ebp-1Ch]
  int v9; // [esp+Ch] [ebp-Ch]
  int v10; // [esp+10h] [ebp-8h]
  char v11; // [esp+14h] [ebp-4h]

  sub_404530();
  sub_4015B0(&v11, &v9);
  v0 = dword_444704;
  sub_434560();
  v1 = dword_455BEC;
  v10 = dword_455BEC;
  if ( dword_455BEC & 0x10 )
  {
    if ( v0 )
      --v0;
    else
      v0 = 4;
    sub_404910(0, 16);
    sub_407E00((int)&unk_444764);
  }
  if ( v1 & 0x40 )
  {
    if ( v0 >= 4 )
      v0 = 0;
    else
      ++v0;
    sub_404910(0, 64);
    sub_407E00((int)&unk_444764);
  }
  if ( v1 & 0xA0 )
  {
    switch ( v0 )
    {
      case 0u:
        v2 = dword_455CAC ^ 1;
        goto LABEL_19;
      case 1u:
        v2 = dword_455CAC ^ 2;
        goto LABEL_19;
      case 2u:
        v2 = dword_455CAC ^ 4;
        goto LABEL_19;
      case 3u:
        v2 = dword_455CAC ^ 8;
        goto LABEL_19;
      case 4u:
        v2 = dword_455CAC ^ 0x10;
        goto LABEL_19;
      case 5u:
        v2 = dword_455CAC ^ 0x20;
LABEL_19:
        dword_455CAC = v2;
        break;
      default:
        break;
    }
    sub_404910(0, v1 & 0xA0);
    sub_407E00((int)&unk_444764);
  }
  sub_404D30(0x50u);
  sub_401580(1);
  v3 = 0;
  do
  {
    if ( v3 == v0 )
    {
      byte_443AF0 = 0;
      byte_443AF2 = word_442380;
      byte_443AF1 = word_442380;
    }
    else
    {
      byte_443AF2 = -112;
      byte_443AF1 = 66;
      byte_443AF0 = 78;
    }
    switch ( v3 )
    {
      case 0u:
        sub_4015D0(0x28u, 66, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x51u);
        break;
      case 1u:
        sub_4015D0(0x28u, v9 + 66, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x52u);
        break;
      case 2u:
        sub_4015D0(0x28u, 2 * v9 + 66, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x53u);
        break;
      case 3u:
        sub_4015D0(0x28u, 3 * v9 + 66, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x54u);
        break;
      case 4u:
        v8 = 86;
        v7 = HIWORD(dword_443AE4);
        v6 = (unsigned __int16)dword_443AE4;
        v4 = 4 * v9 + 66;
        goto LABEL_32;
      case 5u:
        v8 = 85;
        v7 = HIWORD(dword_443AE4);
        v6 = (unsigned __int16)dword_443AE4;
        v4 = 5 * v9 + 66;
LABEL_32:
        sub_4015D0(0x28u, v4, v6, v7, 1, v8);
        break;
      default:
        break;
    }
    sub_401D10();
    if ( (1 << v3) & dword_455CAC )
      sub_4015D0(0x136u, v9 * v3 + 66, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x10u);
    else
      sub_4015D0(0x136u, v9 * v3 + 66, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x11u);
    sub_401D10();
    ++v3;
  }
  while ( v3 < 5 );
  sub_404950(20, 450, 14);
  sub_404FD0();
  sub_404DD0();
  sub_401D10();
  sub_402A90();
  if ( v10 & 0x1000 )
  {
    if ( byte_455CAB )
    {
      if ( dword_455CAC & 2 )
        LOBYTE(dword_44B804) = 13;
    }
    sub_407E00((int)&dword_444758);
    sub_404910(0, 4096);
    result = sub_405550(0);
  }
  else
  {
    result = sub_404530();
    dword_444704 = v0;
  }
  return result;
}
// 442380: using guessed type __int16 word_442380;
// 443AE4: using guessed type int dword_443AE4;
// 443AF0: using guessed type char byte_443AF0;
// 443AF1: using guessed type char byte_443AF1;
// 443AF2: using guessed type char byte_443AF2;
// 444704: using guessed type int dword_444704;
// 44B804: using guessed type int dword_44B804;
// 455BEC: using guessed type int dword_455BEC;
// 455CAB: using guessed type char byte_455CAB;
// 455CAC: using guessed type int dword_455CAC;

//----- (004078A0) --------------------------------------------------------
signed __int64 sub_4078A0()
{
  int *v0; // esi
  int v1; // edi
  long double v2; // st7
  signed __int64 result; // rax

  v0 = dword_4449A4;
  v1 = 0;
  dword_4449D0 = AGLSCREEN::EnableSoundManager(dword_443D24, 0xAC44u, byte_443F60) == 0;
  do
  {
    v2 = __FYL2X__((double)(unsigned int)++v1, 0.30102999566398119802) * 10000.0 * 1.5;
    if ( v2 > 10000.0 )
      v2 = 10000.0;
    result = (signed __int64)v2;
    *v0 = (signed __int64)v2;
    ++v0;
  }
  while ( (signed int)v0 < (signed int)&dword_4449D0 );
  return result;
}
// 4449D0: using guessed type int dword_4449D0;

//----- (00407920) --------------------------------------------------------
int sub_407920()
{
  return AGLSCREEN::DisableSoundManager(dword_443D24);
}

//----- (00407930) --------------------------------------------------------
unsigned int __cdecl sub_407930(unsigned int a1, int a2, int a3)
{
  unsigned int v3; // ebx
  unsigned __int16 v4; // cx
  unsigned __int16 v5; // bp
  unsigned int v6; // edi
  unsigned __int16 v7; // cx
  unsigned int v8; // esi
  struct AGLSOUNDBUFFER *v9; // eax
  unsigned __int8 *v10; // eax
  unsigned int v11; // ebp
  unsigned int *v12; // ebx
  unsigned int v13; // ecx
  unsigned __int16 v14; // ax
  unsigned int v15; // edx
  unsigned int v16; // eax
  __int16 v17; // dx
  int v19; // [esp+10h] [ebp-4h]
  unsigned int v20; // [esp+18h] [ebp+4h]

  v3 = a1;
  LOBYTE(v4) = *(_WORD *)(a1 + 20) >> 8;
  HIBYTE(v4) = *(_WORD *)(a1 + 20);
  v5 = v4;
  v20 = sub_407A80(a1 + 28);
  v6 = v5
     * (((*(_DWORD *)(v3 + 22) & 0xFF00 | (*(_DWORD *)(v3 + 22) << 16)) << 8) | (((*(_DWORD *)(v3 + 22) >> 16) | *(_DWORD *)(v3 + 22) & 0xFF0000u) >> 8));
  LOBYTE(v7) = 0;
  HIBYTE(v7) = *(_WORD *)(v3 + 26);
  v8 = v6 * (v7 | ((unsigned int)*(unsigned __int16 *)(v3 + 26) >> 8)) >> 3;
  if ( *(_DWORD *)a3 )
  {
    (***(void (****)(void))a3)();
    *(_DWORD *)a3 = 0;
  }
  v9 = AGLSCREEN::CreateSoundBuffer(dword_443D24, v5, v20, v8);
  *(_DWORD *)a3 = v9;
  if ( v9 )
  {
    v10 = (unsigned __int8 *)(v3 + 54);
    v11 = v6 >> 1;
    v19 = v3 + 54;
    v12 = (unsigned int *)(v3 + 54);
    if ( v6 >> 1 )
    {
      do
      {
        v13 = *v12;
        ++v12;
        v14 = v13;
        v13 &= 0xFFFF0000;
        v15 = (v14 << 8) | ((unsigned int)v14 >> 8);
        v16 = v13;
        LOBYTE(v16) = 0;
        --v11;
        *(v12 - 1) = v15 | (v16 << 8) | (v13 >> 8) & 0xFF0000;
      }
      while ( v11 );
      v11 = v6 >> 1;
      v10 = (unsigned __int8 *)v19;
    }
    if ( v11 != 2 * v6 )
    {
      LOBYTE(v17) = *(_WORD *)v12 >> 8;
      HIBYTE(v17) = *(_WORD *)v12;
      *(_WORD *)v12 = v17;
    }
    AGLSOUNDBUFFER::SetData(*(AGLSOUNDBUFFER **)a3, v10, v8);
    AGLSOUNDBUFFER::SetPan(*(AGLSOUNDBUFFER **)a3, 0);
    AGLSOUNDBUFFER::SetVolume(*(AGLSOUNDBUFFER **)a3, 10000);
    *(_DWORD *)(a3 + 4) = 0x3FFF;
    *(_DWORD *)(a3 + 8) = 0;
  }
  return v8;
}

//----- (00407A80) --------------------------------------------------------
unsigned int __cdecl sub_407A80(int a1)
{
  char v1; // dl
  unsigned int result; // eax
  int v3; // ecx

  v1 = 0;
  result = (*(unsigned __int8 *)(a1 + 2) << 24) | ((unsigned int)*(unsigned __int8 *)(a1 + 2) >> 24);
  if ( 30 != *(_BYTE *)(a1 + 1) )
  {
    v3 = (unsigned __int8)(30 - *(_BYTE *)(a1 + 1) - 1) + 1;
    do
    {
      v1 = result;
      result >>= 1;
      --v3;
    }
    while ( v3 );
  }
  if ( v1 & 1 )
    ++result;
  return result;
}

//----- (00407AE0) --------------------------------------------------------
int __cdecl sub_407AE0(int a1, int a2, int a3)
{
  AGLFILE *v3; // eax
  AGLFILE *v4; // esi
  unsigned int v5; // edi
  int *v6; // ebx
  int v7; // esi
  int v8; // edi
  int v9; // ebp
  unsigned int v10; // esi
  unsigned int v11; // eax

  v3 = sub_403630(a1, 2);
  v4 = v3;
  if ( !v3 )
    return a2;
  v5 = sub_403700(v3);
  v6 = (int *)sub_401250(v5);
  sub_4036A0(v4, v6, v5);
  sub_403690(v4);
  v7 = (int)(v6 + 1);
  if ( *v6 )
  {
    v8 = a3;
    v9 = *v6;
    do
    {
      v10 = v7 + 4;
      v11 = sub_407930(v10, (int)&a2, v8);
      v8 += 12;
      --v9;
      v7 = v10 + v11 + 54;
    }
    while ( v9 );
  }
  sub_401380((unsigned int)v6);
  return a2;
}

//----- (00407B60) --------------------------------------------------------
char __cdecl sub_407B60(char a1)
{
  char result; // al

  result = a1;
  byte_455CB7 = a1;
  return result;
}
// 455CB7: using guessed type char byte_455CB7;

//----- (00407B70) --------------------------------------------------------
__int16 __cdecl sub_407B70(__int16 a1)
{
  __int16 result; // ax

  result = a1;
  LOBYTE(dword_455CB8) = a1;
  if ( dword_443D24 )
    result = AGLSCREEN::SetCDAudioVolume(dword_443D24, 0xFFFF * a1 / 10);
  return result;
}
// 455CB8: using guessed type int dword_455CB8;

//----- (00407BB0) --------------------------------------------------------
char __cdecl sub_407BB0(int a1)
{
  char result; // al

  result = byte_444748;
  if ( !byte_444748 )
  {
    AGLSCREEN::PlayCDAudioTrack(dword_443D24, dword_4423A0[11 * a1]);
    sub_407B70(HIBYTE(word_455CB7));
    result = 1;
    byte_444748 = 1;
    byte_444756 = 1;
    unk_455CBB = 0;
    byte_444755 = 0;
  }
  return result;
}
// 4423A0: using guessed type int dword_4423A0[];
// 444748: using guessed type char byte_444748;
// 444755: using guessed type char byte_444755;
// 444756: using guessed type char byte_444756;
// 455CB7: using guessed type __int16 word_455CB7;

//----- (00407C10) --------------------------------------------------------
char sub_407C10()
{
  char result; // al

  result = byte_444748;
  if ( byte_444748 )
    result = AGLSCREEN::StopCDAudio(dword_443D24);
  byte_444748 = 0;
  return result;
}
// 444748: using guessed type char byte_444748;

//----- (00407C30) --------------------------------------------------------
char sub_407C30()
{
  char result; // al

  result = byte_444748;
  if ( byte_444748 )
    result = AGLSCREEN::PauseCDAudio(dword_443D24);
  byte_444748 = 0;
  return result;
}
// 444748: using guessed type char byte_444748;

//----- (00407C50) --------------------------------------------------------
int __cdecl sub_407C50(int a1, int a2, int a3)
{
  int result; // eax
  AGLSOUNDBUFFER *v4; // ecx

  result = a2;
  v4 = *(AGLSOUNDBUFFER **)a1;
  *(_DWORD *)(a1 + 4) = a2;
  *(_DWORD *)(a1 + 8) = a3;
  if ( v4 )
  {
    AGLSOUNDBUFFER::SetVolume(v4, dword_4449A4[a2 * (unsigned int)(unsigned __int8)byte_455CB7 / 0x3FFF]);
    result = AGLSOUNDBUFFER::SetPan(*(AGLSOUNDBUFFER **)a1, a3);
  }
  return result;
}
// 455CB7: using guessed type char byte_455CB7;

//----- (00407CB0) --------------------------------------------------------
char __cdecl sub_407CB0(int a1, int a2, float a3)
{
  double v4; // st7
  double v5; // st6
  float v6; // ST0C_4
  double v7; // st7
  double v8; // st7
  int v9; // esi
  float v10; // ST10_4
  double v11; // st7
  float v12; // ST18_4
  float v13; // ST08_4
  double v14; // st7
  float v15; // ST10_4
  double v16; // st7
  signed __int64 v17; // rax
  float v18; // [esp+14h] [ebp-Ch]
  float v19; // [esp+1Ch] [ebp-4h]
  int v20; // [esp+28h] [ebp+8h]

  if ( a3 == 0.0 )
    return 0;
  v18 = *(float *)a2 - *(float *)&dword_448A08;
  v4 = *(float *)(a2 + 4) - *(float *)&dword_448A0C;
  v5 = *(float *)(a2 + 8) - *(float *)&dword_448A10;
  v19 = v5;
  v6 = v5 * v19 + v4 * v4 + v18 * v18;
  v7 = AGLSqrt(v6);
  *(float *)&v20 = v7;
  if ( v7 > a3 )
    return 0;
  v8 = 100.0 - *(float *)&v20 * 100.0 / a3;
  if ( v8 == 0.0 )
    return 0;
  v9 = (signed __int64)(v8 * 16383.0 * 0.0099999998);
  v10 = -(*(float *)&dword_448A04 - *(float *)&dword_448A10);
  v11 = *(float *)&dword_4489FC - *(float *)&dword_448A08;
  v12 = v11;
  v13 = v11 * v12 + v10 * v10;
  v14 = 1.0 / AGLSqrt(v13);
  v15 = v14 * v10;
  v16 = (v14 * v12 * v19 + v15 * v18) / *(float *)&v20;
  if ( v16 == 0.0 )
    LODWORD(v17) = 0;
  else
    v17 = (signed __int64)(v16 * 10000.0);
  sub_407C50(a1, v9, v17);
  return 1;
}
// 4489FC: using guessed type int dword_4489FC;
// 448A04: using guessed type int dword_448A04;
// 448A08: using guessed type int dword_448A08;
// 448A0C: using guessed type int dword_448A0C;
// 448A10: using guessed type int dword_448A10;

//----- (00407E00) --------------------------------------------------------
int __cdecl sub_407E00(int a1)
{
  int result; // eax

  if ( *(_DWORD *)a1 )
  {
    sub_407C50(a1, *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
    result = AGLSOUNDBUFFER::Play(*(AGLSOUNDBUFFER **)a1, 1u);
  }
  return result;
}

//----- (00407E30) --------------------------------------------------------
unsigned __int8 __cdecl sub_407E30(AGLSOUNDBUFFER **a1)
{
  unsigned __int8 result; // al

  if ( *a1 )
    result = AGLSOUNDBUFFER::IsPlaying(*a1);
  else
    result = 0;
  return result;
}

//----- (00407E50) --------------------------------------------------------
int __cdecl sub_407E50(AGLSOUNDBUFFER **a1)
{
  int result; // eax

  result = (int)a1;
  if ( *a1 )
    result = AGLSOUNDBUFFER::Stop(*a1);
  return result;
}

//----- (00407E60) --------------------------------------------------------
int sub_407E60()
{
  AGLSOUNDBUFFER **v0; // esi
  int result; // eax

  v0 = (AGLSOUNDBUFFER **)&dword_444758;
  do
  {
    result = sub_407E50(v0);
    v0 += 3;
  }
  while ( (signed int)v0 < (signed int)dword_4449A4 );
  return result;
}

//----- (00407E80) --------------------------------------------------------
char __cdecl sub_407E80(char a1)
{
  char result; // al
  char v2; // bl
  unsigned __int8 v3; // cl

  result = dword_455BF8;
  switch ( dword_455BF8 )
  {
    case 0:
    case 2:
    case 3:
    case 5:
    case 7:
    case 10:
      v2 = a1;
      result = unk_455CBB;
      if ( a1 != unk_455CBB )
      {
        if ( !unk_455CBB )
        {
          if ( !sub_407E30((AGLSOUNDBUFFER **)&unk_444830) )
            sub_407E00((int)&unk_444830);
          v3 = LOBYTE(dword_4423A0[11 * dword_455BF8]) + 1;
          goto LABEL_12;
        }
        if ( !sub_407E30((AGLSOUNDBUFFER **)&unk_444824) )
          sub_407E00((int)&unk_444824);
        result = sub_431C40();
        if ( !result )
        {
          v3 = dword_4423A0[11 * dword_455BF8];
          goto LABEL_12;
        }
      }
      break;
    case 11:
    case 12:
    case 13:
      v2 = a1;
      v3 = a1 + LOBYTE(dword_4423A0[11 * dword_455BF8]);
LABEL_12:
      result = AGLSCREEN::PlayCDAudioTrack(dword_443D24, v3);
      byte_444755 = 1;
      unk_455CBB = v2;
      break;
    default:
      return result;
  }
  return result;
}
// 4423A0: using guessed type int dword_4423A0[];
// 444755: using guessed type char byte_444755;
// 455BF8: using guessed type int dword_455BF8;

//----- (00407F70) --------------------------------------------------------
char *sub_407F70()
{
  char *result; // eax
  long double v1; // st7
  unsigned int v2; // ecx

  result = (char *)dword_4449D8;
  if ( !dword_4449D8 )
  {
    result = (char *)malloc(0x5000u);
    v1 = 0.0;
    dword_4449D4 = (std::codecvt_base *)(result + 4096);
    dword_4449D8 = result;
    v2 = 0;
    while ( 1 )
    {
      v2 += 4;
      *(float *)&result[v2 - 4] = sin(v1);
      v1 = v1 + 0.0015339808;
      if ( v2 >= 0x5000 )
        break;
      result = (char *)dword_4449D8;
    }
  }
  return result;
}

//----- (00407FD0) --------------------------------------------------------
int sub_407FD0()
{
  int result; // eax

  free(dword_4449D8);
  result = 0;
  dword_4449D4 = 0;
  dword_4449D8 = 0;
  return result;
}

//----- (00407FF0) --------------------------------------------------------
int __cdecl sub_407FF0(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  a2[9] = *a1;
  a2[10] = a1[1];
  result = a1[2];
  a2[11] = result;
  return result;
}

//----- (00408010) --------------------------------------------------------
int __cdecl sub_408010(__int16 a1, int a2)
{
  int v2; // eax
  double v3; // st7
  double v4; // st6
  int result; // eax

  v2 = 4 * (a1 & 0xFFF);
  v3 = *(float *)((char *)dword_4449D4 + v2);
  v4 = *(float *)((char *)dword_4449D8 + v2);
  result = a2;
  *(float *)(a2 + 16) = v3;
  *(_DWORD *)a2 = 1065353216;
  *(_DWORD *)(a2 + 4) = 0;
  *(float *)(a2 + 20) = -v4;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(float *)(a2 + 28) = v4;
  *(_DWORD *)(a2 + 24) = 0;
  *(float *)(a2 + 32) = v3;
  return result;
}

//----- (00408060) --------------------------------------------------------
int __cdecl sub_408060(__int16 a1, int a2)
{
  int v2; // eax
  double v3; // st7
  double v4; // st6
  int result; // eax

  v2 = 4 * (a1 & 0xFFF);
  v3 = *(float *)((char *)dword_4449D4 + v2);
  v4 = *(float *)((char *)dword_4449D8 + v2);
  result = a2;
  *(float *)a2 = v3;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(float *)(a2 + 8) = v4;
  *(float *)(a2 + 24) = -v4;
  *(_DWORD *)(a2 + 16) = 1065353216;
  *(_DWORD *)(a2 + 20) = 0;
  *(float *)(a2 + 32) = v3;
  *(_DWORD *)(a2 + 28) = 0;
  return result;
}

//----- (004080B0) --------------------------------------------------------
int __cdecl sub_4080B0(__int16 a1, int a2)
{
  int v2; // eax
  double v3; // st7
  double v4; // st6
  int result; // eax

  v2 = 4 * (a1 & 0xFFF);
  v3 = *(float *)((char *)dword_4449D4 + v2);
  v4 = *(float *)((char *)dword_4449D8 + v2);
  result = a2;
  *(float *)a2 = v3;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 20) = 0;
  *(float *)(a2 + 4) = -v4;
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = 0;
  *(float *)(a2 + 12) = v4;
  *(_DWORD *)(a2 + 32) = 1065353216;
  *(float *)(a2 + 16) = v3;
  return result;
}

//----- (00408100) --------------------------------------------------------
float *__cdecl sub_408100(float *a1, float *a2, float *a3)
{
  float *result; // eax
  float *v4; // ecx

  result = a1;
  v4 = a2;
  *a3 = *a1 * *a2 + a1[1] * a2[3] + a2[6] * a1[2];
  a3[1] = result[1] * v4[4] + v4[7] * result[2] + v4[1] * *result;
  a3[2] = result[1] * v4[5] + v4[8] * result[2] + v4[2] * *result;
  a3[3] = result[4] * v4[3] + result[3] * *v4 + result[5] * v4[6];
  a3[4] = result[5] * v4[7] + result[4] * v4[4] + result[3] * v4[1];
  a3[5] = result[5] * v4[8] + result[4] * v4[5] + result[3] * v4[2];
  a3[6] = result[6] * *v4 + v4[6] * result[8] + result[7] * v4[3];
  a3[7] = v4[7] * result[8] + v4[4] * result[7] + v4[1] * result[6];
  a3[8] = v4[8] * result[8] + v4[5] * result[7] + a2[2] * a1[6];
  return result;
}

//----- (004081F0) --------------------------------------------------------
float *__cdecl sub_4081F0(float *a1, float *a2, float *a3)
{
  float *result; // eax
  float *v4; // ecx

  result = a1;
  v4 = a2;
  *a3 = *a1 * *a2 + a1[1] * a2[3] + a2[6] * a1[2];
  a3[1] = result[1] * v4[4] + v4[7] * result[2] + v4[1] * *result;
  a3[2] = result[1] * v4[5] + v4[8] * result[2] + v4[2] * *result;
  a3[9] = result[1] * v4[10] + v4[11] * result[2] + v4[9] * *result + result[9];
  a3[3] = result[4] * v4[3] + result[3] * *v4 + result[5] * v4[6];
  a3[4] = result[5] * v4[7] + result[4] * v4[4] + result[3] * v4[1];
  a3[5] = result[5] * v4[8] + result[4] * v4[5] + result[3] * v4[2];
  a3[10] = v4[11] * result[5] + v4[10] * result[4] + v4[9] * result[3] + result[10];
  a3[6] = result[7] * v4[3] + result[8] * v4[6] + *v4 * result[6];
  a3[7] = result[8] * v4[7] + result[7] * v4[4] + v4[1] * result[6];
  a3[8] = result[8] * v4[8] + result[7] * v4[5] + v4[2] * result[6];
  a3[11] = result[8] * v4[11] + result[7] * v4[10] + a2[9] * a1[6] + result[11];
  return result;
}

//----- (00408330) --------------------------------------------------------
double __cdecl sub_408330(float *a1, float *a2)
{
  float v2; // ST00_4
  double result; // st7
  double v4; // st6
  float v5; // [esp+4h] [ebp-8h]
  float v6; // [esp+8h] [ebp-4h]
  float v7; // [esp+10h] [ebp+4h]

  v5 = a1[1];
  v6 = a1[2];
  v7 = *a1;
  v2 = v6 * v6 + v5 * v5 + v7 * v7;
  result = AGLSqrt(v2);
  if ( result == 0.0 )
  {
    v4 = v6;
  }
  else
  {
    v7 = 1.0 / result * v7;
    v5 = 1.0 / result * v5;
    v4 = 1.0 / result * v6;
  }
  *a2 = v7;
  a2[1] = v5;
  a2[2] = v4;
  return result;
}

//----- (004083C0) --------------------------------------------------------
void __cdecl sub_4083C0(float *a1)
{
  float v1; // ST00_4

  v1 = a1[2] * a1[2] + a1[1] * a1[1] + *a1 * *a1;
  AGLSqrt(v1);
}

//----- (004083F0) --------------------------------------------------------
void __cdecl sub_4083F0(int *a1)
{
  int v1; // ecx
  unsigned __int16 v2; // ax
  unsigned __int16 v3; // dx
  int v4; // eax
  int v5; // edi
  int v6; // eax
  _DWORD *v7; // esi
  int v8; // ebp
  int v9; // ecx
  float *v10; // eax
  int v11; // ecx
  int v12; // eax
  int v13; // eax
  float v14; // eax

  v1 = a1[46];
  if ( v1 )
  {
    v2 = *((_WORD *)a1 + 88);
    v3 = ++*((_WORD *)a1 + 87);
    if ( v2 )
    {
      if ( v3 >= v2 )
      {
        *((_WORD *)a1 + 87) = 0;
        *((_WORD *)a1 + 88) = 0;
      }
    }
    else if ( v3 >= *(_WORD *)v1 )
    {
      v4 = *a1;
      *((_WORD *)a1 + 87) = 0;
      LOBYTE(v4) = v4 | 2;
      *a1 = v4;
    }
    v5 = *(_DWORD *)(v1 + 4);
    v6 = *(unsigned __int16 *)(v1 + 2);
    if ( (unsigned __int16)v6 > 0u )
    {
      v7 = (_DWORD *)(a1[45] + 216);
      v8 = *(unsigned __int16 *)(v1 + 2);
      do
      {
        v9 = *(_DWORD *)(v5 + 8);
        if ( v9 )
        {
          v10 = (float *)(v9 + 36 * *((unsigned __int16 *)v7 - 30));
          if ( *((unsigned __int16 *)a1 + 87) == *(_DWORD *)(v9 + 36 * *((unsigned __int16 *)v7 - 30)) )
          {
            v11 = (int)(v10 + 2);
            *(v7 - 2) = *((_DWORD *)v10 + 2);
            *(v7 - 1) = *((_DWORD *)v10 + 3);
            *v7 = *((_DWORD *)v10 + 4);
            v7[1] = *((_DWORD *)v10 + 5);
            v7[2] = *((_DWORD *)v10 + 6);
            v7[3] = *((_DWORD *)v10 + 7);
            v12 = *((_DWORD *)v10 + 8);
            ++*((_WORD *)v7 - 30);
            v7[4] = v12;
            if ( *((_WORD *)v7 - 30) >= *(_WORD *)(v5 + 4) )
              *((_WORD *)v7 - 30) = 0;
            v13 = *(_DWORD *)(v5 + 8) + 36 * *((unsigned __int16 *)v7 - 30);
            sub_408530(v11, v13 + 8, *(float *)(v13 + 4), (int)(v7 - 14));
          }
          else
          {
            if ( *((_WORD *)a1 + 88) )
              v14 = *(float *)v5;
            else
              v14 = v10[1];
            sub_408600(v14, (int)(v7 - 2), (int)(v7 - 14));
          }
        }
        v7 += 59;
        v5 += 12;
        --v8;
      }
      while ( v8 );
    }
  }
}

//----- (00408530) --------------------------------------------------------
int __cdecl sub_408530(int a1, int a2, float a3, int a4)
{
  float *v4; // ecx
  _DWORD *v5; // eax
  _DWORD *v6; // ebx
  __int16 v7; // fps
  double v8; // st7
  bool v9; // c0
  char v10; // c2
  bool v11; // c3
  int result; // eax
  double v13; // st7
  double v14; // st6
  float v15; // [esp+20h] [ebp+10h]

  v4 = (float *)a4;
  *(_DWORD *)a4 = 0;
  v5 = (_DWORD *)(a4 + 4);
  *v5 = *(_DWORD *)a1;
  v5[1] = *(_DWORD *)(a1 + 4);
  v5[2] = *(_DWORD *)(a1 + 8);
  v5[3] = *(_DWORD *)(a1 + 12);
  v6 = (_DWORD *)(a4 + 20);
  *v6 = *(_DWORD *)a2;
  v6[1] = *(_DWORD *)(a2 + 4);
  v6[2] = *(_DWORD *)(a2 + 8);
  result = *(_DWORD *)(a2 + 12);
  v6[3] = result;
  v8 = *(float *)(a1 + 4) * *(float *)(a2 + 4)
     + *(float *)a1 * *(float *)a2
     + *(float *)(a1 + 8) * *(float *)(a2 + 8)
     + *(float *)(a1 + 12) * *(float *)(a2 + 12);
  v9 = v8 < 0.0;
  v10 = 0;
  v11 = v8 == 0.0;
  LOWORD(result) = v7;
  if ( v8 < 0.0 )
  {
    *(float *)(a4 + 20) = -*(float *)(a4 + 20);
    *(float *)(a4 + 24) = -*(float *)(a4 + 24);
    *(float *)(a4 + 28) = -*(float *)(a4 + 28);
    *(float *)(a4 + 32) = -*(float *)(a4 + 32);
  }
  v13 = (*(float *)(a2 + 20) - *(float *)(a1 + 20)) * a3;
  v15 = (*(float *)(a2 + 24) - *(float *)(a1 + 24)) * a3;
  v14 = *(float *)(a2 + 16) - *(float *)(a1 + 16);
  v4[11] = v15;
  v4[9] = v14 * a3;
  v4[10] = v13;
  return result;
}

//----- (00408600) --------------------------------------------------------
float *__cdecl sub_408600(float a1, int a2, int a3)
{
  float *result; // eax
  int v4; // ecx
  double v5; // st7

  result = (float *)a3;
  v4 = a2;
  v5 = a1 + *(float *)a3;
  *(float *)a3 = v5;
  *(float *)a2 = (1.0 - v5) * result[1] + v5 * result[5];
  *(float *)(a2 + 4) = (1.0 - v5) * result[2] + v5 * result[6];
  *(float *)(a2 + 8) = (1.0 - v5) * *(float *)(a3 + 12) + v5 * *(float *)(a3 + 28);
  *(float *)(a2 + 12) = (1.0 - v5) * *(float *)(a3 + 16) + v5 * *(float *)(a3 + 32);
  *(float *)(v4 + 16) = *(float *)(a3 + 36) + *(float *)(v4 + 16);
  *(float *)(v4 + 20) = *(float *)(a3 + 40) + *(float *)(v4 + 20);
  *(float *)(a2 + 24) = *(float *)(a3 + 44) + *(float *)(a2 + 24);
  return result;
}

//----- (00408670) --------------------------------------------------------
char __cdecl sub_408670(float a1, int a2, int a3)
{
  float v3; // edi
  int v5; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // esi
  unsigned int v9; // eax
  int v10; // ebx
  _DWORD *v11; // esi
  unsigned int v12; // ebp
  int v13; // eax
  int v14; // eax
  _DWORD *v15; // esi
  unsigned int v16; // ebx
  int v17; // eax
  float v18; // [esp+18h] [ebp+4h]

  v3 = a1;
  if ( a1 == 0.0 )
    return 0;
  v5 = dword_448AC4 + 48 * *(unsigned __int16 *)(LODWORD(a1) + 178);
  if ( a2 >= (unsigned int)*(unsigned __int16 *)(v5 + 26) )
    return 0;
  v6 = *(_DWORD *)(LODWORD(a1) + 184);
  v7 = *(_DWORD *)(v5 + 36) + 8 * a2;
  if ( v7 == v6 || !*(_WORD *)v7 )
    return 1;
  v8 = *(_DWORD *)(LODWORD(a1) + 180);
  v9 = *(unsigned __int16 *)(LODWORD(a1) + 172);
  if ( !v6 || !a3 )
  {
    *(_DWORD *)(LODWORD(a1) + 184) = v7;
    *(_WORD *)(LODWORD(a1) + 174) = *(_WORD *)v7 - 1;
    *(_WORD *)(LODWORD(a1) + 176) = 0;
    if ( v9 > 0 )
    {
      v15 = (_DWORD *)(v8 + 160);
      v16 = v9;
      do
      {
        *((_WORD *)v15 - 2) = 0;
        sub_408800(v15);
        sub_408830(v15 + 12);
        v15 += 59;
        --v16;
      }
      while ( v16 );
    }
    sub_4083F0((int *)LODWORD(a1));
    goto LABEL_20;
  }
  *(_DWORD *)(LODWORD(a1) + 184) = v7;
  *(_WORD *)(LODWORD(a1) + 174) = 0;
  *(_WORD *)(LODWORD(a1) + 176) = a3;
  v10 = *(_DWORD *)(v7 + 4);
  v18 = 1.0 / (double)(unsigned int)a3;
  if ( v9 <= 0 )
  {
LABEL_20:
    v17 = *(_DWORD *)LODWORD(v3);
    LOBYTE(v17) = *(_DWORD *)LODWORD(v3) & 0xFD;
    *(_DWORD *)LODWORD(v3) = v17;
    return 1;
  }
  v11 = (_DWORD *)(v8 + 208);
  v12 = v9;
  do
  {
    v13 = *(_DWORD *)(v10 + 8);
    if ( v13 )
    {
      sub_408530((int)v11, v13 + 8, v18, (int)(v11 - 12));
    }
    else
    {
      sub_408800(v11 - 12);
      sub_408830(v11);
    }
    v11 += 59;
    *(float *)v10 = v18;
    *((_WORD *)v11 - 144) = 0;
    v10 += 12;
    --v12;
  }
  while ( v12 );
  v14 = *(_DWORD *)LODWORD(v3);
  LOBYTE(v14) = *(_DWORD *)LODWORD(v3) & 0xFD;
  *(_DWORD *)LODWORD(v3) = v14;
  return 1;
}
// 448AC4: using guessed type int dword_448AC4;

//----- (00408800) --------------------------------------------------------
_DWORD *__cdecl sub_408800(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = 0;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 1065353216;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 1065353216;
  a1[9] = 0;
  a1[10] = 0;
  a1[11] = 0;
  return result;
}

//----- (00408830) --------------------------------------------------------
_DWORD *__cdecl sub_408830(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 1065353216;
  a1[4] = 0;
  a1[5] = 0;
  a1[6] = 0;
  return result;
}

//----- (00408850) --------------------------------------------------------
__int16 __cdecl sub_408850(int a1, unsigned __int16 a2)
{
  int v2; // eax
  __int16 result; // ax

  v2 = dword_448AC4 + 48 * *(unsigned __int16 *)(a1 + 178);
  if ( a2 < *(_WORD *)(v2 + 26) )
    result = *(_WORD *)(*(_DWORD *)(v2 + 36) + 8 * a2);
  else
    result = 0;
  return result;
}
// 448AC4: using guessed type int dword_448AC4;

//----- (00408890) --------------------------------------------------------
int __cdecl sub_408890(int a1, int a2)
{
  int v2; // esi

  v2 = a1;
  sub_408E20(*(float **)a1, *(_DWORD *)(a1 + 4), 0);
  sub_4099B0(*(_DWORD *)(v2 + 12), *(unsigned __int16 *)(v2 + 8), a2, 0);
  return sub_4096F0(*(_DWORD *)(v2 + 16), *(unsigned __int16 *)(v2 + 10), a2, 0);
}

//----- (004088E0) --------------------------------------------------------
char __cdecl sub_4088E0(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3)
{
  sub_408DC0(&dword_448AD4, a1);
  sub_409070((int)&unk_448ADC, a2, 136, a3, 96);
  return 1;
}
// 448AD4: using guessed type int dword_448AD4;

//----- (00408930) --------------------------------------------------------
int __cdecl sub_408930(int a1)
{
  int result; // eax

  result = a1;
  dword_4449DC = a1;
  return result;
}
// 4449DC: using guessed type int dword_4449DC;

//----- (00408940) --------------------------------------------------------
int __cdecl sub_408940(int a1, int a2)
{
  unsigned __int16 *v2; // esi
  int v3; // ebx

  if ( *(_WORD *)(a1 + 172) )
  {
    v2 = (unsigned __int16 *)(*(_DWORD *)(a1 + 180) + 152);
    v3 = *(unsigned __int16 *)(a1 + 172);
    do
    {
      sub_40AB10(v2 - 24);
      sub_408E20((float *)(*(_DWORD *)(a1 + 152) + 12 * *v2), v2[1], *v2);
      v2 += 118;
      --v3;
    }
    while ( v3 );
  }
  sub_4091C0(*(_DWORD *)(a1 + 164), *(unsigned __int16 *)(a1 + 160), a2, dword_4449DC);
  return sub_409400(*(_DWORD *)(a1 + 168), *(unsigned __int16 *)(a1 + 162), a2, dword_4449DC);
}
// 4449DC: using guessed type int dword_4449DC;

//----- (004089F0) --------------------------------------------------------
_BYTE *__cdecl sub_4089F0(int a1)
{
  _BYTE *result; // eax
  unsigned int v2; // ecx
  int v3; // edx

  if ( !a1 )
    return 0;
  result = *(_BYTE **)(a1 + 44);
  v2 = *(unsigned __int16 *)(a1 + 30);
  v3 = 0;
  if ( !(_WORD)v2 )
    return 0;
  while ( *result & 1 )
  {
    result += 188;
    if ( ++v3 >= v2 )
      return 0;
  }
  *(_DWORD *)result |= 1u;
  return result;
}

//----- (00408A30) --------------------------------------------------------
unsigned int *__cdecl sub_408A30(unsigned int *a1)
{
  unsigned int *result; // eax
  unsigned int v2; // ecx

  result = a1;
  if ( a1 )
  {
    v2 = *a1;
    a1[46] = 0;
    *a1 = v2 & 0xFFFFFFFE;
  }
  return result;
}

//----- (00408A50) --------------------------------------------------------
int __cdecl sub_408A50(int a1)
{
  int v1; // esi
  int result; // eax
  int v3; // eax
  int v4; // ebx
  unsigned int v5; // ebp
  unsigned int v6; // edi
  float *v7; // esi
  int v8; // [esp+4h] [ebp-4h]

  v1 = a1;
  result = *(_DWORD *)(a1 + 164);
  if ( result )
  {
    v3 = *(_DWORD *)(a1 + 4);
    if ( v3 )
      sub_4081F0((float *)(v3 + 56), (float *)(a1 + 8), (float *)(a1 + 56));
    v4 = *(_DWORD *)(a1 + 180);
    v5 = *(unsigned __int16 *)(a1 + 172);
    v6 = 0;
    v8 = *(_DWORD *)(a1 + 184);
    if ( (_WORD)v5 )
    {
      v7 = (float *)(v4 + 48);
      do
      {
        if ( v8 )
        {
          if ( v6 )
          {
            sub_408B40(v7 + 40, (int)(v7 - 10));
            *(v7 - 1) = v7[44];
            *v7 = v7[45];
            v7[1] = v7[46];
          }
        }
        sub_4081F0((float *)(*((_DWORD *)v7 - 11) + 56), v7 - 10, v7 + 2);
        sub_40A9D0(v4, (int)&dword_4489FC);
        v4 += 236;
        v7 += 59;
        ++v6;
      }
      while ( v6 < v5 );
      v1 = a1;
    }
    result = sub_408940(v1, dword_4489E0[dword_4489F8]);
  }
  return result;
}
// 4489E0: using guessed type int dword_4489E0[];
// 4489F8: using guessed type int dword_4489F8;
// 4489FC: using guessed type int dword_4489FC;

//----- (00408B40) --------------------------------------------------------
int __cdecl sub_408B40(float *a1, int a2)
{
  double v2; // st7
  float v3; // ST00_4
  float v4; // ST0C_4
  float v5; // ST08_4
  int result; // eax
  float v7; // ST10_4
  float v8; // ST04_4
  float v9; // ST1C_4
  float v10; // ST14_4
  double v11; // st7
  float v12; // ST18_4
  float v13; // ST00_4
  double v14; // st6
  float v15; // ST0C_4
  float v16; // ST10_4
  double v17; // st5
  float v18; // [esp+24h] [ebp+4h]

  v2 = *a1;
  v3 = -a1[1];
  v4 = a1[2];
  v5 = a1[3];
  result = a2;
  v7 = v2 + v2;
  v8 = v3 + v3;
  v18 = v4 + v4;
  v9 = v7 * v2;
  v10 = v8 * v2;
  v11 = v2 * v18;
  v12 = v8 * v3;
  v13 = v18 * v3;
  v14 = v18 * v4;
  v15 = v7 * v5;
  v16 = v8 * v5;
  v17 = v18 * v5;
  *(float *)a2 = 1.0 - (v14 + v12);
  *(float *)(a2 + 12) = v10 - v17;
  *(float *)(a2 + 24) = v16 + v11;
  *(float *)(a2 + 4) = v17 + v10;
  *(float *)(a2 + 16) = 1.0 - (v14 + v9);
  *(_DWORD *)(a2 + 36) = 0;
  *(_DWORD *)(a2 + 40) = 0;
  *(float *)(a2 + 28) = v13 - v15;
  *(_DWORD *)(a2 + 44) = 0;
  *(float *)(a2 + 8) = v11 - v16;
  *(float *)(a2 + 20) = v15 + v13;
  *(float *)(a2 + 32) = 1.0 - (v12 + v9);
  return result;
}

//----- (00408C50) --------------------------------------------------------
int __cdecl sub_408C50(unsigned int *a1)
{
  int result; // eax

  if ( dword_443D24 )
    result = AGLSCREEN::SetViewport(dword_443D24, *a1, a1[1], a1[2], a1[3]);
  return result;
}

//----- (00408C80) --------------------------------------------------------
char __cdecl sub_408C80(int a1)
{
  int v2; // eax
  int v3; // [esp+0h] [ebp-10h]
  int v4; // [esp+4h] [ebp-Ch]
  int v5; // [esp+8h] [ebp-8h]
  int v6; // [esp+Ch] [ebp-4h]

  if ( dword_4489E0[0] )
    return 0;
  memset(dword_4489E0, 0, 0x108u);
  dword_4489F0 = a1;
  dword_4489F8 = 0;
  dword_4489F4 = 1 << a1;
  v2 = sub_401250(8 * (1 << a1) + 8);
  dword_4489E0[0] = v2;
  dword_4489E4 = v2;
  dword_4489E8[0] = v2 + 8 * dword_4489F4;
  dword_4489EC = v2 + 8 * dword_4489F4;
  sub_4029B0(v2, dword_4489F4);
  v3 = 0;
  v4 = 0;
  v5 = *((_DWORD *)dword_443D44 + 2);
  v6 = *((_DWORD *)dword_443D44 + 3);
  sub_408C50((unsigned int *)&v3);
  return 1;
}
// 4489E0: using guessed type int dword_4489E0[];
// 4489E4: using guessed type int dword_4489E4;
// 4489E8: using guessed type int dword_4489E8[];
// 4489EC: using guessed type int dword_4489EC;
// 4489F0: using guessed type int dword_4489F0;
// 4489F4: using guessed type int dword_4489F4;
// 4489F8: using guessed type int dword_4489F8;

//----- (00408D30) --------------------------------------------------------
int sub_408D30()
{
  int result; // eax

  sub_401380(dword_4489E0[0]);
  sub_40A890();
  sub_40A6E0();
  sub_409FA0();
  sub_401380(dword_448AD4);
  sub_4090E0((int)&unk_448ADC);
  result = 0;
  memset(dword_4489E0, 0, 0x108u);
  return result;
}
// 4489E0: using guessed type int dword_4489E0[];
// 448AD4: using guessed type int dword_448AD4;

//----- (00408D80) --------------------------------------------------------
_DWORD *sub_408D80()
{
  dword_4489F8 ^= 1u;
  return sub_4029B0(dword_4489E0[0], dword_4489F4 + 1);
}
// 4489E0: using guessed type int dword_4489E0[];
// 4489F4: using guessed type int dword_4489F4;
// 4489F8: using guessed type int dword_4489F8;

//----- (00408DB0) --------------------------------------------------------
signed int sub_408DB0()
{
  return 1;
}

//----- (00408DC0) --------------------------------------------------------
char __cdecl sub_408DC0(int *a1, unsigned int a2)
{
  unsigned int v3; // esi
  int v4; // eax

  if ( *a1 )
    return 0;
  a1[1] = 0;
  if ( a2 )
  {
    v3 = a2 / 3;
    if ( 3 * (a2 / 3) < a2 )
      ++v3;
    v4 = sub_401250(36 * v3);
    *a1 = v4;
    if ( !v4 )
      return 0;
    a1[1] = v3;
  }
  return 1;
}

//----- (00408E20) --------------------------------------------------------
int __cdecl sub_408E20(float *a1, unsigned int a2, int a3)
{
  char *v3; // ecx
  __int64 v4; // rax
  float *v5; // esi
  double v6; // st7
  double v7; // st6
  float v8; // ST1C_4
  double v9; // st5
  __int16 v10; // fps
  bool v11; // c0
  char v12; // c2
  bool v13; // c3
  float v15; // [esp+4h] [ebp-20h]
  float v16; // [esp+8h] [ebp-1Ch]
  float v17; // [esp+14h] [ebp-10h]
  float v18; // [esp+1Ch] [ebp-8h]

  v15 = *((float *)dword_443D44 + 5);
  v16 = *((float *)dword_443D44 + 6);
  v3 = (char *)&unk_4449E0 + 16 * a3;
  v4 = a2;
  if ( 3 * a2 )
  {
    v5 = a1;
    do
    {
      if ( v4 & 0x100000000i64 )
      {
        *(float *)&v4 = *v5;
        v6 = v5[1];
        v7 = v5[2];
        v17 = *v5;
      }
      else
      {
        v6 = *v5;
        *(float *)&v4 = v5[2];
        v7 = v5[1];
        v17 = v5[2];
      }
      v18 = flt_448B00 * v7 + flt_448AFC * v6 + flt_448B04 * v17 + flt_448B18;
      v9 = flt_448B0C * v7 + flt_448B08 * v6 + flt_448B10 * v17 + flt_448B1C;
      v11 = v9 < 1.0;
      v12 = 0;
      v13 = v9 == 1.0;
      LOWORD(v4) = v10;
      if ( v9 < 1.0 )
      {
        *((_DWORD *)v3 + 2) = -1082130432;
      }
      else
      {
        v8 = flt_448AF4 * v7 + flt_448AF0 * v6 + flt_448AF8 * v17 + flt_448B14;
        *(float *)v3 = v8 * 479.0 * (1.0 / v9) + v15;
        *((float *)v3 + 1) = v18 * 479.0 * (1.0 / v9) + v16;
        *((float *)v3 + 2) = v9;
        *((float *)v3 + 3) = 1.0 / v9;
      }
      v5 += 3;
      v3 += 16;
      ++HIDWORD(v4);
    }
    while ( HIDWORD(v4) < 3 * a2 );
  }
  return v4;
}
// 448AF0: using guessed type float flt_448AF0;
// 448AF4: using guessed type float flt_448AF4;
// 448AF8: using guessed type float flt_448AF8;
// 448AFC: using guessed type float flt_448AFC;
// 448B00: using guessed type float flt_448B00;
// 448B04: using guessed type float flt_448B04;
// 448B08: using guessed type float flt_448B08;
// 448B0C: using guessed type float flt_448B0C;
// 448B10: using guessed type float flt_448B10;
// 448B14: using guessed type float flt_448B14;
// 448B18: using guessed type float flt_448B18;
// 448B1C: using guessed type float flt_448B1C;

//----- (00408F60) --------------------------------------------------------
void *__cdecl sub_408F60(float *a1, int a2, int a3)
{
  void *result; // eax
  int v4; // esi
  char *v5; // ecx
  float *v6; // edx
  double v7; // st7
  double v8; // st6
  double v9; // st5
  float v10; // ST0C_4
  double v11; // st4
  __int16 v12; // fps
  bool v13; // c0
  char v14; // c2
  bool v15; // c3
  float v16; // [esp+4h] [ebp-14h]
  float v17; // [esp+8h] [ebp-10h]
  float v18; // [esp+10h] [ebp-8h]

  result = dword_443D44;
  v4 = a2;
  v16 = *((float *)dword_443D44 + 5);
  v5 = (char *)&unk_4449E0 + 16 * a3;
  v17 = *((float *)dword_443D44 + 6);
  if ( a2 )
  {
    v6 = a1;
    do
    {
      v7 = *v6;
      v8 = v6[1];
      v9 = v6[2];
      v18 = flt_448B04 * v9 + flt_448B00 * v8 + flt_448AFC * v7 + flt_448B18;
      v11 = flt_448B10 * v9 + flt_448B0C * v8 + flt_448B08 * v7 + flt_448B1C;
      v13 = v11 < 1.0;
      v14 = 0;
      v15 = v11 == 1.0;
      LOWORD(result) = v12;
      if ( v11 < 1.0 )
      {
        *((_DWORD *)v5 + 2) = -1082130432;
      }
      else
      {
        v10 = flt_448AF8 * v9 + flt_448AF4 * v8 + flt_448AF0 * v7 + flt_448B14;
        *(float *)v5 = v10 * 479.0 * (1.0 / v11) + v16;
        *((float *)v5 + 1) = v18 * 479.0 * (1.0 / v11) + v17;
        *((float *)v5 + 2) = v11;
        *((float *)v5 + 3) = 1.0 / v11;
      }
      v6 += 3;
      v5 += 16;
      --v4;
    }
    while ( v4 );
  }
  return result;
}
// 448AF0: using guessed type float flt_448AF0;
// 448AF4: using guessed type float flt_448AF4;
// 448AF8: using guessed type float flt_448AF8;
// 448AFC: using guessed type float flt_448AFC;
// 448B00: using guessed type float flt_448B00;
// 448B04: using guessed type float flt_448B04;
// 448B08: using guessed type float flt_448B08;
// 448B0C: using guessed type float flt_448B0C;
// 448B10: using guessed type float flt_448B10;
// 448B14: using guessed type float flt_448B14;
// 448B18: using guessed type float flt_448B18;
// 448B1C: using guessed type float flt_448B1C;

//----- (00409070) --------------------------------------------------------
char __cdecl sub_409070(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // eax

  if ( *(_DWORD *)(a1 + 4) )
    return 0;
  if ( a2 || a4 )
  {
    *(_WORD *)(a1 + 2) = 0;
    *(_WORD *)a1 = 0;
    v6 = sub_401250(a3 * a2 + a5 * a4);
    *(_DWORD *)(a1 + 4) = v6;
    if ( !v6 )
      return 0;
    *(_WORD *)a1 = a2;
    *(_WORD *)(a1 + 2) = a4;
    *(_DWORD *)(a1 + 8) = v6 + a3 * a2;
  }
  return 1;
}

//----- (004090E0) --------------------------------------------------------
int __cdecl sub_4090E0(int a1)
{
  int result; // eax

  sub_401380(*(_DWORD *)(a1 + 4));
  result = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_WORD *)a1 = 0;
  *(_WORD *)(a1 + 2) = 0;
  return result;
}

//----- (00409100) --------------------------------------------------------
char __cdecl sub_409100(unsigned __int16 a1, unsigned __int16 a2)
{
  int v3; // esi
  int v4; // eax

  if ( !dword_448AB4 )
  {
    dword_448ABC = 0;
    if ( !a1 && !a2 )
      return 1;
    v3 = 104 * a1;
    v4 = sub_401250(v3 + 132 * a2);
    dword_448AB4 = v4;
    if ( v4 )
    {
      word_448AC0 = a1;
      dword_448AB8 = v4 + v3;
      word_448AC2 = a2;
    }
  }
  return 0;
}
// 448AB4: using guessed type int dword_448AB4;
// 448AB8: using guessed type int dword_448AB8;
// 448ABC: using guessed type int dword_448ABC;
// 448AC0: using guessed type __int16 word_448AC0;
// 448AC2: using guessed type __int16 word_448AC2;

//----- (00409190) --------------------------------------------------------
char __cdecl sub_409190(int a1, unsigned __int16 a2, unsigned __int16 a3)
{
  return sub_409070(a1 + 12, a2, 104, a3, 132);
}

//----- (004091C0) --------------------------------------------------------
int __cdecl sub_4091C0(int a1, int a2, int a3, int a4)
{
  int result; // eax
  int v5; // esi
  float *v6; // edi
  float *v7; // ebx
  float *v8; // ebp
  signed int v9; // ecx
  float v10; // [esp+0h] [ebp-10h]
  float v11; // [esp+4h] [ebp-Ch]
  float v12; // [esp+8h] [ebp-8h]
  float v13; // [esp+Ch] [ebp-4h]

  v10 = *((float *)dword_443D24 + 31);
  v11 = *((float *)dword_443D24 + 31);
  v12 = *((float *)dword_443D24 + 33) + v10;
  result = a2;
  v13 = *((float *)dword_443D24 + 34) + v10;
  if ( a2 )
  {
    v5 = a1;
    do
    {
      v6 = (float *)((char *)&unk_4449E0 + 16 * *(unsigned __int16 *)(v5 + 96));
      v7 = (float *)((char *)&unk_4449E0 + 16 * *(unsigned __int16 *)(v5 + 98));
      v8 = (float *)((char *)&unk_4449E0 + 16 * *(unsigned __int16 *)(v5 + 100));
      if ( v6[2] >= 0.0
        && v7[2] >= 0.0
        && v8[2] >= 0.0
        && (*v6 < (double)v12 || *v7 < (double)v12 || *v8 < (double)v12)
        && (*v6 >= (double)v10 || *v7 >= (double)v10 || *v8 >= (double)v10)
        && (v6[1] >= (double)v11 || v7[1] >= (double)v11 || v8[1] >= (double)v11)
        && (v6[1] < (double)v13 || v7[1] < (double)v13 || v8[1] < (double)v13)
        && (v8[1] - v6[1]) * (*v7 - *v6) - (*v8 - *v6) * (v7[1] - v6[1]) > 0.0 )
      {
        v9 = a4 - (unsigned __int64)(signed __int64)((v8[2] + v7[2] + v6[2]) * -0.33333334);
        if ( (double)v9 >= 0.0 && v9 < (unsigned int)dword_4489F4 )
        {
          *(float *)(v5 + 12) = *v6;
          *(float *)(v5 + 16) = v6[1];
          *(float *)(v5 + 20) = v6[2];
          *(float *)(v5 + 24) = v6[3];
          *(float *)(v5 + 40) = *v7;
          *(float *)(v5 + 44) = v7[1];
          *(float *)(v5 + 48) = v7[2];
          *(float *)(v5 + 52) = v7[3];
          *(float *)(v5 + 68) = *v8;
          *(float *)(v5 + 72) = v8[1];
          *(float *)(v5 + 76) = v7[2];
          *(float *)(v5 + 80) = v8[3];
          *(_DWORD *)v5 = *(_DWORD *)(a3 + 8 * v9);
          *(_DWORD *)(a3 + 8 * v9) = v5;
        }
      }
      v5 += 104;
      result = a2-- - 1;
    }
    while ( a2 );
  }
  return result;
}
// 4489F4: using guessed type int dword_4489F4;

//----- (00409400) --------------------------------------------------------
int __cdecl sub_409400(int a1, int a2, int a3, int a4)
{
  int result; // eax
  int v5; // esi
  float *v6; // edi
  float *v7; // ebx
  float *v8; // ebp
  float *v9; // ecx
  signed int v10; // ecx
  float v11; // [esp+0h] [ebp-14h]
  float v12; // [esp+4h] [ebp-10h]
  float v13; // [esp+8h] [ebp-Ch]
  float v14; // [esp+Ch] [ebp-8h]
  _DWORD *v15; // [esp+10h] [ebp-4h]

  v11 = *((float *)dword_443D24 + 31);
  v12 = *((float *)dword_443D24 + 31);
  v13 = *((float *)dword_443D24 + 33) + v11;
  result = a2;
  v14 = *((float *)dword_443D24 + 34) + v11;
  if ( a2 )
  {
    v5 = a1;
    do
    {
      v6 = (float *)((char *)&unk_4449E0 + 16 * *(unsigned __int16 *)(v5 + 124));
      v7 = (float *)((char *)&unk_4449E0 + 16 * *(unsigned __int16 *)(v5 + 126));
      v8 = (float *)((char *)&unk_4449E0 + 16 * *(unsigned __int16 *)(v5 + 128));
      v9 = (float *)((char *)&unk_4449E0 + 16 * *(unsigned __int16 *)(v5 + 130));
      v15 = (_DWORD *)((char *)&unk_4449E0 + 16 * *(unsigned __int16 *)(v5 + 130));
      if ( v6[2] >= 0.0
        && v7[2] >= 0.0
        && v8[2] >= 0.0
        && v9[2] >= 0.0
        && (*v6 < (double)v13 || *v7 < (double)v13 || *v8 < (double)v13 || *v9 < (double)v13)
        && (*v6 >= (double)v11 || *v7 >= (double)v11 || *v8 >= (double)v11 || *v9 >= (double)v11)
        && (v6[1] >= (double)v12 || v7[1] >= (double)v12 || v8[1] >= (double)v12 || v9[1] >= (double)v12)
        && (v6[1] < (double)v14 || v7[1] < (double)v14 || v8[1] < (double)v14 || v9[1] < (double)v14)
        && ((v8[1] - v6[1]) * (*v7 - *v6) - (*v8 - *v6) * (v7[1] - v6[1]) > 0.0
         || (v7[1] - v9[1]) * (*v8 - *v9) - (*v7 - *v9) * (v8[1] - v9[1]) > 0.0) )
      {
        v10 = a4 - (unsigned __int64)(signed __int64)((v9[2] + v8[2] + v7[2] + v6[2]) * -0.25);
        if ( (double)v10 >= 0.0 && v10 < (unsigned int)dword_4489F4 )
        {
          *(float *)(v5 + 12) = *v6;
          *(float *)(v5 + 16) = v6[1];
          *(float *)(v5 + 20) = v6[2];
          *(float *)(v5 + 24) = v6[3];
          *(float *)(v5 + 40) = *v7;
          *(float *)(v5 + 44) = v7[1];
          *(float *)(v5 + 48) = v7[2];
          *(float *)(v5 + 52) = v7[3];
          *(float *)(v5 + 68) = *v8;
          *(float *)(v5 + 72) = v8[1];
          *(float *)(v5 + 76) = v8[2];
          *(float *)(v5 + 80) = v8[3];
          *(_DWORD *)(v5 + 96) = *v15;
          *(_DWORD *)(v5 + 100) = v15[1];
          *(_DWORD *)(v5 + 104) = v15[2];
          *(_DWORD *)(v5 + 108) = v15[3];
          *(_DWORD *)v5 = *(_DWORD *)(a3 + 8 * v10);
          *(_DWORD *)(a3 + 8 * v10) = v5;
        }
      }
      v5 += 132;
      result = a2-- - 1;
    }
    while ( a2 );
  }
  return result;
}
// 4489F4: using guessed type int dword_4489F4;

//----- (004096F0) --------------------------------------------------------
int __cdecl sub_4096F0(int a1, int a2, int a3, int a4)
{
  int result; // eax
  int v5; // esi
  float *v6; // edi
  float *v7; // ebx
  float *v8; // ebp
  float *v9; // ecx
  signed int v10; // ecx
  float v11; // [esp+0h] [ebp-14h]
  float v12; // [esp+4h] [ebp-10h]
  float v13; // [esp+8h] [ebp-Ch]
  float v14; // [esp+Ch] [ebp-8h]
  _DWORD *v15; // [esp+10h] [ebp-4h]

  v11 = *((float *)dword_443D24 + 31);
  v12 = *((float *)dword_443D24 + 31);
  v13 = *((float *)dword_443D24 + 33) + v11;
  result = a2;
  v14 = *((float *)dword_443D24 + 34) + v11;
  if ( a2 )
  {
    v5 = a1;
    do
    {
      v6 = (float *)((char *)&unk_4449E0 + 16 * *(unsigned __int16 *)(v5 + 88));
      v7 = (float *)((char *)&unk_4449E0 + 16 * *(unsigned __int16 *)(v5 + 90));
      v8 = (float *)((char *)&unk_4449E0 + 16 * *(unsigned __int16 *)(v5 + 92));
      v9 = (float *)((char *)&unk_4449E0 + 16 * *(unsigned __int16 *)(v5 + 94));
      v15 = (_DWORD *)((char *)&unk_4449E0 + 16 * *(unsigned __int16 *)(v5 + 94));
      if ( v6[2] >= 0.0
        && v7[2] >= 0.0
        && v8[2] >= 0.0
        && v9[2] >= 0.0
        && (*v6 < (double)v13 || *v7 < (double)v13 || *v8 < (double)v13 || *v9 < (double)v13)
        && (*v6 >= (double)v11 || *v7 >= (double)v11 || *v8 >= (double)v11 || *v9 >= (double)v11)
        && (v6[1] >= (double)v12 || v7[1] >= (double)v12 || v8[1] >= (double)v12 || v9[1] >= (double)v12)
        && (v6[1] < (double)v14 || v7[1] < (double)v14 || v8[1] < (double)v14 || v9[1] < (double)v14)
        && (v8[1] - v6[1]) * (*v7 - *v6) - (*v8 - *v6) * (v7[1] - v6[1]) > 0.0 )
      {
        v10 = a4 - (unsigned __int64)(signed __int64)((v9[2] + v8[2] + v7[2] + v6[2]) * -0.25);
        if ( (double)v10 >= 0.0 && v10 < (unsigned int)dword_4489F4 )
        {
          *(float *)(v5 + 8) = *v6;
          *(float *)(v5 + 12) = v6[1];
          *(float *)(v5 + 16) = v6[2];
          *(float *)(v5 + 20) = v6[3];
          *(float *)(v5 + 28) = *v7;
          *(float *)(v5 + 32) = v7[1];
          *(float *)(v5 + 36) = v7[2];
          *(float *)(v5 + 40) = v7[3];
          *(float *)(v5 + 48) = *v8;
          *(float *)(v5 + 52) = v8[1];
          *(float *)(v5 + 56) = v8[2];
          *(float *)(v5 + 60) = v8[3];
          *(_DWORD *)(v5 + 68) = *v15;
          *(_DWORD *)(v5 + 72) = v15[1];
          *(_DWORD *)(v5 + 76) = v15[2];
          *(_DWORD *)(v5 + 80) = v15[3];
          *(_DWORD *)v5 = *(_DWORD *)(a3 + 8 * v10);
          *(_DWORD *)(a3 + 8 * v10) = v5;
        }
      }
      v5 += 96;
      result = a2-- - 1;
    }
    while ( a2 );
  }
  return result;
}
// 4489F4: using guessed type int dword_4489F4;

//----- (004099B0) --------------------------------------------------------
int __cdecl sub_4099B0(int a1, int a2, int a3, int a4)
{
  int result; // eax
  int v5; // esi
  float *v6; // edi
  float *v7; // ebx
  float *v8; // ebp
  float *v9; // ecx
  signed int v10; // ecx
  float v11; // [esp+0h] [ebp-14h]
  float v12; // [esp+4h] [ebp-10h]
  float v13; // [esp+8h] [ebp-Ch]
  float v14; // [esp+Ch] [ebp-8h]
  _DWORD *v15; // [esp+10h] [ebp-4h]

  v11 = *((float *)dword_443D24 + 31);
  v12 = *((float *)dword_443D24 + 31);
  v13 = *((float *)dword_443D24 + 33) + v11;
  result = a2;
  v14 = *((float *)dword_443D24 + 34) + v11;
  if ( a2 )
  {
    v5 = a1;
    do
    {
      v6 = (float *)((char *)&unk_4449E0 + 16 * *(unsigned __int16 *)(v5 + 128));
      v7 = (float *)((char *)&unk_4449E0 + 16 * *(unsigned __int16 *)(v5 + 130));
      v8 = (float *)((char *)&unk_4449E0 + 16 * *(unsigned __int16 *)(v5 + 132));
      v9 = (float *)((char *)&unk_4449E0 + 16 * *(unsigned __int16 *)(v5 + 134));
      v15 = (_DWORD *)((char *)&unk_4449E0 + 16 * *(unsigned __int16 *)(v5 + 134));
      if ( v6[2] >= 0.0
        && v7[2] >= 0.0
        && v8[2] >= 0.0
        && v9[2] >= 0.0
        && (*v6 < (double)v13 || *v7 < (double)v13 || *v8 < (double)v13 || *v9 < (double)v13)
        && (*v6 >= (double)v11 || *v7 >= (double)v11 || *v8 >= (double)v11 || *v9 >= (double)v11)
        && (v6[1] >= (double)v12 || v7[1] >= (double)v12 || v8[1] >= (double)v12 || v9[1] >= (double)v12)
        && (v6[1] < (double)v14 || v7[1] < (double)v14 || v8[1] < (double)v14 || v9[1] < (double)v14)
        && (v8[1] - v6[1]) * (*v7 - *v6) - (*v8 - *v6) * (v7[1] - v6[1]) > 0.0 )
      {
        v10 = a4 - (unsigned __int64)(signed __int64)((v9[2] + v8[2] + v7[2] + v6[2]) * -0.25);
        if ( (double)v10 >= 0.0 && v10 < (unsigned int)dword_4489F4 )
        {
          *(float *)(v5 + 16) = *v6;
          *(float *)(v5 + 20) = v6[1];
          *(float *)(v5 + 24) = v6[2];
          *(float *)(v5 + 28) = v6[3];
          *(float *)(v5 + 44) = *v7;
          *(float *)(v5 + 48) = v7[1];
          *(float *)(v5 + 52) = v7[2];
          *(float *)(v5 + 56) = v7[3];
          *(float *)(v5 + 72) = *v8;
          *(float *)(v5 + 76) = v8[1];
          *(float *)(v5 + 80) = v8[2];
          *(float *)(v5 + 84) = v8[3];
          *(_DWORD *)(v5 + 100) = *v15;
          *(_DWORD *)(v5 + 104) = v15[1];
          *(_DWORD *)(v5 + 108) = v15[2];
          *(_DWORD *)(v5 + 112) = v15[3];
          *(_DWORD *)v5 = *(_DWORD *)(a3 + 8 * v10);
          *(_DWORD *)(a3 + 8 * v10) = v5;
        }
      }
      v5 += 136;
      result = a2-- - 1;
    }
    while ( a2 );
  }
  return result;
}
// 4489F4: using guessed type int dword_4489F4;

//----- (00409C80) --------------------------------------------------------
int *__cdecl sub_409C80(int a1, char a2)
{
  int v2; // eax
  int *v3; // ecx
  int v4; // esi
  int v5; // eax
  int *result; // eax
  int v7; // ecx
  int v8; // edx

  v2 = *(unsigned __int16 *)(a1 + 160);
  if ( (_WORD)v2 )
  {
    v3 = (int *)(*(_DWORD *)(a1 + 164) + 4);
    v4 = *(unsigned __int16 *)(a1 + 160);
    do
    {
      v5 = *v3;
      if ( a2 )
        BYTE1(v5) |= 1u;
      else
        BYTE1(v5) &= 0xFEu;
      *v3 = v5;
      v3 += 26;
      --v4;
    }
    while ( v4 );
  }
  result = *(int **)(a1 + 168);
  v7 = *(unsigned __int16 *)(a1 + 162);
  if ( (_WORD)v7 )
  {
    ++result;
    do
    {
      v8 = *result;
      if ( a2 )
        BYTE1(v8) |= 1u;
      else
        BYTE1(v8) &= 0xFEu;
      *result = v8;
      result += 33;
      --v7;
    }
    while ( v7 );
  }
  return result;
}

//----- (00409CF0) --------------------------------------------------------
int *__cdecl sub_409CF0(char a1, int a2, int a3)
{
  sub_409C80(a3, a1);
  return sub_409C80(a2, a1);
}
// 4489F8: using guessed type int dword_4489F8;

//----- (00409D20) --------------------------------------------------------
int __cdecl sub_409D20(int a1)
{
  int result; // eax

  result = a1;
  dword_448AE8 = a1;
  return result;
}
// 448AE8: using guessed type int dword_448AE8;

//----- (00409D30) --------------------------------------------------------
void __cdecl sub_409D30(_DWORD *a1, int a2, int a3, int a4)
{
  int v4; // ebx
  int v5; // esi
  int v6; // ebp
  float *v7; // edi
  double v8; // st7
  double v9; // st7
  signed int v10; // ecx
  float v11; // [esp+Ch] [ebp-14h]
  float v12; // [esp+10h] [ebp-10h]
  float v13; // [esp+14h] [ebp-Ch]
  float v14; // [esp+18h] [ebp-8h]
  float v15; // [esp+24h] [ebp+4h]
  float v16; // [esp+24h] [ebp+4h]
  float v17; // [esp+28h] [ebp+8h]
  float v18; // [esp+2Ch] [ebp+Ch]
  float v19; // [esp+30h] [ebp+10h]

  v4 = a4;
  v11 = *((float *)dword_443D24 + 31);
  v12 = *((float *)dword_443D24 + 31);
  v13 = *((float *)dword_443D24 + 33) + v11;
  v14 = *((float *)dword_443D24 + 34) + v12;
  sub_408F60((float *)(*a1 + 12 * a3), a4, 0);
  v5 = a1[1] + (a3 << 7);
  if ( a4 )
  {
    v6 = a2;
    v7 = (float *)&unk_4449E8;
    do
    {
      if ( *v7 >= 0.0 )
      {
        v8 = 1.0 / *v7;
        v15 = (double)*(unsigned __int16 *)(v5 + 12) * 479.0 * v8;
        v9 = v8 * ((double)*(unsigned __int16 *)(v5 + 14) * 479.0);
        v18 = *(v7 - 2) - v15;
        v19 = *(v7 - 1) - v9;
        v16 = v15 + *(v7 - 2);
        v17 = v9 + *(v7 - 1);
        if ( v18 < (double)v13 && v16 >= (double)v11 && v19 < (double)v14 && v17 >= (double)v12 )
        {
          v10 = dword_448AE8 + (unsigned __int64)(signed __int64)*v7;
          if ( (double)v10 >= 0.0 && v10 < (unsigned int)dword_4489F4 )
          {
            *(float *)(v5 + 16) = v18;
            *(float *)(v5 + 20) = v19;
            *(float *)(v5 + 24) = *v7;
            *(float *)(v5 + 28) = v7[1];
            *(float *)(v5 + 44) = v16;
            *(float *)(v5 + 48) = v19;
            *(float *)(v5 + 52) = *v7;
            *(float *)(v5 + 56) = v7[1];
            *(float *)(v5 + 72) = v18;
            *(float *)(v5 + 76) = v17;
            *(float *)(v5 + 80) = *v7;
            *(float *)(v5 + 84) = v7[1];
            *(float *)(v5 + 100) = v16;
            *(float *)(v5 + 104) = v17;
            *(float *)(v5 + 108) = *v7;
            *(float *)(v5 + 112) = v7[1];
            *(_DWORD *)v5 = *(_DWORD *)(v6 + 8 * v10);
            *(_DWORD *)(v6 + 8 * v10) = v5;
          }
        }
      }
      v5 += 128;
      v7 += 4;
      --v4;
    }
    while ( v4 );
  }
}
// 4489F4: using guessed type int dword_4489F4;
// 448AE8: using guessed type int dword_448AE8;

//----- (00409F10) --------------------------------------------------------
char __cdecl sub_409F10(int a1, unsigned int a2)
{
  unsigned int v2; // esi
  int v4; // eax
  int v5; // eax
  _DWORD *v6; // eax

  v2 = a2;
  if ( a2 > 0x1000 )
    return 0;
  *(_WORD *)(a1 + 10) = 0;
  if ( a2 )
  {
    v4 = sub_401250(12 * a2);
    *(_DWORD *)a1 = v4;
    if ( !v4 )
      return 0;
    v5 = sub_401250(a2 << 7);
    *(_DWORD *)(a1 + 4) = v5;
    if ( !v5 )
    {
      sub_401380(*(_DWORD *)a1);
      *(_DWORD *)a1 = 0;
      return 0;
    }
    *(_WORD *)(a1 + 10) = a2;
    if ( a2 )
    {
      v6 = (_DWORD *)(v5 + 4);
      do
      {
        *v6 = 5;
        v6 += 32;
        --v2;
      }
      while ( v2 );
    }
  }
  return 1;
}

//----- (00409FA0) --------------------------------------------------------
char sub_409FA0()
{
  unsigned int *v0; // esi
  unsigned int v1; // edi
  char result; // al

  v0 = (unsigned int *)dword_448ACC;
  v1 = 0;
  if ( dword_448AD0 )
  {
    do
    {
      sub_401380(*v0);
      sub_401380(v0[1]);
      v0 += 3;
      ++v1;
    }
    while ( v1 < dword_448AD0 );
  }
  result = sub_401380(dword_448ACC);
  dword_448ACC = 0;
  dword_448AD0 = 0;
  return result;
}
// 448ACC: using guessed type int dword_448ACC;
// 448AD0: using guessed type int dword_448AD0;

//----- (0040A000) --------------------------------------------------------
char __cdecl sub_40A000(int a1)
{
  void *v1; // edi

  dword_448AD0 = 0;
  if ( a1 )
  {
    v1 = (void *)sub_401250(12 * a1);
    dword_448ACC = (int)v1;
    if ( !v1 )
      return 0;
    dword_448AD0 = a1;
    memset(v1, 0, 12 * a1);
  }
  return 1;
}
// 448ACC: using guessed type int dword_448ACC;
// 448AD0: using guessed type int dword_448AD0;

//----- (0040A060) --------------------------------------------------------
void __cdecl sub_40A060(_DWORD *a1, _DWORD *a2, int a3, int a4)
{
  char v4; // [esp+0h] [ebp-30h]

  sub_40A940(a2, (int)&dword_4489FC, (float *)&v4);
  sub_40AB10(&v4);
  sub_409D30(a1, dword_4489E0[dword_4489F8], a3, a4);
}
// 4489E0: using guessed type int dword_4489E0[];
// 4489F8: using guessed type int dword_4489F8;
// 4489FC: using guessed type int dword_4489FC;

//----- (0040A0B0) --------------------------------------------------------
char __cdecl sub_40A0B0(int a1, int a2)
{
  int v2; // ebx
  int v3; // eax
  unsigned __int16 v5; // ax
  char *v6; // edx
  unsigned int v7; // ecx
  int v8; // eax

  v2 = 0;
  *(_WORD *)(a1 + 26) = 0;
  if ( a2 )
  {
    v3 = sub_401250(8 * a2);
    *(_DWORD *)(a1 + 36) = v3;
    if ( !v3 )
      return 0;
    v5 = *(_WORD *)(a1 + 24);
    *(_WORD *)(a1 + 26) = a2;
    if ( v5 )
    {
      v2 = 12 * v5;
      v6 = (char *)sub_401250(v2 * (unsigned __int16)a2);
      memset(v6, 0, v2 * *(unsigned __int16 *)(a1 + 26));
    }
    else
    {
      v6 = 0;
    }
    v7 = 0;
    if ( *(_WORD *)(a1 + 26) )
    {
      v8 = *(_DWORD *)(a1 + 36) + 2;
      do
      {
        *(_DWORD *)(v8 + 2) = v6;
        *(_WORD *)v8 = *(_WORD *)(a1 + 24);
        v6 += v2;
        v8 += 8;
        ++v7;
      }
      while ( v7 < *(unsigned __int16 *)(a1 + 26) );
    }
  }
  return 1;
}

//----- (0040A170) --------------------------------------------------------
char __cdecl sub_40A170(int a1, int a2)
{
  int v2; // eax

  *(_WORD *)(a1 + 4) = 0;
  if ( a2 )
  {
    v2 = sub_401250(36 * a2);
    *(_DWORD *)(a1 + 8) = v2;
    if ( !v2 )
      return 0;
    *(_WORD *)(a1 + 4) = a2;
  }
  return 1;
}

//----- (0040A1B0) --------------------------------------------------------
char __cdecl sub_40A1B0(int a1, int a2)
{
  int v2; // eax

  *(_WORD *)(a1 + 24) = 0;
  if ( a2 )
  {
    v2 = sub_401250(236 * a2);
    *(_DWORD *)(a1 + 32) = v2;
    if ( !v2 )
      return 0;
    *(_WORD *)(a1 + 24) = a2;
  }
  return 1;
}

//----- (0040A200) --------------------------------------------------------
char __cdecl sub_40A200(int a1, int a2)
{
  int v2; // eax

  *(_WORD *)(a1 + 28) = 0;
  if ( a2 )
  {
    v2 = sub_401250(20 * a2);
    *(_DWORD *)(a1 + 40) = v2;
    if ( !v2 )
      return 0;
    *(_WORD *)(a1 + 28) = a2;
  }
  return 1;
}

//----- (0040A240) --------------------------------------------------------
char __cdecl sub_40A240(int a1, unsigned int a2)
{
  int v2; // ebp
  unsigned int v4; // ebx
  void *v5; // eax
  int v6; // ST10_4
  int v7; // ST08_4
  int v8; // eax
  int v9; // edx
  char *v10; // edx
  int v11; // eax
  int v12; // ebx
  int v13; // ecx
  _DWORD *v14; // eax
  _DWORD *v15; // edx
  int v16; // eax
  int v17; // eax
  __int16 v18; // dx
  unsigned int v19; // ecx
  _DWORD *v20; // [esp+10h] [ebp-24h]
  int v21; // [esp+14h] [ebp-20h]
  int v22; // [esp+18h] [ebp-1Ch]
  int v23; // [esp+1Ch] [ebp-18h]
  int v24; // [esp+20h] [ebp-14h]
  int v25; // [esp+24h] [ebp-10h]
  __int16 v26; // [esp+28h] [ebp-Ch]
  __int16 v27; // [esp+2Ah] [ebp-Ah]
  char *v28; // [esp+2Ch] [ebp-8h]
  int v29; // [esp+30h] [ebp-4h]
  int v30; // [esp+38h] [ebp+4h]

  v2 = a1;
  if ( !*(_DWORD *)(a1 + 16) )
    return 0;
  if ( *(_DWORD *)(a1 + 44) )
    return 0;
  v4 = a2;
  *(_WORD *)(a1 + 30) = 0;
  if ( a2 )
  {
    v5 = (void *)sub_401250(188 * a2);
    *(_DWORD *)(a1 + 44) = v5;
    if ( !v5 )
      return 0;
    *(_WORD *)(a1 + 30) = a2;
    memset(v5, 0, 188 * a2);
    *(_BYTE *)(a1 + 2) |= 1u;
    if ( a2 <= 1 )
    {
      v9 = *(_DWORD *)(a1 + 20);
      v8 = *(_DWORD *)(a1 + 32);
      v28 = *(char **)(a1 + 16);
      v29 = v9;
    }
    else
    {
      v6 = a2 * *(unsigned __int16 *)(a1 + 14);
      v7 = a2 * *(unsigned __int16 *)(a1 + 12);
      v28 = 0;
      v29 = 0;
      v26 = 0;
      v27 = 0;
      sub_409070((int)&v26, v7, 104, v6, 132);
      v8 = sub_401250(236 * a2 * *(unsigned __int16 *)(a1 + 24));
    }
    v10 = v28;
    v23 = v8;
    v11 = *(_DWORD *)(a1 + 44);
    v24 = (int)v28;
    v30 = v29;
    v21 = *(_DWORD *)(v2 + 44);
    v22 = 0;
    if ( a2 > 0 )
    {
      v12 = v11 + 16;
      while ( 1 )
      {
        *(_DWORD *)(v12 - 4) = 0;
        *(_DWORD *)(v12 - 8) = 1065353216;
        *(_DWORD *)v12 = 0;
        *(_DWORD *)(v12 + 4) = 0;
        *(_DWORD *)(v12 + 8) = 1065353216;
        *(_DWORD *)(v12 + 12) = 0;
        *(_DWORD *)(v12 + 16) = 0;
        *(_DWORD *)(v12 + 20) = 0;
        *(_DWORD *)(v12 + 24) = 1065353216;
        *(_DWORD *)(v12 + 28) = 0;
        *(_DWORD *)(v12 + 32) = 0;
        *(_DWORD *)(v12 + 36) = 0;
        *(_DWORD *)(v12 + 40) = 1065353216;
        *(_DWORD *)(v12 + 44) = 0;
        *(_DWORD *)(v12 + 48) = 0;
        *(_DWORD *)(v12 + 52) = 0;
        *(_DWORD *)(v12 + 56) = 1065353216;
        *(_DWORD *)(v12 + 60) = 0;
        *(_DWORD *)(v12 + 64) = 0;
        *(_DWORD *)(v12 + 68) = 0;
        *(_DWORD *)(v12 + 72) = 1065353216;
        *(_DWORD *)(v12 + 76) = 0;
        *(_DWORD *)(v12 + 80) = 0;
        *(_DWORD *)(v12 + 84) = 0;
        *(_DWORD *)(v12 + 88) = 1065353216;
        *(_DWORD *)(v12 + 92) = 0;
        *(_DWORD *)(v12 + 96) = 0;
        *(_DWORD *)(v12 + 100) = 0;
        *(_DWORD *)(v12 + 104) = 1065353216;
        *(_DWORD *)(v12 + 108) = 0;
        *(_DWORD *)(v12 + 112) = 0;
        *(_DWORD *)(v12 + 116) = 0;
        *(_DWORD *)(v12 + 120) = 1065353216;
        *(_DWORD *)(v12 + 124) = 0;
        *(_DWORD *)(v12 + 128) = 0;
        *(_DWORD *)(v12 + 132) = 0;
        *(_DWORD *)(v12 + 140) = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v12 + 136) = *(_DWORD *)(v2 + 4);
        *(_DWORD *)(v12 + 148) = v10;
        *(_WORD *)(v12 + 144) = *(_WORD *)(v2 + 12);
        *(_DWORD *)(v12 + 152) = v30;
        *(_WORD *)(v12 + 146) = *(_WORD *)(v2 + 14);
        if ( a2 > 1 )
        {
          qmemcpy(v10, *(const void **)(v2 + 16), 104 * *(unsigned __int16 *)(v2 + 12));
          qmemcpy(*(void **)(v12 + 152), *(const void **)(v2 + 20), 132 * *(unsigned __int16 *)(v2 + 14));
          v24 = (int)&v10[104 * *(unsigned __int16 *)(v2 + 12)];
          v30 += 132 * *(unsigned __int16 *)(v2 + 14);
        }
        v25 = 0;
        v13 = v23 + 236 * v22 * *(unsigned __int16 *)(v2 + 24);
        *(_DWORD *)(v12 + 164) = v13;
        *(_WORD *)(v12 + 156) = *(_WORD *)(v2 + 24);
        v14 = *(_DWORD **)(v2 + 32);
        v20 = *(_DWORD **)(v2 + 32);
        v15 = (_DWORD *)v13;
        if ( *(_WORD *)(v2 + 24) )
        {
          while ( 1 )
          {
            if ( a2 > 1 )
              qmemcpy(v15, v14, 0xECu);
            v16 = v14[1];
            v15[1] = v16 == 0xFFFF ? v21 : *(_DWORD *)(v12 + 164) + 236 * v16;
            v20 += 59;
            v15 += 59;
            if ( ++v25 >= (unsigned int)*(unsigned __int16 *)(v2 + 24) )
              break;
            v14 = v20;
          }
        }
        v12 += 188;
        v21 += 188;
        *(_WORD *)(v12 - 26) = (v2 - dword_448AC4) / 0x30u;
        if ( ++v22 >= a2 )
          break;
        v10 = (char *)v24;
      }
      v4 = a2;
    }
    if ( v4 > 1 )
    {
      sub_4090E0(v2 + 12);
      v17 = (int)v28;
      v18 = v26;
      *(_DWORD *)(v2 + 20) = v29;
      v19 = *(_DWORD *)(v2 + 32);
      *(_DWORD *)(v2 + 16) = v17;
      LOWORD(v17) = v27;
      *(_WORD *)(v2 + 12) = v18;
      *(_WORD *)(v2 + 14) = v17;
      sub_401380(v19);
      *(_DWORD *)(v2 + 32) = v23;
      return 1;
    }
  }
  else
  {
    sub_40A610(a1);
  }
  return 1;
}
// 448AC4: using guessed type int dword_448AC4;

//----- (0040A5E0) --------------------------------------------------------
signed int __cdecl sub_40A5E0(int a1)
{
  unsigned __int8 *v1; // ecx
  signed int result; // eax

  v1 = (unsigned __int8 *)dword_448AC4;
  result = 0;
  if ( !dword_448AC8 )
    return -1;
  while ( *v1 != a1 )
  {
    v1 += 48;
    if ( ++result >= (unsigned int)dword_448AC8 )
      return -1;
  }
  return result;
}
// 448AC4: using guessed type int dword_448AC4;
// 448AC8: using guessed type int dword_448AC8;

//----- (0040A610) --------------------------------------------------------
char __cdecl sub_40A610(int a1)
{
  int v1; // edi
  unsigned int v2; // eax
  int v3; // ebp
  unsigned __int16 *v4; // ebp
  unsigned int *v5; // esi
  int v6; // ebx
  char result; // al
  int v8; // [esp+10h] [ebp+4h]

  v1 = a1;
  sub_401380(*(_DWORD *)(a1 + 4));
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  sub_4090E0(a1 + 12);
  sub_401380(*(_DWORD *)(a1 + 44));
  v2 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 44) = 0;
  *(_WORD *)(a1 + 30) = 0;
  sub_401380(v2);
  v3 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 24) = 0;
  if ( v3 )
  {
    if ( *(_WORD *)(a1 + 26) > 0u )
    {
      v4 = (unsigned __int16 *)(v3 + 2);
      v8 = *(unsigned __int16 *)(a1 + 26);
      do
      {
        if ( *v4 > 0u )
        {
          v5 = (unsigned int *)(*(_DWORD *)(v4 + 1) + 8);
          v6 = *v4;
          do
          {
            sub_401380(*v5);
            v5 += 3;
            --v6;
          }
          while ( v6 );
        }
        v4 += 4;
        --v8;
      }
      while ( v8 );
    }
    sub_401380(*(_DWORD *)(*(_DWORD *)(v1 + 36) + 4));
    sub_401380(*(_DWORD *)(v1 + 36));
    *(_DWORD *)(v1 + 36) = 0;
    *(_WORD *)(v1 + 26) = 0;
  }
  result = sub_401380(*(_DWORD *)(v1 + 40));
  *(_DWORD *)(v1 + 40) = 0;
  *(_WORD *)(v1 + 28) = 0;
  return result;
}

//----- (0040A6E0) --------------------------------------------------------
char sub_40A6E0()
{
  int v0; // esi
  unsigned int v1; // edi
  char result; // al

  v0 = dword_448AC4;
  v1 = 0;
  if ( dword_448AC8 )
  {
    do
    {
      sub_40A610(v0);
      v0 += 48;
      ++v1;
    }
    while ( v1 < dword_448AC8 );
  }
  result = sub_401380(dword_448AC4);
  dword_448AC4 = 0;
  dword_448AC8 = 0;
  return result;
}
// 448AC4: using guessed type int dword_448AC4;
// 448AC8: using guessed type int dword_448AC8;

//----- (0040A730) --------------------------------------------------------
char __cdecl sub_40A730(int a1)
{
  void *v1; // edi

  dword_448AC8 = 0;
  if ( a1 )
  {
    v1 = (void *)sub_401250(48 * a1);
    dword_448AC4 = (int)v1;
    if ( !v1 )
      return 0;
    dword_448AC8 = a1;
    memset(v1, 0, 48 * a1);
  }
  return 1;
}
// 448AC4: using guessed type int dword_448AC4;
// 448AC8: using guessed type int dword_448AC8;

//----- (0040A790) --------------------------------------------------------
int __cdecl sub_40A790(int a1, __int16 a2, int a3)
{
  int result; // eax

  *(_DWORD *)(a1 + 12) = dword_448AB4 + 104 * (unsigned __int16)dword_448ABC;
  *(_WORD *)(a1 + 8) = a2;
  LOWORD(dword_448ABC) = a2 + dword_448ABC;
  if ( (unsigned __int16)dword_448ABC > (unsigned __int16)word_448AC0 )
    nullsub_1(aTooMuchGt3ForO);
  result = a3;
  *(_DWORD *)(a1 + 16) = dword_448AB8 + 132 * HIWORD(dword_448ABC);
  *(_WORD *)(a1 + 10) = a3;
  HIWORD(dword_448ABC) += a3;
  if ( HIWORD(dword_448ABC) > (unsigned __int16)word_448AC2 )
    result = nullsub_1(aTooMuchGt4ForO);
  return result;
}
// 434B40: using guessed type int __cdecl nullsub_1(_DWORD);
// 448AB4: using guessed type int dword_448AB4;
// 448AB8: using guessed type int dword_448AB8;
// 448ABC: using guessed type int dword_448ABC;
// 448AC0: using guessed type __int16 word_448AC0;
// 448AC2: using guessed type __int16 word_448AC2;

//----- (0040A830) --------------------------------------------------------
char __cdecl sub_40A830(int a1)
{
  void *v1; // edi

  dword_448AB0 = 0;
  if ( a1 )
  {
    v1 = (void *)sub_401250(20 * a1);
    dword_448AAC = (int)v1;
    if ( !v1 )
      return 0;
    dword_448AB0 = a1;
    memset(v1, 0, 20 * a1);
  }
  return 1;
}
// 448AAC: using guessed type int dword_448AAC;
// 448AB0: using guessed type int dword_448AB0;

//----- (0040A890) --------------------------------------------------------
char sub_40A890()
{
  unsigned int *v0; // esi
  int v1; // edi
  char result; // al

  v0 = (unsigned int *)dword_448AAC;
  if ( dword_448AB0 )
  {
    v1 = dword_448AB0;
    do
    {
      sub_401380(*v0);
      v0 += 5;
      --v1;
    }
    while ( v1 );
  }
  sub_401380(dword_448AB4);
  dword_448AB4 = 0;
  dword_448AB8 = 0;
  result = sub_401380(dword_448AAC);
  dword_448AAC = 0;
  dword_448AB0 = 0;
  return result;
}
// 448AAC: using guessed type int dword_448AAC;
// 448AB0: using guessed type int dword_448AB0;
// 448AB4: using guessed type int dword_448AB4;
// 448AB8: using guessed type int dword_448AB8;

//----- (0040A8F0) --------------------------------------------------------
int __cdecl sub_40A8F0(int a1, int a2)
{
  int v2; // esi

  v2 = a1;
  sub_408E20(*(float **)a1, *(_DWORD *)(a1 + 4), 0);
  sub_4091C0(*(_DWORD *)(v2 + 12), *(unsigned __int16 *)(v2 + 8), a2, 0);
  return sub_409400(*(_DWORD *)(v2 + 16), *(unsigned __int16 *)(v2 + 10), a2, 0);
}

//----- (0040A940) --------------------------------------------------------
float *__cdecl sub_40A940(_DWORD *a1, int a2, float *a3)
{
  int v4; // [esp+0h] [ebp-30h]
  int v5; // [esp+4h] [ebp-2Ch]
  int v6; // [esp+8h] [ebp-28h]
  int v7; // [esp+Ch] [ebp-24h]
  int v8; // [esp+10h] [ebp-20h]
  int v9; // [esp+14h] [ebp-1Ch]
  int v10; // [esp+18h] [ebp-18h]
  int v11; // [esp+1Ch] [ebp-14h]
  int v12; // [esp+20h] [ebp-10h]
  int v13; // [esp+24h] [ebp-Ch]
  int v14; // [esp+28h] [ebp-8h]
  int v15; // [esp+2Ch] [ebp-4h]

  v4 = 1065353216;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 1065353216;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 1065353216;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  sub_407FF0(a1, &v4);
  return sub_4081F0((float *)(a2 + 80), (float *)&v4, a3);
}

//----- (0040A9D0) --------------------------------------------------------
float *__cdecl sub_40A9D0(int a1, int a2)
{
  return sub_4081F0((float *)(a2 + 80), (float *)(a1 + 56), (float *)(a1 + 104));
}

//----- (0040A9F0) --------------------------------------------------------
float __usercall sub_40A9F0@<eax>(float *a1)
{
  float *v1; // esi
  float v2; // edx
  float v3; // eax
  float v4; // ecx
  float v5; // edx
  float v6; // eax
  float v7; // ecx
  float v8; // edx
  float result; // eax
  double v10; // st7
  float v11; // [esp+10h] [ebp-40h]
  float v12; // [esp+14h] [ebp-3Ch]
  float v13; // [esp+18h] [ebp-38h]
  float v14; // [esp+20h] [ebp-30h]
  float v15; // [esp+24h] [ebp-2Ch]
  float v16; // [esp+28h] [ebp-28h]
  float v17; // [esp+30h] [ebp-20h]
  float v18; // [esp+34h] [ebp-1Ch]
  float v19; // [esp+38h] [ebp-18h]
  int v20; // [esp+40h] [ebp-10h]
  int v21; // [esp+44h] [ebp-Ch]
  int v22; // [esp+48h] [ebp-8h]

  v1 = a1;
  v11 = a1[3] - *a1;
  v12 = a1[4] - a1[1];
  v13 = a1[5] - a1[2];
  AGLVECTOR::Normalize((AGLVECTOR *)&v11);
  v20 = 0;
  v21 = 1065353216;
  v22 = 0;
  AGLVECTOR::CrossProduct((AGLVECTOR *)&v20, (struct AGLVECTOR *)&v11, (struct AGLVECTOR *)&v14);
  AGLVECTOR::Normalize((AGLVECTOR *)&v14);
  AGLVECTOR::CrossProduct((AGLVECTOR *)&v11, (struct AGLVECTOR *)&v14, (struct AGLVECTOR *)&v17);
  v2 = v15;
  v3 = v16;
  a1[20] = v14;
  v4 = v17;
  a1[21] = v2;
  v5 = v18;
  a1[22] = v3;
  v6 = v19;
  a1[23] = v4;
  v7 = v11;
  a1[24] = v5;
  v8 = v12;
  a1[25] = v6;
  result = v13;
  a1[26] = v7;
  v10 = v14;
  a1[27] = v8;
  a1[28] = result;
  v1[29] = -(v10 * *v1 + v16 * v1[2] + v15 * v1[1]);
  v1[30] = -(v17 * *v1 + v19 * v1[2] + v18 * v1[1]);
  v1[31] = -(v11 * *v1 + v13 * v1[2] + v12 * v1[1]);
  return result;
}

//----- (0040AB10) --------------------------------------------------------
void __cdecl sub_40AB10(const void *a1)
{
  qmemcpy(&flt_448AF0, a1, 0x30u);
}
// 448AF0: using guessed type float flt_448AF0;

//----- (0040AB30) --------------------------------------------------------
char __cdecl sub_40AB30(int a1, int a2)
{
  int v3; // eax

  *(_BYTE *)(a1 + 2) = 0;
  if ( !a2 )
    return 1;
  v3 = sub_401250(44 * a2);
  *(_DWORD *)(a1 + 8) = v3;
  if ( !v3 )
    return 1;
  *(_BYTE *)(a1 + 2) = a2;
  return 0;
}

//----- (0040AB70) --------------------------------------------------------
char __cdecl sub_40AB70(int a1)
{
  char result; // al
  void *v2; // edi

  dword_455C3C = 0;
  if ( !a1 )
    return 1;
  v2 = (void *)sub_401250(12 * a1);
  dword_455C38 = (int)v2;
  if ( !v2 )
    return 1;
  result = 0;
  dword_455C3C = a1;
  memset(v2, 0, 12 * a1);
  return result;
}
// 455C38: using guessed type int dword_455C38;
// 455C3C: using guessed type int dword_455C3C;

//----- (0040ABD0) --------------------------------------------------------
char sub_40ABD0()
{
  unsigned int *v0; // esi
  int v1; // edi
  char result; // al

  if ( (_WORD)dword_455C3C )
  {
    v0 = (unsigned int *)(dword_455C38 + 8);
    v1 = (unsigned __int16)dword_455C3C;
    do
    {
      sub_401380(*v0);
      v0 += 3;
      --v1;
    }
    while ( v1 );
  }
  result = sub_401380(dword_455C38);
  dword_455C38 = 0;
  return result;
}
// 455C38: using guessed type int dword_455C38;
// 455C3C: using guessed type int dword_455C3C;

//----- (0040AC20) --------------------------------------------------------
_BYTE *__cdecl sub_40AC20(unsigned int a1, int a2)
{
  _BYTE *result; // eax

  result = (_BYTE *)dword_455C3C;
  if ( a1 < dword_455C3C )
  {
    result = (_BYTE *)(dword_455C38 + 12 * a1);
    if ( a2 )
    {
      *result |= 0x20u;
      result = (_BYTE *)dword_44B728;
      if ( dword_44B728 )
      {
        result = (_BYTE *)dword_44B72C;
        if ( a1 == dword_44B72C + *(unsigned __int16 *)(dword_44B728 + 32) )
          result = (_BYTE *)sub_42CCD0((int)&dword_44B71C);
      }
    }
    else
    {
      *(_WORD *)result &= 0xFFDFu;
    }
  }
  return result;
}
// 44B728: using guessed type int dword_44B728;
// 44B72C: using guessed type int dword_44B72C;
// 455C38: using guessed type int dword_455C38;
// 455C3C: using guessed type int dword_455C3C;

//----- (0040AC80) --------------------------------------------------------
int sub_40AC80()
{
  int result; // eax

  sub_401380(dword_455C20);
  result = 0;
  dword_455C24 = 0;
  dword_455C20 = 0;
  dword_455C28 = 0;
  return result;
}
// 455C20: using guessed type int dword_455C20;
// 455C24: using guessed type int dword_455C24;

//----- (0040ACA0) --------------------------------------------------------
char __cdecl sub_40ACA0(int a1)
{
  void *v1; // edi

  dword_455C24 = 0;
  if ( a1 )
  {
    v1 = (void *)sub_401250(120 * a1);
    dword_455C20 = (int)v1;
    if ( !v1 )
      return 0;
    dword_455C24 = a1;
    memset(v1, 0, 120 * a1);
  }
  return 1;
}
// 455C20: using guessed type int dword_455C20;
// 455C24: using guessed type int dword_455C24;

//----- (0040AD00) --------------------------------------------------------
int __cdecl sub_40AD00(int a1, float a2)
{
  int result; // eax
  _DWORD *v3; // ebp
  float *v4; // ebx
  int v5; // esi
  double v6; // st7
  double v7; // st7
  double v8; // st7
  int v9; // [esp+8h] [ebp+4h]

  result = dword_455C24;
  v3 = (_DWORD *)dword_455C20;
  dword_455C28 = 0;
  if ( dword_455C24 )
  {
    v4 = (float *)a1;
    v5 = dword_455C20 + 60;
    v9 = dword_455C24;
    do
    {
      v6 = *(float *)v5 - v4[3];
      if ( v6 < 0.0 )
        v6 = -v6;
      if ( v6 < a2 )
      {
        v7 = *(float *)(v5 + 4) - v4[4];
        if ( v7 < 0.0 )
          v7 = -v7;
        if ( v7 < a2 )
        {
          v8 = *(float *)(v5 + 8) - v4[5];
          if ( v8 < 0.0 )
            v8 = -v8;
          if ( v8 < a2 )
          {
            sub_40A940((_DWORD *)v5, (int)v4, (float *)(v5 + 12));
            sub_40AB10((const void *)(v5 + 12));
            if ( sub_408DB0() )
            {
              *v3 = dword_455C28;
              dword_455C28 = (int)v3;
            }
          }
        }
      }
      v3 += 30;
      v5 += 120;
      result = v9-- - 1;
    }
    while ( v9 );
  }
  return result;
}
// 455C20: using guessed type int dword_455C20;
// 455C24: using guessed type int dword_455C24;

//----- (0040ADE0) --------------------------------------------------------
__int16 sub_40ADE0()
{
  bool v0; // cf
  bool v1; // zf
  int v2; // eax
  __int16 result; // ax
  int v4; // ebx
  int v5; // ebp
  int v6; // eax
  int v7; // esi
  int v8; // edi
  int v9; // esi
  int v10; // edi
  int v11; // ebp
  int v12; // ecx
  _DWORD *v13; // eax
  char v14; // al
  int v15; // eax
  double v16; // st7
  double v17; // st6
  float v18; // ST3C_4
  double v19; // st7
  unsigned __int8 v20; // al
  int v21; // eax
  unsigned __int8 v22; // dl
  unsigned __int8 v23; // ST49_1
  int v24; // eax
  double v25; // st7
  double v26; // st6
  float v27; // ST38_4
  double v28; // st7
  int v29; // [esp+0h] [ebp-30h]
  int i; // [esp+4h] [ebp-2Ch]
  unsigned int v31; // [esp+8h] [ebp-28h]
  int v32; // [esp+Ch] [ebp-24h]
  int v33; // [esp+10h] [ebp-20h]
  int v34; // [esp+14h] [ebp-1Ch]
  unsigned __int8 v35; // [esp+20h] [ebp-10h]
  unsigned __int8 v36; // [esp+21h] [ebp-Fh]

  if ( byte_455C14 )
  {
    v0 = (unsigned __int8)byte_455C15 >= 0xFFu;
    v1 = byte_455C15++ == 0;
    if ( !v0 && !v1 )
    {
      if ( ++BYTE2(dword_455C98) >= 0xAu )
        BYTE2(dword_455C98) = 0;
      byte_455C15 = 0;
    }
  }
  v2 = 2 * BYTE2(dword_455C98);
  v35 = byte_440E74[v2];
  v36 = byte_440E75[v2];
  sub_409D20(-180);
  result = dword_4489F8;
  v4 = dword_455C28;
  v5 = 0;
  v34 = dword_4489E0[dword_4489F8];
  v33 = dword_448ACC + 12;
  for ( i = 0; v4; v4 = *(_DWORD *)v4 )
  {
    sub_40AB10((const void *)(v4 + 72));
    v6 = *(unsigned __int16 *)(v4 + 38);
    v7 = dword_448AAC + 20 * *(unsigned __int16 *)(v4 + 36);
    if ( (_WORD)v6 )
    {
      v8 = *(unsigned __int16 *)(v4 + 38);
      do
      {
        sub_40A8F0(v7, v34);
        v7 += 20;
        --v8;
      }
      while ( v8 );
    }
    result = *(_WORD *)(v4 + 58);
    if ( result )
    {
      v29 = 0;
      v9 = dword_455C90 + 16 * *(unsigned __int16 *)(v4 + 56);
      result = *(_WORD *)(v4 + 58);
      if ( *(_WORD *)(v4 + 58) )
      {
        v31 = v5;
        v10 = 12 * v5;
        v11 = v5 << 7;
        v32 = *(unsigned __int16 *)(v4 + 58);
        do
        {
          if ( *(_BYTE *)(v9 + 1) != 10 && !*(_BYTE *)v9 && v31 < *(unsigned __int16 *)(v33 + 10) )
          {
            v12 = v11 + *(_DWORD *)(v33 + 4);
            if ( v12 )
            {
              v13 = (_DWORD *)(*(_DWORD *)v33 + v10);
              *v13 = *(_DWORD *)(v9 + 4);
              v13[1] = *(_DWORD *)(v9 + 8);
              v13[2] = *(_DWORD *)(v9 + 12);
              *(_BYTE *)(v12 + 34) = -1;
              *(_BYTE *)(v12 + 33) = -1;
              *(_BYTE *)(v12 + 32) = -1;
              v14 = *(_BYTE *)(v9 + 1);
              if ( v14 )
              {
                v20 = 80 - 5 * v14;
                *(_WORD *)(v12 + 12) = v20;
                *(_WORD *)(v12 + 14) = v20;
                v21 = 2 * *(unsigned __int8 *)(v9 + 1);
                v22 = byte_440E72[v21];
                v23 = byte_440E73[v21] - 64;
                v24 = *(_DWORD *)(v12 + 4);
                BYTE1(v24) |= 1u;
                *(_DWORD *)(v12 + 4) = v24;
                v25 = (double)v22 * 0.0039215689;
                *(float *)(v12 + 36) = v25;
                v26 = (double)v23 * 0.0039215689;
                *(float *)(v12 + 40) = v26;
                v27 = (double)(unsigned __int8)(v22 + 31) * 0.0039215689;
                *(float *)(v12 + 64) = v27;
                *(float *)(v12 + 68) = v26;
                *(float *)(v12 + 120) = v27;
                *(float *)(v12 + 92) = v25;
                v28 = (double)(unsigned __int8)(v23 + 31) * 0.0039215689;
                *(float *)(v12 + 96) = v28;
                *(float *)(v12 + 124) = v28;
                ++*(_BYTE *)(v9 + 1);
              }
              else
              {
                v15 = *(_DWORD *)(v12 + 4);
                BYTE1(v15) &= 0xFEu;
                *(_DWORD *)(v12 + 4) = v15;
                *(_WORD *)(v12 + 12) = 60;
                *(_WORD *)(v12 + 14) = 60;
                v16 = (double)v35 * 0.0039215689;
                *(float *)(v12 + 36) = v16;
                v17 = (double)v36 * 0.0039215689;
                *(float *)(v12 + 40) = v17;
                v18 = (double)(unsigned __int8)(v35 + 30) * 0.0039215689;
                *(float *)(v12 + 64) = v18;
                *(float *)(v12 + 68) = v17;
                *(float *)(v12 + 120) = v18;
                *(float *)(v12 + 92) = v16;
                v19 = (double)(unsigned __int8)(v36 + 30) * 0.0039215689;
                *(float *)(v12 + 96) = v19;
                *(float *)(v12 + 124) = v19;
              }
              v11 += 128;
              v10 += 12;
              ++v29;
              ++v31;
            }
          }
          v9 += 16;
          --v32;
        }
        while ( v32 );
        result = v29;
        if ( v29 )
        {
          sub_40A060((_DWORD *)v33, (_DWORD *)(v4 + 60), i, v29);
          result = v29;
          i += v29;
        }
        v5 = i;
      }
    }
  }
  return result;
}
// 4489E0: using guessed type int dword_4489E0[];
// 4489F8: using guessed type int dword_4489F8;
// 448AAC: using guessed type int dword_448AAC;
// 448ACC: using guessed type int dword_448ACC;
// 455C14: using guessed type char byte_455C14;
// 455C15: using guessed type char byte_455C15;
// 455C90: using guessed type int dword_455C90;
// 455C98: using guessed type int dword_455C98;

//----- (0040B140) --------------------------------------------------------
bool __cdecl sub_40B140(int a1, int a2, float a3)
{
  int v3; // eax
  float *v4; // ecx
  double v5; // st7
  int v7; // [esp+4h] [ebp+4h]
  int v8; // [esp+8h] [ebp+8h]

  v3 = a2;
  v4 = (float *)a1;
  v5 = *(float *)a2 - *(float *)(a1 + 60);
  *(float *)&v8 = *(float *)(a2 + 4) - *(float *)(a1 + 64);
  *(float *)&v7 = *(float *)(v3 + 8) - *(float *)(a1 + 68);
  return v5 >= v4[2] - a3
      && v5 <= a3 + v4[4]
      && v4[3] - a3 <= *(float *)&v8
      && a3 + v4[5] >= *(float *)&v8
      && v4[6] - a3 <= *(float *)&v7
      && a3 + v4[7] >= *(float *)&v7;
}

//----- (0040B1E0) --------------------------------------------------------
int sub_40B1E0()
{
  char v0; // al
  _DWORD *v1; // ecx
  int result; // eax
  signed int v3; // esi
  int v4; // eax
  signed __int64 v5; // rax
  int v6; // ecx
  float v7; // ST24_4
  double v8; // st7
  float v9; // ST2C_4
  float v10; // ST18_4
  double v11; // st7
  float v12; // ST24_4
  double v13; // st7
  float v14; // [esp+18h] [ebp-90h]
  int v15; // [esp+1Ch] [ebp-8Ch]
  float v16; // [esp+20h] [ebp-88h]
  int v17; // [esp+24h] [ebp-84h]
  int v18; // [esp+28h] [ebp-80h]
  int v19; // [esp+2Ch] [ebp-7Ch]
  float v20; // [esp+30h] [ebp-78h]
  int v21; // [esp+34h] [ebp-74h]
  float v22; // [esp+38h] [ebp-70h]
  int v23; // [esp+3Ch] [ebp-6Ch]
  int v24; // [esp+40h] [ebp-68h]
  int v25; // [esp+44h] [ebp-64h]
  int v26; // [esp+48h] [ebp-60h]
  int v27; // [esp+4Ch] [ebp-5Ch]
  int v28; // [esp+50h] [ebp-58h]
  int v29; // [esp+54h] [ebp-54h]
  int v30; // [esp+58h] [ebp-50h]
  int v31; // [esp+5Ch] [ebp-4Ch]
  int v32; // [esp+60h] [ebp-48h]
  int v33; // [esp+64h] [ebp-44h]
  int v34; // [esp+68h] [ebp-40h]
  int v35; // [esp+6Ch] [ebp-3Ch]
  float v36; // [esp+70h] [ebp-38h]
  int v37; // [esp+74h] [ebp-34h]
  int v38; // [esp+78h] [ebp-30h]
  int v39; // [esp+7Ch] [ebp-2Ch]
  int v40; // [esp+80h] [ebp-28h]
  int v41; // [esp+84h] [ebp-24h]
  int v42; // [esp+88h] [ebp-20h]
  int v43; // [esp+8Ch] [ebp-1Ch]
  int v44; // [esp+90h] [ebp-18h]
  int v45; // [esp+94h] [ebp-14h]
  int v46; // [esp+98h] [ebp-10h]
  int v47; // [esp+9Ch] [ebp-Ch]
  int v48; // [esp+A0h] [ebp-8h]
  int v49; // [esp+A4h] [ebp-4h]

  v0 = byte_455CAA;
  if ( byte_455CAA && !byte_455C13 )
  {
    v0 = 0;
    byte_455CAA = 0;
  }
  if ( (dword_44B728 && *(_BYTE *)(dword_44B728 + 4) & 2 || !byte_455C13 || byte_44B811) && !v0 )
  {
    v1 = dword_443D2C;
    result = *((_DWORD *)dword_443D2C + 16032);
    *((_DWORD *)dword_443D2C + 16032) = result + 88;
    *(_DWORD *)(result + 4) = 0;
    *(_DWORD *)result = v1[26];
    v1[26] = result;
    *(_DWORD *)(result + 4) = 3;
    *(_BYTE *)(result + 26) = 0;
    *(_BYTE *)(result + 25) = 0;
    *(_BYTE *)(result + 24) = 0;
    *(_DWORD *)(result + 8) = -1063256064;
    *(_DWORD *)(result + 12) = -1063256064;
    v3 = (unsigned __int16)dword_455BE4;
    *(_DWORD *)(result + 32) = -1063256064;
    *(_DWORD *)(result + 48) = -1063256064;
    *(float *)(result + 28) = (double)v3;
    *(float *)(result + 52) = (double)HIWORD(dword_455BE4);
    *(float *)(result + 68) = (double)(unsigned __int16)dword_455BE4;
    LOWORD(v1) = HIWORD(dword_455BE4);
    *(_DWORD *)(result + 16) = 0;
    *(_DWORD *)(result + 20) = 1065353216;
    *(_DWORD *)(result + 36) = 0;
    *(_DWORD *)(result + 40) = 1065353216;
    *(_DWORD *)(result + 56) = 0;
    *(float *)(result + 72) = (double)(unsigned __int16)v1;
    *(_DWORD *)(result + 60) = 1065353216;
    *(_DWORD *)(result + 76) = 0;
    *(_DWORD *)(result + 80) = 1065353216;
  }
  else
  {
    v38 = 1065353216;
    v39 = 0;
    v40 = 0;
    v41 = 0;
    v42 = 1065353216;
    v43 = 0;
    v44 = 0;
    v45 = 0;
    v46 = 1065353216;
    v47 = 0;
    v48 = 0;
    v49 = 0;
    v14 = 1.0;
    v15 = 0;
    v16 = 0.0;
    v17 = 0;
    v18 = 1065353216;
    v19 = 0;
    v20 = 0.0;
    v21 = 0;
    v22 = 1.0;
    v23 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 1065353216;
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v30 = 1065353216;
    v31 = 0;
    v32 = 0;
    v33 = 0;
    v34 = 1065353216;
    v35 = 0;
    v36 = 0.0;
    v37 = 0;
    if ( byte_455CA5
      || (_BYTE)dword_455CB0
      || byte_455CA9
      || !dword_44B728
      || (v4 = *(_DWORD *)(dword_44B728 + 4), BYTE1(v4) & 1) )
    {
      HIWORD(v6) = HIWORD(dword_455C18);
    }
    else
    {
      v5 = (signed __int64)(*(float *)&dword_44B764 * -76.799995);
      v6 = v5 + dword_455C18;
      dword_455C18 += v5;
    }
    sub_408060(SHIWORD(v6), (int)&v38);
    v7 = *(float *)&dword_4489FC - *(float *)&dword_448A08;
    v8 = *(float *)&dword_448A04 - *(float *)&dword_448A10;
    v9 = v8;
    v10 = v8 * v9 + v7 * v7;
    v11 = AGLSqrt(v10);
    v12 = v7 / v11;
    v13 = v9 / v11;
    v20 = v12;
    v14 = v13;
    v16 = -v12;
    v22 = v13;
    sub_408100((float *)&v38, &v14, (float *)&v26);
    v37 = 1166016512;
    v36 = (*(float *)&dword_448A00 - flt_455C0C) * 10000.0 / (flt_455C08 - flt_455C0C) - 512.0;
    sub_40AB10(&v26);
    result = sub_408890((int)&dword_448AD4, dword_4489E0[dword_4489F8]);
  }
  return result;
}
// 4489E0: using guessed type int dword_4489E0[];
// 4489F8: using guessed type int dword_4489F8;
// 4489FC: using guessed type int dword_4489FC;
// 448A00: using guessed type int dword_448A00;
// 448A04: using guessed type int dword_448A04;
// 448A08: using guessed type int dword_448A08;
// 448A10: using guessed type int dword_448A10;
// 448AD4: using guessed type int dword_448AD4;
// 44B728: using guessed type int dword_44B728;
// 44B764: using guessed type int dword_44B764;
// 44B811: using guessed type char byte_44B811;
// 455BE4: using guessed type int dword_455BE4;
// 455C08: using guessed type float flt_455C08;
// 455C0C: using guessed type float flt_455C0C;
// 455C13: using guessed type char byte_455C13;
// 455C18: using guessed type int dword_455C18;
// 455C1C: using guessed type int dword_455C1C;
// 455CA5: using guessed type char byte_455CA5;
// 455CA9: using guessed type char byte_455CA9;
// 455CAA: using guessed type char byte_455CAA;
// 455CB0: using guessed type int dword_455CB0;

//----- (0040B560) --------------------------------------------------------
char sub_40B560()
{
  int v0; // edi
  unsigned int *v1; // esi
  char result; // al

  if ( dword_455C30 )
  {
    v0 = dword_455C30;
    v1 = (unsigned int *)(dword_455C2C + 48);
    do
    {
      sub_401380(*v1);
      v1 += 14;
      --v0;
    }
    while ( v0 );
  }
  result = sub_401380(dword_455C2C);
  dword_455C2C = 0;
  return result;
}
// 455C2C: using guessed type int dword_455C2C;
// 455C30: using guessed type int dword_455C30;

//----- (0040B5B0) --------------------------------------------------------
char __cdecl sub_40B5B0(int a1)
{
  void *v1; // edi

  dword_455C30 = 0;
  if ( a1 )
  {
    v1 = (void *)sub_401250(56 * a1);
    dword_455C2C = (int)v1;
    if ( !v1 )
      return 0;
    dword_455C30 = a1;
    memset(v1, 0, 56 * a1);
  }
  return 1;
}
// 455C2C: using guessed type int dword_455C2C;
// 455C30: using guessed type int dword_455C30;

//----- (0040B610) --------------------------------------------------------
char __cdecl sub_40B610(int a1, int a2, int a3)
{
  int v4; // eax

  if ( a2 + a3 )
  {
    v4 = sub_401250(8 * a2 + 10 * a3);
    *(_DWORD *)(a1 + 52) = v4 + 8 * a2;
    *(_WORD *)(a1 + 6) = a3;
    *(_DWORD *)(a1 + 48) = v4;
    *(_WORD *)(a1 + 4) = a2;
  }
  return 1;
}

//----- (0040B660) --------------------------------------------------------
int sub_40B660()
{
  int result; // eax
  int v1; // edx
  unsigned __int8 v2; // cl
  unsigned __int8 v3; // al
  int v4; // eax
  int v5; // ecx
  unsigned __int16 *v6; // eax
  int v7; // edi
  unsigned __int16 v8; // cx
  float *v9; // ecx
  unsigned __int16 *v10; // eax
  int v11; // ebp
  unsigned __int16 v12; // cx
  float *v13; // ecx
  unsigned __int8 v14; // [esp+0h] [ebp-10h]
  unsigned __int8 v15; // [esp+4h] [ebp-Ch]
  int v16; // [esp+8h] [ebp-8h]

  result = dword_455C30;
  v1 = dword_455C2C;
  if ( (unsigned __int8)byte_455C35 < 2u )
  {
    byte_455C34 = 0;
  }
  else
  {
    byte_455C35 = 0;
    byte_455C34 = 1;
  }
  if ( dword_455C30 )
  {
    v16 = dword_455C30;
    do
    {
      if ( byte_455C34 )
      {
        v2 = *(_BYTE *)(v1 + 2);
        v3 = *(_BYTE *)(v1 + 3) + 1;
        *(_BYTE *)(v1 + 3) = v3;
        if ( v3 >= v2 )
          *(_BYTE *)(v1 + 3) = 0;
      }
      v4 = *(unsigned __int8 *)(v1 + 3);
      v14 = *(_BYTE *)(v1 + 4 * v4 + 8);
      v5 = *(unsigned __int16 *)(v1 + 4);
      v15 = *(_BYTE *)(v1 + 4 * v4 + 9);
      v6 = *(unsigned __int16 **)(v1 + 48);
      if ( (_WORD)v5 )
      {
        v7 = *(unsigned __int16 *)(v1 + 4);
        do
        {
          v8 = *v6;
          v6 += 4;
          v9 = (float *)(dword_448AB4 + 104 * v8);
          v9[8] = (double)(v14 + *((unsigned __int8 *)v6 - 6)) * 0.0039215689;
          v9[9] = (double)(v15 + *((unsigned __int8 *)v6 - 5)) * 0.0039215689;
          v9[15] = (double)(v14 + *((unsigned __int8 *)v6 - 4)) * 0.0039215689;
          v9[16] = (double)(v15 + *((unsigned __int8 *)v6 - 3)) * 0.0039215689;
          v9[22] = (double)(v14 + *((unsigned __int8 *)v6 - 4)) * 0.0039215689;
          --v7;
          v9[23] = (double)(v15 + *((unsigned __int8 *)v6 - 3)) * 0.0039215689;
        }
        while ( v7 );
      }
      v10 = *(unsigned __int16 **)(v1 + 52);
      v11 = *(unsigned __int16 *)(v1 + 6);
      if ( (_WORD)v11 )
      {
        do
        {
          v12 = *v10;
          v10 += 5;
          v13 = (float *)(dword_448AB8 + 132 * v12);
          v13[8] = (double)(v14 + *((unsigned __int8 *)v10 - 8)) * 0.0039215689;
          v13[9] = (double)(v15 + *((unsigned __int8 *)v10 - 7)) * 0.0039215689;
          v13[15] = (double)(v14 + *((unsigned __int8 *)v10 - 6)) * 0.0039215689;
          v13[16] = (double)(v15 + *((unsigned __int8 *)v10 - 5)) * 0.0039215689;
          v13[22] = (double)(v14 + *((unsigned __int8 *)v10 - 4)) * 0.0039215689;
          v13[23] = (double)(v15 + *((unsigned __int8 *)v10 - 3)) * 0.0039215689;
          v13[29] = (double)(v14 + *((unsigned __int8 *)v10 - 2)) * 0.0039215689;
          --v11;
          v13[30] = (double)(v15 + *((unsigned __int8 *)v10 - 1)) * 0.0039215689;
        }
        while ( v11 );
      }
      v1 += 56;
      result = v16-- - 1;
    }
    while ( v16 );
  }
  return result;
}
// 448AB4: using guessed type int dword_448AB4;
// 448AB8: using guessed type int dword_448AB8;
// 455C2C: using guessed type int dword_455C2C;
// 455C30: using guessed type int dword_455C30;
// 455C34: using guessed type char byte_455C34;
// 455C35: using guessed type char byte_455C35;

//----- (0040B8D0) --------------------------------------------------------
_DWORD *sub_40B8D0()
{
  _DWORD *result; // eax
  unsigned int v1; // ecx

  result = &unk_448B60;
  v1 = 0;
  while ( result[628] )
  {
    result += 634;
    if ( ++v1 >= 4 )
      return 0;
  }
  if ( v1 >= 4 )
    return 0;
  result[1] = 4;
  return result;
}

//----- (0040B900) --------------------------------------------------------
char *sub_40B900()
{
  char *result; // eax
  signed int v1; // ecx

  result = (char *)&unk_449530;
  v1 = 4;
  do
  {
    result[18] = 0;
    *(_DWORD *)result = 0;
    result += 2536;
    --v1;
  }
  while ( v1 );
  return result;
}

//----- (0040B920) --------------------------------------------------------
int __cdecl sub_40B920(int a1, float a2, float a3, float a4)
{
  int v4; // eax
  double v5; // st7
  double v6; // st6
  double v7; // st5
  int v8; // eax
  signed int v9; // edx
  int result; // eax

  v4 = *(_DWORD *)(a1 + 4);
  if ( v4 & 1 )
  {
    if ( v4 & 2 )
    {
      LOBYTE(v4) = v4 & 0xFD;
      *(_DWORD *)(a1 + 4) = v4;
    }
    else
    {
      v5 = a2 - *(float *)(a1 + 2516);
      v6 = a3 - *(float *)(a1 + 2520);
      v7 = a4 - *(float *)(a1 + 2524);
      v8 = a1 + 8;
      v9 = 25;
      do
      {
        if ( *(_BYTE *)(v8 + 86) )
        {
          *(float *)v8 = *(float *)v8 - v5;
          *(float *)(v8 + 4) = *(float *)(v8 + 4) - v6;
          *(float *)(v8 + 8) = *(float *)(v8 + 8) - v7;
        }
        v8 += 100;
        --v9;
      }
      while ( v9 );
    }
  }
  *(float *)(a1 + 2516) = a2;
  result = LODWORD(a4);
  *(float *)(a1 + 2520) = a3;
  *(float *)(a1 + 2524) = a4;
  return result;
}

//----- (0040B9B0) --------------------------------------------------------
int __cdecl sub_40B9B0(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, unsigned __int8 a5, unsigned __int8 a6, unsigned __int8 a7)
{
  double v7; // st7
  double v8; // st6
  int result; // eax
  signed int v10; // ecx
  double v11; // st5
  double v12; // st4

  v7 = (double)a5 * 0.0039215689;
  v8 = (double)a4 * 0.0039215689;
  result = *(_DWORD *)(*(_DWORD *)(a1 + 2508) + 4) + 14;
  v10 = 25;
  v11 = (double)a6 * 0.0039215689;
  v12 = (double)a7 * 0.0039215689;
  do
  {
    *(_WORD *)(result - 2) = a2;
    *(_WORD *)result = a3;
    *(float *)(result + 22) = v8;
    *(float *)(result + 26) = v7;
    *(float *)(result + 50) = v11;
    *(float *)(result + 54) = v7;
    *(float *)(result + 78) = v8;
    *(float *)(result + 82) = v12;
    *(float *)(result + 106) = v11;
    *(float *)(result + 110) = v12;
    result += 128;
    --v10;
  }
  while ( v10 );
  return result;
}

//----- (0040BA70) --------------------------------------------------------
void __usercall sub_40BA70(int a1@<ebx>)
{
  _DWORD *v1; // esi
  signed int v2; // edi

  sub_409D20(-255);
  v1 = &unk_448B60;
  v2 = 4;
  do
  {
    if ( v1[628] )
      sub_40BAB0(a1, (int)v1);
    v1 += 634;
    --v2;
  }
  while ( v2 );
}

//----- (0040BAB0) --------------------------------------------------------
void __usercall sub_40BAB0(int a1@<ebx>, int a2)
{
  int v2; // edi
  int v3; // ebp
  char v4; // bl
  int v5; // esi
  _DWORD *v6; // eax
  int v7; // ecx
  int v8; // edx
  _BYTE *v9; // eax
  bool v10; // zf
  __int16 v11; // dx
  __int16 v12; // cx
  char v13; // al
  char v14; // al
  unsigned int v15; // [esp+10h] [ebp-1Ch]
  unsigned int v16; // [esp+14h] [ebp-18h]
  int v17; // [esp+18h] [ebp-14h]
  int v18; // [esp+1Ch] [ebp-10h]
  signed int v19; // [esp+20h] [ebp-Ch]
  __int16 v20; // [esp+24h] [ebp-8h]
  char v21; // [esp+30h] [ebp+4h]

  v2 = a2;
  v15 = 0;
  v16 = 0;
  v3 = *(_DWORD *)(a2 + 2508);
  v4 = *(_BYTE *)(a2 + 4) & 4;
  v5 = a2 + 8;
  v20 = *(_WORD *)(a2 + 2528);
  v21 = *(_BYTE *)(a2 + 4) & 4;
  if ( v4 )
    *(_DWORD *)(v2 + 4) &= 0xFFFFFFFB;
  v18 = 0;
  v17 = 0;
  v19 = 25;
  do
  {
    if ( !*(_BYTE *)(v5 + 86) || v4 )
    {
      *(_BYTE *)(v5 + 86) = 0;
      if ( v16 < *(unsigned __int8 *)(v2 + 2531) && *(_BYTE *)(v2 + 2530) && byte_455C14 )
      {
        (*(void (__cdecl **)(int, int))(v2 + 2512))(v2, v5);
        *(_BYTE *)(v5 + 86) = *(_BYTE *)(v5 + 87);
        ++v16;
      }
    }
    if ( *(_BYTE *)(v5 + 86) )
    {
      v6 = (_DWORD *)(v17 + *(_DWORD *)v3);
      *v6 = *(_DWORD *)v5;
      v6[1] = *(_DWORD *)(v5 + 4);
      v7 = *(_DWORD *)(v5 + 8);
      HIWORD(v8) = 0;
      v6[2] = v7;
      if ( v15 >= *(unsigned __int16 *)(v3 + 10) )
      {
        v9 = 0;
      }
      else
      {
        HIWORD(v7) = HIWORD(v18);
        v9 = (_BYTE *)(v18 + *(_DWORD *)(v3 + 4));
      }
      LOWORD(v7) = *(_WORD *)(v5 + 90);
      LOWORD(v8) = *(_WORD *)(v5 + 92);
      LOWORD(a1) = *(_WORD *)(v5 + 88);
      a1 >>= 7;
      v9[34] = a1;
      v9[33] = v7 >> 7;
      v9[32] = v8 >> 7;
      if ( byte_455C14 )
      {
        v10 = *(_WORD *)(v5 + 84) == 0;
        *(float *)(v5 + 76) = (double)v20 + *(float *)(v5 + 76);
        if ( !v10 && *(unsigned __int8 *)(v5 + 86) % *(signed __int16 *)(v5 + 84) )
        {
          if ( *(float *)(v5 + 36) < (double)*(float *)(v5 + 48) && *(float *)(v5 + 36) > (double)*(float *)(v5 + 60) )
            *(float *)(v5 + 36) = *(float *)(v5 + 72) + *(float *)(v5 + 36);
          if ( *(float *)(v5 + 40) < (double)*(float *)(v5 + 52) && *(float *)(v5 + 40) > (double)*(float *)(v5 + 64) )
            *(float *)(v5 + 40) = *(float *)(v5 + 76) + *(float *)(v5 + 40);
          if ( *(float *)(v5 + 44) < (double)*(float *)(v5 + 56) && *(float *)(v5 + 44) > (double)*(float *)(v5 + 68) )
            *(float *)(v5 + 44) = *(float *)(v5 + 80) + *(float *)(v5 + 44);
        }
        if ( *(float *)v5 < (double)*(float *)(v5 + 12) && *(float *)v5 > (double)*(float *)(v5 + 24) )
          *(float *)v5 = *(float *)(v5 + 36) + *(float *)v5;
        if ( *(float *)(v5 + 4) < (double)*(float *)(v5 + 16) && *(float *)(v5 + 4) > (double)*(float *)(v5 + 28) )
          *(float *)(v5 + 4) = *(float *)(v5 + 40) + *(float *)(v5 + 4);
        if ( *(float *)(v5 + 8) < (double)*(float *)(v5 + 20) && *(float *)(v5 + 8) > (double)*(float *)(v5 + 32) )
          *(float *)(v5 + 8) = *(float *)(v5 + 44) + *(float *)(v5 + 8);
        v11 = *(_WORD *)(v5 + 94);
        *(_WORD *)(v5 + 90) += *(_WORD *)(v5 + 96);
        v12 = *(_WORD *)(v5 + 98);
        v13 = *(_BYTE *)(v5 + 86);
        *(_WORD *)(v5 + 88) += v11;
        *(_WORD *)(v5 + 92) += v12;
        *(_BYTE *)(v5 + 86) = v13 - 1;
      }
      v4 = v21;
      ++v15;
      v17 += 12;
      v18 += 128;
    }
    v5 += 100;
    --v19;
  }
  while ( v19 );
  if ( byte_455C14 )
  {
    v14 = *(_BYTE *)(v2 + 2530);
    if ( v14 )
    {
      if ( v14 != -1 )
        *(_BYTE *)(v2 + 2530) = v14 - 1;
    }
  }
  if ( v15 )
    sub_40A060((_DWORD *)v3, (_DWORD *)(v2 + 2516), 0, v15);
  else
    *(_DWORD *)(v2 + 2512) = 0;
}
// 455C14: using guessed type char byte_455C14;

//----- (0040BD60) --------------------------------------------------------
char sub_40BD60()
{
  int v0; // eax
  _DWORD *v1; // esi
  signed int v2; // ebp
  float *v3; // edi
  float *v4; // ebx
  _DWORD *v5; // eax
  float *v6; // ecx
  int v7; // ecx

  if ( dword_455BF8 == 1 )
  {
    v0 = *(_DWORD *)(LODWORD(dword_44B71C) + 180);
    v1 = &unk_448B60;
    v2 = 4;
    v3 = (float *)(v0 + 2596);
    v4 = (float *)(v0 + 1652);
    do
    {
      v5 = (_DWORD *)v1[628];
      if ( v5 )
      {
        v6 = (float *)v1[633];
        if ( v6 )
        {
          LOBYTE(v5) = *(_BYTE *)v1;
          if ( *(_BYTE *)v1 == 5 || (_BYTE)v5 == 6 || (_BYTE)v5 == 7 )
          {
            if ( v6 == v3 )
            {
              LOBYTE(v5) = sub_40B920((int)v1, v3[23], v3[24], v3[25]);
            }
            else if ( v6 == v4 )
            {
              LOBYTE(v5) = sub_40B920((int)v1, v4[23], v4[24], v4[25]);
            }
          }
        }
      }
      v1 += 634;
      --v2;
    }
    while ( v2 );
  }
  else
  {
    v5 = &unk_448B60;
    v7 = 0;
    while ( !v5[628] || !v5[633] || *(_BYTE *)v5 != 3 )
    {
      v5 += 634;
      if ( (unsigned __int16)++v7 >= 4u )
        return (char)v5;
    }
    LOBYTE(v5) = sub_40B920((int)v5, *(float *)(v5[633] + 92), *(float *)(v5[633] + 96), *(float *)(v5[633] + 100));
  }
  return (char)v5;
}
// 455BF8: using guessed type int dword_455BF8;

//----- (0040BE40) --------------------------------------------------------
int __cdecl sub_40BE40(int a1, float a2, int a3, int a4)
{
  int result; // eax

  result = a1;
  *(float *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  *(_DWORD *)(a1 + 8) = a4;
  return result;
}

//----- (0040BE60) --------------------------------------------------------
int __cdecl sub_40BE60(int a1, float a2, int a3, int a4)
{
  int result; // eax

  result = a1;
  *(float *)(a1 + 24) = a2;
  *(_DWORD *)(a1 + 28) = a3;
  *(_DWORD *)(a1 + 32) = a4;
  return result;
}

//----- (0040BE80) --------------------------------------------------------
int __cdecl sub_40BE80(int a1, float a2, int a3, int a4)
{
  int result; // eax

  result = a1;
  *(float *)(a1 + 12) = a2;
  *(_DWORD *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 20) = a4;
  return result;
}

//----- (0040BEA0) --------------------------------------------------------
int __cdecl sub_40BEA0(int a1, float a2, int a3, int a4)
{
  int result; // eax

  result = a1;
  *(float *)(a1 + 36) = a2;
  *(_DWORD *)(a1 + 40) = a3;
  *(_DWORD *)(a1 + 44) = a4;
  return result;
}

//----- (0040BEC0) --------------------------------------------------------
int __cdecl sub_40BEC0(int a1, float a2, int a3, int a4)
{
  int result; // eax

  result = a1;
  *(float *)(a1 + 60) = a2;
  *(_DWORD *)(a1 + 64) = a3;
  *(_DWORD *)(a1 + 68) = a4;
  return result;
}

//----- (0040BEE0) --------------------------------------------------------
int __cdecl sub_40BEE0(int a1, float a2, int a3, int a4)
{
  int result; // eax

  result = a1;
  *(float *)(a1 + 48) = a2;
  *(_DWORD *)(a1 + 52) = a3;
  *(_DWORD *)(a1 + 56) = a4;
  return result;
}

//----- (0040BF00) --------------------------------------------------------
int __cdecl sub_40BF00(int a1, float a2, int a3, int a4, __int16 a5)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 76) = a3;
  *(_DWORD *)(a1 + 80) = a4;
  *(float *)(a1 + 72) = a2;
  *(_WORD *)(a1 + 84) = a5;
  return result;
}

//----- (0040BF30) --------------------------------------------------------
__int16 __cdecl sub_40BF30(_WORD *a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int16 a5)
{
  int v5; // eax

  LOWORD(v5) = a2;
  a1[44] = a2;
  a1[45] = a3;
  a1[46] = a4;
  if ( a5 )
  {
    a1[47] = -(a2 / (signed int)a5);
    a1[48] = -(a3 / (signed int)a5);
    v5 = -(a4 / (signed int)a5);
    a1[49] = v5;
  }
  return v5;
}

//----- (0040BF90) --------------------------------------------------------
int __cdecl sub_40BF90(_WORD *a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int16 a5)
{
  int result; // eax

  if ( a5 )
  {
    a1[47] = -(a2 / (signed int)a5);
    a1[48] = -(a3 / (signed int)a5);
    result = -(a4 / (signed int)a5);
    a1[49] = result;
  }
  return result;
}

//----- (0040BFD0) --------------------------------------------------------
_DWORD *sub_40BFD0()
{
  int v0; // esi
  int v1; // esi
  int v2; // edx
  int v3; // edx
  signed int v4; // ecx
  _DWORD *v5; // eax
  signed int v6; // ebx
  int v7; // edx
  signed int v8; // ecx
  _DWORD *v9; // eax
  signed int v10; // ebx
  int v11; // edx
  signed int v12; // ecx
  _DWORD *v13; // eax
  int v14; // edx
  _DWORD *result; // eax
  signed int v16; // [esp+10h] [ebp-8h]
  signed int v17; // [esp+10h] [ebp-8h]
  _DWORD *v18; // [esp+14h] [ebp-4h]

  sub_40A000(7);
  sub_40C1F0();
  v0 = dword_448ACC;
  v18 = (_DWORD *)dword_448ACC;
  sub_409F10(dword_448ACC, 0x36u);
  v1 = *(_DWORD *)(v0 + 4);
  v16 = 8;
  do
  {
    *(_WORD *)(v1 + 12) = 16;
    *(_WORD *)(v1 + 14) = 16;
    *(_DWORD *)(v1 + 8) = sub_401000(0, 1, 1024, 256);
    v2 = *(_DWORD *)(v1 + 4);
    BYTE1(v2) |= 1u;
    *(_DWORD *)(v1 + 4) = v2;
    *(_BYTE *)(v1 + 34) = 100;
    *(_BYTE *)(v1 + 33) = 100;
    *(_BYTE *)(v1 + 32) = 100;
    *(_DWORD *)(v1 + 36) = 0;
    *(_DWORD *)(v1 + 40) = 0;
    *(_DWORD *)(v1 + 64) = 1030811889;
    *(_DWORD *)(v1 + 68) = 0;
    *(_DWORD *)(v1 + 92) = 0;
    *(_DWORD *)(v1 + 96) = 1030811889;
    *(_DWORD *)(v1 + 120) = 1030811889;
    *(_DWORD *)(v1 + 124) = 1030811889;
    v1 += 128;
    --v16;
  }
  while ( v16 );
  v17 = 30;
  do
  {
    *(_WORD *)(v1 + 12) = 16;
    *(_WORD *)(v1 + 14) = 16;
    *(_DWORD *)(v1 + 8) = sub_401000(0, 1, 1024, 256);
    v3 = *(_DWORD *)(v1 + 4);
    BYTE1(v3) |= 1u;
    *(_DWORD *)(v1 + 4) = v3;
    *(_BYTE *)(v1 + 34) = 100;
    *(_BYTE *)(v1 + 33) = 100;
    *(_BYTE *)(v1 + 32) = 100;
    *(_DWORD *)(v1 + 36) = 0;
    *(_DWORD *)(v1 + 40) = 0;
    *(_DWORD *)(v1 + 64) = 1030811889;
    *(_DWORD *)(v1 + 68) = 0;
    *(_DWORD *)(v1 + 92) = 0;
    *(_DWORD *)(v1 + 96) = 1030811889;
    *(_DWORD *)(v1 + 120) = 1030811889;
    *(_DWORD *)(v1 + 124) = 1030811889;
    v1 += 128;
    --v17;
  }
  while ( v17 );
  v4 = 30;
  v5 = (_DWORD *)(*v18 + 96);
  do
  {
    *v5 = 0;
    v5[1] = 0;
    v5[2] = 0;
    v5 += 3;
    --v4;
  }
  while ( v4 );
  v6 = 5;
  do
  {
    *(_WORD *)(v1 + 12) = 200;
    *(_WORD *)(v1 + 14) = 200;
    *(_DWORD *)(v1 + 8) = sub_401000(0, 1, 1024, 256);
    v7 = *(_DWORD *)(v1 + 4);
    BYTE1(v7) |= 1u;
    *(_DWORD *)(v1 + 4) = v7;
    v1 += 128;
    --v6;
  }
  while ( v6 );
  v8 = 5;
  v9 = (_DWORD *)(*v18 + 456);
  do
  {
    *v9 = 0;
    v9[1] = 0;
    v9[2] = 0;
    v9 += 3;
    --v8;
  }
  while ( v8 );
  v10 = 10;
  do
  {
    *(_WORD *)(v1 + 12) = 225;
    *(_WORD *)(v1 + 14) = 150;
    *(_DWORD *)(v1 + 8) = sub_401000(0, 1, 1024, 256);
    v11 = *(_DWORD *)(v1 + 4);
    BYTE1(v11) |= 1u;
    *(_DWORD *)(v1 + 4) = v11;
    v1 += 128;
    --v10;
  }
  while ( v10 );
  v12 = 10;
  v13 = (_DWORD *)(*v18 + 516);
  do
  {
    *v13 = 0;
    v13[1] = 0;
    v13[2] = 0;
    v13 += 3;
    --v12;
  }
  while ( v12 );
  *(_WORD *)(v1 + 12) = 200;
  *(_WORD *)(v1 + 14) = 150;
  *(_DWORD *)(v1 + 8) = sub_401000(0, 1, 1024, 430);
  v14 = *(_DWORD *)(v1 + 4);
  BYTE1(v14) |= 1u;
  *(_DWORD *)(v1 + 4) = v14;
  result = (_DWORD *)(*v18 + 636);
  *result = 0;
  result[1] = 0;
  result[2] = 0;
  return result;
}
// 448ACC: using guessed type int dword_448ACC;

//----- (0040C1F0) --------------------------------------------------------
int sub_40C1F0()
{
  char *v0; // ebx
  unsigned int v1; // ebp
  int v2; // ST08_4
  signed int v3; // edi
  int *v4; // esi
  int v5; // ecx
  int result; // eax

  v0 = (char *)&unk_44952C;
  v1 = 36;
  do
  {
    memset(v0 - 2508, 0, 0x9E8u);
    v2 = v1 + dword_448ACC;
    *(_DWORD *)v0 = v1 + dword_448ACC;
    sub_409F10(v2, 0x19u);
    v3 = 25;
    v4 = (int *)(*(_DWORD *)(*(_DWORD *)v0 + 4) + 4);
    do
    {
      v5 = *v4;
      BYTE1(v5) |= 1u;
      *v4 = v5;
      result = sub_401000(0, 1, 1024, 256);
      v4[1] = result;
      v4 += 32;
      --v3;
    }
    while ( v3 );
    v1 += 12;
    v0 += 2536;
  }
  while ( v1 < 0x54 );
  return result;
}
// 448ACC: using guessed type int dword_448ACC;

//----- (0040C270) --------------------------------------------------------
int __cdecl sub_40C270(float a1, float a2, float a3, int a4, int a5)
{
  _DWORD *v5; // eax
  int v6; // esi
  double v7; // st7
  signed int v8; // eax
  int result; // eax
  float v10; // [esp+1Ch] [ebp+14h]

  v5 = dword_443D2C;
  v6 = *((_DWORD *)dword_443D2C + 16032);
  *((_DWORD *)dword_443D2C + 16032) = v6 + 128;
  *(_DWORD *)(v6 + 4) = 0;
  *(_DWORD *)v6 = v5[30];
  v5[30] = v6;
  *(_DWORD *)(v6 + 4) = 261;
  *(_DWORD *)(v6 + 24) = 0;
  v7 = a2 + a1;
  *(float *)(v6 + 44) = v7;
  v8 = (signed int)((unsigned __int64)(438086664345i64 * (unsigned __int8)a5) >> 32) >> 2;
  *(float *)(v6 + 16) = a2;
  v10 = a3 - 80.0;
  LOBYTE(v8) = (v8 < 0) + v8;
  *(float *)(v6 + 72) = a2;
  *(_BYTE *)(v6 + 34) = v8;
  *(_BYTE *)(v6 + 33) = v8;
  *(_BYTE *)(v6 + 32) = v8;
  *(float *)(v6 + 20) = a3;
  *(float *)(v6 + 48) = a3;
  *(float *)(v6 + 76) = v10;
  *(float *)(v6 + 104) = v10;
  *(float *)(v6 + 100) = v7;
  *(_DWORD *)(v6 + 28) = 1065353216;
  *(_DWORD *)(v6 + 56) = 1065353216;
  *(_DWORD *)(v6 + 84) = 1065353216;
  *(_DWORD *)(v6 + 112) = 1065353216;
  *(_DWORD *)(v6 + 40) = 1048608897;
  *(_DWORD *)(v6 + 68) = 1048608897;
  *(_DWORD *)(v6 + 52) = 0;
  *(_DWORD *)(v6 + 80) = 0;
  *(_DWORD *)(v6 + 108) = 0;
  *(_DWORD *)(v6 + 36) = 0;
  *(_DWORD *)(v6 + 64) = 1039726841;
  *(_DWORD *)(v6 + 92) = 0;
  *(_DWORD *)(v6 + 96) = 1052688063;
  *(_DWORD *)(v6 + 120) = 1039726841;
  *(_DWORD *)(v6 + 124) = 1052688063;
  result = sub_401000(0, 1, 1024, 320);
  *(_DWORD *)(v6 + 8) = result;
  return result;
}

//----- (0040C370) --------------------------------------------------------
int __cdecl sub_40C370(int a1, int a2)
{
  *(_DWORD *)(a1 + 2512) = sub_40C3E0;
  *(_BYTE *)a1 = 0;
  *(_DWORD *)(a1 + 2532) = a2;
  sub_40B920(a1, dword_44B73C, dword_44B740, dword_44B744);
  *(_BYTE *)(a1 + 2530) = 1;
  *(_BYTE *)(a1 + 2531) = 8;
  *(_WORD *)(a1 + 2528) = 1;
  return sub_40B9B0(a1, 0xA4u, 0x64u, 0, 0, 0x10u, 0x10u);
}

//----- (0040C3E0) --------------------------------------------------------
__int16 __cdecl sub_40C3E0(int a1, int a2)
{
  unsigned __int8 v2; // bl
  int v3; // eax
  unsigned int v4; // edx
  int v5; // edi
  int v6; // eax
  unsigned int v7; // eax
  int v8; // ST40_4
  float v9; // ST3C_4

  v2 = 25 * rand() / 0x7FFF + 15;
  *(_BYTE *)(a2 + 87) = v2;
  v3 = rand();
  v4 = (signed int)(100 * v3 + ((unsigned __int64)(-214741810900i64 * v3) >> 32)) >> 14;
  v5 = v4 + (v4 >> 31) - 50;
  v6 = rand();
  v7 = (signed int)(500 * v6 + ((unsigned __int64)(-1073709054500i64 * v6) >> 32)) >> 14;
  *(float *)&v8 = (double)(signed __int16)(v7 + (v7 >> 31) - 450);
  v9 = (double)(signed __int16)v5;
  sub_40BE40(a2, v9, v8, 0);
  sub_40BE80(a2, 1000.0, 1148846080, 1148846080);
  sub_40BE60(a2, -1000.0, -998637568, -998637568);
  sub_40BEA0(a2, 0.0, -1069547520, 0);
  sub_40BEE0(a2, 100.0, 1120403456, 1120403456);
  sub_40BEC0(a2, -100.0, -1027080192, -1027080192);
  sub_40BF00(a2, 0.0, -1073741824, 0, 1);
  return sub_40BF30((_WORD *)a2, 32640, 32640, 32640, v2);
}

//----- (0040C520) --------------------------------------------------------
int __cdecl sub_40C520(int a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 2532) = a2;
  *(_DWORD *)(a1 + 2512) = sub_40C580;
  *(_BYTE *)a1 = 2;
  *(_DWORD *)(a1 + 4) = v2 | 3;
  *(_BYTE *)(a1 + 2530) = 1;
  *(_BYTE *)(a1 + 2531) = 8;
  *(_WORD *)(a1 + 2528) = 1;
  return sub_40B9B0(a1, 0x60u, 0x40u, 0, 0, 0x10u, 0x10u);
}

//----- (0040C580) --------------------------------------------------------
__int16 __cdecl sub_40C580(float a1, float a2)
{
  __int16 result; // ax
  int v3; // eax
  int v4; // esi
  unsigned int v5; // edx
  int v6; // ebx
  float v7; // ST24_4
  int v8; // eax
  unsigned int v9; // edx
  float v10; // ST24_4
  float v11; // [esp+18h] [ebp+4h]
  int v12; // [esp+18h] [ebp+4h]
  float v13; // [esp+1Ch] [ebp+8h]

  result = LOWORD(a1);
  if ( *(_BYTE *)LODWORD(a1) == 2 )
  {
    v3 = rand();
    v4 = LODWORD(a2);
    v5 = (signed int)(30 * v3 + ((unsigned __int64)(-64422543270i64 * v3) >> 32)) >> 14;
    v6 = (v5 >> 31) + v5;
    *(_BYTE *)(LODWORD(a2) + 87) = v6;
    v11 = (double)(40 * rand() / 0x7FFF + 30);
    if ( byte_44B797 == -1 )
    {
      v7 = -v11;
      sub_40BE40(SLODWORD(a2), v7, 0, 0);
    }
    else
    {
      sub_40BE40(SLODWORD(a2), v11, 0, 0);
    }
    sub_40BE80(SLODWORD(a2), 1000.0, 1148846080, 0);
    sub_40BE60(SLODWORD(a2), -1000.0, -998637568, 0);
    v13 = (double)(10 * rand() / 0x7FFF) + 10.0;
    v8 = rand();
    v9 = (signed int)(-7 * v8 + ((unsigned __int64)(15031926763i64 * v8) >> 32)) >> 14;
    *(float *)&v12 = (double)(signed int)((v9 >> 31) + v9);
    if ( byte_44B797 == -1 )
    {
      v10 = -v13;
      sub_40BEA0(v4, v10, v12, 0);
      sub_40BEE0(v4, 0.0, 0, 0);
      sub_40BEC0(v4, -20.0, -1059061760, 0);
    }
    else
    {
      sub_40BEA0(v4, v13, v12, 0);
      sub_40BEE0(v4, 20.0, 0, 0);
      sub_40BEC0(v4, 0.0, -1059061760, 0);
    }
    sub_40BF00(v4, 0.0, 0, 0, 1);
    result = sub_40BF30((_WORD *)v4, 0x2000, 0x2000, 0x2000, (unsigned __int8)v6);
  }
  return result;
}
// 44B797: using guessed type char byte_44B797;

//----- (0040C730) --------------------------------------------------------
__int16 __cdecl sub_40C730(int a1, int a2)
{
  _WORD *v2; // esi
  unsigned __int8 v3; // bl
  float v4; // ST50_4
  int v5; // ST4C_4
  int v6; // eax
  unsigned int v7; // edx
  int v8; // ST3C_4
  float v9; // ST38_4
  int v10; // ST3C_4
  float v11; // ST38_4
  float v12; // ST50_4
  int v13; // eax
  unsigned int v14; // edx
  int v15; // ST4C_4
  __int16 result; // ax
  int v17; // [esp+24h] [ebp+8h]
  int v18; // [esp+24h] [ebp+8h]

  v2 = (_WORD *)a2;
  v3 = 10 * rand() / 0x7FFF + 20;
  *(_BYTE *)(a2 + 87) = v3;
  v4 = (double)rand() * flt_448B44 * 0.000030518509 - flt_448B44 * 0.5;
  *(float *)&v5 = (double)rand() * flt_448B40 * 0.000030518509 - flt_448B40 * 0.5;
  v6 = rand();
  v7 = (signed int)(200 * v6 + ((unsigned __int64)(-429483621800i64 * v6) >> 32)) >> 14;
  *(float *)&v17 = (double)(signed int)((v7 >> 31) + v7) - 100.0;
  sub_40BE40((int)v2, v4, v5, v17);
  if ( byte_448B48 )
  {
    *(float *)&v8 = flt_448B40 * 0.5;
    v9 = flt_448B44 * 0.5;
    sub_40BE80((int)v2, v9, v8, 1120403456);
    *(float *)&v10 = -(flt_448B40 * 0.5);
    v11 = -(flt_448B44 * 0.5);
    sub_40BE60((int)v2, v11, v10, -1027080192);
  }
  else
  {
    sub_40BE80((int)v2, 1000.0, 1148846080, 1120403456);
    sub_40BE60((int)v2, -1000.0, -998637568, -1027080192);
  }
  v12 = (double)(15 * rand() / 0x7FFF) - 7.0;
  v13 = rand();
  v14 = (signed int)(15 * v13 + ((unsigned __int64)(-32211271635i64 * v13) >> 32)) >> 14;
  *(float *)&v15 = (double)(signed int)((v14 >> 31) + v14) - 8.0;
  *(float *)&v18 = (double)(20 * rand() / 0x7FFF) - 10.0;
  sub_40BEA0((int)v2, v12, v15, v18);
  sub_40BEE0((int)v2, 15.0, 1097859072, 1097859072);
  sub_40BEC0((int)v2, -15.0, -1049624576, -1049624576);
  sub_40BF00((int)v2, 0.0, 0, 0, 1);
  if ( byte_448B48 )
    result = sub_40BF30(v2, 25600, 25600, 25600, v3);
  else
    result = sub_40BF30(v2, 12800, 12800, 7680, v3);
  return result;
}
// 448B40: using guessed type float flt_448B40;
// 448B44: using guessed type float flt_448B44;
// 448B48: using guessed type char byte_448B48;

//----- (0040C9D0) --------------------------------------------------------
_DWORD *__cdecl sub_40C9D0(float a1, float a2, float a3, char a4, int a5, int a6)
{
  _DWORD *result; // eax
  _DWORD *v7; // esi

  result = sub_40B8D0();
  v7 = result;
  if ( result )
  {
    LODWORD(flt_448B44) = a5;
    LODWORD(flt_448B40) = a6;
    byte_448B48 = 0;
    result[628] = sub_40C730;
    *(_BYTE *)result = 13;
    sub_40B920((int)result, a1, a2, a3);
    *((_BYTE *)v7 + 2530) = 1;
    *((_BYTE *)v7 + 2531) = a4;
    *((_WORD *)v7 + 1264) = 1;
    result = (_DWORD *)sub_40B9B0((int)v7, 0x46u, 0x46u, 0x20u, 0x40u, 0x38u, 0x58u);
  }
  return result;
}
// 448B40: using guessed type float flt_448B40;
// 448B44: using guessed type float flt_448B44;
// 448B48: using guessed type char byte_448B48;

//----- (0040CA50) --------------------------------------------------------
_DWORD *__cdecl sub_40CA50(float a1, float a2, float a3, char a4, int a5, int a6)
{
  _DWORD *result; // eax
  _DWORD *v7; // esi

  result = sub_40B8D0();
  v7 = result;
  if ( result )
  {
    LODWORD(flt_448B44) = a5;
    LODWORD(flt_448B40) = a6;
    byte_448B48 = 1;
    result[628] = sub_40C730;
    *(_BYTE *)result = 13;
    sub_40B920((int)result, a1, a2, a3);
    *((_BYTE *)v7 + 2530) = 1;
    *((_BYTE *)v7 + 2531) = a4;
    *((_WORD *)v7 + 1264) = 1;
    result = (_DWORD *)sub_40B9B0((int)v7, 0xA4u, 0x64u, 0, 0, 0x10u, 0x10u);
  }
  return result;
}
// 448B40: using guessed type float flt_448B40;
// 448B44: using guessed type float flt_448B44;
// 448B48: using guessed type char byte_448B48;

//----- (0040CAD0) --------------------------------------------------------
int __cdecl sub_40CAD0(int a1)
{
  *(_DWORD *)(a1 + 2512) = sub_40CB10;
  *(_BYTE *)a1 = 14;
  *(_BYTE *)(a1 + 2530) = 1;
  *(_BYTE *)(a1 + 2531) = 40;
  *(_WORD *)(a1 + 2528) = 1;
  return sub_40B9B0(a1, 0xCu, 0xCu, 0x24u, 0, 0x2Eu, 0xAu);
}

//----- (0040CB10) --------------------------------------------------------
__int16 __cdecl sub_40CB10(int a1, int a2)
{
  int v2; // eax
  _WORD *v3; // esi
  signed int v4; // edx
  unsigned int v5; // eax
  unsigned __int8 v6; // bl
  int v7; // eax
  unsigned int v8; // edx
  float v9; // ST58_4
  float v10; // ST58_4
  int v11; // eax
  unsigned int v12; // edx
  int v13; // ST5C_4
  int v14; // eax
  unsigned int v15; // edx
  int v16; // edi
  int v17; // ebp
  int v18; // ecx
  int v20; // [esp+20h] [ebp+8h]
  int v21; // [esp+20h] [ebp+8h]

  v2 = rand();
  v3 = (_WORD *)a2;
  v4 = (signed int)(25 * v2 + ((unsigned __int64)(-53685452725i64 * v2) >> 32)) >> 14;
  v5 = (unsigned int)(25 * v2 + ((unsigned __int64)(-53685452725i64 * v2) >> 32)) >> 31;
  v6 = v5 + v4;
  *(_BYTE *)(a2 + 87) = v5 + v4;
  v7 = rand();
  v8 = (signed int)(50 * v7 + ((unsigned __int64)(-107370905450i64 * v7) >> 32)) >> 14;
  v9 = (double)(signed int)((v8 >> 31) + v8) - 25.0;
  *(float *)&v20 = (double)(30 * rand() / 0x7FFF) - 15.0;
  sub_40BE40((int)v3, v9, v20, 0);
  sub_40BE80((int)v3, 1000.0, 1148846080, 1148846080);
  sub_40BE60((int)v3, -1000.0, -998637568, -998637568);
  v10 = (double)(20 * rand() / 0x7FFF) - 10.0;
  v11 = rand();
  v12 = (signed int)(-10 * v11 + ((unsigned __int64)(21474181090i64 * v11) >> 32)) >> 14;
  *(float *)&v21 = (double)(signed int)((v12 >> 31) + v12);
  *(float *)&v13 = (double)(20 * rand() / 0x7FFF) - 10.0;
  sub_40BEA0((int)v3, v10, v21, v13);
  sub_40BEE0((int)v3, 15.0, 1097859072, 1097859072);
  sub_40BEC0((int)v3, -15.0, -1049624576, -1049624576);
  sub_40BF00((int)v3, 0.0, 0, 0, 1);
  v14 = rand();
  v15 = (signed int)(255 * v14 + ((unsigned __int64)(-547591617795i64 * v14) >> 32)) >> 14;
  v16 = ((v15 >> 31) + v15) << 7;
  v17 = 255 * rand() / 0x7FFF << 7;
  v18 = 255 * rand();
  return sub_40BF30(
           v3,
           v16,
           v17,
           (((unsigned int)(v18 + ((unsigned __int64)(-2147418109i64 * v18) >> 32)) >> 31)
          + (unsigned __int16)((signed int)(v18 + ((unsigned __int64)(-2147418109i64 * v18) >> 32)) >> 14)) << 7,
           v6);
}

//----- (0040CD50) --------------------------------------------------------
int __cdecl sub_40CD50(int a1)
{
  *(_DWORD *)(a1 + 2512) = sub_40CB10;
  *(_BYTE *)a1 = 14;
  *(_BYTE *)(a1 + 2530) = 1;
  *(_BYTE *)(a1 + 2531) = 10;
  *(_WORD *)(a1 + 2528) = 1;
  return sub_40B9B0(a1, 0x18u, 0x18u, 0x20u, 0x40u, 0x38u, 0x58u);
}

//----- (0040CD90) --------------------------------------------------------
int __cdecl sub_40CD90(int a1, int a2)
{
  int v2; // edi
  int v3; // eax
  int v4; // ST28_4
  float v5; // ST24_4
  int v6; // ST28_4
  float v7; // ST24_4
  int v8; // ST28_4
  float v9; // ST24_4

  sub_40BE40(a2, 0.0, 0, 0);
  sub_40BE80(a2, 1.0, 1120403456, 0);
  sub_40BE60(a2, -1000.0, -1027080192, 0);
  v2 = -30 * rand() / 0x7FFF;
  if ( *(float *)&dword_44B764 == 4300.0 || *(float *)&dword_44B764 == 8300.0 )
  {
    *(float *)&v8 = (double)((signed __int16)(-30 * rand()) / 0x7FFF);
    v9 = (double)(signed __int16)v2;
    sub_40BEA0(a2, v9, v8, 0);
    sub_40BEE0(a2, -25.0, -1043857408, 0);
    sub_40BEC0(a2, -30.0, -1041235968, 0);
  }
  else if ( *(float *)&dword_44B764 == 3500.0 || *(float *)&dword_44B764 == 7500.0 )
  {
    *(float *)&v6 = (double)((signed __int16)(-20 * rand()) / 0x7FFF);
    v7 = (double)(signed __int16)v2;
    sub_40BEA0(a2, v7, v6, 0);
    sub_40BEE0(a2, -25.0, -1049624576, 0);
    sub_40BEC0(a2, -30.0, -1046478848, 0);
  }
  else if ( *(float *)&dword_44B764 == 2900.0 || *(float *)&dword_44B764 == 6900.0 )
  {
    v3 = rand();
    *(float *)&v4 = (double)(signed __int16)(((unsigned int)(((unsigned __int64)(32211271635i64 * v3) >> 32) - 15 * v3) >> 31)
                                           + ((signed int)(((unsigned __int64)(32211271635i64 * v3) >> 32) - 15 * v3) >> 14));
    v5 = (double)(signed __int16)v2;
    sub_40BEA0(a2, v5, v4, 0);
    sub_40BEE0(a2, -25.0, -1054867456, 0);
    sub_40BEC0(a2, -30.0, -1049624576, 0);
  }
  return sub_40BF00(a2, 0.0, 1097859072, 0, 1);
}
// 44B764: using guessed type int dword_44B764;

//----- (0040CFD0) --------------------------------------------------------
int sub_40CFD0()
{
  int result; // eax

  result = 0;
  word_448B5A = 0;
  word_448B58 = 0;
  LOBYTE(dword_448B3C) = 0;
  return result;
}
// 448B3C: using guessed type int dword_448B3C;
// 448B58: using guessed type __int16 word_448B58;
// 448B5A: using guessed type __int16 word_448B5A;

//----- (0040CFF0) --------------------------------------------------------
int __cdecl sub_40CFF0(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4, char a5, char a6, char a7)
{
  int v7; // eax
  __int16 v8; // cx
  unsigned __int8 v9; // al
  unsigned __int16 v10; // bp
  _DWORD *v11; // eax
  int v12; // esi
  double v13; // st7
  double v14; // st6
  double v15; // st5
  double v16; // st7
  double v17; // st6
  double v18; // st5
  _DWORD *v19; // eax
  int v20; // esi
  unsigned __int8 v21; // al
  unsigned __int8 v22; // cl
  _DWORD *v23; // ecx
  int v24; // eax
  double v25; // st7
  double v26; // st6
  unsigned int v27; // ebp
  double v28; // st7
  _DWORD *v29; // eax
  signed int v30; // ST50_4
  double v31; // ST6C_8
  int v32; // esi
  double v33; // ST7C_8
  double v34; // st7
  int v35; // ST5C_4
  double v36; // st7
  _DWORD *v37; // eax
  int v38; // esi
  double v39; // ST8C_8
  double v40; // ST74_8
  double v41; // st7
  double v42; // st7
  _DWORD *v43; // eax
  int v44; // esi
  double v45; // ST84_8
  double v46; // st7
  float v47; // ST68_4
  float v48; // ST5C_4
  double v49; // st6
  double v50; // st7
  double v51; // st7
  _DWORD *v52; // eax
  int v53; // esi
  double v54; // ST84_8
  double v55; // st7
  float v56; // ST68_4
  double v57; // st7
  _DWORD *v58; // eax
  int v59; // esi
  double v60; // st7
  double v61; // st7
  _DWORD *v62; // eax
  int v63; // esi
  double v64; // st7
  double v65; // ST8C_8
  double v66; // st7
  _DWORD *v67; // eax
  int v68; // esi
  double v69; // st7
  double v70; // st7
  _DWORD *v71; // eax
  int v72; // esi
  double v73; // st7
  double v74; // st7
  int result; // eax
  float v76; // [esp+1Ch] [ebp-34h]
  float v77; // [esp+20h] [ebp-30h]
  float v78; // [esp+54h] [ebp+4h]
  float v79; // [esp+54h] [ebp+4h]
  float v80; // [esp+54h] [ebp+4h]
  float v81; // [esp+54h] [ebp+4h]
  signed int v82; // [esp+58h] [ebp+8h]
  float v83; // [esp+58h] [ebp+8h]
  float v84; // [esp+58h] [ebp+8h]
  float v85; // [esp+5Ch] [ebp+Ch]
  float v86; // [esp+5Ch] [ebp+Ch]
  float v87; // [esp+5Ch] [ebp+Ch]
  float v88; // [esp+5Ch] [ebp+Ch]
  float v89; // [esp+5Ch] [ebp+Ch]
  float v90; // [esp+5Ch] [ebp+Ch]
  float v91; // [esp+5Ch] [ebp+Ch]
  float v92; // [esp+60h] [ebp+10h]
  float v93; // [esp+60h] [ebp+10h]
  float v94; // [esp+60h] [ebp+10h]
  int v95; // [esp+64h] [ebp+14h]
  float v96; // [esp+64h] [ebp+14h]
  float v97; // [esp+64h] [ebp+14h]
  signed int v98; // [esp+68h] [ebp+18h]
  signed int v99; // [esp+68h] [ebp+18h]
  signed int v100; // [esp+68h] [ebp+18h]
  float v101; // [esp+68h] [ebp+18h]
  float v102; // [esp+68h] [ebp+18h]
  float v103; // [esp+68h] [ebp+18h]
  float v104; // [esp+68h] [ebp+18h]
  float v105; // [esp+68h] [ebp+18h]
  signed int v106; // [esp+6Ch] [ebp+1Ch]
  float v107; // [esp+6Ch] [ebp+1Ch]
  float v108; // [esp+6Ch] [ebp+1Ch]

  v7 = 4 * (word_448B5A & 0xFFF);
  v77 = *(float *)((char *)dword_4449D4 + v7);
  v76 = *(float *)((char *)dword_4449D8 + v7);
  if ( !byte_455CA5 )
  {
    word_448B58 += 192;
    v8 = word_448B5A + 320;
    word_448B5A = v8;
    if ( (unsigned __int16)v8 >= 0x1000u )
    {
      v8 -= 4096;
      word_448B5A = v8;
    }
    if ( (unsigned __int16)word_448B58 >= 0x1000u )
      word_448B58 -= 4096;
    if ( (unsigned __int16)v8 >= 0x800u )
      v9 = dword_448B3C - 1;
    else
      v9 = dword_448B3C + 1;
    LOBYTE(dword_448B3C) = v9;
    if ( v9 > 0x80u )
      LOBYTE(dword_448B3C) = 0;
  }
  v10 = a1;
  if ( a6 != 1 || a7 )
    goto LABEL_37;
  v11 = dword_443D2C;
  v12 = *((_DWORD *)dword_443D2C + 16032);
  *((_DWORD *)dword_443D2C + 16032) = v12 + 128;
  *(_DWORD *)(v12 + 4) = 0;
  *(_DWORD *)v12 = v11[30];
  v11[30] = v12;
  *(_BYTE *)(v12 + 34) = -1;
  *(_BYTE *)(v12 + 33) = -1;
  *(_BYTE *)(v12 + 32) = -1;
  *(_DWORD *)(v12 + 4) = 261;
  if ( a5 == 1 )
  {
    if ( byte_44B78E )
    {
      if ( *(float *)&dword_44B764 == 0.0 )
      {
        *(float *)(v12 + 16) = (double)(signed int)(a1 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) - 53);
        *(float *)(v12 + 20) = (double)(signed int)(a4 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + a2 - 5);
        *(float *)(v12 + 44) = (double)(signed int)(a1 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) - 53)
                             + (double)((unsigned __int8)dword_448B3C >> 1)
                             + 14.4;
        *(float *)(v12 + 48) = (double)(signed int)(a4 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + a2 - 5);
        *(float *)(v12 + 72) = (double)(signed int)(a1 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) - 53);
        v13 = (double)(a4 + a2 + 7);
        *(float *)(v12 + 76) = v13;
        v98 = a1 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) - 53;
      }
      else
      {
        *(float *)(v12 + 16) = (double)(signed int)(a1 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) - 43);
        *(float *)(v12 + 20) = (double)(signed int)(a4 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + a2 - 5);
        *(float *)(v12 + 44) = (double)(signed int)(a1 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) - 43)
                             + (double)((unsigned __int8)dword_448B3C >> 1)
                             + 14.4;
        *(float *)(v12 + 48) = (double)(signed int)(a4 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + a2 - 5);
        *(float *)(v12 + 72) = (double)(signed int)(a1 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) - 43);
        v13 = (double)(a4 + a2 + 7);
        *(float *)(v12 + 76) = v13;
        v98 = a1 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) - 43;
      }
      v14 = (double)v98;
      v15 = (double)((unsigned __int8)dword_448B3C >> 1);
    }
    else
    {
      *(float *)(v12 + 16) = (double)(signed int)(a1 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) - 72);
      *(float *)(v12 + 20) = (double)(signed int)(a4 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + a2 - 10);
      *(float *)(v12 + 44) = (double)(signed int)(a1 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) - 72)
                           + (double)((unsigned __int8)dword_448B3C >> 1)
                           + 14.4;
      *(float *)(v12 + 48) = (double)(signed int)(a4 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + a2 - 10);
      *(float *)(v12 + 72) = (double)(signed int)(a1 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) - 72);
      v13 = (double)(a4 + a2 + 2);
      *(float *)(v12 + 76) = v13;
      v14 = (double)(signed int)(a1 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) - 72);
      v15 = (double)((unsigned __int8)dword_448B3C >> 1);
    }
    *(_DWORD *)(v12 + 36) = 1040220289;
    *(_DWORD *)(v12 + 92) = 1040220289;
    *(float *)(v12 + 100) = v14 + v15 + 14.4;
    *(_DWORD *)(v12 + 24) = 0;
    *(float *)(v12 + 104) = v13;
    *(_DWORD *)(v12 + 28) = 1065353216;
    *(_DWORD *)(v12 + 52) = 0;
    *(_DWORD *)(v12 + 56) = 1065353216;
    *(_DWORD *)(v12 + 80) = 0;
    *(_DWORD *)(v12 + 84) = 1065353216;
    *(_DWORD *)(v12 + 108) = 0;
    *(_DWORD *)(v12 + 112) = 1065353216;
    *(_DWORD *)(v12 + 40) = 1058905502;
    *(_DWORD *)(v12 + 64) = 0;
    *(_DWORD *)(v12 + 68) = 1058905502;
    *(_DWORD *)(v12 + 96) = 1061010878;
    *(_DWORD *)(v12 + 120) = 0;
  }
  else
  {
    if ( a5 != -1 )
      goto LABEL_30;
    if ( byte_44B78E )
    {
      if ( *(float *)&dword_44B764 == 0.0 )
      {
        *(float *)(v12 + 16) = (double)(signed int)(a3 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + a1 + 41);
        *(float *)(v12 + 20) = (double)(signed int)(a4 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + a2 - 10);
        *(float *)(v12 + 44) = (double)(signed int)(a3 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + a1 + 41)
                             + (double)((unsigned __int8)dword_448B3C >> 1)
                             + 14.4;
        *(float *)(v12 + 48) = (double)(signed int)(a4 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + a2 - 10);
        *(float *)(v12 + 72) = (double)(signed int)(a3 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + a1 + 41);
        v16 = (double)(a4 + a2 + 2);
        *(float *)(v12 + 76) = v16;
        v99 = a3 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + a1 + 41;
      }
      else
      {
        *(float *)(v12 + 16) = (double)(signed int)(a3 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + a1 + 31);
        *(float *)(v12 + 20) = (double)(signed int)(a4 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + a2 - 10);
        *(float *)(v12 + 44) = (double)(signed int)(a3 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + a1 + 31)
                             + (double)((unsigned __int8)dword_448B3C >> 1)
                             + 14.4;
        *(float *)(v12 + 48) = (double)(signed int)(a4 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + a2 - 10);
        *(float *)(v12 + 72) = (double)(signed int)(a3 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + a1 + 31);
        v16 = (double)(a4 + a2 + 2);
        *(float *)(v12 + 76) = v16;
        v99 = a3 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + a1 + 31;
      }
      v17 = (double)v99;
      v18 = (double)((unsigned __int8)dword_448B3C >> 1);
    }
    else
    {
      *(float *)(v12 + 16) = (double)(signed int)(a3 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + a1 + 52);
      *(float *)(v12 + 20) = (double)(signed int)(a4 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + a2 - 10);
      *(float *)(v12 + 44) = (double)(signed int)(a3 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + a1 + 52)
                           + (double)((unsigned __int8)dword_448B3C >> 1)
                           + 14.4;
      *(float *)(v12 + 48) = (double)(signed int)(a4 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + a2 - 10);
      *(float *)(v12 + 72) = (double)(signed int)(a3 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + a1 + 52);
      v16 = (double)(a4 + a2 + 2);
      *(float *)(v12 + 76) = v16;
      v17 = (double)(signed int)(a3 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + a1 + 52);
      v18 = (double)((unsigned __int8)dword_448B3C >> 1);
    }
    *(_DWORD *)(v12 + 40) = 1058905502;
    *(_DWORD *)(v12 + 68) = 1058905502;
    *(float *)(v12 + 100) = v17 + v18 + 14.4;
    *(_DWORD *)(v12 + 24) = 0;
    *(float *)(v12 + 104) = v16;
    *(_DWORD *)(v12 + 28) = 1065353216;
    *(_DWORD *)(v12 + 52) = 0;
    *(_DWORD *)(v12 + 56) = 1065353216;
    *(_DWORD *)(v12 + 80) = 0;
    *(_DWORD *)(v12 + 84) = 1065353216;
    *(_DWORD *)(v12 + 108) = 0;
    *(_DWORD *)(v12 + 112) = 1065353216;
    *(_DWORD *)(v12 + 36) = 0;
    *(_DWORD *)(v12 + 64) = 1040220289;
    *(_DWORD *)(v12 + 92) = 0;
    *(_DWORD *)(v12 + 96) = 1061010878;
    *(_DWORD *)(v12 + 120) = 1040220289;
  }
  *(_DWORD *)(v12 + 124) = 1061010878;
LABEL_30:
  *(_DWORD *)(v12 + 8) = sub_401000(0, 1, 1088, 413);
  if ( !byte_44B78E )
  {
    v19 = dword_443D2C;
    v20 = *((_DWORD *)dword_443D2C + 16032);
    *((_DWORD *)dword_443D2C + 16032) = v20 + 128;
    *(_DWORD *)(v20 + 4) = 0;
    *(_DWORD *)v20 = v19[30];
    v19[30] = v20;
    *(_BYTE *)(v20 + 34) = -1;
    *(_BYTE *)(v20 + 33) = -1;
    *(_BYTE *)(v20 + 32) = -1;
    *(_DWORD *)(v20 + 4) = 261;
    if ( a5 == 1 )
    {
      *(float *)(v20 + 16) = (double)(signed int)(a1 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) - 60);
      *(float *)(v20 + 20) = (double)(signed int)(a2 + a4 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) - 30);
      *(float *)(v20 + 44) = (double)(signed int)(a1 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) - 60)
                           + (double)(unsigned __int8)dword_448B3C
                           + 14.4;
      *(float *)(v20 + 48) = (double)(signed int)(a2 + a4 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) - 30);
      *(float *)(v20 + 72) = (double)(signed int)(a1 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) - 60);
      *(float *)(v20 + 76) = (double)(signed int)((unsigned __int8)dword_448B3C
                                                + a2
                                                + a4
                                                - ((unsigned int)(unsigned __int8)dword_448B3C >> 1)
                                                - 18);
      *(float *)(v20 + 100) = (double)(signed int)(a1 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) - 60)
                            + (double)(unsigned __int8)dword_448B3C
                            + 14.4;
      v21 = dword_448B3C;
      *(_DWORD *)(v20 + 24) = 0;
      *(_DWORD *)(v20 + 28) = 1065353216;
      *(_DWORD *)(v20 + 52) = 0;
      *(_DWORD *)(v20 + 56) = 1065353216;
      *(_DWORD *)(v20 + 80) = 0;
      *(_DWORD *)(v20 + 84) = 1065353216;
      *(_DWORD *)(v20 + 40) = 1058905502;
      *(_DWORD *)(v20 + 68) = 1058905502;
      *(_DWORD *)(v20 + 108) = 0;
      *(float *)(v20 + 104) = (double)(signed int)(a2 + a4 - ((unsigned int)v21 >> 1) + v21 - 18);
      *(_DWORD *)(v20 + 112) = 1065353216;
      *(_DWORD *)(v20 + 36) = 0;
      *(_DWORD *)(v20 + 64) = 1040220289;
      *(_DWORD *)(v20 + 92) = 0;
      *(_DWORD *)(v20 + 96) = 1061010878;
      *(_DWORD *)(v20 + 120) = 1040220289;
      *(_DWORD *)(v20 + 124) = 1061010878;
    }
    else
    {
      if ( a5 != -1 )
      {
LABEL_36:
        *(_DWORD *)(v20 + 8) = sub_401000(0, 1, 1088, 413);
        goto LABEL_37;
      }
      *(float *)(v20 + 16) = (double)(signed int)(a3 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + a1 + 38);
      *(float *)(v20 + 20) = (double)(signed int)(a2 + a4 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) - 30);
      *(float *)(v20 + 44) = (double)(signed int)(a1 + a3 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + 38)
                           + (double)(unsigned __int8)dword_448B3C
                           + 14.4;
      *(float *)(v20 + 48) = (double)(signed int)(a2 + a4 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) - 30);
      *(float *)(v20 + 72) = (double)(signed int)(a1 + a3 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + 38);
      *(float *)(v20 + 76) = (double)(signed int)((unsigned __int8)dword_448B3C
                                                + a2
                                                + a4
                                                - ((unsigned int)(unsigned __int8)dword_448B3C >> 1)
                                                - 18);
      *(float *)(v20 + 100) = (double)(signed int)(a3 - ((unsigned int)(unsigned __int8)dword_448B3C >> 1) + a1 + 38)
                            + (double)(unsigned __int8)dword_448B3C
                            + 14.4;
      v22 = dword_448B3C;
      *(_DWORD *)(v20 + 24) = 0;
      *(_DWORD *)(v20 + 28) = 1065353216;
      *(_DWORD *)(v20 + 52) = 0;
      *(_DWORD *)(v20 + 56) = 1065353216;
      *(_DWORD *)(v20 + 80) = 0;
      *(_DWORD *)(v20 + 84) = 1065353216;
      *(_DWORD *)(v20 + 40) = 1058905502;
      *(_DWORD *)(v20 + 68) = 1058905502;
      *(_DWORD *)(v20 + 108) = 0;
      *(float *)(v20 + 104) = (double)(signed int)(a2 + a4 - ((unsigned int)v22 >> 1) + v22 - 18);
      *(_DWORD *)(v20 + 112) = 1065353216;
      *(_DWORD *)(v20 + 36) = 1040220289;
      *(_DWORD *)(v20 + 64) = 0;
      *(_DWORD *)(v20 + 92) = 1040220289;
      *(_DWORD *)(v20 + 96) = 1061010878;
      *(_DWORD *)(v20 + 120) = 0;
      *(_DWORD *)(v20 + 124) = 1061010878;
    }
    v10 = a1;
    goto LABEL_36;
  }
LABEL_37:
  v23 = dword_443D2C;
  v106 = v10;
  v24 = *((_DWORD *)dword_443D2C + 16032);
  v25 = (double)v10;
  *((_DWORD *)dword_443D2C + 16032) = v24 + 88;
  *(_DWORD *)(v24 + 4) = 0;
  *(_DWORD *)v24 = v23[30];
  v23[30] = v24;
  *(float *)(v24 + 8) = v25;
  v100 = a2;
  v82 = a3;
  v26 = (double)v100;
  v95 = v10 + a3;
  v27 = a4;
  *(float *)(v24 + 12) = v26;
  *(_BYTE *)(v24 + 26) = -1;
  *(_BYTE *)(v24 + 25) = -1;
  v78 = (double)v95;
  *(float *)(v24 + 28) = v78;
  *(_BYTE *)(v24 + 24) = -1;
  *(float *)(v24 + 32) = v26;
  *(_DWORD *)(v24 + 4) = 3;
  *(float *)(v24 + 68) = v78;
  *(float *)(v24 + 48) = v25;
  v28 = (double)(v100 + a4);
  *(_DWORD *)(v24 + 16) = 0;
  *(_DWORD *)(v24 + 20) = 1065353216;
  *(_DWORD *)(v24 + 36) = 0;
  *(_DWORD *)(v24 + 40) = 1065353216;
  *(float *)(v24 + 52) = v28;
  *(float *)(v24 + 72) = v28;
  *(_DWORD *)(v24 + 56) = 0;
  *(_DWORD *)(v24 + 60) = 1065353216;
  *(_DWORD *)(v24 + 76) = 0;
  *(_DWORD *)(v24 + 80) = 1065353216;
  v29 = dword_443D2C;
  v30 = a4;
  v31 = (double)v106;
  v32 = *((_DWORD *)dword_443D2C + 16032);
  *((_DWORD *)dword_443D2C + 16032) = v32 + 128;
  *(_DWORD *)(v32 + 4) = 0;
  v33 = v31 - 36.0;
  *(_DWORD *)v32 = v29[30];
  v29[30] = v32;
  *(_BYTE *)(v32 + 34) = -1;
  *(_BYTE *)(v32 + 33) = -1;
  v96 = v77 + v77;
  v34 = v33 - (double)(a3 >> 3) + v96;
  *(_BYTE *)(v32 + 32) = -1;
  *(_DWORD *)(v32 + 4) = 261;
  v79 = v34;
  *(float *)(v32 + 16) = v79;
  v35 = a4 / 10;
  *(float *)(v32 + 72) = v79;
  v107 = v76 + v76;
  *(_DWORD *)(v32 + 40) = 1058905502;
  *(_DWORD *)(v32 + 68) = 1058905502;
  *(_DWORD *)(v32 + 24) = 0;
  *(_DWORD *)(v32 + 28) = 1065353216;
  *(_DWORD *)(v32 + 52) = 0;
  *(_DWORD *)(v32 + 56) = 1065353216;
  *(_DWORD *)(v32 + 80) = 0;
  v92 = (double)(v100 + v35 - 32) + v107;
  *(float *)(v32 + 20) = v92;
  *(_DWORD *)(v32 + 84) = 1065353216;
  v36 = v34 + 72.0;
  *(float *)(v32 + 44) = v36;
  *(float *)(v32 + 48) = v92;
  *(_DWORD *)(v32 + 108) = 0;
  *(_DWORD *)(v32 + 112) = 1065353216;
  *(_DWORD *)(v32 + 36) = 0;
  v93 = v92 + 64.0;
  *(_DWORD *)(v32 + 92) = 0;
  *(float *)(v32 + 76) = v93;
  *(float *)(v32 + 104) = v93;
  *(float *)(v32 + 100) = v36;
  *(_DWORD *)(v32 + 64) = 1040220289;
  *(_DWORD *)(v32 + 96) = 1061010878;
  *(_DWORD *)(v32 + 120) = 1040220289;
  *(_DWORD *)(v32 + 124) = 1061010878;
  *(_DWORD *)(v32 + 8) = sub_401000(0, 1, 1088, 413);
  v37 = dword_443D2C;
  v38 = *((_DWORD *)dword_443D2C + 16032);
  *((_DWORD *)dword_443D2C + 16032) = v38 + 128;
  *(_DWORD *)(v38 + 4) = 0;
  *(_DWORD *)v38 = v37[30];
  v37[30] = v38;
  *(_BYTE *)(v38 + 34) = -1;
  *(_BYTE *)(v38 + 33) = -1;
  v39 = (double)(a3 >> 1) - 36.0;
  *(_BYTE *)(v38 + 32) = -1;
  *(_DWORD *)(v38 + 4) = 261;
  v40 = (double)(a3 / 12);
  v94 = v77 + v77;
  *(_DWORD *)(v38 + 24) = 0;
  *(_DWORD *)(v38 + 28) = 1065353216;
  *(_DWORD *)(v38 + 52) = 0;
  *(_DWORD *)(v38 + 56) = 1065353216;
  *(_DWORD *)(v38 + 80) = 0;
  v41 = v39 + v31 - v40 - v94;
  *(_DWORD *)(v38 + 84) = 1065353216;
  *(_DWORD *)(v38 + 108) = 0;
  *(_DWORD *)(v38 + 112) = 1065353216;
  *(_DWORD *)(v38 + 36) = 0;
  *(_DWORD *)(v38 + 92) = 0;
  v80 = v41;
  *(float *)(v38 + 16) = v80;
  *(float *)(v38 + 72) = v80;
  *(_DWORD *)(v38 + 40) = 1058905502;
  *(_DWORD *)(v38 + 68) = 1058905502;
  *(_DWORD *)(v38 + 96) = 1061010878;
  *(_DWORD *)(v38 + 124) = 1061010878;
  v85 = (double)(v100 - v35 - 32) - v107;
  *(float *)(v38 + 20) = v85;
  v42 = v41 + 72.0;
  *(float *)(v38 + 44) = v42;
  *(float *)(v38 + 48) = v85;
  v86 = v85 + 64.0;
  *(float *)(v38 + 76) = v86;
  *(float *)(v38 + 104) = v86;
  *(float *)(v38 + 100) = v42;
  *(_DWORD *)(v38 + 64) = 1040220289;
  *(_DWORD *)(v38 + 120) = 1040220289;
  *(_DWORD *)(v38 + 8) = sub_401000(0, 1, 1088, 413);
  v43 = dword_443D2C;
  v44 = *((_DWORD *)dword_443D2C + 16032);
  v45 = (double)v82 - 36.0;
  *((_DWORD *)dword_443D2C + 16032) = v44 + 128;
  *(_DWORD *)(v44 + 4) = 0;
  v46 = v96 + v45 + v31;
  *(_DWORD *)v44 = v43[30];
  v43[30] = v44;
  *(_BYTE *)(v44 + 34) = -1;
  *(_BYTE *)(v44 + 33) = -1;
  *(_BYTE *)(v44 + 32) = -1;
  v47 = v46;
  *(float *)(v44 + 16) = v47;
  *(_DWORD *)(v44 + 4) = 261;
  *(float *)(v44 + 72) = v47;
  *(_DWORD *)(v44 + 36) = 1040220289;
  *(_DWORD *)(v44 + 92) = 1040220289;
  v48 = (double)(signed int)((v27 >> 1) + v100 - 32);
  v49 = v76 + v76;
  *(_DWORD *)(v44 + 24) = 0;
  *(_DWORD *)(v44 + 28) = 1065353216;
  v81 = v49;
  *(_DWORD *)(v44 + 52) = 0;
  *(_DWORD *)(v44 + 56) = 1065353216;
  *(_DWORD *)(v44 + 80) = 0;
  *(_DWORD *)(v44 + 84) = 1065353216;
  *(_DWORD *)(v44 + 108) = 0;
  *(_DWORD *)(v44 + 112) = 1065353216;
  *(_DWORD *)(v44 + 64) = 0;
  *(_DWORD *)(v44 + 96) = 1061010878;
  *(_DWORD *)(v44 + 120) = 0;
  *(_DWORD *)(v44 + 124) = 1061010878;
  v87 = v49 + v48 - 5.0;
  *(float *)(v44 + 20) = v87;
  v50 = v46 + 72.0;
  *(float *)(v44 + 44) = v50;
  *(float *)(v44 + 48) = v87;
  v88 = v87 + 64.0;
  *(float *)(v44 + 76) = v88;
  *(float *)(v44 + 104) = v88;
  *(float *)(v44 + 100) = v50;
  *(_DWORD *)(v44 + 40) = 1058905502;
  *(_DWORD *)(v44 + 68) = 1058905502;
  v51 = v45 + v31;
  *(_DWORD *)(v44 + 8) = sub_401000(0, 1, 1088, 413);
  v52 = dword_443D2C;
  v53 = *((_DWORD *)dword_443D2C + 16032);
  v54 = v51;
  *((_DWORD *)dword_443D2C + 16032) = v53 + 128;
  v55 = v51 - v40 + v94;
  *(_DWORD *)(v53 + 4) = 0;
  *(_DWORD *)v53 = v52[30];
  v52[30] = v53;
  v56 = v55;
  *(float *)(v53 + 16) = v56;
  *(_BYTE *)(v53 + 34) = -1;
  *(_BYTE *)(v53 + 33) = -1;
  *(_BYTE *)(v53 + 32) = -1;
  *(_DWORD *)(v53 + 4) = 261;
  v89 = (double)(v100 - 32) - v81;
  *(float *)(v53 + 20) = v89;
  v57 = v55 + 72.0;
  *(float *)(v53 + 44) = v57;
  *(float *)(v53 + 48) = v89;
  *(float *)(v53 + 72) = v56;
  *(_DWORD *)(v53 + 36) = 1040220289;
  v90 = v89 + 64.0;
  *(float *)(v53 + 76) = v90;
  *(_DWORD *)(v53 + 92) = 1040220289;
  *(float *)(v53 + 100) = v57;
  *(float *)(v53 + 104) = v90;
  *(_DWORD *)(v53 + 24) = 0;
  *(_DWORD *)(v53 + 28) = 1065353216;
  *(_DWORD *)(v53 + 52) = 0;
  *(_DWORD *)(v53 + 56) = 1065353216;
  *(_DWORD *)(v53 + 80) = 0;
  *(_DWORD *)(v53 + 84) = 1065353216;
  *(_DWORD *)(v53 + 108) = 0;
  *(_DWORD *)(v53 + 112) = 1065353216;
  *(_DWORD *)(v53 + 40) = 1058905502;
  *(_DWORD *)(v53 + 64) = 0;
  *(_DWORD *)(v53 + 68) = 1058905502;
  *(_DWORD *)(v53 + 96) = 1061010878;
  *(_DWORD *)(v53 + 120) = 0;
  *(_DWORD *)(v53 + 124) = 1061010878;
  *(_DWORD *)(v53 + 8) = sub_401000(0, 1, 1088, 413);
  v58 = dword_443D2C;
  v59 = *((_DWORD *)dword_443D2C + 16032);
  *((_DWORD *)dword_443D2C + 16032) = v59 + 128;
  *(_DWORD *)(v59 + 4) = 0;
  *(_DWORD *)v59 = v58[30];
  v58[30] = v59;
  *(_BYTE *)(v59 + 34) = -1;
  v60 = v40 + v33 - v96;
  v91 = v60;
  *(float *)(v59 + 16) = v91;
  *(_BYTE *)(v59 + 33) = -1;
  *(_BYTE *)(v59 + 32) = -1;
  *(_DWORD *)(v59 + 4) = 261;
  *(float *)(v59 + 72) = v91;
  v97 = (double)(signed int)(v100 + v27 - (signed int)v27 / 7 - 32) - v107;
  v61 = v60 + 72.0;
  *(float *)(v59 + 44) = v61;
  *(float *)(v59 + 20) = v97;
  *(float *)(v59 + 48) = v97;
  v108 = v97 + 64.0;
  *(float *)(v59 + 76) = v108;
  *(float *)(v59 + 100) = v61;
  *(float *)(v59 + 104) = v108;
  *(_DWORD *)(v59 + 24) = 0;
  *(_DWORD *)(v59 + 28) = 1065353216;
  *(_DWORD *)(v59 + 52) = 0;
  *(_DWORD *)(v59 + 56) = 1065353216;
  *(_DWORD *)(v59 + 80) = 0;
  *(_DWORD *)(v59 + 84) = 1065353216;
  *(_DWORD *)(v59 + 108) = 0;
  *(_DWORD *)(v59 + 112) = 1065353216;
  *(_DWORD *)(v59 + 36) = 0;
  *(_DWORD *)(v59 + 40) = 1058905502;
  *(_DWORD *)(v59 + 64) = 1040220289;
  *(_DWORD *)(v59 + 68) = 1058905502;
  *(_DWORD *)(v59 + 92) = 0;
  *(_DWORD *)(v59 + 96) = 1061010878;
  *(_DWORD *)(v59 + 120) = 1040220289;
  *(_DWORD *)(v59 + 124) = 1061010878;
  *(_DWORD *)(v59 + 8) = sub_401000(0, 1, 1088, 413);
  v62 = dword_443D2C;
  v63 = *((_DWORD *)dword_443D2C + 16032);
  *((_DWORD *)dword_443D2C + 16032) = v63 + 128;
  *(_DWORD *)(v63 + 4) = 0;
  *(_DWORD *)v63 = v62[30];
  v62[30] = v63;
  *(_BYTE *)(v63 + 34) = -1;
  *(_BYTE *)(v63 + 33) = -1;
  *(_BYTE *)(v63 + 32) = -1;
  *(_DWORD *)(v63 + 4) = 261;
  *(_DWORD *)(v63 + 24) = 0;
  *(_DWORD *)(v63 + 28) = 1065353216;
  v64 = (double)(v82 / 10) + v77 + v39 + v31;
  v83 = v64;
  *(float *)(v63 + 16) = v83;
  *(float *)(v63 + 72) = v83;
  v65 = (double)v30 - 36.0 + v76 * 4.0 + (double)v100;
  v101 = v65;
  *(float *)(v63 + 20) = *(float *)&v65;
  v66 = v64 + 72.0;
  *(float *)(v63 + 44) = v66;
  *(float *)(v63 + 48) = v101;
  v102 = v65 + 64.0;
  *(float *)(v63 + 76) = v102;
  *(float *)(v63 + 100) = v66;
  *(float *)(v63 + 104) = v102;
  *(_DWORD *)(v63 + 52) = 0;
  *(_DWORD *)(v63 + 56) = 1065353216;
  *(_DWORD *)(v63 + 80) = 0;
  *(_DWORD *)(v63 + 84) = 1065353216;
  *(_DWORD *)(v63 + 108) = 0;
  *(_DWORD *)(v63 + 112) = 1065353216;
  *(_DWORD *)(v63 + 36) = 0;
  *(_DWORD *)(v63 + 40) = 1058905502;
  *(_DWORD *)(v63 + 64) = 1040220289;
  *(_DWORD *)(v63 + 68) = 1058905502;
  *(_DWORD *)(v63 + 92) = 0;
  *(_DWORD *)(v63 + 96) = 1061010878;
  *(_DWORD *)(v63 + 120) = 1040220289;
  *(_DWORD *)(v63 + 124) = 1061010878;
  *(_DWORD *)(v63 + 8) = sub_401000(0, 1, 1088, 413);
  v67 = dword_443D2C;
  v68 = *((_DWORD *)dword_443D2C + 16032);
  v69 = v33 - v40 - v94;
  *((_DWORD *)dword_443D2C + 16032) = v68 + 128;
  *(_DWORD *)(v68 + 4) = 0;
  *(_DWORD *)v68 = v67[30];
  v67[30] = v68;
  v84 = v69;
  *(float *)(v68 + 16) = v84;
  *(_BYTE *)(v68 + 34) = -1;
  *(float *)(v68 + 72) = v84;
  *(_BYTE *)(v68 + 33) = -1;
  *(_BYTE *)(v68 + 32) = -1;
  v103 = v48 + v76;
  *(float *)(v68 + 20) = v103;
  *(_DWORD *)(v68 + 4) = 261;
  v70 = v69 + 72.0;
  *(float *)(v68 + 44) = v70;
  *(float *)(v68 + 48) = v103;
  *(_DWORD *)(v68 + 24) = 0;
  *(_DWORD *)(v68 + 28) = 1065353216;
  v104 = v103 + 64.0;
  *(float *)(v68 + 76) = v104;
  *(_DWORD *)(v68 + 52) = 0;
  *(float *)(v68 + 100) = v70;
  *(float *)(v68 + 104) = v104;
  *(_DWORD *)(v68 + 56) = 1065353216;
  *(_DWORD *)(v68 + 80) = 0;
  *(_DWORD *)(v68 + 84) = 1065353216;
  *(_DWORD *)(v68 + 108) = 0;
  *(_DWORD *)(v68 + 112) = 1065353216;
  *(_DWORD *)(v68 + 36) = 0;
  *(_DWORD *)(v68 + 40) = 1058905502;
  *(_DWORD *)(v68 + 64) = 1040220289;
  *(_DWORD *)(v68 + 68) = 1058905502;
  *(_DWORD *)(v68 + 92) = 0;
  *(_DWORD *)(v68 + 96) = 1061010878;
  *(_DWORD *)(v68 + 120) = 1040220289;
  *(_DWORD *)(v68 + 124) = 1061010878;
  *(_DWORD *)(v68 + 8) = sub_401000(0, 1, 1088, 413);
  v71 = dword_443D2C;
  v72 = *((_DWORD *)dword_443D2C + 16032);
  *((_DWORD *)dword_443D2C + 16032) = v72 + 128;
  *(_DWORD *)(v72 + 4) = 0;
  v73 = v77 * 4.0 + v54 + v40;
  *(_DWORD *)v72 = v71[30];
  v71[30] = v72;
  *(_BYTE *)(v72 + 34) = -1;
  *(float *)(v72 + 20) = v97;
  v105 = v73;
  *(float *)(v72 + 16) = v105;
  v74 = v73 + 72.0;
  *(float *)(v72 + 44) = v74;
  *(float *)(v72 + 48) = v97;
  *(float *)(v72 + 76) = v108;
  *(float *)(v72 + 104) = v108;
  *(float *)(v72 + 100) = v74;
  *(_BYTE *)(v72 + 33) = -1;
  *(_BYTE *)(v72 + 32) = -1;
  *(_DWORD *)(v72 + 4) = 261;
  *(float *)(v72 + 72) = v105;
  *(_DWORD *)(v72 + 24) = 0;
  *(_DWORD *)(v72 + 28) = 1065353216;
  *(_DWORD *)(v72 + 52) = 0;
  *(_DWORD *)(v72 + 56) = 1065353216;
  *(_DWORD *)(v72 + 80) = 0;
  *(_DWORD *)(v72 + 84) = 1065353216;
  *(_DWORD *)(v72 + 108) = 0;
  *(_DWORD *)(v72 + 112) = 1065353216;
  *(_DWORD *)(v72 + 36) = 0;
  *(_DWORD *)(v72 + 40) = 1058905502;
  *(_DWORD *)(v72 + 64) = 1040220289;
  *(_DWORD *)(v72 + 68) = 1058905502;
  *(_DWORD *)(v72 + 92) = 0;
  *(_DWORD *)(v72 + 96) = 1061010878;
  *(_DWORD *)(v72 + 120) = 1040220289;
  *(_DWORD *)(v72 + 124) = 1061010878;
  result = sub_401000(0, 1, 1088, 413);
  *(_DWORD *)(v72 + 8) = result;
  return result;
}
// 448B3C: using guessed type int dword_448B3C;
// 448B58: using guessed type __int16 word_448B58;
// 448B5A: using guessed type __int16 word_448B5A;
// 44B764: using guessed type int dword_44B764;
// 44B78E: using guessed type char byte_44B78E;
// 455CA5: using guessed type char byte_455CA5;

//----- (0040E6D0) --------------------------------------------------------
char sub_40E6D0()
{
  int i; // esi
  long double v1; // st7
  double v2; // st7
  char result; // al
  double v4; // st7
  double v5; // st7
  double v6; // st7
  double v7; // st7
  char v8; // al
  unsigned int v9; // edx

  for ( i = dword_455C7C; i; i = *(_DWORD *)i )
  {
    if ( *(_BYTE *)(i + 4) == 34 )
      break;
  }
  switch ( (unsigned __int8)dword_44B30C )
  {
    case 0u:
      if ( !byte_44B312 )
      {
        v1 = *(float *)&dword_448A10 - *(float *)(i + 40);
        byte_44B312 = 1;
        dbl_448B50 = fabs(v1) / fabs(*(float *)&dword_448A10 - *(float *)&dword_448A04);
        flt_448B34 = (*(float *)&dword_4489FC - *(float *)&dword_448A08) * dbl_448B50 + *(float *)&dword_448A08;
        flt_448B38 = (*(float *)&dword_448A00 - *(float *)&dword_448A0C) * dbl_448B50 + *(float *)&dword_448A0C;
      }
      nullsub_1(aLratioD);
      if ( *(float *)(i + 32) == flt_448B34 && *(float *)(i + 36) == flt_448B38 )
      {
        LOBYTE(dword_44B30C) = dword_44B30C + 1;
        LOWORD(dword_44B30C) = (unsigned __int8)dword_44B30C;
        flt_44B300 = (*(float *)&dword_4489FC - flt_448B34) * 0.033333335;
        flt_44B304 = (*(float *)&dword_448A00 - flt_448B38) * 0.033333335;
        v2 = *(float *)&dword_448A04 - *(float *)(i + 40);
        byte_440E88 = 1;
        result = 0;
        flt_44B308 = v2 * 0.033333335;
        return result;
      }
      if ( *(float *)(i + 32) >= (double)flt_448B34 )
      {
        if ( *(float *)(i + 32) > (double)flt_448B34 )
        {
          nullsub_1(aDeplacementNeg);
          v5 = *(float *)(i + 32) - (double)byte_440E88;
          *(float *)(i + 32) = v5;
          if ( v5 < flt_448B34 )
            *(float *)(i + 32) = flt_448B34;
        }
      }
      else
      {
        nullsub_1(aDeplacementPos);
        v4 = (double)byte_440E88 + *(float *)(i + 32);
        *(float *)(i + 32) = v4;
        if ( v4 > flt_448B34 )
          *(float *)(i + 32) = flt_448B34;
      }
      if ( *(float *)(i + 36) >= (double)flt_448B38 )
      {
        if ( *(float *)(i + 36) > (double)flt_448B38 )
        {
          v7 = *(float *)(i + 36) - (double)(2 * byte_440E88);
          *(float *)(i + 36) = v7;
          if ( v7 < flt_448B38 )
            *(float *)(i + 36) = flt_448B38;
        }
      }
      else
      {
        v6 = (double)(2 * byte_440E88) + *(float *)(i + 36);
        *(float *)(i + 36) = v6;
        if ( v6 > flt_448B38 )
        {
          *(float *)(i + 36) = flt_448B38;
          ++byte_440E88;
          return 0;
        }
      }
      ++byte_440E88;
      result = 0;
      break;
    case 1u:
      nullsub_1(aValueD);
      if ( SBYTE1(dword_44B30C) >= 25 )
      {
        BYTE1(dword_44B30C) = 30;
        LOBYTE(dword_44B30C) = dword_44B30C + 1;
        result = 0;
      }
      else
      {
        ++BYTE1(dword_44B30C);
        result = 0;
        *(float *)(i + 32) = flt_44B300 + *(float *)(i + 32);
        *(float *)(i + 36) = flt_44B304 + *(float *)(i + 36);
        *(float *)(i + 40) = flt_44B308 + *(float *)(i + 40);
      }
      break;
    case 2u:
      if ( SBYTE1(dword_44B30C) <= 0 )
      {
        BYTE1(dword_44B30C) = 25;
        LOBYTE(dword_44B30C) = dword_44B30C + 1;
      }
      else
      {
        --BYTE1(dword_44B30C);
      }
      result = 0;
      break;
    case 3u:
      byte_44B312 = 0;
      if ( *(float *)(i + 36) >= -1500.0 )
      {
        *(float *)(i + 32) = *(float *)(i + 32) - flt_44B300;
        *(float *)(i + 36) = *(float *)(i + 36) - (double)byte_440E88;
        *(float *)(i + 40) = *(float *)(i + 40) - flt_44B308;
        byte_440E88 += 5;
        goto LABEL_33;
      }
      dword_44B30C = 0;
      v8 = dword_44B808 + 1;
      LOBYTE(dword_44B808) = v8;
      HIBYTE(dword_44B804) = 2 * v8;
      result = 1;
      byte_440E88 = 1;
      word_44B310 = 0;
      v9 = *(_DWORD *)(i + 12) & 0xBFFFFFFF;
      BYTE1(v9) |= 0x40u;
      *(_DWORD *)(i + 12) = v9;
      break;
    default:
LABEL_33:
      result = 0;
      break;
  }
  return result;
}
// 434B40: using guessed type int __cdecl nullsub_1(_DWORD);
// 440E88: using guessed type char byte_440E88;
// 4489FC: using guessed type int dword_4489FC;
// 448A00: using guessed type int dword_448A00;
// 448A04: using guessed type int dword_448A04;
// 448A08: using guessed type int dword_448A08;
// 448A0C: using guessed type int dword_448A0C;
// 448A10: using guessed type int dword_448A10;
// 448B34: using guessed type float flt_448B34;
// 448B38: using guessed type float flt_448B38;
// 448B50: using guessed type double dbl_448B50;
// 44B300: using guessed type float flt_44B300;
// 44B304: using guessed type float flt_44B304;
// 44B308: using guessed type float flt_44B308;
// 44B30C: using guessed type int dword_44B30C;
// 44B310: using guessed type __int16 word_44B310;
// 44B312: using guessed type char byte_44B312;
// 44B804: using guessed type int dword_44B804;
// 44B808: using guessed type int dword_44B808;
// 455C7C: using guessed type int dword_455C7C;

//----- (0040EA90) --------------------------------------------------------
void __cdecl sub_40EA90(float a1, float a2, char a3)
{
  unsigned __int8 v3; // al
  int v4; // edi
  int v5; // ebp
  int v6; // edi
  int v7; // ebp

  if ( (unsigned __int8)a3 >= 0xAu )
  {
    if ( (unsigned __int8)a3 < 0x64u )
    {
      sub_401580(1);
      byte_443AF2 = 127;
      byte_443AF1 = 127;
      byte_443AF0 = 127;
      v6 = (signed __int64)a2;
      v7 = (signed __int64)a1;
      sub_401870(v7 - 6, v6 - 30, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, (unsigned __int8)a3);
      sub_401D10();
      sub_401580(2);
      byte_443AF2 = 127;
      byte_443AF1 = 127;
      byte_443AF0 = 127;
      sub_401870(v7 - 4, v6 - 28, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, (unsigned __int8)a3);
      sub_401D10();
    }
  }
  else
  {
    sub_401580(1);
    if ( (unsigned __int8)a3 > 3u )
    {
      byte_443AF2 = 127;
      byte_443AF1 = 127;
      byte_443AF0 = 127;
    }
    else
    {
      if ( byte_440E89 )
        v3 = byte_440E89 - 1;
      else
        v3 = 20;
      byte_440E89 = v3;
      byte_443AF2 = 127;
      byte_443AF0 = 0;
      byte_443AF1 = 127 / (21 - v3);
    }
    v4 = (signed __int64)a2;
    v5 = (signed __int64)a1;
    sub_401870(v5, v4 - 30, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, (unsigned __int8)a3);
    sub_401D10();
    sub_401580(2);
    byte_443AF2 = 127;
    byte_443AF1 = 127;
    byte_443AF0 = 127;
    sub_401870(v5 + 2, v4 - 28, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, (unsigned __int8)a3);
    sub_401D10();
  }
}
// 440E89: using guessed type char byte_440E89;
// 443AE4: using guessed type int dword_443AE4;
// 443AF0: using guessed type char byte_443AF0;
// 443AF1: using guessed type char byte_443AF1;
// 443AF2: using guessed type char byte_443AF2;

//----- (0040EC50) --------------------------------------------------------
unsigned int sub_40EC50()
{
  int *v0; // edx
  unsigned int result; // eax

  sub_40ECA0();
  sub_40EC80();
  v0 = &dword_444758;
  result = 0;
  do
  {
    if ( result == 16 )
    {
      if ( *v0 )
        *(_BYTE *)(*v0 + 46) = 1;
    }
    v0 += 3;
    ++result;
  }
  while ( result < 0x31 );
  return result;
}

//----- (0040EC80) --------------------------------------------------------
int sub_40EC80()
{
  return sub_407AE0((int)aDataSoundSound, 0, (int)&dword_444758);
}

//----- (0040ECA0) --------------------------------------------------------
char sub_40ECA0()
{
  AGLFILE *v0; // eax
  AGLFILE *v1; // esi
  unsigned int v2; // ebx
  int v3; // edi
  int v4; // ebx
  unsigned __int8 *v5; // esi
  int v6; // ebx
  unsigned __int8 *v7; // esi
  int v8; // ebx
  unsigned __int8 *v9; // esi
  int v10; // ebx
  unsigned __int8 *v11; // esi
  int v12; // ebx
  unsigned __int8 *v13; // esi
  int v14; // ebx
  unsigned __int8 *v15; // esi
  int v16; // ebx
  unsigned __int8 *v17; // esi
  int v18; // ebx
  unsigned __int8 *v19; // esi
  int v20; // ebx
  unsigned __int8 *v21; // esi
  int v22; // ebx
  unsigned __int8 *v23; // esi
  int v24; // ebx
  unsigned __int8 *v25; // esi
  int v26; // ebx
  unsigned __int8 *v27; // esi
  int v28; // ebx
  unsigned __int8 *v29; // esi
  int v30; // ebx
  unsigned __int8 *v31; // esi
  int v32; // ebx
  unsigned __int8 *v33; // esi
  int v34; // ebx
  unsigned __int8 *v35; // esi
  int v36; // ebx
  unsigned __int8 *v37; // esi
  int v38; // ebx
  unsigned __int8 *v39; // esi
  int v40; // ebx
  unsigned __int8 *v41; // esi
  int v42; // ebx
  unsigned __int8 *v43; // esi
  int v44; // ebx
  unsigned __int8 *v45; // esi
  int v46; // ebx
  unsigned __int8 *v47; // esi
  int v48; // ebx
  unsigned __int8 *v49; // esi
  int v50; // ebx
  unsigned __int8 *v51; // esi
  int v52; // ebx
  unsigned __int8 *v53; // esi
  int v54; // ebx
  unsigned __int8 *v55; // esi
  int v56; // ebx
  unsigned __int8 *v57; // esi
  int v58; // ebx
  unsigned __int8 *v59; // esi
  int v60; // ebx
  unsigned __int8 *v61; // esi
  int v62; // ebx
  unsigned __int8 *v63; // esi
  int v64; // ebx
  unsigned __int8 *v65; // esi
  int v66; // ebx
  unsigned __int8 *v67; // esi
  int v68; // ebx
  unsigned __int8 *v69; // esi
  int v70; // ebx
  unsigned __int8 *v71; // esi
  int v72; // ebx
  unsigned __int8 *v73; // esi
  int v74; // ebx
  unsigned __int8 *v75; // esi
  int v76; // ebx
  unsigned __int8 *v77; // esi
  int v78; // ebx
  unsigned __int8 *v79; // esi
  int v80; // ebx
  unsigned __int8 *v81; // esi
  int v82; // ebx
  unsigned __int8 *v83; // esi
  int v84; // ebx
  unsigned __int8 *v85; // esi
  int v86; // ebx
  unsigned __int8 *v87; // esi
  int v88; // ebx
  unsigned __int8 *v89; // esi
  int v90; // ebx
  unsigned __int8 *v91; // esi
  int v92; // ebx
  unsigned __int8 *v93; // esi
  int v94; // ebx
  unsigned __int8 *v95; // esi
  int v96; // ebx
  unsigned __int8 *v97; // esi
  int v98; // ebx
  unsigned __int8 *v99; // esi
  int v100; // ebx
  unsigned __int8 *v101; // esi
  int v102; // ebx
  unsigned __int8 *v103; // esi
  int v104; // ebx
  unsigned __int8 *v105; // esi
  int v106; // ebx
  unsigned __int8 *v107; // esi
  int v108; // ebx
  unsigned __int8 *v109; // esi
  int v110; // ebx
  unsigned __int8 *v111; // esi
  int v112; // ebx
  unsigned __int8 *v113; // esi
  int v114; // ebx
  unsigned __int8 *v115; // esi
  int v116; // ebx
  unsigned __int8 *v117; // esi
  int v118; // ebx
  unsigned __int8 *v119; // esi
  int v120; // ebx
  unsigned __int8 *v121; // esi
  int v122; // ebx
  unsigned __int8 *v123; // esi
  int v124; // ebx
  unsigned __int8 *v125; // esi
  int v126; // ebx
  unsigned __int8 *v127; // esi
  int v128; // ebx
  unsigned __int8 *v129; // esi
  int v130; // ebx
  unsigned __int8 *v131; // esi
  int v132; // ebx
  unsigned __int8 *v133; // esi
  int v134; // ebx
  unsigned __int8 *v135; // esi
  int v136; // ebx
  unsigned __int8 *v137; // esi
  int v138; // ebx
  unsigned __int8 *v139; // esi
  int v140; // ebx
  unsigned __int8 *v141; // esi
  int v142; // ebx
  unsigned __int8 *v143; // esi
  int v144; // ebx
  unsigned __int8 *v145; // esi
  int v146; // ebx
  unsigned __int8 *v147; // esi
  int v148; // ebx
  unsigned __int8 *v149; // esi
  int v150; // ebx
  unsigned __int8 *v151; // esi
  int v152; // ebx
  unsigned __int8 *v153; // esi
  int v154; // ebx
  unsigned __int8 *v155; // esi
  int v156; // ebx
  unsigned __int8 *v157; // esi
  int v158; // ebx
  unsigned __int8 *v159; // esi
  int v160; // ebx
  unsigned __int8 *v161; // esi
  int v162; // ebx
  unsigned __int8 *v163; // esi
  int v164; // ebx

  v0 = sub_403630((int)aDataGraphImage, 2);
  v1 = v0;
  if ( v0 )
  {
    v2 = sub_403700(v0);
    v3 = sub_401250(v2);
    sub_4036A0(v1, (void *)v3, v2);
    sub_403690(v1);
    v4 = *(_DWORD *)(v3 + 4);
    sub_401DB0((unsigned __int8 *)(v3 + 8), 0, 0x3C0u, 0x1C1u, 0, 0);
    sub_401E20(v3 + 8, 880, 492);
    v5 = (unsigned __int8 *)(v4 + v3 + 8);
    v6 = *(_DWORD *)v5;
    v5 += 4;
    sub_401DB0(v5, 0, 0x3C0u, 0x1AEu, 0, 0);
    sub_401E20((int)v5, 880, 491);
    v7 = &v5[v6];
    v8 = *(_DWORD *)v7;
    v7 += 4;
    sub_401DB0(v7, 0, 0x3C6u, 0x1AEu, 0, 0);
    sub_401E20((int)v7, 880, 493);
    v9 = &v7[v8];
    v10 = *(_DWORD *)v9;
    v9 += 4;
    sub_401DB0(v9, 0, 0x3D2u, 0x1DAu, 0, 0);
    sub_401E20((int)v9, 880, 494);
    v11 = &v9[v10];
    v12 = *(_DWORD *)v11;
    v11 += 4;
    sub_401DB0(v11, 0, 0x3D2u, 0x1AEu, 0, 0);
    sub_401E20((int)v11, 880, 495);
    v13 = &v11[v12];
    v14 = *(_DWORD *)v13;
    v13 += 4;
    sub_401DB0(v13, 0, 0x440u, 0x19Du, 0, 0);
    sub_401E20((int)v13, 960, 511);
    v15 = &v13[v14];
    v16 = *(_DWORD *)v15;
    v15 += 4;
    sub_401DB0(v15, 1, 0x400u, 0x100u, 0, 0);
    sub_401E20((int)v15, 896, 508);
    v17 = &v15[v16];
    v18 = *(_DWORD *)v17;
    v17 += 4;
    sub_401DB0(v17, 0, 0x400u, 0x1AEu, 0, 0);
    sub_401E20((int)v17, 896, 507);
    v19 = &v17[v18];
    v20 = *(_DWORD *)v19;
    v19 += 4;
    sub_401DB0(v19, 0, 0x400u, 0x1DAu, 0, 0);
    sub_401E20((int)v19, 976, 506);
    v21 = &v19[v20];
    v22 = *(_DWORD *)v21;
    v21 += 4;
    sub_401DB0(v21, 0, 0x408u, 0x1DAu, 0, 0);
    sub_401E20((int)v21, 976, 505);
    v23 = &v21[v22];
    v24 = *(_DWORD *)v23;
    v23 += 4;
    sub_401DB0(v23, 0, 0x410u, 0x1DAu, 0, 0);
    sub_401E20((int)v23, 976, 504);
    v25 = &v23[v24];
    v26 = *(_DWORD *)v25;
    v25 += 4;
    sub_401DB0(v25, 0, 0x418u, 0x1DAu, 0, 0);
    sub_401E20((int)v25, 976, 503);
    v27 = &v25[v26];
    v28 = *(_DWORD *)v27;
    v27 += 4;
    sub_401DB0(v27, 0, 0x420u, 0x1DAu, 0, 0);
    sub_401E20((int)v27, 976, 502);
    v29 = &v27[v28];
    v30 = *(_DWORD *)v29;
    v29 += 4;
    sub_401DB0(v29, 0, 0x428u, 0x1DAu, 0, 0);
    sub_401E20((int)v29, 976, 501);
    v31 = &v29[v30];
    v32 = *(_DWORD *)v31;
    v31 += 4;
    sub_401DB0(v31, 0, 0x440u, 0x100u, 0, 0);
    sub_401E20((int)v31, 896, 508);
    v33 = &v31[v32];
    v34 = *(_DWORD *)v33;
    v33 += 4;
    sub_401DB0(v33, 0, 0x440u, 0x181u, 0, 0);
    sub_401E20((int)v33, 976, 384);
    v35 = &v33[v34];
    v36 = *(_DWORD *)v35;
    v35 += 4;
    sub_401DB0(v35, 0, 0x450u, 0x181u, 0, 0);
    sub_401E20((int)v35, 992, 384);
    v37 = &v35[v36];
    v38 = *(_DWORD *)v37;
    v37 += 4;
    sub_401DB0(v37, 0, 0x466u, 0x14Au, 0, 0);
    sub_401E20((int)v37, 960, 510);
    v39 = &v37[v38];
    v40 = *(_DWORD *)v39;
    v39 += 4;
    sub_401DB0(v39, 0, 0x44Cu, 0x126u, 0, 0);
    sub_401E20((int)v39, 960, 508);
    v41 = &v39[v40];
    v42 = *(_DWORD *)v41;
    v41 += 4;
    sub_401DB0(v41, 0, 0x44Cu, 0x138u, 0, 0);
    sub_401E20((int)v41, 960, 507);
    v43 = &v41[v42];
    v44 = *(_DWORD *)v43;
    v43 += 4;
    sub_401DB0(v43, 0, 0x44Cu, 0x14Au, 0, 0);
    sub_401E20((int)v43, 960, 506);
    v45 = &v43[v44];
    v46 = *(_DWORD *)v45;
    v45 += 4;
    sub_401DB0(v45, 0, 0x44Cu, 0x15Cu, 0, 0);
    sub_401E20((int)v45, 960, 505);
    v47 = &v45[v46];
    v48 = *(_DWORD *)v47;
    v47 += 4;
    sub_401DB0(v47, 0, 0x44Cu, 0x16Eu, 0, 0);
    sub_401E20((int)v47, 960, 504);
    v49 = &v47[v48];
    v50 = *(_DWORD *)v49;
    v49 += 4;
    sub_401DB0(v49, 0, 0x459u, 0x126u, 0, 0);
    sub_401E20((int)v49, 960, 503);
    v51 = &v49[v50];
    v52 = *(_DWORD *)v51;
    v51 += 4;
    sub_401DB0(v51, 0, 0x459u, 0x138u, 0, 0);
    sub_401E20((int)v51, 960, 502);
    v53 = &v51[v52];
    v54 = *(_DWORD *)v53;
    v53 += 4;
    sub_401DB0(v53, 0, 0x459u, 0x14Au, 0, 0);
    sub_401E20((int)v53, 960, 501);
    v55 = &v53[v54];
    v56 = *(_DWORD *)v55;
    v55 += 4;
    sub_401DB0(v55, 0, 0x459u, 0x15Cu, 0, 0);
    sub_401E20((int)v55, 960, 500);
    v57 = &v55[v56];
    v58 = *(_DWORD *)v57;
    v57 += 4;
    sub_401DB0(v57, 0, 0x459u, 0x16Eu, 0, 0);
    sub_401E20((int)v57, 960, 499);
    v59 = &v57[v58];
    v60 = *(_DWORD *)v59;
    v59 += 4;
    sub_401DB0(v59, 0, 0x466u, 0x126u, 0, 0);
    sub_401E20((int)v59, 960, 498);
    v61 = &v59[v60];
    v62 = *(_DWORD *)v61;
    v61 += 4;
    sub_401DB0(v61, 0, 0x466u, 0x138u, 0, 0);
    sub_401E20((int)v61, 960, 497);
    v63 = &v61[v62];
    v64 = *(_DWORD *)v63;
    v63 += 4;
    sub_401DB0(v63, 0, 0x468u, 0x181u, 0, 0);
    sub_401E20((int)v63, 960, 496);
    v65 = &v63[v64];
    v66 = *(_DWORD *)v65;
    v65 += 4;
    sub_401DB0(v65, 0, 0x468u, 0x1A1u, 0, 0);
    sub_401E20((int)v65, 960, 495);
    v67 = &v65[v66];
    v68 = *(_DWORD *)v67;
    v67 += 4;
    sub_401DB0(v67, 0, 0x466u, 0x156u, 0, 0);
    sub_401E20((int)v67, 960, 490);
    v69 = &v67[v68];
    v70 = *(_DWORD *)v69;
    v69 += 4;
    sub_401DB0(v69, 0, 0x45Bu, 0x1C1u, 0, 0);
    sub_401E20((int)v69, 960, 493);
    v71 = &v69[v70];
    v72 = *(_DWORD *)v71;
    v71 += 4;
    sub_401DB0(v71, 0, 0x44Cu, 0x100u, 0, 0);
    sub_401E20((int)v71, 960, 492);
    v73 = &v71[v72];
    v74 = *(_DWORD *)v73;
    v73 += 4;
    sub_401DB0(v73, 1, 0x466u, 0x166u, 0, 0);
    sub_401E20((int)v73, 960, 491);
    v75 = &v73[v74];
    v76 = *(_DWORD *)v75;
    v75 += 4;
    sub_401DB0(v75, 0, 0x466u, 0x156u, 0, 0);
    sub_401E20((int)v75, 960, 490);
    v77 = &v75[v76];
    v78 = *(_DWORD *)v77;
    v77 += 4;
    sub_401DB0(v77, 0, 0x4AAu, 0x21u, 0, 0);
    v79 = &v77[v78];
    v80 = *(_DWORD *)v79;
    v79 += 4;
    sub_401DB0(v79, 0, 0x4AAu, 0, 0, 0);
    v81 = &v79[v80];
    v82 = *(_DWORD *)v81;
    v81 += 4;
    sub_401DB0(v81, 0, 0x4B3u, 0, 0, 0);
    v83 = &v81[v82];
    v84 = *(_DWORD *)v83;
    v83 += 4;
    sub_401DB0(v83, 0, 0x480u, 0xDAu, 0, 0);
    v85 = &v83[v84];
    v86 = *(_DWORD *)v85;
    v85 += 4;
    sub_401DB0(v85, 0, 0x4AAu, 0x68u, 0, 0);
    v87 = &v85[v86];
    v88 = *(_DWORD *)v87;
    v87 += 4;
    sub_401DB0(v87, 0, 0x480u, 0xA9u, 0, 0);
    v89 = &v87[v88];
    v90 = *(_DWORD *)v89;
    v89 += 4;
    sub_401DB0(v89, 0, 0x489u, 0xA9u, 0, 0);
    v91 = &v89[v90];
    v92 = *(_DWORD *)v91;
    v91 += 4;
    sub_401DB0(v91, 0, 0x492u, 0xA9u, 0, 0);
    v93 = &v91[v92];
    v94 = *(_DWORD *)v93;
    v93 += 4;
    sub_401DB0(v93, 0, 0x49Bu, 0xA9u, 0, 0);
    v95 = &v93[v94];
    v96 = *(_DWORD *)v95;
    v95 += 4;
    sub_401DB0(v95, 0, 0x4A4u, 0xA9u, 0, 0);
    v97 = &v95[v96];
    v98 = *(_DWORD *)v97;
    v97 += 4;
    sub_401DB0(v97, 0, 0x4ADu, 0xA9u, 0, 0);
    v99 = &v97[v98];
    v100 = *(_DWORD *)v99;
    v99 += 4;
    sub_401DB0(v99, 0, 0x4AAu, 0x42u, 0, 0);
    v101 = &v99[v100];
    v102 = *(_DWORD *)v101;
    v101 += 4;
    sub_401DB0(v101, 0, 0x4C0u, 0, 0, 0);
    v103 = &v101[v102];
    v104 = *(_DWORD *)v103;
    v103 += 4;
    sub_401DB0(v103, 0, 0x48Cu, 0xDAu, 0, 0);
    v105 = &v103[v104];
    v106 = *(_DWORD *)v105;
    v105 += 4;
    sub_401DB0(v105, 0, 0x480u, 0x35u, 0, 0);
    v107 = &v105[v106];
    v108 = *(_DWORD *)v107;
    v107 += 4;
    sub_401DB0(v107, 0, 0x48Eu, 0x35u, 0, 0);
    v109 = &v107[v108];
    v110 = *(_DWORD *)v109;
    v109 += 4;
    sub_401DB0(v109, 0, 0x49Cu, 0x35u, 0, 0);
    v111 = &v109[v110];
    v112 = *(_DWORD *)v111;
    v111 += 4;
    sub_401DB0(v111, 0, 0x480u, 0x52u, 0, 0);
    v113 = &v111[v112];
    v114 = *(_DWORD *)v113;
    v113 += 4;
    sub_401DB0(v113, 0, 0x48Eu, 0x52u, 0, 0);
    v115 = &v113[v114];
    v116 = *(_DWORD *)v115;
    v115 += 4;
    sub_401DB0(v115, 0, 0x49Cu, 0x52u, 0, 0);
    v117 = &v115[v116];
    v118 = *(_DWORD *)v117;
    v117 += 4;
    sub_401DB0(v117, 0, 0x480u, 0x6Fu, 0, 0);
    v119 = &v117[v118];
    v120 = *(_DWORD *)v119;
    v119 += 4;
    sub_401DB0(v119, 0, 0x48Eu, 0x6Fu, 0, 0);
    v121 = &v119[v120];
    v122 = *(_DWORD *)v121;
    v121 += 4;
    sub_401DB0(v121, 0, 0x49Cu, 0x6Fu, 0, 0);
    v123 = &v121[v122];
    v124 = *(_DWORD *)v123;
    v123 += 4;
    sub_401DB0(v123, 0, 0x480u, 0x8Cu, 0, 0);
    v125 = &v123[v124];
    v126 = *(_DWORD *)v125;
    v125 += 4;
    sub_401DB0(v125, 0, 0x48Eu, 0x8Cu, 0, 0);
    v127 = &v125[v126];
    v128 = *(_DWORD *)v127;
    v127 += 4;
    sub_401DB0(v127, 0, 0x49Cu, 0x8Cu, 0, 0);
    v129 = &v127[v128];
    v130 = *(_DWORD *)v129;
    v129 += 4;
    sub_401DB0(v129, 0, 0x49Cu, 0, 0, 0);
    v131 = &v129[v130];
    v132 = *(_DWORD *)v131;
    v131 += 4;
    sub_401DB0(v131, 0, 0x4CEu, 0x60u, 0, 0);
    v133 = &v131[v132];
    v134 = *(_DWORD *)v133;
    v133 += 4;
    sub_401DB0(v133, 0, 0x4EFu, 0, 0, 0);
    v135 = &v133[v134];
    v136 = *(_DWORD *)v135;
    v135 += 4;
    sub_401DB0(v135, 0, 0x4EAu, 0x60u, 0, 0);
    v137 = &v135[v136];
    v138 = *(_DWORD *)v137;
    v137 += 4;
    sub_401DB0(v137, 0, 0x4EFu, 0x1Fu, 0, 0);
    v139 = &v137[v138];
    v140 = *(_DWORD *)v139;
    v139 += 4;
    sub_401DB0(v139, 0, 0x4C0u, 0x60u, 0, 0);
    v141 = &v139[v140];
    v142 = *(_DWORD *)v141;
    v141 += 4;
    sub_401DB0(v141, 0, 0x4E7u, 0, 0, 0);
    v143 = &v141[v142];
    v144 = *(_DWORD *)v143;
    v143 += 4;
    sub_401DB0(v143, 0, 0x4DCu, 0x60u, 0, 0);
    v145 = &v143[v144];
    v146 = *(_DWORD *)v145;
    v145 += 4;
    sub_401DB0(v145, 0, 0x4E7u, 0x1Fu, 0, 0);
    v147 = &v145[v146];
    v148 = *(_DWORD *)v147;
    v147 += 4;
    sub_401DB0(v147, 0, 0x48Eu, 0, 0, 0);
    v149 = &v147[v148];
    v150 = *(_DWORD *)v149;
    v149 += 4;
    sub_401DB0(v149, 0, 0x4F7u, 0, 0, 0);
    v151 = &v149[v150];
    v152 = *(_DWORD *)v151;
    v151 += 4;
    sub_401DB0(v151, 1, 0x480u, 0, 0, 0);
    v153 = &v151[v152];
    v154 = *(_DWORD *)v153;
    v153 += 4;
    sub_401DB0(v153, 1, 0x4F7u, 0x1Fu, 0, 0);
    v155 = &v153[v154];
    v156 = *(_DWORD *)v155;
    v155 += 4;
    sub_401DB0(v155, 1, 0x4C0u, 0x95u, 0, 0);
    v157 = &v155[v156];
    v158 = *(_DWORD *)v157;
    v157 += 4;
    sub_401DB0(v157, 1, 0x4E7u, 0x3Eu, 0, 0);
    v159 = &v157[v158];
    v160 = *(_DWORD *)v159;
    v159 += 4;
    sub_401DB0(v159, 1, 0x4D8u, 0x5Bu, 0, 0);
    v161 = &v159[v160];
    v162 = *(_DWORD *)v161;
    v161 += 4;
    sub_401DB0(v161, 1, 0x440u, 0x1BDu, 0, 0);
    v163 = &v161[v162];
    v164 = *(_DWORD *)v163;
    v163 += 4;
    sub_401DB0(v163, 1, 0x448u, 0x19Du, 0, 0);
    sub_401DB0(&v163[v164 + 4], 1, 0x4B3u, 0x3Du, 0, 0);
    LOBYTE(v0) = sub_401380(v3);
  }
  return (char)v0;
}

//----- (0040F890) --------------------------------------------------------
char sub_40F890()
{
  return sub_40F8B0(dword_44EAB4, 20);
}
// 44EAB4: using guessed type int dword_44EAB4;

//----- (0040F8B0) --------------------------------------------------------
char __cdecl sub_40F8B0(int a1, char a2)
{
  int v2; // eax
  float v3; // ST04_4

  *(_BYTE *)(a1 + 8) = a2;
  LOBYTE(v2) = a2 - 1;
  *(_DWORD *)(a1 + 16) = 0;
  switch ( a2 )
  {
    case 1:
    case 0x13:
      LOBYTE(v2) = sub_408670(*(float *)(a1 + 20), 0, 3);
      break;
    case 2:
      LOBYTE(v2) = sub_408670(*(float *)(a1 + 20), 1, 3);
      break;
    case 3:
      sub_430130((_DWORD *)(40 * (unsigned __int8)dword_440F04 + 4502348));
      LOBYTE(v2) = sub_408670(*(float *)(a1 + 20), 1, 3);
      break;
    case 5:
      LOBYTE(v2) = sub_408670(*(float *)(a1 + 20), 3, 0);
      break;
    case 7:
      LOBYTE(v2) = sub_408670(*(float *)(a1 + 20), 5, 0);
      break;
    case 8:
    case 9:
      byte_44B38A = 0;
      byte_44B39C = 0;
      LOBYTE(v2) = sub_408670(*(float *)(a1 + 20), 6, 3);
      break;
    case 0xA:
      byte_44B38B = 0;
      byte_44B39C = 0;
      dword_44B318 = LODWORD(dword_44B73C);
      dword_44B31C = LODWORD(dword_44B740);
      dword_44B320 = LODWORD(dword_44B744);
      LOBYTE(v2) = sub_408670(*(float *)(a1 + 20), 7, 3);
      break;
    case 0xB:
    case 0xC:
    case 0xD:
      LOBYTE(v2) = sub_408670(*(float *)(a1 + 20), 8, 0);
      break;
    case 0xE:
      if ( !sub_407E30((AGLSOUNDBUFFER **)&unk_444950) )
        sub_407E00((int)&unk_444950);
      *(_DWORD *)(dword_44B384 + 12) &= 0xFFFFFFFE;
      v3 = *(float *)(a1 + 20);
      --*(_BYTE *)(a1 + 5);
      LOBYTE(v2) = sub_408670(v3, 9, 0);
      break;
    case 0xF:
    case 0x14:
      if ( !sub_407E30((AGLSOUNDBUFFER **)&unk_44495C) )
        sub_407E00((int)&unk_44495C);
      LOBYTE(v2) = sub_408670(*(float *)(a1 + 20), 10, 0);
      break;
    case 0x10:
      LOBYTE(v2) = sub_408670(*(float *)(a1 + 20), 2, 3);
      break;
    case 0x11:
      if ( !sub_407E30((AGLSOUNDBUFFER **)&unk_444968) )
        sub_407E00((int)&unk_444968);
      sub_408670(*(float *)(a1 + 20), 11, 3);
      v2 = *(_DWORD *)(a1 + 12);
      LOBYTE(v2) = v2 | 0x20;
      *(_DWORD *)(a1 + 12) = v2;
      break;
    case 0x12:
      HIBYTE(dword_455CB0) = 1;
      sub_434530();
      LOBYTE(v2) = sub_408670(*(float *)(a1 + 20), 12, 0);
      break;
    default:
      return v2;
  }
  return v2;
}
// 440F04: using guessed type int dword_440F04;
// 44B318: using guessed type int dword_44B318;
// 44B31C: using guessed type int dword_44B31C;
// 44B320: using guessed type int dword_44B320;
// 44B384: using guessed type int dword_44B384;
// 44B38A: using guessed type char byte_44B38A;
// 44B38B: using guessed type char byte_44B38B;
// 44B39C: using guessed type char byte_44B39C;
// 455CB0: using guessed type int dword_455CB0;

//----- (0040FAF0) --------------------------------------------------------
char __cdecl sub_40FAF0(int a1)
{
  int v1; // edi
  _DWORD *v2; // eax
  int v3; // esi
  double v4; // st7
  double v5; // st7
  float v6; // eax
  int v7; // eax
  char v8; // al
  char v9; // al
  char v10; // al
  char v11; // al
  char v12; // al
  int v13; // eax
  int v14; // edx
  _BYTE *v15; // eax
  unsigned __int8 v16; // cl
  int v17; // esi
  float v18; // edx
  unsigned __int8 v19; // bl
  float *v20; // esi
  signed int v21; // eax
  int v22; // ebp
  int v23; // ecx
  int v24; // eax
  double v25; // st7
  int v26; // ecx
  float v27; // esi
  unsigned __int8 v28; // bl
  float *v29; // ebp
  signed int v30; // eax
  int v31; // ecx
  double v32; // st7
  int v33; // edx
  int v34; // ecx
  unsigned __int16 *v35; // ecx
  unsigned __int16 *v36; // ecx
  int v37; // eax
  int v38; // ecx
  unsigned __int16 *v39; // edx
  int v40; // eax
  int v41; // ST08_4
  unsigned __int16 *v42; // ecx
  double v43; // st7
  int *v44; // eax
  double v45; // st7
  int *v46; // eax
  unsigned int v47; // eax
  bool v48; // cf
  bool v49; // zf
  double v50; // st7
  int *v51; // eax
  float v52; // eax
  unsigned __int16 *v53; // ecx
  unsigned int v54; // eax
  bool v55; // cf
  bool v56; // zf
  float v57; // eax
  unsigned __int16 *v58; // ecx
  unsigned int v59; // ecx
  signed __int16 v60; // ax
  int v61; // eax
  unsigned __int16 *v62; // ecx
  unsigned __int16 *v63; // ecx
  unsigned __int16 *v64; // ecx
  unsigned __int16 *v65; // ecx
  unsigned __int16 *v66; // ecx
  signed int v68; // [esp+10h] [ebp-10h]
  float v69; // [esp+14h] [ebp-Ch]
  float v70; // [esp+18h] [ebp-8h]
  float v71; // [esp+1Ch] [ebp-4h]
  unsigned __int8 v72; // [esp+24h] [ebp+4h]
  unsigned __int8 i; // [esp+24h] [ebp+4h]

  sub_42FF60();
  v1 = a1;
  if ( !byte_455CA9 && !byte_44B793 && !byte_455C12 )
  {
    v72 = 0;
    v68 = 0;
    do
    {
      v2 = dword_443D2C;
      v3 = *((_DWORD *)dword_443D2C + 16032);
      *((_DWORD *)dword_443D2C + 16032) = v3 + 128;
      v4 = (double)v68 * 46.5 + 360.0;
      *(_DWORD *)(v3 + 4) = 0;
      *(_DWORD *)v3 = v2[30];
      v2[30] = v3;
      v69 = v4;
      *(float *)(v3 + 16) = v69;
      *(_DWORD *)(v3 + 20) = 1137868800;
      *(_DWORD *)(v3 + 48) = 1137868800;
      v5 = v4 + 49.5;
      v6 = v69;
      *(_BYTE *)(v3 + 34) = -1;
      *(float *)(v3 + 44) = v5;
      *(float *)(v3 + 72) = v6;
      *(float *)(v3 + 100) = v5;
      *(_BYTE *)(v3 + 33) = -1;
      *(_BYTE *)(v3 + 32) = -1;
      *(_DWORD *)(v3 + 4) = 5;
      *(_DWORD *)(v3 + 76) = 1139795558;
      *(_DWORD *)(v3 + 104) = 1139795558;
      *(_DWORD *)(v3 + 24) = 0;
      *(_DWORD *)(v3 + 28) = 1065353216;
      *(_DWORD *)(v3 + 52) = 0;
      *(_DWORD *)(v3 + 56) = 1065353216;
      *(_DWORD *)(v3 + 80) = 0;
      *(_DWORD *)(v3 + 84) = 1065353216;
      *(_DWORD *)(v3 + 108) = 0;
      *(_DWORD *)(v3 + 112) = 1065353216;
      if ( v72 >= *(_BYTE *)(v1 + 5) )
      {
        *(_DWORD *)(v3 + 40) = 1059695018;
        *(_DWORD *)(v3 + 68) = 1059695018;
        *(_DWORD *)(v3 + 36) = 1060418741;
        *(_DWORD *)(v3 + 64) = 1062655703;
        *(_DWORD *)(v3 + 92) = 1060418741;
        *(_DWORD *)(v3 + 96) = 1062853082;
        *(_DWORD *)(v3 + 120) = 1062655703;
        *(_DWORD *)(v3 + 124) = 1062853082;
        v7 = sub_401000(0, 0, 1197, 169);
      }
      else
      {
        *(_DWORD *)(v3 + 36) = 1058050193;
        *(_DWORD *)(v3 + 92) = 1058050193;
        *(_DWORD *)(v3 + 40) = 1059695018;
        *(_DWORD *)(v3 + 64) = 1060418741;
        *(_DWORD *)(v3 + 68) = 1059695018;
        *(_DWORD *)(v3 + 96) = 1062918875;
        *(_DWORD *)(v3 + 120) = 1060418741;
        *(_DWORD *)(v3 + 124) = 1062918875;
        v7 = sub_401000(0, 0, 1188, 169);
      }
      *(_DWORD *)(v3 + 8) = v7;
      v48 = (unsigned __int8)(v72++ + 1) < 6u;
      ++v68;
    }
    while ( v48 );
  }
  if ( !sub_41F2C0() )
  {
    if ( dword_44B384 )
    {
      if ( *(_BYTE *)(dword_44B384 + 12) & 1 )
      {
        if ( sub_41F420((float *)(dword_44B384 + 32), (float *)(v1 + 32)) < 300.0 )
        {
          v8 = *(_BYTE *)(v1 + 8);
          if ( v8 != 14 && v8 != 4 )
          {
            byte_44B380 = *(_BYTE *)(v1 + 8);
            sub_40F8B0(v1, 14);
          }
        }
      }
    }
    if ( *(_BYTE *)dword_44B730 & 0x40 )
    {
      v9 = *(_BYTE *)(v1 + 8);
      if ( v9 != 9 && v9 != 10 && !byte_44B39C && sub_415990(dword_44EAAC + 4, &dword_44B73C) && *(_BYTE *)(v1 + 8) == 1 )
        sub_40F8B0(v1, 9);
    }
    if ( *(_BYTE *)(dword_44B730 + 1) & 2 )
    {
      v10 = *(_BYTE *)(v1 + 8);
      if ( v10 != 9
        && v10 != 10
        && !byte_44B39C
        && sub_415990(dword_44EAAC + 4, &dword_44B73C)
        && *(_BYTE *)(v1 + 8) == 1 )
      {
        sub_40F8B0(v1, 10);
      }
    }
    if ( *(_BYTE *)dword_44B730 < 0 && !byte_44B78C )
    {
      v11 = *(_BYTE *)(v1 + 8);
      if ( v11 != 8 && v11 != 11 && v11 == 1 && sub_41F420(&dword_44B73C, (float *)(v1 + 32)) < 1000.0 )
        sub_40F8B0(v1, 11);
    }
    if ( byte_44B39C )
    {
      dword_44B398 = sub_4336A0();
      if ( dword_44B398 - dword_44B394 >= 2 )
        byte_44B39C = 0;
    }
  }
  v12 = *(_BYTE *)(v1 + 5);
  if ( v12 != 4 || byte_44B388 == 1 )
  {
    if ( v12 != 2 || byte_44B388 == 2 )
      goto LABEL_47;
    sub_407E80(2);
    byte_44B388 = 2;
  }
  else
  {
    sub_407E80(1);
    byte_44B388 = 1;
  }
  sub_40F8B0(v1, 16);
LABEL_47:
  v13 = *(unsigned __int8 *)(v1 + 8);
  switch ( v13 )
  {
    case 0:
      v14 = dword_455C3C;
      v15 = (_BYTE *)dword_455C38;
      v16 = 0;
      for ( i = 0; v14; --v14 )
      {
        if ( *v15 & 0x10 && v16 < 2u )
        {
          v17 = i;
          i = ++v16;
          *((_DWORD *)&v69 + v17) = v15;
        }
        v15 += 12;
      }
      sub_417400(32, &dword_44B384, 1);
      v18 = v69;
      byte_44B330 = 0;
      v19 = 1;
      byte_44B331 = *(_BYTE *)(LODWORD(v69) + 2) - 1;
      v20 = (float *)(dword_455C20 + 120 * *(unsigned __int8 *)(LODWORD(v69) + 3));
      if ( *(unsigned __int8 *)(LODWORD(v69) + 2) - 1 >= 1 )
      {
        v21 = 1;
        do
        {
          v22 = *(_DWORD *)(LODWORD(v18) + 8);
          v23 = 11 * v21;
          v24 = 12 * v21;
          v25 = v20[15] + *(float *)(v22 + 4 * v23);
          v26 = v22 + 4 * v23;
          ++v19;
          *(float *)(v24 + 4502312) = v25;
          *(float *)(v24 + 4502316) = *(float *)(v26 + 4) + v20[16];
          *(float *)(v24 + 4502320) = *(float *)(v26 + 8) + v20[17];
          v21 = v19;
        }
        while ( v19 <= *(unsigned __int8 *)(LODWORD(v18) + 2) - 1 );
      }
      v27 = v70;
      byte_44B358 = 1;
      v28 = 1;
      byte_44B359 = *(_BYTE *)(LODWORD(v70) + 2) - 1;
      v29 = (float *)(dword_455C20 + 120 * *(unsigned __int8 *)(LODWORD(v70) + 3));
      if ( *(unsigned __int8 *)(LODWORD(v70) + 2) - 1 >= 1 )
      {
        v30 = 1;
        do
        {
          v31 = *(_DWORD *)(LODWORD(v27) + 8);
          v32 = v29[15] + *(float *)(v31 + 44 * v30);
          v33 = v31 + 44 * v30;
          v34 = -12 * v30;
          ++v28;
          *(float *)(v34 + 4502400) = v32;
          v30 = v28;
          *(float *)(v34 + 4502404) = *(float *)(v33 + 4) + v29[16];
          *(float *)(v34 + 4502408) = *(float *)(v33 + 8) + v29[17];
        }
        while ( v28 <= *(unsigned __int8 *)(LODWORD(v27) + 2) - 1 );
      }
      *(_DWORD *)(v1 + 32) = dword_44B334[10 * (unsigned __int8)dword_440F04 + 3 * (unsigned __int8)byte_44B389];
      *(_DWORD *)(v1 + 36) = dword_44B338[10 * (unsigned __int8)dword_440F04 + 3 * (unsigned __int8)byte_44B389];
      *(_DWORD *)(v1 + 40) = dword_44B33C[10 * (unsigned __int8)dword_440F04 + 3 * (unsigned __int8)byte_44B389];
      sub_430130((_DWORD *)(v1 + 32));
      sub_41ABD0(0);
      dword_44B328 = *(_DWORD *)(*(_DWORD *)(v1 + 20) + 180) + 4012;
      LOBYTE(v13) = sub_40F8B0(v1, 19);
      return v13;
    case 1:
      v37 = sub_4336A0();
      v38 = v37 - dword_44B38C;
      dword_44B390 = v37;
      if ( v37 - dword_44B38C < 8 )
      {
        v13 = *(_DWORD *)(v1 + 20);
        if ( v13 && (v39 = *(unsigned __int16 **)(v13 + 184)) != 0 && *(unsigned __int16 *)(v13 + 174) == *v39 - 1 )
        {
          byte_44B327 = 2;
          LOBYTE(v13) = sub_40F8B0(v1, 1);
        }
        else if ( !v38 )
        {
          LOBYTE(v13) = byte_44B39D;
          if ( !byte_44B39D )
          {
            if ( byte_44B388 )
              LOBYTE(v13) = sub_40F8B0(v1, 16);
            else
              LOBYTE(v13) = sub_41ABD0(0);
          }
        }
      }
      else
      {
        byte_44B39D = 0;
        if ( (_BYTE)dword_440F04 )
          LOBYTE(v13) = sub_40F8B0(v1, 13);
        else
          LOBYTE(v13) = sub_40F8B0(v1, 12);
      }
      return v13;
    case 2:
      v49 = sub_410AC0(v1, 2u) == 0;
      LOBYTE(v13) = dword_440F04;
      if ( v49 )
      {
        if ( (_BYTE)dword_440F04 )
          goto LABEL_91;
        goto LABEL_85;
      }
      LOBYTE(dword_440F04) = (_BYTE)dword_440F04 == 0;
      LOBYTE(v13) = sub_40F8B0(v1, 4);
      return v13;
    case 3:
      if ( sub_410AC0(v1, 0) )
        goto LABEL_156;
      LOBYTE(v13) = dword_440F04;
      if ( (_BYTE)dword_440F04 )
LABEL_85:
        byte_44EA99 = 1;
      else
LABEL_91:
        byte_44EA98 = 1;
      return v13;
    case 4:
      sub_431E70(*(_BYTE *)(dword_44EAAC + 180), 1);
      if ( sub_410AC0(v1, 2u) )
      {
        LOBYTE(v13) = sub_40F8B0(v1, 7);
      }
      else
      {
        LOWORD(v40) = sub_431960(
                        (float *)(40 * (unsigned __int8)dword_440F04 + 4502348),
                        0,
                        (char *)(40 * (unsigned __int8)dword_440F04 + 4502348));
        LOBYTE(v13) = sub_42F360(v40, v41, 50.0, 0.0);
      }
      return v13;
    case 7:
      v13 = *(_DWORD *)(v1 + 20);
      if ( v13 )
      {
        v42 = *(unsigned __int16 **)(v13 + 184);
        if ( v42 )
        {
          if ( *(unsigned __int16 *)(v13 + 174) == *v42 - 1 )
            LOBYTE(v13) = sub_40F8B0(v1, 3);
        }
      }
      return v13;
    case 8:
      if ( *(_DWORD *)(v1 + 16) == 4 )
      {
        if ( !sub_407E30((AGLSOUNDBUFFER **)&dword_444944) )
          sub_407E00((int)&dword_444944);
        v70 = dword_44B740;
        v69 = dword_44B73C;
        v71 = dword_44B744;
        v70 = *(float *)(dword_44B328 + 96);
        if ( sub_4194A0((int *)(dword_44B328 + 92), (int *)&v69, 4000, &unk_44B324) )
          ++byte_44B38A;
      }
      if ( *(_DWORD *)(v1 + 16) <= 5u
        || !sub_419630(*((unsigned __int8 *)&dword_44B320 + (unsigned __int8)byte_44B38A + 3)) )
      {
        goto LABEL_165;
      }
      sub_40F8B0(v1, 2);
      v13 = *(_DWORD *)(v1 + 16) + 1;
      *(_DWORD *)(v1 + 16) = v13;
      return v13;
    case 9:
      if ( !(*(_BYTE *)dword_44B730 & 0x40) || byte_44B78C )
        goto LABEL_155;
      if ( *(_DWORD *)(v1 + 16) == 4 )
      {
        if ( !sub_407E30((AGLSOUNDBUFFER **)&dword_444938) )
          sub_407E00((int)&dword_444938);
        v69 = dword_44B73C;
        v70 = dword_44B740;
        v71 = dword_44B744;
        if ( sub_4167F0(v1) >= 0.0 )
        {
          v44 = (int *)(dword_44B328 + 92);
          v43 = *(float *)(dword_44B328 + 92) + 1400.0;
        }
        else
        {
          v43 = *(float *)(dword_44B328 + 92) - 1400.0;
          v44 = (int *)(dword_44B328 + 92);
        }
        v69 = v43;
        v70 = v70 - 310.0;
        if ( sub_4194A0(v44, (int *)&v69, 4000, &unk_44B324) )
          ++byte_44B38A;
      }
      if ( *(_DWORD *)(v1 + 16) == 15 )
      {
        v69 = dword_44B73C;
        v70 = dword_44B740;
        v71 = dword_44B744;
        if ( sub_4167F0(v1) >= 0.0 )
        {
          v46 = (int *)(dword_44B328 + 92);
          v45 = *(float *)(dword_44B328 + 92) + 1400.0;
        }
        else
        {
          v45 = *(float *)(dword_44B328 + 92) - 1400.0;
          v46 = (int *)(dword_44B328 + 92);
        }
        v69 = v45;
        v70 = v70 - 310.0;
        if ( sub_4194A0(v46, (int *)&v69, 4000, &unk_44B325) )
          ++byte_44B38A;
      }
      v47 = *(_DWORD *)(v1 + 16);
      v48 = v47 < 0x19;
      v49 = v47 == 25;
      if ( v47 == 25 )
      {
        v69 = dword_44B73C;
        v70 = dword_44B740;
        v71 = dword_44B744;
        if ( sub_4167F0(v1) >= 0.0 )
        {
          v51 = (int *)(dword_44B328 + 92);
          v50 = *(float *)(dword_44B328 + 92) + 1400.0;
        }
        else
        {
          v50 = *(float *)(dword_44B328 + 92) - 1400.0;
          v51 = (int *)(dword_44B328 + 92);
        }
        v69 = v50;
        v70 = v70 - 310.0;
        if ( sub_4194A0(v51, (int *)&v69, 4000, &unk_44B326) )
          ++byte_44B38A;
        v48 = *(_DWORD *)(v1 + 16) < 0x19u;
        v49 = *(_DWORD *)(v1 + 16) == 25;
      }
      if ( v48 || v49 )
        goto LABEL_165;
      v52 = *(float *)(v1 + 20);
      if ( v52 != 0.0 )
      {
        v53 = *(unsigned __int16 **)(LODWORD(v52) + 184);
        if ( v53 )
        {
          if ( *(unsigned __int16 *)(LODWORD(v52) + 174) == *v53 - 1 )
            sub_408670(v52, 0, 0);
        }
      }
      if ( !sub_419630(*((unsigned __int8 *)&dword_44B320 + (unsigned __int8)byte_44B38A + 3)) )
        goto LABEL_165;
      goto LABEL_154;
    case 10:
      if ( !(*(_BYTE *)(dword_44B730 + 1) & 2) || byte_44B78C )
      {
LABEL_155:
        byte_44B39C = 0;
LABEL_156:
        dword_44B38C = sub_4336A0();
        LOBYTE(v13) = sub_40F8B0(v1, 1);
        return v13;
      }
      if ( *(_DWORD *)(v1 + 16) == 4 )
      {
        if ( !sub_407E30((AGLSOUNDBUFFER **)&dword_444938) )
          sub_407E00((int)&dword_444938);
        if ( sub_4194A0((int *)(dword_44B328 + 92), &dword_44B318, 4000, &unk_44B324) )
          ++byte_44B38B;
      }
      if ( *(_DWORD *)(v1 + 16) == 11 )
      {
        *(float *)&dword_44B31C = *(float *)&dword_44B31C - 100.0;
        if ( sub_4194A0((int *)(dword_44B328 + 92), &dword_44B318, 4000, &unk_44B325) )
          ++byte_44B38B;
      }
      v54 = *(_DWORD *)(v1 + 16);
      v55 = v54 < 0x13;
      v56 = v54 == 19;
      if ( v54 == 19 )
      {
        *(float *)&dword_44B31C = *(float *)&dword_44B31C - 230.0;
        if ( sub_4194A0((int *)(dword_44B328 + 92), &dword_44B318, 4000, &unk_44B326) )
          ++byte_44B38B;
        v55 = *(_DWORD *)(v1 + 16) < 0x13u;
        v56 = *(_DWORD *)(v1 + 16) == 19;
      }
      if ( !v55 && !v56 )
      {
        v57 = *(float *)(v1 + 20);
        if ( v57 != 0.0 )
        {
          v58 = *(unsigned __int16 **)(LODWORD(v57) + 184);
          if ( v58 )
          {
            if ( *(unsigned __int16 *)(LODWORD(v57) + 174) == *v58 - 1 )
              sub_408670(v57, 0, 0);
          }
        }
        if ( sub_419630(*((unsigned __int8 *)&dword_44B320 + (unsigned __int8)byte_44B38B + 3)) )
        {
LABEL_154:
          byte_44B39C = 1;
          dword_44B38C = sub_4336A0();
          dword_44B394 = sub_4336A0();
          LOBYTE(v13) = sub_40F8B0(v1, 1);
          return v13;
        }
      }
      goto LABEL_165;
    case 11:
      v59 = (unsigned __int16)sub_408850(*(_DWORD *)(v1 + 20), 8u);
      if ( *(_DWORD *)(v1 + 16) < v59 )
        goto LABEL_164;
      v60 = 1024;
      if ( (_BYTE)dword_440F04 != 1 )
        v60 = 3072;
      *(_WORD *)(LODWORD(dword_44EAB0) + 108) = v60;
      *(_WORD *)(LODWORD(dword_44EAB0) + 110) = v60;
      LOBYTE(v13) = sub_40F8B0(v1, 8);
      return v13;
    case 12:
      v59 = (unsigned __int16)sub_408850(*(_DWORD *)(v1 + 20), 8u);
      if ( *(_DWORD *)(v1 + 16) < v59 )
        goto LABEL_164;
      *(_WORD *)(LODWORD(dword_44EAB0) + 108) = 3072;
      *(_WORD *)(LODWORD(dword_44EAB0) + 110) = 3072;
      LOBYTE(v13) = sub_40F8B0(v1, 2);
      return v13;
    case 13:
      v59 = (unsigned __int16)sub_408850(*(_DWORD *)(v1 + 20), 8u);
      if ( *(_DWORD *)(v1 + 16) >= v59 )
      {
        *(_WORD *)(LODWORD(dword_44EAB0) + 108) = 1024;
        *(_WORD *)(LODWORD(dword_44EAB0) + 110) = 1024;
        LOBYTE(v13) = sub_40F8B0(v1, 2);
      }
      else
      {
LABEL_164:
        sub_408060(-2048 / (signed int)v59, *(_DWORD *)(v1 + 20) + 56);
LABEL_165:
        v13 = *(_DWORD *)(v1 + 16) + 1;
        *(_DWORD *)(v1 + 16) = v13;
      }
      return v13;
    case 14:
      v13 = *(_DWORD *)(v1 + 20);
      if ( v13 )
      {
        v63 = *(unsigned __int16 **)(v13 + 184);
        if ( v63 )
        {
          if ( *(unsigned __int16 *)(v13 + 174) == *v63 - 1 )
          {
            if ( *(_BYTE *)(v1 + 5) )
              LOBYTE(v13) = sub_40F8B0(v1, 15);
            else
              LOBYTE(v13) = sub_40F8B0(v1, 17);
          }
        }
      }
      return v13;
    case 15:
      v13 = *(_DWORD *)(v1 + 20);
      if ( v13 )
      {
        v64 = *(unsigned __int16 **)(v13 + 184);
        if ( v64 )
        {
          if ( *(unsigned __int16 *)(v13 + 174) == *v64 - 1 )
            LOBYTE(v13) = sub_40F8B0(v1, byte_44B380);
        }
      }
      return v13;
    case 16:
      if ( *(_DWORD *)(v1 + 16) == 11 && !sub_407E30((AGLSOUNDBUFFER **)&unk_444974) )
      {
        sub_41ABD0(1);
        if ( byte_44B388 == 2 )
          sub_41AD70();
        sub_407E00((int)&unk_444974);
      }
      v61 = *(_DWORD *)(v1 + 20);
      if ( !v61 )
        goto LABEL_165;
      v62 = *(unsigned __int16 **)(v61 + 184);
      if ( !v62 || *(unsigned __int16 *)(v61 + 174) != *v62 - 1 )
        goto LABEL_165;
      byte_44B39D = 1;
      sub_40F8B0(v1, 1);
      v13 = *(_DWORD *)(v1 + 16) + 1;
      *(_DWORD *)(v1 + 16) = v13;
      return v13;
    case 17:
      v13 = *(_DWORD *)(v1 + 20);
      if ( v13 )
      {
        v65 = *(unsigned __int16 **)(v13 + 184);
        if ( v65 )
        {
          if ( *(unsigned __int16 *)(v13 + 174) == *v65 - 1 )
            LOBYTE(v13) = sub_40F8B0(v1, 18);
        }
      }
      return v13;
    case 18:
      byte_455C12 = 1;
      if ( !(_BYTE)dword_455004 )
        sub_434690(5u, 0);
      v13 = *(_DWORD *)(v1 + 20);
      if ( v13 )
      {
        v66 = *(unsigned __int16 **)(v13 + 184);
        if ( v66 )
        {
          if ( *(unsigned __int16 *)(v13 + 174) == *v66 - 1 )
          {
            byte_455C12 = 1;
            if ( !(_BYTE)dword_455004 )
              sub_434690(5u, 0);
            LOBYTE(v13) = sub_40F8B0(v1, 18);
          }
        }
      }
      return v13;
    case 19:
      if ( !byte_455CA9 )
        goto LABEL_156;
      v13 = *(_DWORD *)(v1 + 20);
      if ( v13 )
      {
        v35 = *(unsigned __int16 **)(v13 + 184);
        if ( v35 )
        {
          if ( *(unsigned __int16 *)(v13 + 174) == *v35 - 1 )
            LOBYTE(v13) = sub_40F8B0(v1, 19);
        }
      }
      return v13;
    case 20:
      v13 = *(_DWORD *)(v1 + 20);
      if ( v13 )
      {
        v36 = *(unsigned __int16 **)(v13 + 184);
        if ( v36 )
        {
          if ( *(unsigned __int16 *)(v13 + 174) == *v36 - 1 )
            LOBYTE(v13) = sub_40F8B0(v1, 0);
        }
      }
      return v13;
    default:
      return v13;
  }
}
// 440F04: using guessed type int dword_440F04;
// 444938: using guessed type int dword_444938;
// 444944: using guessed type int dword_444944;
// 44B318: using guessed type int dword_44B318;
// 44B31C: using guessed type int dword_44B31C;
// 44B320: using guessed type int dword_44B320;
// 44B327: using guessed type char byte_44B327;
// 44B328: using guessed type int dword_44B328;
// 44B330: using guessed type char byte_44B330;
// 44B331: using guessed type char byte_44B331;
// 44B334: using guessed type int dword_44B334[];
// 44B338: using guessed type int dword_44B338[];
// 44B33C: using guessed type int dword_44B33C[];
// 44B358: using guessed type char byte_44B358;
// 44B359: using guessed type char byte_44B359;
// 44B380: using guessed type char byte_44B380;
// 44B384: using guessed type int dword_44B384;
// 44B388: using guessed type char byte_44B388;
// 44B389: using guessed type char byte_44B389;
// 44B38A: using guessed type char byte_44B38A;
// 44B38B: using guessed type char byte_44B38B;
// 44B38C: using guessed type int dword_44B38C;
// 44B390: using guessed type int dword_44B390;
// 44B394: using guessed type int dword_44B394;
// 44B398: using guessed type int dword_44B398;
// 44B39C: using guessed type char byte_44B39C;
// 44B39D: using guessed type char byte_44B39D;
// 44B730: using guessed type int dword_44B730;
// 44B78C: using guessed type char byte_44B78C;
// 44B793: using guessed type char byte_44B793;
// 44EA98: using guessed type char byte_44EA98;
// 44EA99: using guessed type char byte_44EA99;
// 455004: using guessed type int dword_455004;
// 455C12: using guessed type char byte_455C12;
// 455C20: using guessed type int dword_455C20;
// 455C38: using guessed type int dword_455C38;
// 455C3C: using guessed type int dword_455C3C;
// 455CA9: using guessed type char byte_455CA9;

//----- (00410AC0) --------------------------------------------------------
bool __cdecl sub_410AC0(int a1, unsigned __int8 a2)
{
  return sub_41F420((float *)(a1 + 32), (float *)&dword_44B334[10 * (unsigned __int8)dword_440F04 + 3 * a2]) < 50.0;
}
// 440F04: using guessed type int dword_440F04;
// 44B334: using guessed type int dword_44B334[];

//----- (00410B10) --------------------------------------------------------
char __cdecl sub_410B10(int a1)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  double v5; // st7
  float v6; // ecx
  float v7; // eax
  char v8; // al

  if ( !a1 )
    return 0;
  if ( !(_BYTE)dword_455CB0 )
  {
    v2 = *(_DWORD *)(a1 + 20);
    if ( v2 )
    {
      *(_DWORD *)(v2 + 92) = *(_DWORD *)(a1 + 32);
      *(_DWORD *)(*(_DWORD *)(a1 + 20) + 96) = *(_DWORD *)(a1 + 36);
      *(_DWORD *)(*(_DWORD *)(a1 + 20) + 100) = *(_DWORD *)(a1 + 40);
      if ( byte_455C14 )
        sub_4083F0(*(int **)(a1 + 20));
    }
    dword_44EAB4 = a1;
    dword_44EAAC = *(_DWORD *)(a1 + 100);
    *(_DWORD *)(*(_DWORD *)(dword_44EAAC + 8) + 92) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(*(_DWORD *)(dword_44EAAC + 8) + 96) = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(*(_DWORD *)(dword_44EAAC + 8) + 100) = *(_DWORD *)(a1 + 40);
    LODWORD(dword_44EAB0) = *(_DWORD *)(dword_44EAB4 + 100) + 4;
    word_44EA94 = *(_WORD *)(LODWORD(dword_44EAB0) + 16) + *(_WORD *)(*(_DWORD *)(LODWORD(dword_44EAB0) + 12) + 32);
    if ( *(_BYTE *)(dword_44EAAC + 506) )
      dword_44EAB8 = *(_DWORD *)(dword_44EAAC + 4 * *(unsigned __int8 *)(dword_44EAAC + 508) + 184);
    if ( !byte_455CA5 )
    {
      v3 = *(_DWORD *)(a1 + 12);
      if ( (v3 & 0x8000) != 0 )
      {
        BYTE1(v3) = BYTE1(v3) & 0x7F | 0x20;
        *(_DWORD *)(a1 + 12) = v3;
        sub_431920();
        *(_BYTE *)(dword_44EAAC + 182) = 1;
        *(_BYTE *)(dword_44EAAC + 546) = 1;
        if ( *(_BYTE *)(a1 + 5) == 6 )
          byte_44B388 = 0;
        sub_40F8B0(a1, 0);
      }
      v4 = *(_DWORD *)(a1 + 12);
      if ( v4 & 0x400 )
      {
        BYTE1(v4) &= 0xFBu;
        *(_DWORD *)(a1 + 12) = v4;
        *(_BYTE *)(a1 + 5) = 6;
        sub_431610(a1);
        *(_DWORD *)(a1 + 44) = dword_44B35C;
        *(_DWORD *)(a1 + 48) = dword_44B360;
        *(_DWORD *)(a1 + 52) = dword_44B364;
        sub_430130(&dword_44B35C);
        dword_44B390 = sub_4336A0();
        dword_44B38C = dword_44B390;
        byte_44B39C = 0;
        LOBYTE(dword_440F04) = 1;
        HIBYTE(dword_455CB0) = 0;
        byte_44B39D = 0;
        byte_44B388 = 0;
        word_44B7EC = 0;
        word_44B7EE = 0;
        word_44B7F0 = 0;
        sub_407BB0((unsigned __int8)dword_455BF8);
        sub_40F8B0(a1, 1);
      }
      else if ( *(_DWORD *)(a1 + 20) )
      {
        sub_40FAF0(a1);
      }
      *(_WORD *)(dword_44EAAC + 504) = word_44EA94;
      sub_430420(dword_44EAB0);
      if ( *(_WORD *)(LODWORD(dword_44EAB0) + 104) == -1 )
        sub_430630(dword_44EAB0, COERCE_FLOAT(1));
      sub_41F2E0();
      v5 = *(float *)&dword_4412A4 + *(float *)(LODWORD(dword_44EAB0) + 32);
      flt_44E9E4 = v5;
      flt_44E9E8 = *(float *)&dword_4412A8 + *(float *)(LODWORD(dword_44EAB0) + 36);
      v6 = *(float *)(LODWORD(dword_44EAB0) + 40);
      dword_44E9F4 = 0;
      flt_44E9D8 = v5;
      dword_44E9EC = LODWORD(v6);
      flt_44E9DC = flt_44E9E8 - 400.0;
      flt_44E9E0 = v6 - 1600.0;
      sub_40A9F0(&flt_44E9D8);
      sub_40AD00((int)&flt_44E9D8, 5120.0);
      v7 = dword_44EAB0;
      if ( *(_BYTE *)(LODWORD(dword_44EAB0) + 112) )
      {
        sub_42D4A0(SLODWORD(dword_44EAB0), 0, *(float *)(LODWORD(dword_44EAB0) + 92));
        v7 = dword_44EAB0;
      }
      *(_DWORD *)(dword_44EAB4 + 32) = *(_DWORD *)(LODWORD(v7) + 32);
      *(_DWORD *)(dword_44EAB4 + 36) = *(_DWORD *)(LODWORD(dword_44EAB0) + 36);
      *(_DWORD *)(dword_44EAB4 + 40) = *(_DWORD *)(LODWORD(dword_44EAB0) + 40);
      sub_41F320();
      *(_DWORD *)LODWORD(dword_44EAB0) = *(_DWORD *)(dword_44EAB4 + 20);
      sub_410E20();
      v8 = *(_BYTE *)(a1 + 8);
      if ( v8 != 12 && v8 != 13 )
        sub_42CF10(SLODWORD(dword_44EAB0));
    }
  }
  return 1;
}
// 440F04: using guessed type int dword_440F04;
// 4412A4: using guessed type int dword_4412A4;
// 4412A8: using guessed type int dword_4412A8;
// 44B35C: using guessed type int dword_44B35C;
// 44B360: using guessed type int dword_44B360;
// 44B364: using guessed type int dword_44B364;
// 44B388: using guessed type char byte_44B388;
// 44B38C: using guessed type int dword_44B38C;
// 44B390: using guessed type int dword_44B390;
// 44B39C: using guessed type char byte_44B39C;
// 44B39D: using guessed type char byte_44B39D;
// 44B7EC: using guessed type __int16 word_44B7EC;
// 44B7EE: using guessed type __int16 word_44B7EE;
// 44B7F0: using guessed type __int16 word_44B7F0;
// 44E9D8: using guessed type float flt_44E9D8;
// 44E9DC: using guessed type float flt_44E9DC;
// 44E9E0: using guessed type float flt_44E9E0;
// 44E9E4: using guessed type float flt_44E9E4;
// 44E9E8: using guessed type float flt_44E9E8;
// 44E9EC: using guessed type int dword_44E9EC;
// 44E9F4: using guessed type int dword_44E9F4;
// 44EA94: using guessed type __int16 word_44EA94;
// 44EAB4: using guessed type int dword_44EAB4;
// 44EAB8: using guessed type int dword_44EAB8;
// 455BF8: using guessed type int dword_455BF8;
// 455C14: using guessed type char byte_455C14;
// 455CA5: using guessed type char byte_455CA5;
// 455CB0: using guessed type int dword_455CB0;

//----- (00410E20) --------------------------------------------------------
char sub_410E20()
{
  float v0; // eax
  int v1; // ecx
  int v2; // eax
  unsigned __int16 *v3; // ecx

  LOBYTE(v0) = *(_BYTE *)(LODWORD(dword_44EAB0) + 112);
  if ( LOBYTE(v0) )
  {
    if ( byte_44EA9A )
    {
      v1 = *(_DWORD *)(dword_44EAB4 + 12);
      LOBYTE(v1) = v1 | 0x80;
      *(_DWORD *)(dword_44EAB4 + 12) = v1;
      LOBYTE(v0) = sub_408670(*(float *)LODWORD(dword_44EAB0), 3, 0);
    }
    else
    {
      v2 = *(_DWORD *)(dword_44EAB4 + 12);
      if ( (v2 & 0x80u) == 0 )
      {
        LOBYTE(v2) = v2 | 0x80;
        *(_DWORD *)(dword_44EAB4 + 12) = v2;
        LOBYTE(v0) = sub_408670(*(float *)LODWORD(dword_44EAB0), 4, 0);
      }
      else
      {
        v0 = *(float *)LODWORD(dword_44EAB0);
        if ( *(_DWORD *)LODWORD(dword_44EAB0) )
        {
          v3 = *(unsigned __int16 **)(LODWORD(v0) + 184);
          if ( v3 )
          {
            if ( *(unsigned __int16 *)(LODWORD(v0) + 174) == *v3 - 1 )
              LOBYTE(v0) = sub_408670(v0, 4, 0);
          }
        }
      }
    }
  }
  return LOBYTE(v0);
}
// 44EA9A: using guessed type char byte_44EA9A;
// 44EAB4: using guessed type int dword_44EAB4;

//----- (00410EC0) --------------------------------------------------------
char sub_410EC0()
{
  char result; // al
  _DWORD *v1; // esi
  int v2; // ecx
  int v3; // eax
  unsigned __int8 v4; // dl
  unsigned __int8 v5; // cl
  double v6; // st7
  double v7; // st6
  float v8; // ST1C_4
  double v9; // st7

  result = sub_409D20(-255);
  v1 = (_DWORD *)dword_448ACC;
  if ( (_WORD)dword_44B3BC )
  {
    v2 = (unsigned __int16)(dword_44B3BC - 1);
    if ( *(_WORD *)(dword_448ACC + 10) <= 0x35u )
      v3 = 0;
    else
      v3 = *(_DWORD *)(dword_448ACC + 4) + 6784;
    *(_BYTE *)(v3 + 34) = byte_440FC8[5 * v2];
    *(_BYTE *)(v3 + 33) = byte_440FC9[5 * v2];
    *(_BYTE *)(v3 + 32) = byte_440FCA[5 * v2];
    v4 = byte_440FCB[5 * v2];
    v5 = byte_440FCC[5 * v2];
    v6 = (double)v4 * 0.0039215689;
    *(float *)(v3 + 36) = v6;
    v7 = (double)v5 * 0.0039215689;
    *(float *)(v3 + 40) = v7;
    v8 = (double)(unsigned __int8)(v4 + 39) * 0.0039215689;
    *(float *)(v3 + 64) = v8;
    *(float *)(v3 + 68) = v7;
    *(float *)(v3 + 120) = v8;
    *(float *)(v3 + 92) = v6;
    v9 = (double)(unsigned __int8)(v5 + 39) * 0.0039215689;
    *(float *)(v3 + 96) = v9;
    *(float *)(v3 + 124) = v9;
    sub_40A060(v1, &dword_44B3B0, 53, 1);
    result = byte_455C14;
    if ( byte_455C14 )
    {
      LOWORD(dword_44B3BC) = dword_44B3BC + 1;
      if ( (unsigned __int16)dword_44B3BC > 0xCu )
        LOWORD(dword_44B3BC) = 0;
    }
  }
  return result;
}
// 448ACC: using guessed type int dword_448ACC;
// 44B3B0: using guessed type int dword_44B3B0;
// 44B3BC: using guessed type int dword_44B3BC;
// 455C14: using guessed type char byte_455C14;

//----- (00411010) --------------------------------------------------------
int __cdecl sub_411010(int a1, int a2)
{
  *(_DWORD *)(a1 + 2532) = a2;
  *(_DWORD *)(a1 + 2512) = sub_411060;
  *(_BYTE *)a1 = 3;
  *(_BYTE *)(a1 + 2530) = 1;
  *(_BYTE *)(a1 + 2531) = 8;
  *(_WORD *)(a1 + 2528) = 1;
  return sub_40B9B0(a1, 0xAu, 0xAu, 0x24u, 0, 0x2Eu, 0xAu);
}

//----- (00411060) --------------------------------------------------------
int __cdecl sub_411060(int a1, int a2)
{
  int v2; // ebx
  int v3; // eax
  unsigned int v4; // edx
  int v5; // edi
  int v6; // ebp
  int v7; // ST40_4
  int v8; // ST3C_4
  float v9; // ST38_4

  v2 = 10 * rand() / 0x7FFF;
  *(_BYTE *)(a2 + 87) = v2;
  sub_40BE40(a2, 0.0, 0, 0);
  sub_40BE80(a2, 50.0, 1112014848, 1112014848);
  sub_40BE60(a2, -50.0, -1035468800, -1035468800);
  v3 = rand();
  v4 = (signed int)(20 * v3 + ((unsigned __int64)(-42948362180i64 * v3) >> 32)) >> 14;
  v5 = v4 + (v4 >> 31) - 10;
  v6 = 20 * rand() / 0x7FFF - 10;
  *(float *)&v7 = (double)(signed __int16)((signed __int16)(20 * rand()) / 0x7FFF - 10);
  *(float *)&v8 = (double)(signed __int16)v6;
  v9 = (double)(signed __int16)v5;
  sub_40BEA0(a2, v9, v8, v7);
  sub_40BEE0(a2, 100.0, 1120403456, 1120403456);
  sub_40BEC0(a2, -100.0, -1027080192, -1027080192);
  sub_40BF00(a2, 0.0, 0, 0, 1);
  sub_40BF30((_WORD *)a2, 16256, 0, 0, (unsigned __int8)v2);
  return sub_40BF90((_WORD *)a2, 0, -16256, 0, (unsigned __int8)v2);
}

//----- (004111C0) --------------------------------------------------------
int __cdecl sub_4111C0(int a1, float *a2)
{
  *(_DWORD *)(a1 + 2512) = sub_411230;
  *(_BYTE *)a1 = 4;
  *(_DWORD *)(a1 + 2532) = a2;
  sub_40B920(a1, a2[23], a2[24], a2[25]);
  *(_BYTE *)(a1 + 2530) = 1;
  *(_BYTE *)(a1 + 2531) = 10;
  *(_WORD *)(a1 + 2528) = 1;
  return sub_40B9B0(a1, 0x80u, 0x40u, 0, 0, 0x10u, 0x10u);
}

//----- (00411230) --------------------------------------------------------
__int16 __cdecl sub_411230(int a1, int a2)
{
  unsigned __int8 v2; // bl
  int v3; // eax
  unsigned int v4; // edx
  int v5; // edi
  int v6; // ebp
  int v7; // ST40_4
  int v8; // ST3C_4
  float v9; // ST38_4
  int v10; // eax
  unsigned int v11; // eax
  int v12; // edi
  int v13; // eax
  unsigned int v14; // edx
  int v15; // ebp
  int v16; // eax
  unsigned int v17; // eax
  int v18; // ST40_4
  int v19; // ST3C_4
  float v20; // ST38_4

  v2 = 25 * rand() / 0x7FFF + 60;
  *(_BYTE *)(a2 + 87) = v2;
  v3 = rand();
  v4 = (signed int)(200 * v3 + ((unsigned __int64)(-429483621800i64 * v3) >> 32)) >> 14;
  v5 = v4 + (v4 >> 31) - 100;
  v6 = 200 * rand() / 0x7FFF - 100;
  *(float *)&v7 = (double)(signed __int16)((signed __int16)(200 * rand()) / 0x7FFF - 100);
  *(float *)&v8 = (double)(signed __int16)v6;
  v9 = (double)(signed __int16)v5;
  sub_40BE40(a2, v9, v8, v7);
  sub_40BE80(a2, 100.0, 1120403456, 1120403456);
  sub_40BE60(a2, -100.0, -1027080192, -1027080192);
  v10 = rand();
  v11 = (signed int)(15 * v10 + ((unsigned __int64)(-32211271635i64 * v10) >> 32)) >> 14;
  v12 = v11 + (v11 >> 31) - 7;
  v13 = rand();
  v14 = (signed int)(15 * v13 + ((unsigned __int64)(-32211271635i64 * v13) >> 32)) >> 14;
  v15 = v14 + (v14 >> 31) - 8;
  v16 = rand();
  v17 = (signed int)(20 * v16 + ((unsigned __int64)(-42948362180i64 * v16) >> 32)) >> 14;
  *(float *)&v18 = (double)(signed __int16)(v17 + (v17 >> 31) - 10);
  *(float *)&v19 = (double)(signed __int16)v15;
  v20 = (double)(signed __int16)v12;
  sub_40BEA0(a2, v20, v19, v18);
  sub_40BEE0(a2, 15.0, 1097859072, 1097859072);
  sub_40BEC0(a2, -15.0, -1049624576, -1049624576);
  sub_40BF00(a2, 0.0, 0, 0, 1);
  return sub_40BF30((_WORD *)a2, 25600, 25600, 25600, v2);
}

//----- (00411420) --------------------------------------------------------
char __cdecl sub_411420(int a1)
{
  int v1; // esi
  int v3; // eax
  int v4; // eax
  unsigned int v5; // eax
  int v6; // eax
  int v7; // edx
  int v8; // ecx
  int v9; // edx
  int v10; // eax
  float v11; // ST0C_4
  int v12; // eax
  int v13; // edx
  int v14; // eax
  int v15; // eax
  int v16; // ecx
  int v17; // edx
  float v18; // ST0C_4
  int v19; // eax
  int v20; // eax
  float *v21; // edi
  double v22; // st7
  signed int v23; // ST2C_4
  double v24; // st6
  int v25; // ebx
  signed int v26; // ebp
  char v27; // cl
  int v28; // eax
  char v29; // dl
  int v30; // eax
  float *v31; // edi
  double v32; // st7
  float v33; // ST10_4
  float v34; // ST10_4
  float v35; // ST10_4
  int v36; // eax
  unsigned int v37; // eax
  int v38; // edx
  int v39; // eax
  int v40; // ecx
  float v41; // ST08_4
  float v42; // ST04_4
  _DWORD *v43; // eax
  char v44; // cl
  int v45; // eax
  int *v46; // edi
  _DWORD *v47; // eax
  char v48; // bl
  unsigned __int8 v49; // bl
  double v51; // st7
  char v52; // c0
  double v54; // st7
  char v55; // c0
  double v57; // st7
  char v58; // c0
  float v59; // [esp+24h] [ebp-24h]
  float v60; // [esp+28h] [ebp-20h]
  float v61; // [esp+30h] [ebp-18h]
  float v62; // [esp+34h] [ebp-14h]
  float v63; // [esp+38h] [ebp-10h]
  float v64; // [esp+3Ch] [ebp-Ch]
  float v65; // [esp+40h] [ebp-8h]
  float v66; // [esp+44h] [ebp-4h]
  float v67; // [esp+4Ch] [ebp+4h]

  v1 = a1;
  if ( *(float *)&a1 == 0.0 )
    return 0;
  v3 = *(_DWORD *)(a1 + 20);
  if ( v3 )
  {
    *(_DWORD *)(v3 + 92) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 96) = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 100) = *(_DWORD *)(a1 + 40);
    if ( byte_455C14 )
      sub_4083F0(*(int **)(a1 + 20));
  }
  if ( (_BYTE)dword_455CB0 || byte_455CB4 )
    return 1;
  if ( *(_DWORD *)(a1 + 12) & 0x1000000 || sub_41F2C0() )
  {
    if ( dword_455BF8 != 8 && !sub_407E30((AGLSOUNDBUFFER **)&unk_4447A0) && *(_DWORD *)(a1 + 12) & 0x1000000 )
      sub_407E00((int)&unk_4447A0);
    v4 = *(_DWORD *)(a1 + 12);
    if ( v4 & 0x1000000 )
    {
      *(_DWORD *)(a1 + 16) = 0;
      v5 = v4 & 0xFC807FFF | 0x800400;
    }
    else
    {
      *(_DWORD *)(a1 + 16) = 0;
      v5 = v4 & 0xFE007FFF | 0x2000000;
    }
    *(_DWORD *)(a1 + 12) = v5;
    *(_DWORD *)(a1 + 12) &= 0xFEFFFFFF;
  }
  v6 = *(_DWORD *)(a1 + 12);
  if ( v6 & 0x400 )
  {
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 92) = 0;
    *(_DWORD *)(a1 + 12) = v6 & 0xF8103BFE | 0x100000;
    if ( *(_DWORD *)(a1 + 20) && dword_44B7C0 && *(_BYTE *)(dword_44B7C0 + 4) == 32 )
    {
      LOBYTE(dword_44B7BC) = 0;
      dword_44B7C0 = 0;
    }
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 4) = 0;
    v7 = *(_DWORD *)(a1 + 20) + 56;
    *(_DWORD *)(a1 + 80) = 0;
    *(_DWORD *)(a1 + 76) = 0;
    sub_4080B0(2048, v7);
    v8 = *(_DWORD *)(a1 + 48);
    v9 = *(_DWORD *)(a1 + 52);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 36) = v8;
    *(_DWORD *)(a1 + 40) = v9;
    if ( dword_44B3A8 )
    {
      *(_BYTE *)(dword_44B3A8 + 2530) = 0;
      *(_DWORD *)(dword_44B3A8 + 2512) = 0;
      dword_44B3A8 = 0;
    }
    dword_44B714 = 0;
    dword_44B3C0 = 0;
    byte_455CB4 = 0;
  }
  v10 = *(_DWORD *)(a1 + 12);
  if ( v10 & 0x100000 )
  {
    if ( !*(_DWORD *)(a1 + 16) )
    {
      v11 = *(float *)(a1 + 20);
      *(_DWORD *)(a1 + 16) = dword_455BE0;
      sub_408670(v11, 0, 0);
      v12 = *(_DWORD *)(a1 + 12);
      BYTE1(v12) &= 0xBFu;
      *(_DWORD *)(a1 + 12) = v12;
      sub_4080B0(2048, *(_DWORD *)(a1 + 20) + 56);
      v13 = *(_DWORD *)(a1 + 36);
      v14 = *(_DWORD *)(a1 + 40);
      *(_DWORD *)(a1 + 44) = *(_DWORD *)(a1 + 32);
      *(_DWORD *)(a1 + 48) = v13;
      *(_DWORD *)(a1 + 52) = v14;
      byte_44B3A4 = 0;
      dword_44B3C0 = 0;
    }
    if ( dword_44B7C0 == a1 )
    {
      v15 = sub_4336A0();
      *(_DWORD *)(a1 + 80) = v15;
      *(_DWORD *)(a1 + 76) = v15;
      if ( !sub_407E30((AGLSOUNDBUFFER **)&unk_44477C) && dword_455BF8 != 5 && !HIBYTE(dword_455CB0) )
        sub_407E00((int)&unk_44477C);
      v16 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 12) = v16 & 0xFC017FFF | 0x10000;
    }
    goto LABEL_140;
  }
  if ( !(v10 & 0x10000) )
  {
    if ( !(v10 & 0x800000) )
    {
      if ( v10 & 0x2000000 )
      {
        BYTE1(v10) |= 0x40u;
        *(_DWORD *)(a1 + 12) = v10;
        if ( *(_DWORD *)(a1 + 20) && dword_44B7C0 && *(_BYTE *)(dword_44B7C0 + 4) == 32 )
        {
          LOBYTE(dword_44B7BC) = 0;
          dword_44B7C0 = 0;
        }
        if ( dword_44B3A8 )
        {
          *(_BYTE *)(dword_44B3A8 + 2530) = 0;
          *(_DWORD *)(dword_44B3A8 + 2512) = 0;
          dword_44B3A8 = 0;
        }
        *(_DWORD *)(*(_DWORD *)(a1 + 20) + 4) = 0;
      }
      goto LABEL_140;
    }
    if ( *(_DWORD *)(a1 + 16) )
    {
LABEL_112:
      v37 = *(_DWORD *)(a1 + 16);
      if ( v37 == 1 )
        *(_DWORD *)(a1 + 12) |= 0x4000u;
      if ( v37 > 0x28 )
      {
        byte_455CB5 = byte_44B3C4;
        byte_455CB6 = byte_44B3AC;
        sub_4080B0(2048, *(_DWORD *)(a1 + 20) + 56);
        v38 = *(_DWORD *)(a1 + 48);
        v39 = *(_DWORD *)(a1 + 52);
        *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 44);
        v40 = *(_DWORD *)(a1 + 12);
        *(_DWORD *)(a1 + 36) = v38;
        *(_DWORD *)(a1 + 40) = v39;
        *(_DWORD *)(a1 + 16) = 0;
        *(_DWORD *)(a1 + 12) = v40 & 0xFC107FFE | 0x100000;
        dword_44B714 = 0;
        if ( dword_44B3A8 )
        {
          *(_BYTE *)(dword_44B3A8 + 2530) = 0;
          *(_DWORD *)(dword_44B3A8 + 2512) = 0;
          dword_44B3A8 = 0;
        }
        if ( dword_44B3A0 )
        {
          *(_BYTE *)(dword_44B3A0 + 2530) = 0;
          *(_DWORD *)(dword_44B3A0 + 2512) = 0;
          dword_44B3A0 = 0;
        }
        v41 = *(float *)(a1 + 40) - 50.0;
        v42 = *(float *)(a1 + 36) - 64.0;
        sub_40C9D0(*(float *)(a1 + 32), v42, v41, 8, 1120403456, 1124073472);
        sub_434530();
        goto LABEL_140;
      }
      if ( dword_455BF8 == 5 )
      {
        v45 = *(_DWORD *)(a1 + 12);
        *(_DWORD *)(a1 + 16) = 41;
        *(_DWORD *)(a1 + 12) = v45 | 0x4000;
        dword_44B714 = 0;
        goto LABEL_140;
      }
      if ( v37
        || (LOWORD(dword_44B3BC) = 0,
            sub_411FD0(
              *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 20) + 180) + 328),
              *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 20) + 180) + 332),
              *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 20) + 180) + 336)),
            byte_44B3C4 = byte_455CB5,
            byte_44B3AC = byte_455CB6,
            dword_44B3C0) )
      {
        if ( dword_44B3C0 != a1 )
        {
LABEL_130:
          ++*(_DWORD *)(a1 + 16);
          goto LABEL_140;
        }
      }
      else
      {
        dword_44B3C0 = a1;
      }
      sub_410EC0();
      v43 = sub_40B8D0();
      v44 = byte_44B3A4;
      dword_44B3A0 = (int)v43;
      if ( byte_44B3A4 )
        v44 = byte_44B3A4-- - 1;
      if ( v43 && !v44 )
      {
        sub_4111C0((int)v43, (float *)(*(_DWORD *)(*(_DWORD *)(a1 + 20) + 180) + 236));
        byte_44B3A4 = 50;
      }
      goto LABEL_130;
    }
    sub_434500(0x78u);
    if ( dword_455BF8 != 5 )
      sub_407E00((int)&unk_4447A0);
    v36 = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 92) = 0;
    *(_DWORD *)(v36 + 4) = 0;
    if ( dword_44B7C0 != a1 && !sub_412010(a1) )
    {
LABEL_111:
      byte_44B3D3 = 0;
      goto LABEL_112;
    }
    if ( sub_41F2C0() || dword_455BF8 == 5 )
    {
      if ( !dword_44B7C0 || *(_BYTE *)(dword_44B7C0 + 4) != 32 )
        goto LABEL_110;
    }
    else
    {
      sub_41BB60(0);
      byte_44B793 = 1;
      sub_41ED70(0xFFu);
      BYTE2(dword_44B80C) = 0;
      byte_44B818 = 0;
      *(_DWORD *)(a1 + 12) |= 0x4004000u;
      if ( !dword_44B7C0 || *(_BYTE *)(dword_44B7C0 + 4) != 32 )
        goto LABEL_110;
    }
    LOBYTE(dword_44B7BC) = 0;
    dword_44B7C0 = 0;
LABEL_110:
    sub_4159D0(a1);
    goto LABEL_111;
  }
  *(_DWORD *)(a1 + 80) = sub_4336A0();
  if ( byte_455CA5 || !(dword_455BEC & 0x800) || sub_41F2C0() || dword_44B7C0 == a1 )
  {
    if ( HIBYTE(dword_455CB0) )
      goto LABEL_140;
  }
  else
  {
    if ( HIBYTE(dword_455CB0) )
      goto LABEL_140;
    if ( dword_455BF8 != 5 )
    {
      v17 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 12) = v17 & 0xFC807FFF | 0x800000;
      if ( !sub_412010(a1) && !sub_41F2C0() )
      {
        *(_DWORD *)(a1 + 12) |= 1u;
        sub_412040(a1);
        return 1;
      }
      return 1;
    }
  }
  if ( !*(_DWORD *)(a1 + 16) )
  {
    v18 = *(float *)(a1 + 20);
    *(_DWORD *)(a1 + 16) = dword_455BE0;
    sub_408670(v18, 0, 0);
  }
  if ( dword_455BF8 == 5 && (unsigned __int8)byte_440FBD + *(_DWORD *)(a1 + 76) - *(_DWORD *)(a1 + 80) == 8 )
    sub_408670(*(float *)(a1 + 20), 1, 0);
  if ( *(_DWORD *)(a1 + 80) - *(_DWORD *)(a1 + 76) <= (unsigned __int8)byte_440FB8[dword_455BF8] - 1 )
  {
    if ( dword_455BF8 == 5 )
      return 1;
    v20 = *(_DWORD *)(a1 + 20);
    if ( v20 )
    {
      v21 = *(float **)(v20 + 180);
      v22 = v21[37];
      if ( v22 > 0.0 )
      {
        v23 = *((_DWORD *)dword_443D44 + 3);
        v24 = (double)v23;
        v59 = v21[35] * v24 / v22 + (double)(*((_DWORD *)dword_443D44 + 2) / 2);
        *(float *)&a1 = v21[36] * v24 / v22 + (double)(v23 / 2);
      }
      if ( v59 > 12.0 )
      {
        v25 = *((_DWORD *)dword_443D44 + 2);
        if ( (double)(v25 - 12) > v59 && *(float *)&a1 > 0.0 )
        {
          v26 = *((_DWORD *)dword_443D44 + 3);
          v60 = (double)v26;
          if ( *(float *)&a1 < (double)v60 && !(_BYTE)dword_455004 )
          {
            v27 = *(_BYTE *)(v1 + 76) + byte_440FB8[dword_455BF8] - *(_BYTE *)(v1 + 80);
            if ( byte_44B812 && dword_44B7C0 && *(_BYTE *)(dword_44B7C0 + 4) == *(_BYTE *)(v1 + 4)
              || byte_44B78F && dword_44B7C0 && *(_BYTE *)(dword_44B7C0 + 4) == *(_BYTE *)(v1 + 4) )
            {
              if ( !byte_455CA5 )
              {
                if ( byte_44B812 )
                {
                  v28 = dword_455C7C;
                  if ( dword_455C7C )
                  {
                    while ( 1 )
                    {
                      if ( *(_DWORD *)(v28 + 12) & 0x10000 )
                      {
                        v29 = *(_BYTE *)(v28 + 4);
                        if ( v29 == 15 || v29 == 16 )
                          break;
                      }
                      v28 = *(_DWORD *)v28;
                      if ( !v28 )
                      {
                        byte_44B3D4 = 0;
                        goto LABEL_140;
                      }
                    }
                    if ( v28 )
                    {
                      v30 = *(_DWORD *)(v28 + 20);
                      if ( v30 )
                      {
                        v31 = *(float **)(v30 + 180);
                        v32 = v31[37];
                        if ( v32 > 0.0 )
                        {
                          v59 = v31[35] * v60 / v32 + (double)(v25 / 2);
                          *(float *)&a1 = v31[36] * v60 / v32 + (double)(v26 / 2);
                        }
                        if ( v27 )
                        {
                          v33 = *(float *)&a1 - 120.0;
                          sub_40EA90(v59, v33, v27);
                          byte_44B3D4 = 0;
                          goto LABEL_140;
                        }
                      }
                    }
                  }
                }
                else if ( v27 )
                {
                  v34 = flt_44B7E8 - 30.0;
                  sub_40EA90(dword_44B7E4, v34, v27);
                }
              }
              byte_44B3D4 = 0;
              goto LABEL_140;
            }
            if ( byte_44B3D4 && !byte_455CA5 && v27 )
            {
              v35 = *(float *)&a1 - 25.0;
              sub_40EA90(v59, v35, v27);
            }
            byte_44B3D4 = 1;
          }
        }
      }
    }
  }
  else
  {
    if ( dword_44B7C0 != a1 && !sub_412010(a1) && !sub_41F2C0() && dword_455BF8 != 5 )
    {
      *(_DWORD *)(a1 + 12) |= 1u;
      if ( dword_455BF8 != 5 )
        sub_412040(a1);
    }
    v19 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 12) = v19 & 0xFC807FFF | 0x800000;
  }
LABEL_140:
  if ( dword_455BF8 == 5 || !(*(_DWORD *)(v1 + 12) & 0x10000) || HIBYTE(dword_455CB0) )
    return 1;
  v46 = (int *)(*(_DWORD *)(*(_DWORD *)(v1 + 20) + 180) + 236);
  if ( dword_455BF8 == 7 )
  {
    if ( byte_44B812 || byte_44B78F )
    {
      byte_44B3D3 = 1;
      sub_433210(0);
    }
    else if ( (unsigned __int8)byte_44B3D3 >= 0xFu )
    {
      sub_433210(1);
    }
    else
    {
      ++byte_44B3D3;
      sub_433210(0);
    }
    v48 = 80 * rand() / 0x7FFF + 35;
    v64 = *((float *)v46 + 23);
    v65 = *((float *)v46 + 24);
    v66 = *((float *)v46 + 25);
    sub_433180(&v64, v48);
    v49 = v48 - 20;
    v61 = v64 * 0.5;
    v62 = v65 * 0.5;
    v63 = v66 * 0.5;
    v51 = v61;
    if ( v52 )
      v51 = -v51;
    v67 = (double)v49;
    if ( v51 > v67 )
      goto LABEL_172;
    v54 = v63;
    if ( v55 )
      v54 = -v54;
    if ( v54 > v67 )
      goto LABEL_172;
    v57 = v62;
    if ( v58 )
      v57 = -v57;
    if ( v57 > v67 )
    {
LABEL_172:
      v64 = v61 * 0.5;
      v65 = v62 * 0.5;
      v66 = v63 * 0.5;
      sub_433180(&v64, v49);
      sub_433180(&v64, v49 - 5);
      v64 = v61 * -0.5;
      v65 = v62 * -0.5;
      v66 = v63 * -0.5;
      sub_433180(&v64, v49 - 2);
    }
    return 1;
  }
  if ( byte_44B812 && dword_44B7C0 )
  {
LABEL_148:
    if ( !byte_44B78F || *(_BYTE *)(dword_44B7C0 + 4) == *(_BYTE *)(v1 + 4) )
      return 1;
    goto LABEL_150;
  }
  if ( byte_44B78F )
  {
    if ( !dword_44B7C0 )
      return 1;
    goto LABEL_148;
  }
LABEL_150:
  v47 = (_DWORD *)dword_44B3A8;
  if ( dword_44B3A8 || (v47 = sub_40B8D0(), (dword_44B3A8 = (int)v47) != 0) )
  {
    sub_411010((int)v47, (int)v46);
    return 1;
  }
  return 1;
}
// 440FBD: using guessed type char byte_440FBD;
// 44B3A0: using guessed type int dword_44B3A0;
// 44B3A4: using guessed type char byte_44B3A4;
// 44B3A8: using guessed type int dword_44B3A8;
// 44B3AC: using guessed type char byte_44B3AC;
// 44B3BC: using guessed type int dword_44B3BC;
// 44B3C0: using guessed type int dword_44B3C0;
// 44B3C4: using guessed type char byte_44B3C4;
// 44B3D3: using guessed type char byte_44B3D3;
// 44B3D4: using guessed type char byte_44B3D4;
// 44B714: using guessed type int dword_44B714;
// 44B78F: using guessed type char byte_44B78F;
// 44B793: using guessed type char byte_44B793;
// 44B7BC: using guessed type int dword_44B7BC;
// 44B7C0: using guessed type int dword_44B7C0;
// 44B7E8: using guessed type float flt_44B7E8;
// 44B80C: using guessed type int dword_44B80C;
// 44B812: using guessed type char byte_44B812;
// 44B818: using guessed type char byte_44B818;
// 455004: using guessed type int dword_455004;
// 455BE0: using guessed type int dword_455BE0;
// 455BEC: using guessed type int dword_455BEC;
// 455BF8: using guessed type int dword_455BF8;
// 455C14: using guessed type char byte_455C14;
// 455C7C: using guessed type int dword_455C7C;
// 455CA5: using guessed type char byte_455CA5;
// 455CB0: using guessed type int dword_455CB0;
// 455CB4: using guessed type char byte_455CB4;
// 455CB5: using guessed type char byte_455CB5;
// 455CB6: using guessed type char byte_455CB6;

//----- (00411FD0) --------------------------------------------------------
int __cdecl sub_411FD0(int a1, int a2, int a3)
{
  int result; // eax

  result = 0;
  while ( (_WORD)dword_44B3BC )
  {
    if ( (unsigned int)++result >= 1 )
      return result;
  }
  result = a1;
  LOWORD(dword_44B3BC) = 1;
  dword_44B3B0 = a1;
  dword_44B3B4 = a2;
  dword_44B3B8 = a3;
  return result;
}
// 44B3B0: using guessed type int dword_44B3B0;
// 44B3B4: using guessed type int dword_44B3B4;
// 44B3B8: using guessed type int dword_44B3B8;
// 44B3BC: using guessed type int dword_44B3BC;

//----- (00412010) --------------------------------------------------------
bool __cdecl sub_412010(int a1)
{
  return sub_41F420(&dword_44B73C, (float *)(a1 + 32)) < 250.0;
}

//----- (00412040) --------------------------------------------------------
void __cdecl sub_412040(int a1)
{
  int i; // esi
  char v2; // al
  double v3; // st7
  double v4; // st7
  double v5; // st7
  double v6; // st7
  double v7; // st7
  double v8; // st7

  for ( i = dword_455C7C; i; i = *(_DWORD *)i )
  {
    v2 = *(_BYTE *)(i + 4);
    if ( v2 == 1 || v2 == 2 || v2 == 4 || v2 == 5 || v2 == 6 || v2 == 7 || v2 == 8 )
    {
      v3 = *(float *)(i + 32) - *(float *)(a1 + 32);
      if ( v3 < 0.0 )
        v3 = -v3;
      if ( v3 <= 350.0 )
      {
        v4 = *(float *)(i + 36) - *(float *)(a1 + 36);
        if ( v4 < 0.0 )
          v4 = -v4;
        if ( v4 <= 350.0 )
        {
          v5 = *(float *)(i + 40) - *(float *)(a1 + 40);
          if ( v5 < 0.0 )
            v5 = -v5;
          if ( v5 <= 350.0
            && sub_41F420((float *)(i + 32), (float *)(a1 + 32)) <= 350.0
            && dword_455BF8 != 10
            && *(_BYTE *)(a1 + 4) != 6 )
          {
            sub_4166E0(i);
          }
        }
      }
    }
    if ( dword_455BF8 == 11 && *(_BYTE *)(i + 4) == 10 )
    {
      v6 = *(float *)(i + 32) - *(float *)(a1 + 32);
      if ( v6 < 0.0 )
        v6 = -v6;
      if ( v6 <= 350.0 )
      {
        v7 = *(float *)(i + 36) - *(float *)(a1 + 36);
        if ( v7 < 0.0 )
          v7 = -v7;
        if ( v7 <= 350.0 )
        {
          v8 = *(float *)(i + 40) - *(float *)(a1 + 40);
          if ( v8 < 0.0 )
            v8 = -v8;
          if ( v8 <= 350.0 && sub_41F420((float *)(i + 32), (float *)(a1 + 32)) <= 350.0 )
            sub_41AC70(i, 0, (float *)(a1 + 32));
        }
      }
    }
  }
}
// 455BF8: using guessed type int dword_455BF8;
// 455C7C: using guessed type int dword_455C7C;

//----- (004121D0) --------------------------------------------------------
int __cdecl sub_4121D0(unsigned __int8 a1)
{
  _DWORD *v1; // eax
  int v2; // esi
  double v3; // st7
  int result; // eax
  float v5; // [esp+8h] [ebp+4h]

  v1 = dword_443D2C;
  v2 = *((_DWORD *)dword_443D2C + 16032);
  *((_DWORD *)dword_443D2C + 16032) = v2 + 128;
  *(_DWORD *)(v2 + 4) = 0;
  *(_DWORD *)v2 = v1[30];
  v1[30] = v2;
  *(_BYTE *)(v2 + 34) = -1;
  *(_BYTE *)(v2 + 33) = -1;
  *(_BYTE *)(v2 + 32) = -1;
  v3 = (double)(2 * a1 - 60);
  *(_DWORD *)(v2 + 20) = 1134821376;
  *(_DWORD *)(v2 + 48) = 1134821376;
  *(float *)(v2 + 16) = v3;
  *(_DWORD *)(v2 + 76) = 1137483776;
  *(_DWORD *)(v2 + 104) = 1137483776;
  *(_DWORD *)(v2 + 4) = 5;
  *(_DWORD *)(v2 + 28) = 1065353216;
  *(_DWORD *)(v2 + 56) = 1065353216;
  *(_DWORD *)(v2 + 84) = 1065353216;
  *(_DWORD *)(v2 + 112) = 1065353216;
  v5 = v3 + 85.0;
  *(float *)(v2 + 44) = v5;
  *(float *)(v2 + 100) = v5;
  *(_DWORD *)(v2 + 40) = 1053872337;
  *(float *)(v2 + 72) = v3;
  *(_DWORD *)(v2 + 68) = 1053872337;
  *(_DWORD *)(v2 + 24) = 0;
  *(_DWORD *)(v2 + 52) = 0;
  *(_DWORD *)(v2 + 80) = 0;
  *(_DWORD *)(v2 + 108) = 0;
  *(_DWORD *)(v2 + 36) = 1059629225;
  *(_DWORD *)(v2 + 64) = 1063971563;
  *(_DWORD *)(v2 + 92) = 1059629225;
  *(_DWORD *)(v2 + 96) = 1059563432;
  *(_DWORD *)(v2 + 120) = 1063971563;
  *(_DWORD *)(v2 + 124) = 1059563432;
  result = sub_401000(0, 0, 1194, 104);
  *(_DWORD *)(v2 + 8) = result;
  return result;
}

//----- (004122C0) --------------------------------------------------------
char __cdecl sub_4122C0(unsigned __int8 a1, char a2, unsigned __int8 a3)
{
  _DWORD *v3; // eax
  int v4; // esi
  double v5; // st7
  unsigned __int16 v6; // cx
  unsigned __int16 v7; // dx
  unsigned __int16 v8; // cx
  char result; // al

  sub_401580(1);
  if ( a1 != -1 )
  {
    v3 = dword_443D2C;
    v4 = *((_DWORD *)dword_443D2C + 16032);
    *((_DWORD *)dword_443D2C + 16032) = v4 + 128;
    *(_DWORD *)(v4 + 4) = 0;
    *(_DWORD *)v4 = v3[30];
    v3[30] = v4;
    *(_BYTE *)(v4 + 34) = -1;
    *(_BYTE *)(v4 + 33) = -1;
    *(_BYTE *)(v4 + 32) = -1;
    *(_DWORD *)(v4 + 4) = 5;
    v5 = (double)((unsigned __int16)dword_455BE4 - 45);
    *(_DWORD *)(v4 + 20) = 1138819072;
    *(float *)(v4 + 16) = v5;
    v6 = dword_455BE4;
    *(_DWORD *)(v4 + 48) = 1138819072;
    *(float *)(v4 + 44) = (double)(v6 - 13);
    v7 = dword_455BE4;
    *(_DWORD *)(v4 + 76) = 1139834880;
    *(float *)(v4 + 72) = (double)(v7 - 45);
    v8 = dword_455BE4;
    *(_DWORD *)(v4 + 104) = 1139834880;
    *(_DWORD *)(v4 + 28) = 1065353216;
    *(_DWORD *)(v4 + 56) = 1065353216;
    *(_DWORD *)(v4 + 84) = 1065353216;
    *(_DWORD *)(v4 + 112) = 1065353216;
    *(float *)(v4 + 100) = (double)(v8 - 13);
    *(_DWORD *)(v4 + 40) = 1039726841;
    *(_DWORD *)(v4 + 68) = 1039726841;
    *(_DWORD *)(v4 + 24) = 0;
    *(_DWORD *)(v4 + 52) = 0;
    *(_DWORD *)(v4 + 80) = 0;
    *(_DWORD *)(v4 + 108) = 0;
    *(_DWORD *)(v4 + 36) = 1060945085;
    *(_DWORD *)(v4 + 64) = 1062918875;
    *(_DWORD *)(v4 + 92) = 1060945085;
    *(_DWORD *)(v4 + 96) = 1047589105;
    *(_DWORD *)(v4 + 120) = 1062918875;
    *(_DWORD *)(v4 + 124) = 1047589105;
    *(_DWORD *)(v4 + 8) = sub_401000(0, 0, 1263, 31);
    sub_401D10();
    byte_443AF2 = -1;
    byte_443AF1 = -1;
    byte_443AF0 = 0;
    sub_4015D0(0x10000000u, 420, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, a1);
    sub_401D10();
  }
  sub_401580(3);
  byte_443AF2 = 0;
  byte_443AF1 = 0;
  byte_443AF0 = 0;
  byte_443C1D = 0;
  byte_443C1E = 0;
  byte_443C1C = 0;
  if ( !a2 )
  {
    sub_4121D0(a3);
    sub_401D10();
  }
  sub_401E50(-5, 0, 645, 2 * a3, 2);
  sub_401E50(-5, 2 * (240 - a3), 645, 2 * a3, 2);
  if ( dword_455BEC & 0x4000 )
  {
    sub_404910(0, 0x4000);
    result = 0;
  }
  else
  {
    dword_455BEC = 0;
    result = 1;
  }
  return result;
}
// 443AE4: using guessed type int dword_443AE4;
// 443AF0: using guessed type char byte_443AF0;
// 443AF1: using guessed type char byte_443AF1;
// 443AF2: using guessed type char byte_443AF2;
// 443C1C: using guessed type char byte_443C1C;
// 443C1D: using guessed type char byte_443C1D;
// 443C1E: using guessed type char byte_443C1E;
// 455BE4: using guessed type int dword_455BE4;
// 455BEC: using guessed type int dword_455BEC;

//----- (004124E0) --------------------------------------------------------
char __cdecl sub_4124E0(int a1)
{
  char result; // al
  int v2; // eax
  unsigned int v3; // eax
  char v4; // cl
  int v5; // eax
  unsigned int v6; // eax
  float v7; // ST08_4
  float v8; // ST04_4
  float v9; // ST08_4
  float v10; // ST04_4
  int v11; // eax
  int v12; // eax
  unsigned int v13; // ecx
  unsigned int v14; // ecx
  unsigned int v15; // ecx
  float v16; // eax
  char v17; // al
  int v18; // eax

  if ( !a1 )
    return 1;
  v2 = *(_DWORD *)(a1 + 20);
  if ( v2 )
  {
    *(_DWORD *)(v2 + 92) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 96) = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 100) = *(_DWORD *)(a1 + 40);
    if ( byte_455C14 )
      sub_4083F0(*(int **)(a1 + 20));
  }
  v3 = *(_DWORD *)(a1 + 12);
  v4 = *(_BYTE *)(a1 + 4);
  if ( v3 & 0x400 )
  {
    if ( v4 == 36 )
    {
      if ( v3 & 1 )
      {
LABEL_12:
        v5 = dword_455BF8;
        if ( dword_455BF8 == 4 || dword_455BF8 == 8 || dword_455BF8 == 11 )
        {
          if ( v4 != 40 && v4 != 34 )
          {
LABEL_20:
            if ( v5 == 8 && v4 == 33 )
            {
              *(_DWORD *)(a1 + 12) &= 0xFFFFBFFF;
              return 0;
            }
            return 0;
          }
          v6 = *(_DWORD *)(a1 + 12);
          BYTE1(v6) |= 0x40u;
        }
        else
        {
          v6 = *(_DWORD *)(a1 + 12) & 0xFFFFBFFF;
        }
        *(_DWORD *)(a1 + 12) = v6;
        v5 = dword_455BF8;
        goto LABEL_20;
      }
      BYTE1(v3) &= 0xFBu;
    }
    else
    {
      v3 = v3 & 0xFFFFFBFE | 0xC0000000;
    }
    *(_DWORD *)(a1 + 12) = v3;
    goto LABEL_12;
  }
  if ( (v4 == 40 || v4 == 34) && (dword_455BF8 == 4 || dword_455BF8 == 8 || dword_455BF8 == 11) && HIBYTE(dword_455CB0) )
  {
    if ( *((_BYTE *)&dword_44B81A + dword_455BF8) & 1 )
    {
      if ( v4 == 34 )
      {
        BYTE1(v3) |= 0x40u;
LABEL_38:
        *(_DWORD *)(a1 + 12) = v3;
        goto LABEL_39;
      }
      if ( v3 & 0x4000 )
      {
        v7 = *(float *)(a1 + 40) - 50.0;
        v8 = *(float *)(a1 + 36) - 64.0;
        sub_40C9D0(*(float *)(a1 + 32), v8, v7, 8, 1120403456, 1124073472);
      }
      sub_417460(a1);
    }
    else if ( v3 & 0x4000 )
    {
      v9 = *(float *)(a1 + 40) - 50.0;
      v10 = *(float *)(a1 + 36) - 64.0;
      sub_40C9D0(*(float *)(a1 + 32), v10, v9, 8, 1120403456, 1124073472);
    }
    v3 = *(_DWORD *)(a1 + 12);
    BYTE1(v3) &= 0xBFu;
    goto LABEL_38;
  }
LABEL_39:
  if ( *(_BYTE *)(a1 + 4) == 40
    && !*(_DWORD *)(a1 + 16)
    && (_BYTE)dword_44B814 != 2
    && *((_BYTE *)&dword_44B81A + dword_455BF8) & 1
    && *(_DWORD *)(a1 + 20) )
  {
    *(_DWORD *)(a1 + 16) = dword_455BE0;
    sub_417460(a1);
  }
  v11 = *(_DWORD *)(a1 + 12);
  if ( !(v11 & 1) )
  {
    if ( !*(_DWORD *)(a1 + 16) )
    {
      v16 = *(float *)(a1 + 20);
      if ( v16 != 0.0 )
      {
        *(_DWORD *)(a1 + 16) = dword_455BE0;
        sub_408670(v16, 0, 3);
        if ( dword_455BF8 == 4 || dword_455BF8 == 8 || dword_455BF8 == 11 )
        {
          v17 = *(_BYTE *)(a1 + 4);
          if ( v17 == 40 || v17 == 34 )
          {
            v18 = *(_DWORD *)(a1 + 12);
            BYTE1(v18) |= 0x40u;
            *(_DWORD *)(a1 + 12) = v18;
          }
        }
      }
    }
    return 0;
  }
  switch ( *(unsigned __int8 *)(a1 + 4) )
  {
    case 0x21u:
      if ( HIBYTE(dword_44B804) != 2 * (unsigned __int8)dword_44B808 )
      {
        sub_407E00((int)&unk_4447B8);
        HIBYTE(dword_44B804) += 2;
        if ( HIBYTE(dword_44B804) > 2 * (unsigned __int8)dword_44B808 )
          HIBYTE(dword_44B804) = 2 * dword_44B808;
        goto LABEL_58;
      }
      LOBYTE(v11) = v11 & 0xFE;
      *(_DWORD *)(a1 + 12) = v11;
      result = 0;
      break;
    case 0x22u:
      BYTE1(dword_44B808) = 1;
      result = 0;
      break;
    case 0x24u:
      if ( sub_41EAE0((float *)(a1 + 32)) )
        goto LABEL_58;
      v12 = *(_DWORD *)(a1 + 12);
      LOBYTE(v12) = v12 & 0xFE;
      *(_DWORD *)(a1 + 12) = v12;
      v13 = v12 & 0xBFFFFFFF;
      BYTE1(v13) |= 0x40u;
      result = 0;
      *(_DWORD *)(a1 + 12) = v13;
      break;
    case 0x28u:
      if ( !(*((_BYTE *)&dword_44B81A + dword_455BF8) & 1) )
        ++BYTE1(dword_44B804);
      if ( (_BYTE)dword_44B814 )
        goto LABEL_58;
      HIBYTE(dword_455C98) = 1;
      v14 = *(_DWORD *)(a1 + 12) & 0xBFFFFFFF;
      BYTE1(v14) |= 0x40u;
      result = 0;
      *(_DWORD *)(a1 + 12) = v14;
      break;
    default:
LABEL_58:
      v15 = *(_DWORD *)(a1 + 12) & 0xBFFFFFFF;
      BYTE1(v15) |= 0x40u;
      result = 0;
      *(_DWORD *)(a1 + 12) = v15;
      break;
  }
  return result;
}
// 44B804: using guessed type int dword_44B804;
// 44B808: using guessed type int dword_44B808;
// 44B814: using guessed type int dword_44B814;
// 44B81A: using guessed type int dword_44B81A;
// 455BE0: using guessed type int dword_455BE0;
// 455BF8: using guessed type int dword_455BF8;
// 455C14: using guessed type char byte_455C14;
// 455C98: using guessed type int dword_455C98;
// 455CB0: using guessed type int dword_455CB0;

//----- (00412830) --------------------------------------------------------
bool sub_412830()
{
  __int16 v0; // ax

  v0 = *(_WORD *)dword_44B730;
  return *(_WORD *)dword_44B730 & 0x40 || (v0 & 0x80u) != 0 && byte_44B78E;
}
// 44B730: using guessed type int dword_44B730;
// 44B78E: using guessed type char byte_44B78E;

//----- (00412850) --------------------------------------------------------
int __cdecl sub_412850(int a1, float *a2, _WORD *a3)
{
  _DWORD *v3; // eax
  signed __int64 v4; // rax
  float v6; // [esp+0h] [ebp-30h]
  float v7; // [esp+4h] [ebp-2Ch]
  float v8; // [esp+8h] [ebp-28h]
  float v9; // [esp+Ch] [ebp-24h]
  float v10; // [esp+10h] [ebp-20h]
  float v11; // [esp+14h] [ebp-1Ch]
  int v12; // [esp+18h] [ebp-18h]
  int v13; // [esp+1Ch] [ebp-14h]
  int v14; // [esp+20h] [ebp-10h]
  float v15; // [esp+24h] [ebp-Ch]
  float v16; // [esp+2Ch] [ebp-4h]

  v3 = *(_DWORD **)(a1 + 20);
  v12 = v3[16];
  v13 = v3[19];
  v14 = v3[22];
  sub_408330((float *)&v12, &v9);
  v6 = dword_44B73C;
  v7 = 0.0;
  v8 = dword_44B744;
  sub_408330(&v6, &v15);
  *a2 = v16 * v11 + v15 * v9;
  v4 = (signed __int64)(v10 * v7 + v9 * v8 + -v11 * v6);
  *a3 = v4;
  return v4;
}

//----- (00412900) --------------------------------------------------------
char __cdecl sub_412900(int a1)
{
  char result; // al
  float v2; // [esp+0h] [ebp-8h]
  int v3; // [esp+4h] [ebp-4h]

  v2 = 0.0;
  v3 = 0;
  if ( !*(_DWORD *)(a1 + 20) )
    return 0;
  sub_412850(a1, &v2, &v3);
  if ( (v3 & 0x8000u) != 0 )
  {
    if ( sub_412830() )
    {
      result = 4;
    }
    else if ( (signed __int16)v3 <= -695 || v2 >= 0.0 )
    {
      if ( (signed __int16)v3 <= -1845 || v2 >= 0.0 )
        result = 5;
      else
        result = 6;
    }
    else
    {
      result = 8;
    }
  }
  else if ( sub_412830() )
  {
    result = 1;
  }
  else if ( (signed __int16)v3 >= 695 || v2 >= 0.0 )
  {
    if ( (signed __int16)v3 >= 1845 || v2 >= 0.0 )
      result = 2;
    else
      result = 3;
  }
  else
  {
    result = 7;
  }
  return result;
}

//----- (004129F0) --------------------------------------------------------
char *__cdecl sub_4129F0(int a1)
{
  word_44B406 = (signed __int64)(atan2(*(float *)(a1 + 32) - flt_44B7D8, *(float *)(a1 + 40) - flt_44B7E0)
                               * 4096.0
                               * 0.15915494) & 0xFFF;
  sub_412A40(a1, &word_44B406);
  return sub_40B900();
}
// 44B406: using guessed type __int16 word_44B406;
// 44B7D8: using guessed type float flt_44B7D8;
// 44B7E0: using guessed type float flt_44B7E0;

//----- (00412A40) --------------------------------------------------------
int __cdecl sub_412A40(int a1, _WORD *a2)
{
  int v2; // eax
  double v3; // st7
  double v4; // st6
  int result; // eax
  int v6; // ecx
  float v7; // [esp+8h] [ebp+8h]

  v2 = 4 * (*a2 & 0xFFF);
  v3 = *(float *)((char *)dword_4449D4 + v2);
  v4 = *(float *)((char *)dword_4449D8 + v2);
  result = a1;
  v6 = *(_DWORD *)(a1 + 20);
  v7 = v4;
  if ( v6 )
  {
    *(float *)(v6 + 56) = v3;
    *(float *)(*(_DWORD *)(a1 + 20) + 88) = v3;
    *(float *)(*(_DWORD *)(a1 + 20) + 80) = -v7;
    result = *(_DWORD *)(a1 + 20);
    *(float *)(result + 64) = v7;
  }
  return result;
}

//----- (00412AA0) --------------------------------------------------------
int __cdecl sub_412AA0(int a1, float a2, int a3, float a4, int a5)
{
  *(_WORD *)a5 = (signed __int64)(atan2(*(float *)(a1 + 32) - a2, *(float *)(a1 + 40) - a4) * 4096.0 * 0.15915494) & 0xFFF;
  return sub_412A40(a1, (_WORD *)a5);
}

//----- (00412AF0) --------------------------------------------------------
char __cdecl sub_412AF0(int a1)
{
  int v1; // edi
  char result; // al
  int v3; // eax
  int v4; // eax
  char v5; // al
  int v6; // esi
  signed int v7; // ebp
  signed int v8; // eax
  _DWORD *v9; // eax
  int v10; // esi
  double v11; // st7
  unsigned __int8 v12; // cl
  double v13; // st7
  float v14; // eax
  int v15; // eax
  bool v16; // cf
  int v17; // eax
  unsigned __int16 *v18; // ecx
  int v19; // eax
  unsigned __int16 *v20; // ecx
  unsigned int v21; // eax
  float v22; // eax
  unsigned __int16 *v23; // ecx
  unsigned int v24; // eax
  int v25; // eax
  int v26; // ecx
  int v27; // eax
  int v28; // ecx
  unsigned int v29; // eax
  float v30; // eax
  unsigned __int16 *v31; // ecx
  int v32; // eax
  unsigned __int16 *v33; // ecx
  int v34; // eax
  unsigned __int16 *v35; // ecx
  unsigned int v36; // eax
  int v37; // eax
  unsigned __int16 *v38; // ecx
  int v39; // eax
  unsigned __int16 *v40; // ecx
  int v41; // eax
  int v42; // eax
  float v43; // edi
  unsigned __int16 *v44; // eax
  signed int v45; // [esp+10h] [ebp-10h]
  int v46; // [esp+14h] [ebp-Ch]
  int v47; // [esp+18h] [ebp-8h]
  float v48; // [esp+1Ch] [ebp-4h]

  v1 = a1;
  v47 = 0;
  v46 = 0;
  dword_44B3E8 = a1;
  if ( !a1 )
    return 0;
  v3 = *(_DWORD *)(a1 + 20);
  if ( v3 )
  {
    *(_DWORD *)(v3 + 92) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(*(_DWORD *)(v1 + 20) + 96) = *(_DWORD *)(v1 + 36);
    *(_DWORD *)(*(_DWORD *)(v1 + 20) + 100) = *(_DWORD *)(v1 + 40);
    if ( byte_455C14 )
      sub_4083F0(*(int **)(v1 + 20));
  }
  if ( !(_BYTE)dword_455CB0 && !byte_455CA5 )
  {
    v4 = *(_DWORD *)(v1 + 12);
    if ( v4 & 0x400 )
    {
      BYTE1(v4) &= 0xFBu;
      *(_DWORD *)(v1 + 12) = v4;
      sub_416160(v1);
      byte_44B414 = 0;
      byte_44B415 = 0;
      sub_41BB60(0);
      byte_44B812 = 0;
      if ( dword_44B3F0 )
        *(_DWORD *)(dword_44B3F0 + 12) &= 0xBFFFFFFF;
      word_44B3E0 = 0;
      word_44B654 = 0;
      HIBYTE(dword_455CB0) = 0;
      byte_44B3E2 = 0;
      byte_44B656 = 0;
      word_44B7EC = 0;
      word_44B7EE = 0;
      word_44B7F0 = 0;
      sub_408A30((unsigned int *)dword_44B3E4);
      sub_4129F0(v1);
      sub_413790(v1, 0);
    }
    sub_412850(v1, (float *)&v47, &v46);
    if ( !byte_455CA8 )
    {
      if ( sub_412830() )
        sub_409CF0(1, SLODWORD(dword_44B700), SLODWORD(dword_44B71C));
      else
        sub_409CF0(0, SLODWORD(dword_44B700), SLODWORD(dword_44B71C));
    }
    if ( !byte_44B415 )
    {
      v5 = *(_BYTE *)(v1 + 8);
      if ( v5 != 13 && v5 != 14 && v5 && dword_44B730 && !sub_412830() && !byte_44B414 )
      {
        switch ( sub_412900(v1) )
        {
          case 3:
          case 7:
            byte_44B414 = 1;
            sub_413790(v1, 7);
            break;
          case 6:
          case 8:
            byte_44B414 = 1;
            sub_413790(v1, 8);
            break;
          default:
            break;
        }
      }
    }
    v6 = 0;
    v7 = 3;
    do
    {
      if ( *((_BYTE *)&word_44B654 + v6) && !*((_BYTE *)&word_44B3E0 + v6) )
      {
        *((_BYTE *)&word_44B3E0 + v6) = 1;
        --*(_BYTE *)(v1 + 5);
        if ( (_BYTE)word_44B3E0 && HIBYTE(word_44B3E0) && byte_44B3E2 )
        {
          sub_413790(v1, 13);
        }
        else
        {
          word_441004 += 70;
          sub_413790(v1, 16);
        }
      }
      ++v6;
      --v7;
    }
    while ( v7 );
    if ( *(_DWORD *)(v1 + 12) & 0x100000 )
    {
      if ( !*(_DWORD *)(v1 + 16) )
      {
        sub_417400(55, &dword_44B3F0, 1);
        *(_DWORD *)(dword_44B3F0 + 32) = *(_DWORD *)(v1 + 32);
        *(float *)(dword_44B3F0 + 36) = *(float *)(v1 + 36) - 1750.0;
        *(_DWORD *)(dword_44B3F0 + 40) = *(_DWORD *)(v1 + 40);
        *(_DWORD *)(dword_44B3F0 + 12) &= 0xBFFFFFFF;
        sub_417400(32, &dword_44B3D8, 1);
        v8 = sub_40A5E0(59);
        if ( v8 != -1 )
        {
          dword_44B3E4 = (int)sub_4089F0(dword_448AC4 + 48 * v8);
          *(_DWORD *)(dword_44B3E4 + 4) = *(_DWORD *)(*(_DWORD *)(v1 + 20) + 180) + 4720;
        }
        word_441004 = 110;
        word_44B3E0 = 0;
        byte_44B3E2 = 0;
      }
      sub_4129F0(v1);
      *(_DWORD *)(v1 + 12) &= 0xFFEFFFFF;
      LOBYTE(dword_44B3FC) = 0;
      sub_413790(v1, 0);
    }
    if ( !byte_455CA9 && !byte_44B793 && !byte_455C12 )
    {
      LOBYTE(a1) = 0;
      v45 = 0;
      do
      {
        v9 = dword_443D2C;
        v10 = *((_DWORD *)dword_443D2C + 16032);
        v11 = (double)v45 * 60.0 + 390.0;
        *((_DWORD *)dword_443D2C + 16032) = v10 + 128;
        *(_DWORD *)(v10 + 4) = 0;
        v12 = a1;
        *(_DWORD *)v10 = v9[30];
        v9[30] = v10;
        v48 = v11;
        *(float *)(v10 + 16) = v48;
        *(_BYTE *)(v10 + 34) = -1;
        v13 = v11 + 54.0;
        *(float *)(v10 + 44) = v13;
        *(_DWORD *)(v10 + 20) = 1138065408;
        *(_DWORD *)(v10 + 48) = 1138065408;
        v14 = v48;
        *(_BYTE *)(v10 + 33) = -1;
        *(float *)(v10 + 72) = v14;
        *(float *)(v10 + 100) = v13;
        *(_BYTE *)(v10 + 32) = -1;
        *(_DWORD *)(v10 + 4) = 5;
        *(_DWORD *)(v10 + 76) = 1139992166;
        *(_DWORD *)(v10 + 104) = 1139992166;
        *(_DWORD *)(v10 + 24) = 0;
        *(_DWORD *)(v10 + 28) = 1065353216;
        *(_DWORD *)(v10 + 52) = 0;
        *(_DWORD *)(v10 + 56) = 1065353216;
        *(_DWORD *)(v10 + 80) = 0;
        *(_DWORD *)(v10 + 84) = 1065353216;
        *(_DWORD *)(v10 + 108) = 0;
        *(_DWORD *)(v10 + 112) = 1065353216;
        if ( v12 >= *(_BYTE *)(v1 + 5) )
        {
          *(_DWORD *)(v10 + 36) = 1041272977;
          *(_DWORD *)(v10 + 92) = 1041272977;
          *(_DWORD *)(v10 + 40) = 1059695018;
          *(_DWORD *)(v10 + 64) = 1049529999;
          *(_DWORD *)(v10 + 68) = 1059695018;
          *(_DWORD *)(v10 + 96) = 1062853082;
          *(_DWORD *)(v10 + 120) = 1049529999;
          *(_DWORD *)(v10 + 124) = 1062853082;
          v15 = sub_401000(0, 0, 1161, 169);
        }
        else
        {
          *(_DWORD *)(v10 + 40) = 1059695018;
          *(_DWORD *)(v10 + 68) = 1059695018;
          *(_DWORD *)(v10 + 36) = 0;
          *(_DWORD *)(v10 + 64) = 1041009805;
          *(_DWORD *)(v10 + 92) = 0;
          *(_DWORD *)(v10 + 96) = 1062853082;
          *(_DWORD *)(v10 + 120) = 1041009805;
          *(_DWORD *)(v10 + 124) = 1062853082;
          v15 = sub_401000(0, 0, 1152, 169);
        }
        *(_DWORD *)(v10 + 8) = v15;
        v16 = (unsigned __int8)(a1 + 1) < 3u;
        LOBYTE(a1) = a1 + 1;
        ++v45;
      }
      while ( v16 );
    }
    switch ( *(unsigned __int8 *)(v1 + 8) )
    {
      case 0u:
      case 2u:
        goto LABEL_50;
      case 1u:
        switch ( (unsigned __int8)dword_44B3FC )
        {
          case 1u:
            sub_413790(v1, 0);
            result = 1;
            break;
          case 2u:
            sub_413790(v1, 2);
            result = 1;
            break;
          case 3u:
          case 4u:
          case 5u:
            sub_413790(v1, 3);
            result = 1;
            break;
          default:
            return 1;
        }
        return result;
      case 3u:
        v19 = *(_DWORD *)(v1 + 20);
        if ( !v19 )
          return 1;
        v20 = *(unsigned __int16 **)(v19 + 184);
        if ( !v20 || *(unsigned __int16 *)(v19 + 174) != *v20 - 1 )
          return 1;
        if ( (_BYTE)dword_44B3FC == 5 )
        {
          sub_413790(v1, 6);
          result = 1;
        }
        else
        {
          if ( (_BYTE)dword_44B3FC == 3 )
            sub_413790(v1, 4);
          else
            sub_413790(v1, 5);
          result = 1;
        }
        return result;
      case 4u:
        v29 = *(_DWORD *)(v1 + 16);
        if ( !v29 )
        {
          v30 = *(float *)(v1 + 20);
          if ( v30 != 0.0 )
          {
            v31 = *(unsigned __int16 **)(LODWORD(v30) + 184);
            if ( v31 )
            {
              if ( *(unsigned __int16 *)(LODWORD(v30) + 174) == *v31 - 1 )
              {
                *(_DWORD *)(v1 + 16) = 1;
                sub_408670(v30, 6, 4);
                return 1;
              }
            }
          }
          return 1;
        }
        if ( v29 >= 9 )
          goto LABEL_74;
        word_44B406 += 220;
        goto LABEL_104;
      case 5u:
        v21 = *(_DWORD *)(v1 + 16);
        if ( !v21 )
          goto LABEL_68;
        if ( v21 >= 5 )
          goto LABEL_74;
        word_44B406 -= word_441004;
        goto LABEL_104;
      case 6u:
        v24 = *(_DWORD *)(v1 + 16);
        if ( !v24 )
        {
LABEL_68:
          v22 = *(float *)(v1 + 20);
          if ( v22 != 0.0 )
          {
            v23 = *(unsigned __int16 **)(LODWORD(v22) + 184);
            if ( v23 )
            {
              if ( *(unsigned __int16 *)(LODWORD(v22) + 174) == *v23 - 1 )
              {
                sub_408670(v22, 6, 4);
                ++*(_DWORD *)(v1 + 16);
                return 1;
              }
            }
          }
          return 1;
        }
        if ( v24 >= 5 )
        {
LABEL_74:
          sub_413790(v1, 10);
          return 1;
        }
        word_44B406 += word_441004;
LABEL_104:
        sub_412A40(v1, &word_44B406);
        goto LABEL_105;
      case 7u:
        v25 = (signed __int16)v46;
        v26 = (signed __int16)v46;
        if ( (v46 & 0x8000u) != 0 )
          v26 = -(signed __int16)v46;
        if ( v26 >= 0 )
        {
          if ( (v46 & 0x8000u) != 0 )
            v25 = -(signed __int16)v46;
          if ( v25 <= 500 )
          {
            sub_412AA0(v1, dword_44B73C, SLODWORD(dword_44B740), dword_44B744, (int)&word_44B406);
            goto LABEL_93;
          }
        }
        word_44B406 += 220;
        sub_412A40(v1, &word_44B406);
        return 1;
      case 8u:
        v27 = (signed __int16)v46;
        v28 = (signed __int16)v46;
        if ( (v46 & 0x8000u) != 0 )
          v28 = -(signed __int16)v46;
        if ( v28 < 0 )
          goto LABEL_162;
        if ( (v46 & 0x8000u) != 0 )
          v27 = -(signed __int16)v46;
        if ( v27 > 500 )
        {
LABEL_162:
          word_44B406 -= 220;
          sub_412A40(v1, &word_44B406);
          result = 1;
        }
        else
        {
          sub_412AA0(v1, dword_44B73C, SLODWORD(dword_44B740), dword_44B744, (int)&word_44B406);
LABEL_93:
          sub_413790(v1, 10);
          result = 1;
        }
        return result;
      case 0xAu:
        if ( byte_44B414 )
        {
          byte_44B415 = 1;
          sub_413790(v1, 11);
          byte_44B414 = 0;
          return 1;
        }
LABEL_50:
        v17 = *(_DWORD *)(v1 + 20);
        if ( v17 )
        {
          v18 = *(unsigned __int16 **)(v17 + 184);
          if ( v18 )
          {
            if ( *(unsigned __int16 *)(v17 + 174) == *v18 - 1 )
            {
              sub_413790(v1, 1);
              return 1;
            }
          }
        }
        return 1;
      case 0xBu:
        sub_412AA0(v1, dword_44B73C, SLODWORD(dword_44B740), dword_44B744, (int)&word_44B406);
        sub_412AA0(dword_44B3F0, dword_44B73C, SLODWORD(dword_44B740), dword_44B744, (int)&unk_44B408);
        *(_DWORD *)(dword_44B3F0 + 12) |= 0x40000000u;
        sub_408670(*(float *)(dword_44B3F0 + 20), 0, 0);
        dword_44B410 = dword_455BE0;
        if ( (unsigned int)(dword_455BE0 - dword_44B40C) >= 0x28 )
        {
          *(_DWORD *)(dword_44B3F0 + 12) &= 0xBFFFFFFF;
          if ( sub_412830() || sub_41F2C0() )
          {
            byte_44B415 = 0;
            LOBYTE(dword_44B3FC) = 4;
            sub_413790(v1, 1);
          }
          else
          {
            sub_413790(v1, 12);
          }
        }
        if ( *(_DWORD *)(v1 + 16) <= 0x14u )
          goto LABEL_105;
        *(_DWORD *)(dword_44B3F0 + 12) &= 0xBFFFFFFF;
        byte_44B415 = 0;
        LOBYTE(dword_44B3FC) = 4;
        sub_413790(v1, 1);
        ++*(_DWORD *)(v1 + 16);
        return 1;
      case 0xCu:
        sub_408850(*(_DWORD *)(v1 + 20), 7u);
        sub_412AA0(v1, dword_44B73C, SLODWORD(dword_44B740), dword_44B744, (int)&word_44B406);
        if ( sub_412830() || *(_DWORD *)(dword_44B3D8 + 12) & 0x4000000 )
        {
          byte_44B415 = 0;
          sub_41BB60(0);
          byte_44B793 = 0;
          LOBYTE(dword_44B3FC) = 4;
          sub_413790(v1, 1);
          result = 1;
        }
        else
        {
          v34 = *(_DWORD *)(v1 + 20);
          if ( v34 )
          {
            v35 = *(unsigned __int16 **)(v34 + 184);
            if ( v35 )
            {
              if ( *(unsigned __int16 *)(v34 + 174) == *v35 - 1 )
                sub_413790(v1, 15);
            }
          }
          v36 = *(_DWORD *)(v1 + 16);
          if ( v36 > 0xF && v36 < 0x32 )
            sub_408A50(dword_44B3E4);
          if ( *(_DWORD *)(v1 + 16) == 15 )
          {
            byte_44B812 = 1;
            ++*(_DWORD *)(v1 + 16);
            result = 1;
          }
          else
          {
LABEL_105:
            ++*(_DWORD *)(v1 + 16);
            result = 1;
          }
        }
        return result;
      case 0xDu:
        sub_417400(34, &dword_44B3DC, 1);
        if ( dword_44B3DC )
          sub_412AA0(dword_44B3DC, *(float *)&dword_4489FC, dword_448A00, *(float *)&dword_448A04, (int)&unk_44B408);
        v39 = *(_DWORD *)(v1 + 20);
        if ( !v39 )
          return 1;
        v40 = *(unsigned __int16 **)(v39 + 184);
        if ( !v40 || *(unsigned __int16 *)(v39 + 174) != *v40 - 1 )
          return 1;
        sub_413790(v1, 14);
        return 1;
      case 0xEu:
        sub_417400(34, &dword_44B3DC, 1);
        sub_417400(40, &a1, 1);
        v41 = dword_44B3DC;
        if ( dword_44B3DC )
        {
          sub_412AA0(dword_44B3DC, *(float *)&dword_4489FC, dword_448A00, *(float *)&dword_448A04, (int)&unk_44B408);
          v41 = dword_44B3DC;
        }
        if ( *((_BYTE *)&dword_44B81A + dword_455BF8) & 1 )
        {
          if ( *(_BYTE *)(a1 + 12) & 1 )
          {
            byte_455C12 = 1;
            if ( !(_BYTE)dword_455004 )
            {
LABEL_154:
              sub_434690(5u, 0);
              goto LABEL_155;
            }
          }
        }
        else
        {
          v42 = *(_DWORD *)(v41 + 12);
          if ( v42 & 1 )
          {
            if ( v42 & 0x4000 )
            {
              if ( *(_BYTE *)(a1 + 12) & 1 )
              {
                if ( BYTE1(dword_44B80C) != 3 )
                {
                  byte_455C12 = 1;
                  if ( !(_BYTE)dword_455004 )
                    goto LABEL_154;
                }
              }
            }
          }
        }
LABEL_155:
        v43 = *(float *)(v1 + 20);
        if ( v43 != 0.0 )
        {
          v44 = *(unsigned __int16 **)(LODWORD(v43) + 184);
          if ( v44 )
          {
            if ( *(unsigned __int16 *)(LODWORD(v43) + 174) == *v44 - 1 )
              sub_408670(v43, 9, 0);
          }
        }
        break;
      case 0xFu:
        v37 = *(_DWORD *)(v1 + 20);
        if ( v37 )
        {
          v38 = *(unsigned __int16 **)(v37 + 184);
          if ( v38 )
          {
            if ( *(unsigned __int16 *)(v37 + 174) == *v38 - 1 )
              sub_41ED70(0xFFu);
          }
        }
        if ( !sub_434920() )
          return 1;
        sub_412AA0(v1, flt_44B7D8, dword_44B7DC, flt_44B7E0, (int)&word_44B406);
        sub_413790(v1, 0);
        return 1;
      case 0x10u:
        v32 = *(_DWORD *)(v1 + 20);
        if ( !v32 )
          return 1;
        v33 = *(unsigned __int16 **)(v32 + 184);
        if ( !v33 || *(unsigned __int16 *)(v32 + 174) != *v33 - 1 )
          return 1;
        if ( byte_44B415 )
          byte_44B415 = 0;
        LOBYTE(dword_44B3FC) = 4;
        sub_413790(v1, 1);
        return 1;
      default:
        return 1;
    }
  }
  return 1;
}
// 441004: using guessed type __int16 word_441004;
// 4489FC: using guessed type int dword_4489FC;
// 448A00: using guessed type int dword_448A00;
// 448A04: using guessed type int dword_448A04;
// 448AC4: using guessed type int dword_448AC4;
// 44B3D8: using guessed type int dword_44B3D8;
// 44B3E0: using guessed type __int16 word_44B3E0;
// 44B3E2: using guessed type char byte_44B3E2;
// 44B3E4: using guessed type int dword_44B3E4;
// 44B3E8: using guessed type int dword_44B3E8;
// 44B3FC: using guessed type int dword_44B3FC;
// 44B406: using guessed type __int16 word_44B406;
// 44B40C: using guessed type int dword_44B40C;
// 44B410: using guessed type int dword_44B410;
// 44B414: using guessed type char byte_44B414;
// 44B415: using guessed type char byte_44B415;
// 44B654: using guessed type __int16 word_44B654;
// 44B656: using guessed type char byte_44B656;
// 44B730: using guessed type int dword_44B730;
// 44B793: using guessed type char byte_44B793;
// 44B7D8: using guessed type float flt_44B7D8;
// 44B7DC: using guessed type int dword_44B7DC;
// 44B7E0: using guessed type float flt_44B7E0;
// 44B7EC: using guessed type __int16 word_44B7EC;
// 44B7EE: using guessed type __int16 word_44B7EE;
// 44B7F0: using guessed type __int16 word_44B7F0;
// 44B80C: using guessed type int dword_44B80C;
// 44B812: using guessed type char byte_44B812;
// 44B81A: using guessed type int dword_44B81A;
// 455004: using guessed type int dword_455004;
// 455BE0: using guessed type int dword_455BE0;
// 455BF8: using guessed type int dword_455BF8;
// 455C12: using guessed type char byte_455C12;
// 455C14: using guessed type char byte_455C14;
// 455CA5: using guessed type char byte_455CA5;
// 455CA8: using guessed type char byte_455CA8;
// 455CA9: using guessed type char byte_455CA9;
// 455CB0: using guessed type int dword_455CB0;

//----- (00413790) --------------------------------------------------------
char __cdecl sub_413790(int a1, char a2)
{
  char result; // al
  int v3; // eax
  unsigned int v4; // edx
  int v5; // edx
  char v6; // [esp+Ch] [ebp+8h]

  *(_BYTE *)(a1 + 8) = a2;
  result = a2;
  *(_DWORD *)(a1 + 16) = 0;
  switch ( a2 )
  {
    case 0:
      result = sub_408670(*(float *)(a1 + 20), 0, 0);
      byte_44B414 = 0;
      break;
    case 1:
      if ( (_BYTE)dword_44B3FC )
      {
        do
        {
          v3 = rand();
          v4 = (signed int)(4 * v3 + ((unsigned __int64)(-8589672436i64 * v3) >> 32)) >> 14;
          v5 = (v4 >> 31) + v4;
          v6 = v5;
        }
        while ( byte_44B40A == (_BYTE)v5 );
        byte_44B40A = v5;
      }
      else
      {
        v6 = 2;
      }
      switch ( v6 )
      {
        case 0:
          LOBYTE(dword_44B3FC) = 1;
          return sub_408670(*(float *)(a1 + 20), 0, 5);
        case 1:
          LOBYTE(dword_44B3FC) = 2;
          return sub_408670(*(float *)(a1 + 20), 0, 5);
        case 2:
          LOBYTE(dword_44B3FC) = 4;
          return sub_408670(*(float *)(a1 + 20), 0, 5);
        case 3:
          LOBYTE(dword_44B3FC) = 3;
          goto LABEL_12;
        default:
          goto LABEL_12;
      }
      goto LABEL_12;
    case 2:
      result = sub_408670(*(float *)(a1 + 20), 1, 5);
      break;
    case 3:
      if ( (_BYTE)dword_44B3FC == 3 )
        result = sub_408670(*(float *)(a1 + 20), 2, 5);
      break;
    case 4:
    case 6:
      if ( !sub_407E30((AGLSOUNDBUFFER **)&dword_444920) )
        sub_407E00((int)&dword_444920);
      result = sub_408670(*(float *)(a1 + 20), 4, 5);
      break;
    case 5:
      result = sub_408670(*(float *)(a1 + 20), 5, 5);
      break;
    case 7:
    case 8:
    case 0xF:
LABEL_12:
      result = sub_408670(*(float *)(a1 + 20), 0, 5);
      break;
    case 0xB:
      if ( !sub_407E30((AGLSOUNDBUFFER **)&unk_44492C) )
        sub_407E00((int)&unk_44492C);
      result = sub_408670(*(float *)(a1 + 20), 0, 6);
      dword_44B40C = dword_455BE0;
      break;
    case 0xC:
      if ( !sub_407E30((AGLSOUNDBUFFER **)&dword_444908) )
        sub_407E00((int)&dword_444908);
      if ( dword_44B7C0 && *(_BYTE *)(dword_44B7C0 + 4) == 32 )
        *(_DWORD *)(dword_44B3D8 + 12) |= 0x1000000u;
      sub_41BB60(3);
      byte_44B793 = 1;
      if ( dword_44B734 )
      {
        if ( dword_44B734 == *(unsigned __int8 *)(dword_44B730 + 2) - 1 )
          result = sub_408670(*(float *)(a1 + 20), 11, 5);
        else
          result = sub_408670(*(float *)(a1 + 20), 7, 5);
      }
      else
      {
        result = sub_408670(*(float *)(a1 + 20), 10, 5);
      }
      break;
    case 0xD:
      HIBYTE(dword_455CB0) = 1;
      HIBYTE(dword_455C98) = 1;
      *(_DWORD *)(dword_44B3F0 + 12) &= 0xBFFFFFFF;
      if ( !sub_407E30((AGLSOUNDBUFFER **)&dword_444938) )
        sub_407E00((int)&dword_444938);
      result = sub_408670(*(float *)(a1 + 20), 8, 0);
      break;
    case 0xE:
      sub_434530();
      result = sub_408670(*(float *)(a1 + 20), 9, 0);
      break;
    case 0x10:
      if ( !sub_407E30((AGLSOUNDBUFFER **)&dword_444914) )
        sub_407E00((int)&dword_444914);
      *(_DWORD *)(dword_44B3F0 + 12) &= 0xBFFFFFFF;
      result = sub_408670(*(float *)(a1 + 20), 3, 5);
      break;
    default:
      return result;
  }
  return result;
}
// 444908: using guessed type int dword_444908;
// 444914: using guessed type int dword_444914;
// 444920: using guessed type int dword_444920;
// 444938: using guessed type int dword_444938;
// 44B3D8: using guessed type int dword_44B3D8;
// 44B3FC: using guessed type int dword_44B3FC;
// 44B40A: using guessed type char byte_44B40A;
// 44B40C: using guessed type int dword_44B40C;
// 44B414: using guessed type char byte_44B414;
// 44B730: using guessed type int dword_44B730;
// 44B734: using guessed type int dword_44B734;
// 44B793: using guessed type char byte_44B793;
// 44B7C0: using guessed type int dword_44B7C0;
// 455BE0: using guessed type int dword_455BE0;
// 455C98: using guessed type int dword_455C98;
// 455CB0: using guessed type int dword_455CB0;

//----- (00413AD0) --------------------------------------------------------
int __cdecl sub_413AD0(int a1)
{
  int v1; // edx

  v1 = *(_DWORD *)(a1 + 4) | 3;
  *(_DWORD *)(a1 + 2512) = sub_413B20;
  *(_BYTE *)a1 = 10;
  *(_DWORD *)(a1 + 4) = v1;
  *(_BYTE *)(a1 + 2530) = 50;
  *(_BYTE *)(a1 + 2531) = 50;
  *(_WORD *)(a1 + 2528) = 0;
  return sub_40B9B0(a1, 0x9Cu, 0x80u, 0, 0, 0xFu, 0xFu);
}

//----- (00413B20) --------------------------------------------------------
int __cdecl sub_413B20(int a1, int a2)
{
  int v2; // esi
  int v3; // eax
  unsigned int v4; // edx
  int v5; // eax
  __int64 v6; // rax
  int v7; // eax
  unsigned int v8; // edx
  int v9; // eax
  __int64 v10; // rax
  int result; // eax
  unsigned __int8 v12; // [esp+Ch] [ebp-4h]
  float v13; // [esp+18h] [ebp+8h]
  signed int v14; // [esp+18h] [ebp+8h]

  v2 = a2;
  v12 = 50 * rand() / 0x7FFF;
  *(_BYTE *)(a2 + 87) = v12;
  v3 = rand();
  v4 = (signed int)(80 * v3 + ((unsigned __int64)(-171793448720i64 * v3) >> 32)) >> 14;
  *(float *)a2 = (double)(signed int)((v4 >> 31) + v4);
  *(float *)(a2 + 4) = (double)(80 * rand() / 0x7FFF);
  v5 = rand();
  *(_WORD *)(a2 + 84) = 1;
  v6 = (signed __int16)(((unsigned int)(50 * v5 + ((unsigned __int64)(-107370905450i64 * v5) >> 32)) >> 31)
                      + ((signed int)(50 * v5 + ((unsigned __int64)(-107370905450i64 * v5) >> 32)) >> 14));
  *(_DWORD *)(a2 + 24) = -1027080192;
  *(_DWORD *)(a2 + 28) = -1027080192;
  *(_DWORD *)(a2 + 32) = -1027080192;
  *(float *)(a2 + 8) = (double)(signed int)(HIDWORD(v6) - (HIDWORD(v6) ^ v6));
  *(_DWORD *)(a2 + 12) = 1120403456;
  *(_DWORD *)(a2 + 16) = 1120403456;
  *(_DWORD *)(a2 + 72) = 1092616192;
  *(_DWORD *)(a2 + 76) = 1092616192;
  *(_DWORD *)(a2 + 48) = 1092616192;
  *(_DWORD *)(a2 + 52) = 1092616192;
  *(_DWORD *)(a2 + 20) = 0;
  *(_DWORD *)(a2 + 80) = 0;
  *(_DWORD *)(a2 + 56) = 0;
  *(_DWORD *)(a2 + 60) = -1054867456;
  *(_DWORD *)(a2 + 64) = -1054867456;
  *(_DWORD *)(a2 + 68) = -1054867456;
  v13 = (double)((unsigned __int16)rand() > 0x3FFFu ? 1 : -1);
  v7 = rand();
  v8 = (signed int)(10 * v7 + ((unsigned __int64)(-21474181090i64 * v7) >> 32)) >> 14;
  *(float *)(v2 + 36) = (double)(signed int)((v8 >> 31) + v8) * v13;
  *(float *)(v2 + 40) = (double)(10 * rand() / 0x7FFF) * v13;
  v9 = rand();
  v10 = (signed __int16)(((unsigned int)(10 * v9 + ((unsigned __int64)(-21474181090i64 * v9) >> 32)) >> 31)
                       + ((signed int)(10 * v9 + ((unsigned __int64)(-21474181090i64 * v9) >> 32)) >> 14));
  v14 = HIDWORD(v10) - (HIDWORD(v10) ^ v10);
  result = 32640;
  *(_WORD *)(v2 + 88) = 32640;
  *(_WORD *)(v2 + 90) = 32640;
  *(float *)(v2 + 44) = (double)v14;
  *(_WORD *)(v2 + 92) = 32640;
  if ( v12 )
  {
    result = -32640 / v12;
    *(_WORD *)(v2 + 94) = result;
    *(_WORD *)(v2 + 96) = result;
    *(_WORD *)(v2 + 98) = result;
  }
  return result;
}

//----- (00413D10) --------------------------------------------------------
char sub_413D10()
{
  return sub_413D30(dword_44B484, 15);
}
// 44B484: using guessed type int dword_44B484;

//----- (00413D30) --------------------------------------------------------
char __cdecl sub_413D30(int a1, char a2)
{
  char result; // al
  int v3; // eax
  float v4; // ST04_4

  *(_BYTE *)(a1 + 8) = a2;
  result = a2;
  *(_DWORD *)(a1 + 16) = 0;
  switch ( a2 )
  {
    case 0:
    case 2:
      result = sub_408670(*(float *)(a1 + 20), 0, 5);
      break;
    case 3:
      result = sub_408670(*(float *)(a1 + 20), 1, 3);
      break;
    case 4:
      if ( !sub_407E30((AGLSOUNDBUFFER **)&dword_444944) )
        sub_407E00((int)&dword_444944);
      result = sub_408670(*(float *)(a1 + 20), 10, 3);
      break;
    case 5:
      sub_413F90(a1);
      result = sub_408670(*(float *)(a1 + 20), 2, 4);
      break;
    case 6:
      result = sub_408670(*(float *)(a1 + 20), 3, 4);
      break;
    case 7:
    case 8:
    case 9:
      v3 = *(_DWORD *)(dword_44B458 + 12);
      if ( v3 & 0x200000 )
        *(_DWORD *)(dword_44B458 + 12) = v3 | 0x100000;
      sub_407E00((int)&dword_444908);
      result = sub_408670(*(float *)(a1 + 20), 4, 15);
      break;
    case 0xA:
      if ( !sub_407E30((AGLSOUNDBUFFER **)&dword_444938) )
        sub_407E00((int)&dword_444938);
      if ( byte_44B488 && byte_44B489 && sub_41F2C0() && !sub_407E30((AGLSOUNDBUFFER **)&unk_4447A0) )
        sub_407E00((int)&unk_4447A0);
      result = sub_408670(*(float *)(a1 + 20), 5, 0);
      break;
    case 0xB:
      if ( !sub_407E30((AGLSOUNDBUFFER **)&dword_444914) )
        sub_407E00((int)&dword_444914);
      if ( !sub_407E30((AGLSOUNDBUFFER **)&unk_4447A0) )
        sub_407E00((int)&unk_4447A0);
      v4 = *(float *)(a1 + 20);
      --*(_BYTE *)(a1 + 5);
      result = sub_408670(v4, 6, 1);
      break;
    case 0xC:
    case 0xF:
      if ( !sub_407E30((AGLSOUNDBUFFER **)&unk_444950) )
        sub_407E00((int)&unk_444950);
      result = sub_408670(*(float *)(a1 + 20), 7, 2);
      break;
    case 0xD:
      if ( !sub_407E30((AGLSOUNDBUFFER **)&dword_444914) )
        sub_407E00((int)&dword_444914);
      result = sub_408670(*(float *)(a1 + 20), 8, 11);
      break;
    case 0xE:
      HIBYTE(dword_455CB0) = 1;
      HIBYTE(dword_455C98) = 1;
      sub_434530();
      result = sub_408670(*(float *)(a1 + 20), 9, 0);
      break;
    default:
      return result;
  }
  return result;
}
// 444908: using guessed type int dword_444908;
// 444914: using guessed type int dword_444914;
// 444938: using guessed type int dword_444938;
// 444944: using guessed type int dword_444944;
// 44B458: using guessed type int dword_44B458;
// 44B488: using guessed type char byte_44B488;
// 44B489: using guessed type char byte_44B489;
// 455C98: using guessed type int dword_455C98;
// 455CB0: using guessed type int dword_455CB0;

//----- (00413F90) --------------------------------------------------------
int __cdecl sub_413F90(int a1)
{
  unsigned __int8 v1; // cl
  int v2; // eax
  unsigned __int8 v3; // cl
  int v4; // eax
  int v5; // esi
  unsigned __int8 v6; // cl
  int v7; // eax
  int v8; // eax
  unsigned __int8 v9; // cl
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int result; // eax
  unsigned __int8 v15; // [esp+10h] [ebp-4h]
  unsigned __int8 v16; // [esp+10h] [ebp-4h]
  unsigned __int8 v17; // [esp+10h] [ebp-4h]

  if ( LOBYTE(dword_441008[0]) != 9 && !byte_44BAE4 )
  {
    if ( LOBYTE(dword_441008[0]) == 8 )
    {
      v15 = 0;
      if ( BYTE1(dword_441008[0]) )
      {
        if ( (unsigned int)dword_44B42C > 0 )
        {
          v3 = 0;
          v4 = 0;
          while ( !(*(_DWORD *)(dword_44B45C[v4] + 12) & 0x100000) )
          {
            v3 = ++v15;
            v4 = v15;
            if ( v15 >= (unsigned int)dword_44B42C )
              goto LABEL_35;
          }
          BYTE1(dword_441008[0]) = 0;
          dword_44B458 = dword_44B45C[v3];
        }
      }
      else if ( (unsigned int)dword_44B418 > 0 )
      {
        v1 = 0;
        v2 = 0;
        while ( !(*(_DWORD *)(dword_44B41C[v2] + 12) & 0x100000) )
        {
          v1 = ++v15;
          v2 = v15;
          if ( v15 >= (unsigned int)dword_44B418 )
            goto LABEL_35;
        }
        BYTE1(dword_441008[0]) = 1;
        dword_44B458 = dword_44B41C[v1];
      }
      goto LABEL_35;
    }
    v16 = 0;
    if ( (unsigned int)dword_44B418 > 0 )
    {
      v5 = a1;
      v6 = 0;
      v7 = 0;
      while ( !(*(_DWORD *)(dword_44B45C[v7] + 12) & 0x100000) )
      {
        v8 = dword_44B41C[v7];
        if ( *(_DWORD *)(v8 + 12) & 0x100000 )
          v5 = v8;
        v6 = ++v16;
        v7 = v16;
        if ( v16 >= (unsigned int)dword_44B418 )
          goto LABEL_34;
      }
      dword_44B458 = dword_44B45C[v6];
      goto LABEL_35;
    }
    goto LABEL_33;
  }
  v17 = 0;
  if ( (unsigned int)dword_44B418 <= 0 )
  {
LABEL_33:
    v5 = a1;
LABEL_34:
    dword_44B458 = v5;
    goto LABEL_35;
  }
  v5 = a1;
  v9 = 0;
  v10 = 0;
  while ( !(*(_DWORD *)(dword_44B41C[v10] + 12) & 0x100000) )
  {
    v11 = dword_44B45C[v10];
    if ( *(_DWORD *)(v11 + 12) & 0x100000 )
      v5 = v11;
    v9 = ++v17;
    v10 = v17;
    if ( v17 >= (unsigned int)dword_44B418 )
      goto LABEL_34;
  }
  dword_44B458 = dword_44B41C[v9];
LABEL_35:
  v12 = *(_DWORD *)(*(_DWORD *)(a1 + 20) + 180);
  if ( *(_BYTE *)(dword_44B458 + 4) == 62 )
    v13 = v12 + 2360;
  else
    v13 = v12 + 2596;
  *(_WORD *)(dword_44B458 + 60) = HIWORD(dword_44B48C);
  *(_WORD *)(dword_44B458 + 64) = 0;
  *(_DWORD *)(*(_DWORD *)(dword_44B458 + 20) + 4) = v13;
  *(_DWORD *)(dword_44B458 + 12) &= 0xFFEFFFFF;
  result = dword_44B458;
  *(_DWORD *)(result + 12) |= 0x200000u;
  return result;
}
// 441008: using guessed type int dword_441008[];
// 44B418: using guessed type int dword_44B418;
// 44B42C: using guessed type int dword_44B42C;
// 44B458: using guessed type int dword_44B458;
// 44B48C: using guessed type int dword_44B48C;
// 44BAE4: using guessed type char byte_44BAE4;

//----- (004141C0) --------------------------------------------------------
char __cdecl sub_4141C0(int a1)
{
  char result; // al
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // ecx
  unsigned __int8 v6; // bl
  int v7; // eax
  int v8; // ecx
  int *v9; // edx
  int v10; // ecx
  unsigned __int8 v11; // dl
  int v12; // eax
  int v13; // ecx
  int v14; // eax
  char v15; // al
  int v16; // ecx
  _BYTE *i; // eax
  _DWORD *v18; // eax
  int v19; // esi
  double v20; // st7
  double v21; // st7
  double v22; // st7
  float v23; // eax
  int v24; // eax
  int v25; // edx
  bool v26; // cf
  char v27; // al
  int v28; // eax
  char v29; // cl
  char v30; // al
  _BYTE *v31; // eax
  __int16 v32; // cx
  _BYTE *v33; // eax
  char v34; // al
  int v35; // eax
  int v36; // eax
  unsigned __int8 v37; // dl
  int v38; // eax
  int v39; // eax
  unsigned __int16 *v40; // ecx
  int v41; // eax
  int v42; // ecx
  int v43; // eax
  unsigned int v44; // edx
  unsigned int v45; // eax
  int v46; // eax
  unsigned __int16 *v47; // ecx
  unsigned __int16 *v48; // ecx
  int v49; // eax
  unsigned __int16 *v50; // ecx
  int v51; // eax
  int v52; // edi
  int v53; // esi
  int v54; // eax
  unsigned __int16 *v55; // ecx
  char v56; // cl
  char *v57; // eax
  char v58; // bl
  _BYTE *v59; // eax
  char v60; // dl
  int v61; // eax
  unsigned __int16 *v62; // ecx
  unsigned __int8 v63; // bl
  int v64; // ecx
  int v65; // edx
  int v66; // eax
  int v67; // ecx
  int v68; // eax
  char v69; // al
  _DWORD *v70; // eax
  int v71; // esi
  _DWORD *v72; // eax
  int v73; // esi
  unsigned __int16 *v74; // eax
  int v75; // eax
  unsigned __int16 *v76; // ecx
  int v77; // eax
  int v78; // eax
  unsigned __int16 *v79; // ecx
  int v80; // eax
  float v81; // eax
  unsigned __int16 *v82; // ecx
  unsigned __int8 v83; // [esp+4h] [ebp-2Ch]
  int v84; // [esp+8h] [ebp-28h]
  float v85; // [esp+Ch] [ebp-24h]
  int v86[4]; // [esp+10h] [ebp-20h]
  int v87[4]; // [esp+20h] [ebp-10h]

  if ( !a1 )
    return 0;
  dword_44B484 = a1;
  v2 = *(_DWORD *)(a1 + 20);
  if ( v2 )
  {
    *(_DWORD *)(v2 + 92) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 96) = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 100) = *(_DWORD *)(a1 + 40);
    if ( byte_455C14 )
      sub_4083F0(*(int **)(a1 + 20));
  }
  if ( (_BYTE)dword_455CB0 )
    return 1;
  if ( byte_455CA5 )
    return 1;
  v3 = *(_DWORD *)(a1 + 12);
  if ( (v3 & 0x8000) != 0 )
  {
    BYTE1(v3) &= 0x7Fu;
    *(_DWORD *)(a1 + 12) = v3;
    BYTE1(dword_441008[0]) = 1;
    dword_44B458 = 0;
    byte_44B48A = 0;
    byte_44B488 = 0;
    byte_44B489 = 0;
    sub_41BB60(0);
    dword_44B418 = sub_417400(62, v86, 4);
    v4 = sub_417400(63, v87, 4);
    v5 = dword_44B418;
    v6 = 0;
    dword_44B42C = v4;
    if ( dword_44B418 )
    {
      v7 = 0;
      do
      {
        v8 = v86[v7];
        v9 = &v86[v7];
        dword_44B41C[v7] = v8;
        *(_DWORD *)(v8 + 12) |= 0x4000u;
        v10 = v87[v7];
        dword_44B45C[v7] = v10;
        *(_DWORD *)(v10 + 12) |= 0x4000u;
        if ( *(_WORD *)(*v9 + 60) != -1 && !HIWORD(dword_44B48C) )
          HIWORD(dword_44B48C) = *(_WORD *)(*v9 + 60);
        v5 = dword_44B418;
        v7 = ++v6;
      }
      while ( v6 < (unsigned int)dword_44B418 );
    }
    v11 = 0;
    if ( v5 )
    {
      v12 = 0;
      do
      {
        *(_WORD *)(dword_44B41C[v12] + 60) = HIWORD(dword_44B48C);
        *(_WORD *)(dword_44B41C[v12] + 64) = 0;
        v13 = dword_44B41C[v12];
        v14 = 4 * v12 + 4502620;
        *(_DWORD *)(v13 + 12) |= 0x100000u;
        *(_WORD *)(*(_DWORD *)v14 + 60) = HIWORD(dword_44B48C);
        *(_WORD *)(*(_DWORD *)v14 + 64) = 0;
        ++v11;
        *(_DWORD *)(*(_DWORD *)v14 + 12) |= 0x100000u;
        v12 = v11;
      }
      while ( v11 < (unsigned int)dword_44B418 );
    }
    byte_44B448 = sub_417400(17, &dword_44B47C, 1);
    v15 = sub_417400(32, &dword_44B480, 1);
    v16 = dword_455C3C;
    byte_44B448 = v15;
    for ( i = (_BYTE *)dword_455C38; v16; --v16 )
    {
      if ( *i < 0 )
        dword_44B44C = (int)i;
      i += 12;
    }
    LOBYTE(dword_441008[0]) = 9;
    sub_413D30(a1, 0);
  }
  if ( !byte_455CA9 && !byte_44B793 && !byte_455C12 && !byte_44BAE4 )
  {
    v83 = 0;
    v84 = 0;
    do
    {
      v18 = dword_443D2C;
      v19 = *((_DWORD *)dword_443D2C + 16032);
      v20 = (double)v84 * 60.0;
      *((_DWORD *)dword_443D2C + 16032) = v19 + 128;
      v21 = v20 + 390.0;
      *(_DWORD *)(v19 + 4) = 0;
      *(_DWORD *)v19 = v18[30];
      v18[30] = v19;
      v85 = v21;
      *(float *)(v19 + 16) = v85;
      *(_DWORD *)(v19 + 20) = 1137999872;
      *(_DWORD *)(v19 + 48) = 1137999872;
      v22 = v21 + 54.0;
      v23 = v85;
      *(_DWORD *)(v19 + 24) = 0;
      *(float *)(v19 + 44) = v22;
      *(float *)(v19 + 72) = v23;
      *(_DWORD *)(v19 + 52) = 0;
      *(_DWORD *)(v19 + 80) = 0;
      *(_DWORD *)(v19 + 108) = 0;
      *(float *)(v19 + 100) = v22;
      *(_BYTE *)(v19 + 34) = -1;
      *(_BYTE *)(v19 + 33) = -1;
      *(_BYTE *)(v19 + 32) = -1;
      *(_DWORD *)(v19 + 4) = 5;
      *(_DWORD *)(v19 + 76) = 1139926630;
      *(_DWORD *)(v19 + 104) = 1139926630;
      *(_DWORD *)(v19 + 28) = 1065353216;
      *(_DWORD *)(v19 + 56) = 1065353216;
      *(_DWORD *)(v19 + 84) = 1065353216;
      *(_DWORD *)(v19 + 112) = 1065353216;
      if ( v83 >= *(_BYTE *)(a1 + 5) )
      {
        *(_DWORD *)(v19 + 36) = 1054398681;
        *(_DWORD *)(v19 + 40) = 1059695018;
        *(_DWORD *)(v19 + 64) = 1058050193;
        *(_DWORD *)(v19 + 68) = 1059695018;
        *(_DWORD *)(v19 + 92) = 1054398681;
        *(_DWORD *)(v19 + 96) = 1062918875;
        *(_DWORD *)(v19 + 120) = 1058050193;
        *(_DWORD *)(v19 + 124) = 1062918875;
        v24 = sub_401000(0, 0, 1179, 169);
      }
      else
      {
        *(_DWORD *)(v19 + 36) = 1049661585;
        *(_DWORD *)(v19 + 40) = 1059695018;
        *(_DWORD *)(v19 + 64) = 1054398681;
        *(_DWORD *)(v19 + 68) = 1059695018;
        *(_DWORD *)(v19 + 92) = 1049661585;
        *(_DWORD *)(v19 + 96) = 1062918875;
        *(_DWORD *)(v19 + 120) = 1054398681;
        *(_DWORD *)(v19 + 124) = 1062918875;
        v24 = sub_401000(0, 0, 1170, 169);
      }
      v25 = v84;
      *(_DWORD *)(v19 + 8) = v24;
      v26 = (unsigned __int8)(v83++ + 1) < 3u;
      v84 = v25 + 1;
    }
    while ( v26 );
  }
  if ( *(_BYTE *)dword_44B730 >= 0 || (byte_44B818 = 74, HIBYTE(dword_455CB0)) )
    byte_44B818 = 0;
  if ( !byte_455CA9 && !sub_41F2C0() )
  {
    v27 = *(_BYTE *)(a1 + 8);
    if ( v27 != 14 && v27 != 13 && v27 != 12 && v27 != 11 && v27 != 5 )
    {
      v28 = sub_4336A0();
      dword_44B454 = v28;
      v29 = *(_BYTE *)(a1 + 8);
      if ( v29 != 7 && v29 != 8 && v29 != 9 && v29 != 10 && v28 - dword_44B430 >= LOBYTE(dword_441008[0]) )
      {
        dword_44B430 = sub_4336A0();
        sub_413D30(a1, 5);
      }
      v30 = *(_BYTE *)(a1 + 8);
      if ( v30 )
      {
        if ( v30 != 7 && v30 != 8 && v30 != 9 )
        {
          if ( dword_44B47C )
          {
            v31 = *(_BYTE **)(dword_44B47C + 92);
            if ( v31 )
            {
              if ( *v31 < 0 && !(*(_DWORD *)(dword_44B47C + 12) & 0x2000000) )
              {
                v32 = *(_WORD *)dword_44B730 & 0x80;
                if ( v32 && (v33 = *(_BYTE **)(dword_44B480 + 92)) != 0 && *v33 < 0 )
                {
                  byte_44B48A = 1;
                  byte_44B488 = 1;
                  byte_44B489 = 1;
                  sub_413D30(a1, 9);
                }
                else
                {
                  byte_44B48A = 1;
                  if ( v32 )
                  {
                    byte_44B488 = 1;
                    byte_44B489 = 0;
                    sub_413D30(a1, 8);
                  }
                  else
                  {
                    byte_44B488 = 0;
                    byte_44B489 = 0;
                    sub_413D30(a1, 7);
                  }
                }
              }
            }
          }
        }
      }
      v34 = byte_44B48B;
      if ( byte_44B48B && *(_BYTE *)dword_44B730 >= 0 )
      {
        v35 = sub_4336A0();
        dword_44B450 = v35;
        dword_44B46C = v35;
        v34 = 0;
        byte_44B48B = 0;
      }
      if ( *(_BYTE *)dword_44B730 < 0 && *(_BYTE *)(a1 + 8) != 8 )
      {
        if ( !v34 )
        {
          dword_44B46C = sub_4336A0();
          byte_44B48B = 1;
        }
        dword_44B450 = sub_4336A0();
        if ( dword_44B450 - dword_44B46C >= 5 )
        {
          byte_44B48A = 0;
          byte_44B488 = 1;
          sub_41BB60(3);
          byte_44B48B = 0;
          sub_413D30(a1, 8);
        }
      }
    }
  }
  v36 = *(_DWORD *)(a1 + 12);
  if ( v36 & 0x400 )
  {
    BYTE1(v36) &= 0xFBu;
    *(_DWORD *)(a1 + 12) = v36;
    sub_416160(a1);
    *(_DWORD *)(a1 + 92) = 0;
    v37 = 0;
    if ( dword_44B418 )
    {
      v38 = 0;
      do
      {
        *(_DWORD *)(dword_44B41C[v38] + 12) |= 0x100000u;
        ++v37;
        *(_DWORD *)(dword_44B45C[v38] + 12) |= 0x100000u;
        LOBYTE(v85) = v37;
        v38 = v37;
      }
      while ( v37 < (unsigned int)dword_44B418 );
    }
    dword_44B458 = 0;
    if ( byte_44B488 )
      byte_44B812 = 0;
    byte_44B48B = 0;
    sub_41BB60(0);
    byte_44B48A = 0;
    byte_44B488 = 0;
    byte_44B489 = 0;
    LOWORD(dword_441008[0]) = 265;
    word_44B7EC = 0;
    word_44B7EE = 0;
    word_44B7F0 = 0;
    HIBYTE(dword_455CB0) = 0;
    sub_413D30(a1, 2);
  }
  switch ( *(unsigned __int8 *)(a1 + 8) )
  {
    case 0u:
      if ( byte_455CA9 )
      {
        v39 = *(_DWORD *)(a1 + 20);
        goto LABEL_85;
      }
      dword_44B430 = sub_4336A0();
      sub_413D30(a1, 5);
      return 1;
    case 2u:
      v41 = *(_DWORD *)(a1 + 20);
      goto LABEL_107;
    case 3u:
    case 4u:
      v41 = *(_DWORD *)(a1 + 20);
LABEL_107:
      if ( !v41 )
        return 1;
      v48 = *(unsigned __int16 **)(v41 + 184);
      if ( !v48 || *(unsigned __int16 *)(v41 + 174) != *v48 - 1 )
        return 1;
      sub_413D30(a1, 2);
      return 1;
    case 5u:
      v42 = dword_44B458;
      v43 = *(_DWORD *)(dword_44B458 + 12);
      if ( v43 & 1 )
      {
        *(_DWORD *)(dword_44B458 + 12) = v43 & 0xFFDFFFFF;
        sub_413D30(a1, 2);
        result = 1;
      }
      else
      {
        v44 = *(_DWORD *)(a1 + 16);
        if ( v44 >= 0x1E && v44 < 0x36 )
        {
          BYTE1(v43) &= 0xBFu;
          *(_DWORD *)(dword_44B458 + 12) = v43;
          v42 = dword_44B458;
        }
        v45 = *(_DWORD *)(a1 + 16);
        if ( v45 >= 0x36 && v45 < 0x37 )
        {
          *(_DWORD *)(v42 + 12) &= 0xFFDFFFFF;
          *(_DWORD *)(dword_44B458 + 12) |= 0x400000u;
        }
        v46 = *(_DWORD *)(a1 + 20);
        if ( v46 )
        {
          v47 = *(unsigned __int16 **)(v46 + 184);
          if ( v47 )
          {
            if ( *(unsigned __int16 *)(v46 + 174) == *v47 - 1 )
            {
              if ( LOBYTE(dword_441008[0]) == 6 )
                sub_413D30(a1, 2);
              else
                sub_413D30(a1, 6);
            }
          }
        }
        ++*(_DWORD *)(a1 + 16);
        result = 1;
      }
      return result;
    case 6u:
      v49 = *(_DWORD *)(a1 + 20);
      if ( !v49 )
        return 1;
      v50 = *(unsigned __int16 **)(v49 + 184);
      if ( !v50 || *(unsigned __int16 *)(v49 + 174) != *v50 - 1 )
        return 1;
      v51 = rand();
      if ( ((signed int)(3 * v51 + ((unsigned __int64)(-6442254327i64 * v51) >> 32)) >> 14 < 0)
         + (unsigned __int8)((signed int)(3 * v51 + ((unsigned __int64)(-6442254327i64 * v51) >> 32)) >> 14) )
      {
        if ( (unsigned __int8)(((signed int)(3 * v51 + ((unsigned __int64)(-6442254327i64 * v51) >> 32)) >> 14 < 0)
                             + ((signed int)(3 * v51 + ((unsigned __int64)(-6442254327i64 * v51) >> 32)) >> 14)) == 1 )
        {
          sub_413D30(a1, 4);
          result = 1;
        }
        else
        {
          if ( (unsigned __int8)(((signed int)(3 * v51 + ((unsigned __int64)(-6442254327i64 * v51) >> 32)) >> 14 < 0)
                               + ((signed int)(3 * v51 + ((unsigned __int64)(-6442254327i64 * v51) >> 32)) >> 14)) != 2 )
            return 1;
          sub_413D30(a1, 2);
          result = 1;
        }
      }
      else
      {
        sub_413D30(a1, 3);
        result = 1;
      }
      return result;
    case 7u:
    case 8u:
    case 9u:
      v52 = dword_44B480;
      if ( *(_BYTE *)(dword_44B480 + 12) & 1 )
        byte_44B489 = 0;
      if ( *(_DWORD *)(dword_44B480 + 12) & 0x4000000 )
      {
        sub_413D30(a1, 2);
        result = 1;
      }
      else
      {
        v53 = a1;
        v54 = *(_DWORD *)(a1 + 20);
        if ( v54 )
        {
          v55 = *(unsigned __int16 **)(v54 + 184);
          if ( v55 )
          {
            if ( *(unsigned __int16 *)(v54 + 174) == *v55 - 1 )
            {
              sub_413D30(a1, 10);
              v52 = dword_44B480;
            }
          }
        }
        if ( *(_DWORD *)(a1 + 16) == 20 )
        {
          if ( *(_BYTE *)dword_44B730 >= 0 )
          {
            v56 = 0;
            byte_44B488 = 0;
          }
          else
          {
            byte_44B793 = 1;
            dword_44B764 = 0;
            sub_41BB60(3);
            v52 = dword_44B480;
            v53 = a1;
            v56 = 1;
            byte_44B488 = 1;
          }
        }
        else
        {
          v56 = byte_44B488;
        }
        if ( *(_DWORD *)(v53 + 16) > 0x1Bu )
          goto LABEL_244;
        v57 = *(char **)(dword_44B47C + 92);
        if ( !v57 || (v58 = *v57, byte_44B48A = 1, v58 >= 0) )
          byte_44B48A = 0;
        if ( *(_DWORD *)(v53 + 16) != 27
          || ((v59 = *(_BYTE **)(v52 + 92)) == 0 || *v59 >= 0 ? (byte_44B489 = 0) : (LOWORD(dword_44B48C) = 60,
                                                                                     byte_44B489 = 1),
              byte_44B48A || v56) )
        {
LABEL_244:
          if ( *(_DWORD *)(v53 + 16) >= 0x23u )
          {
            if ( v56 )
              byte_44B812 = 1;
            if ( byte_44B489 )
              *(_DWORD *)(v52 + 12) |= 0x1000000u;
            if ( byte_44B48A )
              *(_DWORD *)(dword_44B47C + 12) |= 0x1000000u;
          }
          ++*(_DWORD *)(v53 + 16);
          result = 1;
        }
        else
        {
          sub_413D30(a1, 2);
          result = 1;
        }
      }
      return result;
    case 0xAu:
      sub_434500(0x78u);
      v60 = byte_44B488;
      if ( byte_44B488 )
        byte_44B812 = 1;
      if ( byte_44B48A )
      {
        *(_DWORD *)(dword_44B47C + 12) |= 0x1000000u;
        v60 = byte_44B488;
      }
      v61 = *(_DWORD *)(a1 + 20);
      if ( !v61 )
        goto LABEL_173;
      v62 = *(unsigned __int16 **)(v61 + 184);
      if ( !v62 || *(unsigned __int16 *)(v61 + 174) != *v62 - 1 )
        goto LABEL_173;
      if ( byte_44B489 )
      {
        if ( !v60 )
        {
          v63 = 0;
          if ( (unsigned int)dword_44B418 > 0 )
          {
            v64 = 0;
            do
            {
              v65 = dword_44B41C[v64];
              v66 = *(_DWORD *)(v65 + 12);
              if ( !(v66 & 0x400000) )
                *(_DWORD *)(v65 + 12) = v66 | 0x100000;
              v67 = dword_44B45C[v64];
              v68 = *(_DWORD *)(v67 + 12);
              if ( !(v68 & 0x400000) )
                *(_DWORD *)(v67 + 12) = v68 | 0x100000;
              v64 = ++v63;
            }
            while ( v63 < (unsigned int)dword_44B418 );
          }
          sub_413D30(a1, 11);
LABEL_173:
          if ( dword_44B43C )
          {
            *(_BYTE *)(dword_44B43C + 2530) = 0;
            *(_DWORD *)(dword_44B43C + 2512) = 0;
            dword_44B43C = 0;
          }
          if ( dword_44B440 )
          {
            *(_BYTE *)(dword_44B440 + 2530) = 0;
            result = 1;
            *(_DWORD *)(dword_44B440 + 2512) = 0;
            dword_44B440 = 0;
            return result;
          }
          return 1;
        }
      }
      else if ( !v60 )
      {
LABEL_172:
        sub_413D30(a1, 2);
        goto LABEL_173;
      }
      sub_41ED70(0xFFu);
      goto LABEL_172;
    case 0xBu:
      if ( (_WORD)dword_44B48C )
      {
        if ( (unsigned __int16)dword_44B48C % 2 )
        {
          if ( (signed int)(unsigned __int8)byte_455CB5 > -8 )
            byte_455CB5 -= 2;
          if ( (unsigned __int8)byte_455CB6 >= 0x16u )
            goto LABEL_188;
          v69 = byte_455CB6 + 2;
        }
        else
        {
          if ( (unsigned __int8)byte_455CB5 < 0xCu )
            byte_455CB5 += 2;
          if ( (unsigned __int8)byte_455CB6 <= 2u )
            goto LABEL_188;
          v69 = byte_455CB6 - 2;
        }
        byte_455CB6 = v69;
LABEL_188:
        nullsub_1(dword_443D44);
        nullsub_1(dword_443D38);
        LOWORD(dword_44B48C) = dword_44B48C - 1;
        goto LABEL_191;
      }
      if ( sub_434550() )
        sub_434530();
LABEL_191:
      if ( dword_44B43C )
      {
        v71 = a1;
        sub_40B920(
          dword_44B43C,
          *(float *)(*(_DWORD *)(*(_DWORD *)(a1 + 20) + 180) + 4576),
          *(float *)(*(_DWORD *)(*(_DWORD *)(a1 + 20) + 180) + 4580),
          *(float *)(*(_DWORD *)(*(_DWORD *)(a1 + 20) + 180) + 4584));
      }
      else
      {
        v70 = sub_40B8D0();
        dword_44B43C = (int)v70;
        if ( v70 )
        {
          sub_413AD0((int)v70);
          v71 = a1;
          sub_40B920(
            dword_44B43C,
            *(float *)(*(_DWORD *)(*(_DWORD *)(a1 + 20) + 180) + 4576),
            *(float *)(*(_DWORD *)(*(_DWORD *)(a1 + 20) + 180) + 4580),
            *(float *)(*(_DWORD *)(*(_DWORD *)(a1 + 20) + 180) + 4584));
        }
        else
        {
          v71 = a1;
        }
      }
      if ( dword_44B440 )
      {
        sub_40B920(
          dword_44B440,
          *(float *)(*(_DWORD *)(*(_DWORD *)(v71 + 20) + 180) + 4812),
          *(float *)(*(_DWORD *)(*(_DWORD *)(v71 + 20) + 180) + 4816),
          *(float *)(*(_DWORD *)(*(_DWORD *)(v71 + 20) + 180) + 4820));
      }
      else
      {
        v72 = sub_40B8D0();
        dword_44B440 = (int)v72;
        if ( v72 )
        {
          sub_413AD0((int)v72);
          sub_40B920(
            dword_44B440,
            *(float *)(*(_DWORD *)(*(_DWORD *)(v71 + 20) + 180) + 4812),
            *(float *)(*(_DWORD *)(*(_DWORD *)(v71 + 20) + 180) + 4816),
            *(float *)(*(_DWORD *)(*(_DWORD *)(v71 + 20) + 180) + 4820));
        }
      }
      if ( sub_41F2C0() )
        sub_413D30(v71, 2);
      v73 = *(_DWORD *)(v71 + 20);
      if ( !v73 )
        return 1;
      v74 = *(unsigned __int16 **)(v73 + 184);
      if ( !v74 || *(unsigned __int16 *)(v73 + 174) != *v74 - 1 )
        return 1;
      if ( LOBYTE(dword_441008[0]) == 9 )
      {
        LOBYTE(dword_441008[0]) = 8;
        dword_44B430 = 0;
        dword_44B454 = 0;
      }
      else if ( LOBYTE(dword_441008[0]) == 8 )
      {
        LOBYTE(dword_441008[0]) = 6;
        dword_44B430 = 0;
        dword_44B454 = 0;
      }
      if ( *(_BYTE *)(a1 + 5) )
        sub_413D30(a1, 12);
      else
        sub_413D30(a1, 13);
      return 1;
    case 0xCu:
      v75 = *(_DWORD *)(a1 + 20);
      if ( v75 )
      {
        v76 = *(unsigned __int16 **)(v75 + 184);
        if ( v76 )
        {
          if ( *(unsigned __int16 *)(v75 + 174) == *v76 - 1 )
          {
            dword_44B430 = sub_4336A0();
            sub_413D30(a1, 5);
          }
        }
      }
      v77 = dword_44B43C;
      if ( dword_44B43C )
        goto LABEL_224;
      goto LABEL_225;
    case 0xDu:
      v78 = *(_DWORD *)(a1 + 20);
      if ( v78 )
      {
        v79 = *(unsigned __int16 **)(v78 + 184);
        if ( v79 )
        {
          if ( *(unsigned __int16 *)(v78 + 174) == *v79 - 1 )
            sub_413D30(a1, 14);
        }
      }
      v77 = dword_44B43C;
      if ( dword_44B43C )
      {
LABEL_224:
        *(_BYTE *)(v77 + 2530) = 0;
        *(_DWORD *)(dword_44B43C + 2512) = 0;
        dword_44B43C = 0;
      }
LABEL_225:
      if ( !dword_44B440 )
        return 1;
      *(_BYTE *)(dword_44B440 + 2530) = 0;
      result = 1;
      *(_DWORD *)(dword_44B440 + 2512) = 0;
      dword_44B440 = 0;
      return result;
    case 0xEu:
      sub_417400(34, (int *)&v85, 1);
      sub_417400(40, &v84, 1);
      if ( *((_BYTE *)&dword_44B81A + dword_455BF8) & 1 )
      {
        if ( *(_BYTE *)(v84 + 12) & 1 )
        {
          byte_455C12 = 1;
          if ( !(_BYTE)dword_455004 )
          {
LABEL_236:
            sub_434690(5u, 0);
            goto LABEL_237;
          }
        }
      }
      else
      {
        v80 = *(_DWORD *)(LODWORD(v85) + 12);
        if ( v80 & 1 )
        {
          if ( v80 & 0x4000 )
          {
            if ( *(_BYTE *)(v84 + 12) & 1 )
            {
              if ( BYTE1(dword_44B80C) != 3 )
              {
                byte_455C12 = 1;
                if ( !(_BYTE)dword_455004 )
                  goto LABEL_236;
              }
            }
          }
        }
      }
LABEL_237:
      v81 = *(float *)(a1 + 20);
      if ( v81 != 0.0 )
      {
        v82 = *(unsigned __int16 **)(LODWORD(v81) + 184);
        if ( v82 )
        {
          if ( *(unsigned __int16 *)(LODWORD(v81) + 174) == *v82 - 1 )
            sub_408670(v81, 9, 0);
        }
      }
      return 1;
    case 0xFu:
      v39 = *(_DWORD *)(a1 + 20);
LABEL_85:
      if ( !v39 )
        return 1;
      v40 = *(unsigned __int16 **)(v39 + 184);
      if ( !v40 || *(unsigned __int16 *)(v39 + 174) != *v40 - 1 )
        return 1;
      sub_413D30(a1, 0);
      return 1;
    default:
      return 1;
  }
}
// 434B40: using guessed type int __cdecl nullsub_1(_DWORD);
// 441008: using guessed type int dword_441008[];
// 443D38: using guessed type int dword_443D38;
// 44B418: using guessed type int dword_44B418;
// 44B42C: using guessed type int dword_44B42C;
// 44B430: using guessed type int dword_44B430;
// 44B448: using guessed type char byte_44B448;
// 44B44C: using guessed type int dword_44B44C;
// 44B450: using guessed type int dword_44B450;
// 44B454: using guessed type int dword_44B454;
// 44B458: using guessed type int dword_44B458;
// 44B46C: using guessed type int dword_44B46C;
// 44B47C: using guessed type int dword_44B47C;
// 44B480: using guessed type int dword_44B480;
// 44B484: using guessed type int dword_44B484;
// 44B488: using guessed type char byte_44B488;
// 44B489: using guessed type char byte_44B489;
// 44B48A: using guessed type char byte_44B48A;
// 44B48B: using guessed type char byte_44B48B;
// 44B48C: using guessed type int dword_44B48C;
// 44B730: using guessed type int dword_44B730;
// 44B764: using guessed type int dword_44B764;
// 44B793: using guessed type char byte_44B793;
// 44B7EC: using guessed type __int16 word_44B7EC;
// 44B7EE: using guessed type __int16 word_44B7EE;
// 44B7F0: using guessed type __int16 word_44B7F0;
// 44B80C: using guessed type int dword_44B80C;
// 44B812: using guessed type char byte_44B812;
// 44B818: using guessed type char byte_44B818;
// 44B81A: using guessed type int dword_44B81A;
// 44BAE4: using guessed type char byte_44BAE4;
// 455004: using guessed type int dword_455004;
// 455BF8: using guessed type int dword_455BF8;
// 455C12: using guessed type char byte_455C12;
// 455C14: using guessed type char byte_455C14;
// 455C38: using guessed type int dword_455C38;
// 455C3C: using guessed type int dword_455C3C;
// 455CA5: using guessed type char byte_455CA5;
// 455CA9: using guessed type char byte_455CA9;
// 455CB0: using guessed type int dword_455CB0;
// 455CB5: using guessed type char byte_455CB5;
// 455CB6: using guessed type char byte_455CB6;
// 4141C0: using guessed type int var_20[4];
// 4141C0: using guessed type int var_10[4];

//----- (004151B0) --------------------------------------------------------
void __cdecl sub_4151B0(int a1, float a2, char a3, int a4, int a5)
{
  int v5; // ebp
  char v6; // al
  char v7; // cl
  unsigned __int8 v8; // al
  char v9; // al
  char v10; // [esp+18h] [ebp+8h]

  if ( !a1 || a2 <= 0.0 )
    goto LABEL_31;
  if ( a5 )
  {
    v5 = a4;
    v6 = sub_4157C0(a1, a2, a4, a5);
    v10 = v6;
    v7 = 0;
  }
  else
  {
    v5 = a4;
    v6 = sub_415610(a1, a2, a4);
    v7 = a3;
    v10 = v6;
  }
  if ( *(_DWORD *)(a1 + 164) )
  {
    switch ( v10 )
    {
      case 0:
        if ( (float *)a1 != &dword_44B71C || (unsigned int)dword_44B7C8 >= 0x19 )
          goto LABEL_15;
        *(_BYTE *)(a1 + 161) = 0;
        break;
      case 5:
      case 6:
      case 8:
        goto LABEL_31;
      case 7:
        if ( v7 )
        {
          if ( dword_455BF8 != 8
            || *(_BYTE *)(dword_455C38 + 12 * (*(_DWORD *)(a1 + 16) + *(unsigned __int16 *)(*(_DWORD *)(a1 + 12) + 32))) >= 0 )
          {
            *(_BYTE *)(a1 + 161) = 4;
          }
          else
          {
LABEL_15:
            *(_BYTE *)(a1 + 161) = 3;
          }
        }
        else
        {
          *(_BYTE *)(a1 + 161) = 0;
        }
        break;
      default:
        break;
    }
  }
  else
  {
    switch ( v10 )
    {
      case 0:
        if ( a5 )
          goto LABEL_21;
        goto LABEL_20;
      case 5:
      case 6:
LABEL_21:
        *(_BYTE *)(a1 + 161) = v6;
        break;
      case 7:
        *(_BYTE *)(a1 + 161) = 1;
        break;
      case 8:
LABEL_20:
        *(_BYTE *)(a1 + 161) = 2;
        break;
      default:
        break;
    }
  }
  if ( *(_BYTE *)(a1 + 112) )
  {
    v8 = *(_BYTE *)(a1 + 161);
    if ( v8 > 0u && v8 <= 4u )
      *(_BYTE *)(a1 + 161) = 0;
  }
  v9 = *(_BYTE *)(a1 + 161);
  if ( (v9 == 1 || v9 == 4)
    && dword_455BF8 == 10
    && *(_BYTE *)(*(_DWORD *)v5 + 4) == 18
    && *(_BYTE *)(*(_DWORD *)v5 + 6) != *(_BYTE *)(*(_DWORD *)v5 + 7) )
  {
LABEL_31:
    *(_BYTE *)(a1 + 161) = 0;
  }
}
// 44B7C8: using guessed type int dword_44B7C8;
// 455BF8: using guessed type int dword_455BF8;
// 455C38: using guessed type int dword_455C38;

//----- (00415360) --------------------------------------------------------
char __cdecl sub_415360(int a1, float a2, int a3, int a4)
{
  int v4; // edi
  char v5; // al
  char v6; // dl
  char result; // al
  unsigned __int8 v8; // al
  unsigned __int8 v9; // al
  float *v10; // edi
  int v11; // ecx

  if ( !a1 || !*(_BYTE *)(a1 + 161) || a2 <= 0.0 )
    return 0;
  v4 = a4;
  if ( a4 )
  {
    v5 = sub_4157C0(a1, a2, (int)&a2, a4);
    v6 = 0;
  }
  else
  {
    v5 = sub_415610(a1, a2, (int)&a2);
    v6 = a3;
  }
  switch ( *(unsigned __int8 *)(a1 + 161) )
  {
    case 1u:
      goto LABEL_45;
    case 2u:
      if ( v5 == 5 )
      {
        *(_BYTE *)(a1 + 161) = 5;
        goto LABEL_25;
      }
      if ( v5 == 8 )
        goto LABEL_25;
      return 0;
    case 3u:
      if ( !v5 )
        goto LABEL_25;
      if ( v5 != 7 )
        return 0;
      if ( dword_455BF8 == 8
        && *(_BYTE *)(dword_455C38 + 12 * (*(_DWORD *)(a1 + 16) + *(unsigned __int16 *)(*(_DWORD *)(a1 + 12) + 32))) < 0 )
      {
        goto LABEL_25;
      }
      if ( !v6 )
        return 0;
      *(_BYTE *)(a1 + 161) = 4;
      goto LABEL_25;
    case 4u:
      if ( v5 )
      {
LABEL_45:
        if ( v5 != 7 )
          return 0;
      }
      else
      {
        *(_BYTE *)(a1 + 161) = 3;
      }
LABEL_25:
      if ( *(_BYTE *)(a1 + 112) )
      {
        v8 = *(_BYTE *)(a1 + 161);
        if ( v8 )
        {
          if ( v8 <= 4u )
            return 0;
        }
      }
      switch ( *(unsigned __int8 *)(a1 + 161) )
      {
        case 1u:
        case 2u:
          sub_415890(a1, SLODWORD(a2));
          if ( *(char (__cdecl **)(int))(LODWORD(a2) + 28) == sub_411420 )
            goto LABEL_44;
          dword_44B7C8 = 0;
          result = 1;
          break;
        case 3u:
          sub_4158D0(a1);
          result = 1;
          break;
        case 4u:
          sub_4158D0(a1);
          sub_415890(a1, SLODWORD(a2));
          result = 1;
          break;
        default:
          if ( v4 )
          {
            v10 = &dword_44B71C;
          }
          else if ( dword_44EAA4 && (v9 = 0, (_BYTE)dword_44EAA8) )
          {
            v10 = (float *)a3;
            v11 = dword_44EAA4 + 4;
            do
            {
              if ( *(_DWORD *)(v11 + 164) == LODWORD(a2) )
              {
                v10 = (float *)v11;
                v9 = dword_44EAA8;
              }
              v11 += 552;
              ++v9;
            }
            while ( v9 < (unsigned __int8)dword_44EAA8 );
            dword_44B7C8 = 0;
          }
          else
          {
            v10 = (float *)a3;
            dword_44B7C8 = 0;
          }
          sub_4158D0((int)v10);
          sub_415890(a1, SLODWORD(a2));
          sub_41F120((int *)(*((_DWORD *)v10 + 42) + 92));
LABEL_44:
          result = 1;
          break;
      }
      break;
    case 5u:
      if ( v5 == 5 )
        goto LABEL_24;
      if ( v5 != 8 )
        return 0;
      *(_BYTE *)(a1 + 161) = 2;
      goto LABEL_25;
    case 6u:
      if ( v5 != 6 )
        return 0;
LABEL_24:
      sub_407E00((int)&unk_44489C);
      goto LABEL_25;
    default:
      goto LABEL_25;
  }
  return result;
}
// 44B7C8: using guessed type int dword_44B7C8;
// 44EAA4: using guessed type int dword_44EAA4;
// 44EAA8: using guessed type int dword_44EAA8;
// 455BF8: using guessed type int dword_455BF8;
// 455C38: using guessed type int dword_455C38;

//----- (004155C0) --------------------------------------------------------
char __cdecl sub_4155C0(int a1)
{
  int v1; // ecx
  int v2; // edx

  if ( !a1 )
    return 0;
  v1 = *(_DWORD *)(a1 + 164);
  if ( !v1 )
    return 0;
  v2 = *(_DWORD *)(a1 + 20);
  if ( v2 )
  {
    *(_DWORD *)(v1 + 92) = v2;
    *(_WORD *)(v1 + 96) = *(_WORD *)(a1 + 16) + *(_WORD *)(*(_DWORD *)(a1 + 12) + 32);
  }
  *(_DWORD *)(v1 + 32) = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(v1 + 36) = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(v1 + 40) = *(_DWORD *)(a1 + 40);
  return 1;
}

//----- (00415610) --------------------------------------------------------
char __cdecl sub_415610(int a1, float a2, int a3)
{
  char result; // al
  int v4; // edi
  int v5; // esi
  double v6; // st7
  int v7; // eax
  int v8; // ecx
  double v9; // st7
  int v10; // eax
  unsigned __int8 v11; // al
  unsigned __int8 v12; // bl
  int *v13; // edi
  double v14; // st7
  char v15; // al
  _DWORD *v16; // ecx
  unsigned __int8 v17; // [esp+13h] [ebp-25h]
  float v18; // [esp+14h] [ebp-24h]
  float v19; // [esp+18h] [ebp-20h]
  int v20; // [esp+1Ch] [ebp-1Ch]
  int v21; // [esp+20h] [ebp-18h]
  int v22; // [esp+24h] [ebp-14h]
  int v23; // [esp+28h] [ebp-10h]
  int v24; // [esp+2Ch] [ebp-Ch]
  float v25; // [esp+30h] [ebp-8h]
  int v26; // [esp+34h] [ebp-4h]

  if ( BYTE1(dword_44B80C) == 3 )
  {
    *(_DWORD *)a3 = 0;
    result = 0;
  }
  else
  {
    v4 = a1;
    v5 = dword_455C7C;
    v6 = *(float *)(a1 + 140) * 0.5;
    v7 = *(_DWORD *)(a1 + 40);
    v8 = *(_DWORD *)(a1 + 32);
    v22 = *(_DWORD *)(a1 + 36);
    v9 = *(float *)(a1 + 36) - v6;
    v23 = v7;
    v21 = v8;
    v25 = v9;
    v24 = v8;
    v26 = v7;
    v19 = a2;
    if ( !dword_455C7C )
      goto LABEL_31;
    do
    {
      if ( v5 != *(_DWORD *)(v4 + 164) )
      {
        v10 = *(_DWORD *)(v5 + 12);
        if ( !(v10 & 0x4000) )
        {
          v11 = *(_BYTE *)(v5 + 4);
          if ( v11 >= 0x11u && (v11 <= 0x13u || v11 == 32) )
          {
            v12 = 0;
            v13 = &v21;
            do
            {
              v14 = sub_430D30((int)v13, v5 + 32, a2);
              v18 = v14;
              if ( v14 < a2 && (v18 <= 160.0 || sub_415990(a1, (float *)(v5 + 32))) && v18 < (double)v19 )
              {
                v20 = v5;
                v19 = v14;
                v17 = v12;
              }
              ++v12;
              v13 += 3;
            }
            while ( v12 < 2u );
            v4 = a1;
          }
        }
      }
      v5 = *(_DWORD *)v5;
    }
    while ( v5 );
    if ( v19 != a2 )
    {
      *(_DWORD *)a3 = v20;
      if ( dword_44EAA4 && (v15 = 0, (_BYTE)dword_44EAA8) )
      {
        v16 = (_DWORD *)(dword_44EAA4 + 168);
        while ( *v16 != v20 )
        {
          v16 += 138;
          if ( (unsigned __int8)++v15 >= (unsigned __int8)dword_44EAA8 )
            goto LABEL_25;
        }
        if ( *(_DWORD *)(v4 + 164) )
        {
          *(_DWORD *)a3 = 0;
          result = 0;
        }
        else
        {
          result = 5;
        }
      }
      else
      {
LABEL_25:
        result = (v17 != 0) + 7;
      }
    }
    else
    {
LABEL_31:
      *(_DWORD *)a3 = 0;
      result = 0;
    }
  }
  return result;
}
// 44B80C: using guessed type int dword_44B80C;
// 44EAA4: using guessed type int dword_44EAA4;
// 44EAA8: using guessed type int dword_44EAA8;
// 455C7C: using guessed type int dword_455C7C;

//----- (004157C0) --------------------------------------------------------
char __cdecl sub_4157C0(int a1, float a2, int a3, int a4)
{
  int v4; // esi
  int v5; // edi
  int v6; // eax
  char result; // al

  if ( *(_DWORD *)(a1 + 164) || (v4 = dword_455C74, v5 = 0, !dword_455C78) )
  {
LABEL_10:
    result = 0;
    *(_DWORD *)a3 = 0;
  }
  else
  {
    while ( 1 )
    {
      if ( *(_BYTE *)(v4 + 4) == *(_BYTE *)(*(unsigned __int8 *)(a4 + 180) + dword_44EB0C) )
      {
        v6 = *(_DWORD *)(v4 + 12);
        if ( (!(v6 & 0x4000)
           || v4 == dword_44B7C0 && (_WORD)dword_44B784 == -1 && *(_DWORD *)(*(_DWORD *)dword_44EAAC + 12) < 0)
          && sub_430D30(a1 + 32, v4 + 32, a2) < a2 )
        {
          break;
        }
      }
      v4 += 104;
      if ( (unsigned __int16)++v5 >= (unsigned int)dword_455C78 )
        goto LABEL_10;
    }
    *(_DWORD *)a3 = v4;
    result = (dword_44B7C0 != v4) + 6;
  }
  return result;
}
// 44B784: using guessed type int dword_44B784;
// 44B7C0: using guessed type int dword_44B7C0;
// 44EB0C: using guessed type int dword_44EB0C;
// 455C74: using guessed type int dword_455C74;
// 455C78: using guessed type int dword_455C78;

//----- (00415890) --------------------------------------------------------
int __cdecl sub_415890(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(*(_DWORD *)(a2 + 20) + 4) = *(_DWORD *)(a1 + 168);
  *(_DWORD *)(a1 + 164) = a2;
  if ( *(_BYTE *)(a2 + 4) == 19 && (float *)a1 == &dword_44B71C )
    ++BYTE1(dword_44B804);
  return result;
}
// 44B804: using guessed type int dword_44B804;

//----- (004158D0) --------------------------------------------------------
void __cdecl sub_4158D0(int a1)
{
  int v1; // esi
  int v2; // edx
  int v3; // eax
  int v4; // ecx
  int v5; // edx
  int v6; // ecx
  int v7; // edx
  int v8; // eax
  int v9; // ecx

  if ( a1 )
  {
    v1 = *(_DWORD *)(a1 + 164);
    if ( v1 )
    {
      v2 = *(_DWORD *)(v1 + 12);
      v3 = *(_DWORD *)(v1 + 20);
      BYTE1(v2) &= 0xBFu;
      *(_DWORD *)(v1 + 12) = v2;
      if ( v3 )
      {
        *(_DWORD *)(v3 + 4) = 0;
        if ( (float *)a1 == &dword_44B71C )
        {
          sub_4155C0(a1);
          *(_DWORD *)(*(_DWORD *)(v1 + 20) + 92) = *(_DWORD *)(a1 + 32);
          *(_DWORD *)(*(_DWORD *)(v1 + 20) + 96) = *(_DWORD *)(a1 + 36);
          v4 = *(_DWORD *)(v1 + 20);
          v5 = *(_DWORD *)(a1 + 40);
        }
        else
        {
          v6 = *(_DWORD *)(v1 + 48);
          v7 = *(_DWORD *)(v1 + 52);
          *(_DWORD *)(v1 + 32) = *(_DWORD *)(v1 + 44);
          v8 = *(_DWORD *)(v1 + 20);
          *(_DWORD *)(v1 + 36) = v6;
          v9 = *(_DWORD *)(v1 + 44);
          *(_DWORD *)(v1 + 40) = v7;
          *(_DWORD *)(v8 + 92) = v9;
          *(_DWORD *)(*(_DWORD *)(v1 + 20) + 96) = *(_DWORD *)(v1 + 48);
          v4 = *(_DWORD *)(v1 + 20);
          v5 = *(_DWORD *)(v1 + 52);
        }
        *(_DWORD *)(v4 + 100) = v5;
        sub_4159D0(v1);
      }
      *(_DWORD *)(a1 + 164) = 0;
      if ( *(_BYTE *)(v1 + 4) == 19 && (float *)a1 == &dword_44B71C )
        --BYTE1(dword_44B804);
    }
  }
}
// 44B804: using guessed type int dword_44B804;

//----- (00415990) --------------------------------------------------------
bool __cdecl sub_415990(int a1, float *a2)
{
  char v2; // cl

  v2 = *(_BYTE *)(a1 + 123);
  return v2 == 1 && *(float *)(a1 + 32) <= (double)*a2 || v2 == -1 && *(float *)(a1 + 32) >= (double)*a2;
}

//----- (004159D0) --------------------------------------------------------
int __cdecl sub_4159D0(int a1)
{
  int result; // eax
  int v2; // edx

  result = a1;
  v2 = *(_DWORD *)(a1 + 20);
  if ( v2 )
  {
    *(_DWORD *)(v2 + 56) = -1082130432;
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 68) = 0;
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 80) = 0;
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 60) = 0;
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 72) = -1082130432;
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 84) = 0;
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 64) = 0;
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 76) = 0;
    result = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(result + 88) = 1065353216;
  }
  return result;
}

//----- (00415A20) --------------------------------------------------------
void __cdecl sub_415A20(int a1)
{
  unsigned __int16 v1; // ax
  int v2; // ecx
  double v3; // st7
  int v4; // eax
  int v5; // edx
  float v6; // [esp+8h] [ebp-18h]
  int v7; // [esp+Ch] [ebp-14h]
  float v8; // [esp+10h] [ebp-10h]
  float v9; // [esp+14h] [ebp-Ch]
  int v10; // [esp+1Ch] [ebp-4h]

  if ( a1 && *(_WORD *)(a1 + 60) != -1 && !*(_DWORD *)(a1 + 100) )
  {
    v1 = *(_WORD *)(a1 + 64);
    v2 = *(_DWORD *)(dword_455C84 + 12 * *(unsigned __int16 *)(a1 + 60) + 4);
    v3 = *(float *)(v2 + 12 * v1) - *(float *)(a1 + 32);
    v7 = 0;
    v6 = v3;
    v8 = *(float *)(v2 + 12 * v1 + 8) - *(float *)(a1 + 40);
    if ( v3 == 0.0 )
    {
      if ( v8 == 0.0 )
      {
        v6 = -1.0;
        v8 = 0.0;
LABEL_10:
        sub_408330(&v6, &v9);
        v4 = *(_DWORD *)(a1 + 20);
        v5 = v10;
        *(float *)(a1 + 68) = v9;
        *(_DWORD *)(a1 + 72) = v5;
        if ( v4 )
        {
          *(_DWORD *)(v4 + 56) = v5;
          *(_DWORD *)(*(_DWORD *)(a1 + 20) + 68) = 0;
          *(float *)(*(_DWORD *)(a1 + 20) + 80) = -v9;
          *(_DWORD *)(*(_DWORD *)(a1 + 20) + 60) = 0;
          *(_DWORD *)(*(_DWORD *)(a1 + 20) + 72) = 1065353216;
          *(_DWORD *)(*(_DWORD *)(a1 + 20) + 84) = 0;
          *(float *)(*(_DWORD *)(a1 + 20) + 64) = v9;
          *(_DWORD *)(*(_DWORD *)(a1 + 20) + 76) = 0;
          *(_DWORD *)(*(_DWORD *)(a1 + 20) + 88) = v10;
        }
        return;
      }
      v6 = 1.0;
    }
    if ( v8 == 0.0 )
      v8 = -1.0;
    goto LABEL_10;
  }
}
// 455C84: using guessed type int dword_455C84;

//----- (00415B50) --------------------------------------------------------
void __cdecl sub_415B50(int a1)
{
  int v1; // ecx
  int v2; // eax
  int v3; // ecx
  float v4; // [esp+8h] [ebp-18h]
  int v5; // [esp+10h] [ebp-10h]
  int v6; // [esp+14h] [ebp-Ch]
  int v7; // [esp+18h] [ebp-8h]
  int v8; // [esp+1Ch] [ebp-4h]

  if ( a1 && *(_WORD *)(a1 + 60) != -1 )
  {
    v1 = *(_DWORD *)(a1 + 72);
    v6 = *(_DWORD *)(a1 + 68);
    v7 = 0;
    v8 = v1;
    sub_408330((float *)&v6, &v4);
    v2 = *(_DWORD *)(a1 + 20);
    if ( v2 )
    {
      *(_DWORD *)(v2 + 56) = v5;
      *(_DWORD *)(*(_DWORD *)(a1 + 20) + 68) = 0;
      *(float *)(*(_DWORD *)(a1 + 20) + 80) = -v4;
      *(_DWORD *)(*(_DWORD *)(a1 + 20) + 60) = 0;
      *(_DWORD *)(*(_DWORD *)(a1 + 20) + 72) = 1065353216;
      *(_DWORD *)(*(_DWORD *)(a1 + 20) + 84) = 0;
      *(float *)(*(_DWORD *)(a1 + 20) + 64) = v4;
      *(_DWORD *)(*(_DWORD *)(a1 + 20) + 76) = 0;
      *(_DWORD *)(*(_DWORD *)(a1 + 20) + 88) = v5;
    }
    v3 = v5;
    *(float *)(a1 + 68) = v4;
    *(_DWORD *)(a1 + 72) = v3;
  }
}

//----- (00415C00) --------------------------------------------------------
void __cdecl sub_415C00(int a1)
{
  double v1; // st7
  int v2; // edx
  unsigned __int16 v3; // ax
  int v4; // edx
  __int16 v5; // ax

  if ( a1 )
  {
    v1 = *(float *)(a1 + 56) * -1.0;
    v2 = dword_455C84;
    v3 = *(_WORD *)(a1 + 60);
    *(float *)(a1 + 56) = v1;
    v4 = v2 + 12 * v3;
    if ( v1 >= 0.0 )
    {
      if ( ++*(_WORD *)(a1 + 64) >= *(_WORD *)(v4 + 2) )
        *(_WORD *)(a1 + 64) = 0;
      sub_415A20(a1);
    }
    else
    {
      v5 = *(_WORD *)(a1 + 64);
      if ( v5 )
        *(_WORD *)(a1 + 64) = v5 - 1;
      else
        *(_WORD *)(a1 + 64) = *(_WORD *)(v4 + 2) - 1;
      sub_415A20(a1);
    }
  }
}
// 455C84: using guessed type int dword_455C84;

//----- (00415C80) --------------------------------------------------------
void __cdecl sub_415C80(int a1)
{
  int v1; // eax
  int v2; // edi
  unsigned __int16 v3; // cx
  int v4; // eax
  unsigned int v5; // eax
  double v6; // st7
  int v7; // eax
  unsigned int v8; // eax
  double v9; // st7
  int v10; // [esp+8h] [ebp-Ch]

  if ( !a1 )
    return;
  v1 = *(_DWORD *)(a1 + 12);
  if ( v1 & 0x80000 )
    return;
  if ( v1 & 0x2000000 )
  {
    *(_DWORD *)(a1 + 56) = 0;
    return;
  }
  v2 = dword_455C84 + 12 * *(unsigned __int16 *)(a1 + 60);
  if ( dword_455BEC & 0x400 )
  {
    sub_435281((int)asc_441214, v10);
    sub_435281((int)aVD, COERCE_UNSIGNED_INT64(*(float *)(a1 + 56)));
  }
  v3 = *(_WORD *)(a1 + 64);
  if ( *(float *)(a1 + 56) >= 0.0 )
  {
    if ( (v3 != *(unsigned __int16 *)(v2 + 2) - 1 || !(*(_BYTE *)v2 & 2))
      && (v3 != *(_WORD *)(v2 + 8) || !(*(_DWORD *)(a1 + 12) & 0x10000000)) )
    {
      *(_WORD *)(a1 + 64) = v3 + 1;
      if ( (unsigned __int16)(v3 + 1) >= *(_WORD *)(v2 + 2) )
        *(_WORD *)(a1 + 64) = 0;
      return;
    }
    v7 = *(_DWORD *)(a1 + 12);
    if ( v7 & 0x200000 )
    {
      v8 = v7 & 0xFE007FFF | 0x2000000;
    }
    else
    {
      if ( !(v7 & 4) || v7 & 0x1000000 )
      {
LABEL_33:
        if ( !(*(_DWORD *)(a1 + 12) & 0x2080000) )
        {
          v9 = *(float *)(a1 + 56) * -1.0;
          *(_WORD *)(a1 + 64) = v3 - 1;
          *(float *)(a1 + 56) = v9;
        }
        return;
      }
      v8 = v7 & 0xFD007FFF | 0x1000000;
    }
    *(_DWORD *)(a1 + 12) = v8;
    *(_DWORD *)(a1 + 16) = 0;
    goto LABEL_33;
  }
  if ( !v3 && *(_BYTE *)v2 & 1 || v3 == *(_WORD *)(v2 + 8) && *(_DWORD *)(a1 + 12) & 0x10000000 )
  {
    v4 = *(_DWORD *)(a1 + 12);
    if ( v4 & 0x200000 )
    {
      v5 = v4 & 0xFE007FFF | 0x2000000;
    }
    else
    {
      if ( !(v4 & 4) || v4 & 0x1000000 )
        goto LABEL_18;
      v5 = v4 & 0xFD007FFF | 0x1000000;
    }
    *(_DWORD *)(a1 + 12) = v5;
    *(_DWORD *)(a1 + 16) = 0;
LABEL_18:
    if ( !(*(_DWORD *)(a1 + 12) & 0x2080000) )
    {
      v6 = *(float *)(a1 + 56) * -1.0;
      *(_WORD *)(a1 + 64) = v3 + 1;
      *(float *)(a1 + 56) = v6;
    }
    return;
  }
  if ( v3 )
    *(_WORD *)(a1 + 64) = v3 - 1;
  else
    *(_WORD *)(a1 + 64) = *(_WORD *)(v2 + 2) - 1;
}
// 455BEC: using guessed type int dword_455BEC;
// 455C84: using guessed type int dword_455C84;

//----- (00415E20) --------------------------------------------------------
char __cdecl sub_415E20(float a1, float a2)
{
  int v2; // esi
  char result; // al
  float *v4; // ebx
  int v5; // ebp
  int v6; // eax
  float *v7; // edi
  char v8; // cl
  double v9; // st7
  __int16 v10; // dx
  float v11; // ST08_4
  double v12; // st7
  double v13; // st6
  double v14; // st6
  double v15; // st6
  double v16; // st7
  int v17; // eax
  float v18; // [esp+14h] [ebp-Ch]
  int v19; // [esp+18h] [ebp-8h]
  int v20; // [esp+1Ch] [ebp-4h]
  float v21; // [esp+24h] [ebp+4h]
  float v22; // [esp+24h] [ebp+4h]
  float v23; // [esp+28h] [ebp+8h]

  v2 = LODWORD(a1);
  if ( a1 == 0.0 )
    return 0;
  v4 = (float *)(LODWORD(a1) + 32);
  v5 = dword_455C84 + 12 * *(unsigned __int16 *)(LODWORD(a1) + 60);
  v6 = *(_DWORD *)(v5 + 4);
  v7 = (float *)(v6 + 12 * *(unsigned __int16 *)(LODWORD(a1) + 64));
  v21 = sub_41F420((float *)(LODWORD(a1) + 32), (float *)(v6 + 12 * *(unsigned __int16 *)(LODWORD(a1) + 64))) * 256.0;
  v22 = AGLSqrt(v21);
  v8 = 0;
  if ( a2 == 0.0 )
  {
    v12 = 1.2;
    v18 = *v4;
    v19 = *(_DWORD *)(v2 + 36);
    v20 = *(_DWORD *)(v2 + 40);
  }
  else
  {
    v9 = a2 * 5.1199999 * 0.00390625;
    if ( v22 >= v9 )
    {
      if ( v22 == 0.0 )
      {
        v12 = a2;
      }
      else
      {
        v13 = *v4 - *v7;
        v23 = v13;
        if ( v13 < 0.0 )
          v23 = v23 * -1.0;
        v14 = *(float *)(v2 + 40) - v7[2];
        if ( v14 < 0.0 )
          v14 = v14 * -1.0;
        if ( v23 >= 32.0 || v14 >= 32.0 )
        {
          *v4 = (*v7 - *v4) * v9 / v22 + *v4;
          v18 = *v4;
          *(float *)(v2 + 36) = (v7[1] - *(float *)(v2 + 36)) * v9 / v22 + *(float *)(v2 + 36);
          v19 = *(_DWORD *)(v2 + 36);
          *(float *)(v2 + 40) = (v7[2] - *(float *)(v2 + 40)) * v9 / v22 + *(float *)(v2 + 40);
          v12 = 1.2;
          v20 = *(_DWORD *)(v2 + 40);
        }
        else
        {
          *v4 = (*v7 - *v4) * v9 / v22 + *v4;
          v15 = (v7[1] - *(float *)(v2 + 36)) * v9;
          *(float *)(v2 + 36) = (v15 + v15) / v22 + *(float *)(v2 + 36);
          *(float *)(v2 + 40) = (v7[2] - *(float *)(v2 + 40)) * v9 / v22 + *(float *)(v2 + 40);
          v16 = v7[1] - *(float *)(v2 + 36);
          v19 = *((_DWORD *)v7 + 1);
          if ( v16 < 0.0 )
            v16 = v16 * -1.0;
          if ( v16 < 700.0 )
          {
            v18 = *v4;
            v20 = *(_DWORD *)(v2 + 40);
            v12 = 1.2 - v16 * 1.2 * 0.0014285714;
          }
          else
          {
            v12 = 0.015;
            v18 = *v4;
            v20 = *(_DWORD *)(v2 + 40);
          }
        }
      }
    }
    else
    {
      *v4 = *v7;
      v10 = *(_WORD *)(v2 + 64);
      *(float *)(v2 + 36) = v7[1];
      *(float *)(v2 + 40) = v7[2];
      if ( v10 != *(_WORD *)(v5 + 8) || *(_DWORD *)(v2 + 12) & 0x10000000 )
      {
        sub_415C80(v2);
      }
      else
      {
        sub_415C80(v2);
        *(_DWORD *)(v2 + 12) |= 0x10000000u;
      }
      sub_415A20(v2);
      if ( v22 == 0.0 )
      {
        v19 = *(_DWORD *)(v2 + 36);
        v12 = 1.2;
        v18 = *v4;
        v20 = *(_DWORD *)(v2 + 40);
      }
      else
      {
        v11 = a2 - v22;
        sub_415E20(*(float *)&v2, v11);
        v12 = a2;
      }
      v8 = 1;
    }
  }
  v17 = *(_DWORD *)(v2 + 24);
  if ( !v17 )
    return v8;
  *(float *)(v17 + 92) = v18;
  *(_DWORD *)(*(_DWORD *)(v2 + 24) + 96) = v19;
  *(_DWORD *)(*(_DWORD *)(v2 + 24) + 100) = v20;
  *(float *)(*(_DWORD *)(v2 + 24) + 56) = v12;
  result = v8;
  *(float *)(*(_DWORD *)(v2 + 24) + 88) = v12;
  return result;
}
// 455C84: using guessed type int dword_455C84;

//----- (00416130) --------------------------------------------------------
void __cdecl sub_416130(int a1)
{
  if ( *(_WORD *)(a1 + 60) != -1 && sub_416950((float *)a1) )
  {
    if ( *(_DWORD *)(a1 + 12) & 0x10000000 )
      sub_415C00(a1);
  }
}

//----- (00416160) --------------------------------------------------------
void __cdecl sub_416160(int a1)
{
  unsigned __int8 v1; // cl
  char v2; // al
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // ecx
  int v7; // ecx
  unsigned __int16 v8; // ax
  _DWORD *v9; // eax

  v1 = *(_BYTE *)(a1 + 4);
  *(_BYTE *)(a1 + 5) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_BYTE *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 12) = 1073807360;
  switch ( v1 )
  {
    case 1u:
    case 2u:
      *(_BYTE *)(a1 + 5) = 2;
      *(_DWORD *)(a1 + 28) = sub_41AF60;
      v6 = dword_441008[v1 + 8 * dword_455BF8];
      *(_DWORD *)(a1 + 12) = -805271088;
      *(_DWORD *)(a1 + 56) = v6;
      goto LABEL_63;
    case 4u:
    case 5u:
    case 6u:
    case 7u:
    case 8u:
      *(_BYTE *)(a1 + 5) = 3;
      *(_DWORD *)(a1 + 28) = sub_41AF60;
      v3 = dword_441008[v1 + 8 * dword_455BF8];
      *(_DWORD *)(a1 + 12) = -805271104;
      *(_DWORD *)(a1 + 56) = v3;
      v4 = dword_455BF8;
      switch ( dword_455BF8 )
      {
        case 2:
          if ( v1 != 4 )
            goto LABEL_63;
          break;
        case 1:
          if ( v1 != 8 )
            goto LABEL_63;
          break;
        case 3:
          if ( v1 != 5 )
            goto LABEL_63;
          break;
        case 6:
          if ( v1 != 8 )
            goto LABEL_63;
          break;
        default:
          goto LABEL_51;
      }
      *(_DWORD *)(a1 + 12) = 1343261120;
      v4 = dword_455BF8;
LABEL_51:
      if ( v4 == 5 && v1 == 4 )
      {
        v5 = *(_DWORD *)(a1 + 12);
        BYTE1(v5) &= 0xF7u;
        *(_DWORD *)(a1 + 12) = v5;
      }
      goto LABEL_63;
    case 9u:
    case 0xAu:
      if ( dword_455BF8 == 11 )
      {
        if ( v1 == 9 )
        {
          *(_DWORD *)(a1 + 28) = sub_410B10;
          *(_BYTE *)(a1 + 5) = 6;
        }
        else
        {
          *(_DWORD *)(a1 + 28) = sub_41A010;
          *(_BYTE *)(a1 + 5) = 3;
        }
      }
      else
      {
        *(_DWORD *)(a1 + 28) = sub_42EAA0;
        *(_BYTE *)(a1 + 5) = 1;
      }
      goto LABEL_63;
    case 0xBu:
      *(_BYTE *)(a1 + 5) = 3;
      *(_DWORD *)(a1 + 28) = sub_412AF0;
      *(_DWORD *)(a1 + 12) = 1074864128;
      goto LABEL_63;
    case 0xCu:
      *(_BYTE *)(a1 + 5) = 3;
      *(_DWORD *)(a1 + 28) = sub_4141C0;
      *(_DWORD *)(a1 + 12) = 1073848320;
      goto LABEL_63;
    case 0xFu:
    case 0x10u:
      *(_BYTE *)(a1 + 5) = 1;
      *(_DWORD *)(a1 + 28) = sub_417680;
      *(_DWORD *)(a1 + 12) = -1073643518;
      goto LABEL_63;
    case 0x11u:
      if ( dword_455BF8 != 8 )
        goto LABEL_21;
      *(_BYTE *)(a1 + 5) = 1;
      *(_DWORD *)(a1 + 28) = sub_419200;
      *(_DWORD *)(a1 + 12) = 1073840128;
      goto LABEL_63;
    case 0x12u:
    case 0x13u:
LABEL_21:
      *(_DWORD *)(a1 + 28) = sub_4174D0;
      *(_DWORD *)(a1 + 12) = -1073635328;
      *(_BYTE *)(a1 + 5) = 1;
      goto LABEL_63;
    case 0x14u:
    case 0x15u:
    case 0x16u:
    case 0x17u:
    case 0x18u:
    case 0x19u:
      *(_BYTE *)(a1 + 5) = 1;
      *(_DWORD *)(a1 + 28) = sub_417B00;
      *(_DWORD *)(a1 + 12) = -1073676272;
      if ( dword_455BF8 == 5 )
      {
        if ( v1 != 20 )
          goto LABEL_63;
        goto LABEL_35;
      }
      if ( dword_455BF8 == 9 )
      {
        if ( v1 != 20 )
          goto LABEL_63;
        goto LABEL_35;
      }
      if ( dword_455BF8 != 10 )
      {
        if ( dword_455BF8 != 15 || v1 != 20 )
          goto LABEL_63;
LABEL_35:
        *(_DWORD *)(a1 + 12) = 1074855952;
        goto LABEL_63;
      }
      if ( v1 == 20 || v1 == 21 )
        goto LABEL_35;
LABEL_63:
      v7 = *(_DWORD *)(a1 + 36);
      *(_DWORD *)(a1 + 44) = *(_DWORD *)(a1 + 32);
      *(_DWORD *)(a1 + 52) = *(_DWORD *)(a1 + 40);
      v8 = *(_WORD *)(a1 + 60);
      *(_DWORD *)(a1 + 48) = v7;
      if ( v8 != -1 )
      {
        *(_WORD *)(a1 + 64) = 0;
        v9 = *(_DWORD **)(dword_455C84 + 12 * v8 + 4);
        *(_DWORD *)(a1 + 32) = *v9;
        *(_DWORD *)(a1 + 36) = v9[1];
        *(_DWORD *)(a1 + 40) = v9[2];
        sub_415C80(a1);
        sub_415A20(a1);
      }
      return;
    case 0x20u:
      *(_BYTE *)(a1 + 5) = 1;
      *(_DWORD *)(a1 + 28) = sub_411420;
      *(_DWORD *)(a1 + 12) = 1074798592;
      goto LABEL_63;
    case 0x21u:
    case 0x24u:
      *(_DWORD *)(a1 + 12) = -1073676288;
      *(_BYTE *)(a1 + 5) = 1;
      *(_DWORD *)(a1 + 28) = sub_4124E0;
      goto LABEL_63;
    case 0x22u:
    case 0x28u:
      *(_DWORD *)(a1 + 12) = -1073668096;
      *(_BYTE *)(a1 + 5) = 1;
      *(_DWORD *)(a1 + 28) = sub_4124E0;
      if ( v1 == 40 && !(_BYTE)dword_44B814 )
        *(_DWORD *)(a1 + 12) = -1073676288;
      goto LABEL_63;
    case 0x29u:
    case 0x2Au:
    case 0x2Bu:
    case 0x2Cu:
    case 0x2Du:
    case 0x2Eu:
    case 0x2Fu:
    case 0x30u:
    case 0x31u:
    case 0x4Cu:
    case 0x4Du:
      *(_BYTE *)(a1 + 5) = 1;
      *(_DWORD *)(a1 + 12) = 1073823744;
      *(_DWORD *)(a1 + 28) = sub_42C570;
      goto LABEL_63;
    case 0x32u:
      goto LABEL_37;
    case 0x33u:
    case 0x34u:
    case 0x35u:
    case 0x44u:
      *(_BYTE *)(a1 + 8) = 9;
LABEL_37:
      v2 = *(_BYTE *)(a1 + 8);
      *(_BYTE *)(a1 + 5) = 1;
      *(_DWORD *)(a1 + 28) = sub_42C1E0;
      *(_BYTE *)(a1 + 8) = v2 + 2;
      *(_DWORD *)(a1 + 12) = -1073635328;
      goto LABEL_63;
    case 0x3Au:
      *(_DWORD *)(a1 + 56) = 1167458304;
      if ( !dword_455BF8 )
        *(_DWORD *)(a1 + 56) = 1156415488;
      *(_DWORD *)(a1 + 12) = 1343307784;
      *(_BYTE *)(a1 + 5) = 1;
      *(_DWORD *)(a1 + 28) = sub_417950;
      goto LABEL_63;
    case 0x3Cu:
      *(_BYTE *)(a1 + 5) = 3;
      *(_DWORD *)(a1 + 28) = sub_419760;
      *(_DWORD *)(a1 + 12) = 1073848320;
      goto LABEL_63;
    case 0x3Eu:
    case 0x3Fu:
      *(_BYTE *)(a1 + 5) = 1;
      *(_DWORD *)(a1 + 28) = sub_419A30;
      *(_DWORD *)(a1 + 12) = 1073848320;
      goto LABEL_63;
    case 0x43u:
      *(_DWORD *)(a1 + 12) = 1130496;
      goto LABEL_63;
    case 0x46u:
    case 0x47u:
    case 0x48u:
      *(_BYTE *)(a1 + 5) = 1;
      *(_DWORD *)(a1 + 28) = sub_4181C0;
      *(_DWORD *)(a1 + 12) = -1073643520;
      goto LABEL_63;
    case 0x49u:
      *(_BYTE *)(a1 + 5) = 1;
      *(_DWORD *)(a1 + 28) = sub_418B90;
      *(_DWORD *)(a1 + 12) = -1073676288;
      if ( dword_455BF8 == 10 && ++byte_44B4AC == 4 )
      {
        *(_DWORD *)(a1 + 12) &= 0x7FFFFFFFu;
        dword_455C80 = a1;
      }
      goto LABEL_63;
    case 0x4Au:
      *(_BYTE *)(a1 + 5) = 1;
      *(_DWORD *)(a1 + 28) = sub_418D40;
      *(_DWORD *)(a1 + 12) = 1073782784;
      goto LABEL_63;
    case 0x4Eu:
    case 0x4Fu:
    case 0x50u:
    case 0x51u:
    case 0x52u:
    case 0x53u:
    case 0x54u:
    case 0x55u:
    case 0x56u:
    case 0x57u:
    case 0x58u:
    case 0x59u:
      *(_BYTE *)(a1 + 5) = 1;
      *(_DWORD *)(a1 + 28) = sub_42C510;
      goto LABEL_63;
    default:
      *(_BYTE *)(a1 + 5) = 1;
      *(_DWORD *)(a1 + 12) = -1073676288;
      *(_DWORD *)(a1 + 28) = sub_416610;
      goto LABEL_63;
  }
}
// 416610: using guessed type int sub_416610();
// 41A010: using guessed type int sub_41A010();
// 42EAA0: using guessed type int sub_42EAA0();
// 441008: using guessed type int dword_441008[];
// 44B4AC: using guessed type char byte_44B4AC;
// 44B814: using guessed type int dword_44B814;
// 455BF8: using guessed type int dword_455BF8;
// 455C80: using guessed type int dword_455C80;
// 455C84: using guessed type int dword_455C84;

//----- (00416680) --------------------------------------------------------
int __cdecl sub_416680(int a1)
{
  int result; // eax
  int v2; // ecx

  result = a1;
  v2 = *(_DWORD *)(a1 + 20);
  if ( v2 )
  {
    *(float *)(v2 + 56) = *(float *)(v2 + 56) * -1.0;
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 68) = 0;
    *(float *)(*(_DWORD *)(a1 + 20) + 80) = *(float *)(*(_DWORD *)(a1 + 20) + 80) * -1.0;
    *(float *)(*(_DWORD *)(a1 + 20) + 64) = *(float *)(*(_DWORD *)(a1 + 20) + 64) * -1.0;
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 76) = 0;
    result = *(_DWORD *)(a1 + 20);
    *(float *)(result + 88) = *(float *)(result + 88) * -1.0;
  }
  return result;
}

//----- (004166E0) --------------------------------------------------------
unsigned int *__cdecl sub_4166E0(int a1)
{
  unsigned int *v1; // eax
  unsigned int *result; // eax

  v1 = *(unsigned int **)(a1 + 20);
  *(_BYTE *)(a1 + 5) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  result = sub_408A30(v1);
  *(_DWORD *)(a1 + 20) = 0;
  return result;
}

//----- (00416710) --------------------------------------------------------
int __cdecl sub_416710(int a1)
{
  int result; // eax

  if ( *(float *)(a1 + 56) <= 0.0 )
  {
    result = *(unsigned __int8 *)(a1 + 4) + 8 * dword_455BF8;
    *(float *)(a1 + 56) = -*(float *)&dword_441008[result];
  }
  else
  {
    result = *(unsigned __int8 *)(a1 + 4) + 8 * dword_455BF8;
    *(_DWORD *)(a1 + 56) = dword_441008[result];
  }
  return result;
}
// 441008: using guessed type int dword_441008[];
// 455BF8: using guessed type int dword_455BF8;

//----- (00416760) --------------------------------------------------------
char __cdecl sub_416760(int a1)
{
  int v1; // eax

  v1 = *(_DWORD *)(a1 + 12);
  if ( !(v1 & 0x4000000) )
    return 0;
  *(_DWORD *)(a1 + 12) = v1 & 0xFBFFFFFF;
  sub_416680(a1);
  return 1;
}

//----- (00416790) --------------------------------------------------------
char __cdecl sub_416790(int a1, float a2)
{
  char result; // al

  if ( *(float *)(a1 + 56) <= 0.0 )
  {
    if ( -a2 <= *(float *)(a1 + 56) )
    {
      *(_DWORD *)(a1 + 56) = -1082130432;
      result = 0;
    }
    else
    {
      result = 0;
      *(float *)(a1 + 56) = a2 + *(float *)(a1 + 56);
    }
  }
  else if ( *(float *)(a1 + 56) <= (double)a2 )
  {
    *(_DWORD *)(a1 + 56) = 1065353216;
    result = 0;
  }
  else
  {
    result = 0;
    *(float *)(a1 + 56) = *(float *)(a1 + 56) - a2;
  }
  return result;
}

//----- (004167F0) --------------------------------------------------------
double __cdecl sub_4167F0(int a1)
{
  int v2; // eax

  if ( !dword_44B738 )
    return 0.0;
  v2 = 4 * (*(_WORD *)(dword_44B738 + 24) & 0xFFF);
  return (flt_44B750 - *(float *)(a1 + 40)) * *(float *)((char *)dword_4449D4 + v2)
       - (flt_44B748 - *(float *)(a1 + 32)) * *(float *)((char *)dword_4449D8 + v2);
}
// 44B748: using guessed type float flt_44B748;
// 44B750: using guessed type float flt_44B750;

//----- (00416840) --------------------------------------------------------
char __cdecl sub_416840(int a1)
{
  JUMPOUT(
    (*(float *)(a1 + 40) - dword_44B744) * *((float *)dword_4449D4 + (dword_44B788 & 0xFFF))
  - (*(float *)(a1 + 32) - dword_44B73C) * *((float *)dword_4449D8 + (dword_44B788 & 0xFFF)),
    0.0,
    std::codecvt_base::do_always_noconv);
  return 0;
}
// 44B788: using guessed type int dword_44B788;

//----- (004168A0) --------------------------------------------------------
char __cdecl sub_4168A0(int a1, char a2)
{
  if ( (dword_455BEC & 0x80u) != 0 && dword_44B73C > (double)*(float *)(a1 + 32) )
    return 1;
  if ( dword_455BEC & 0x20 && dword_44B73C < (double)*(float *)(a1 + 32) )
    return 1;
  if ( sub_416840(a1) )
    return 1;
  if ( a2
    && (*(float *)&dword_44B76C < 0.0 && dword_44B73C > (double)*(float *)(a1 + 32)
     || *(float *)&dword_44B76C > 0.0 && dword_44B73C < (double)*(float *)(a1 + 32)) )
  {
    return 1;
  }
  return 0;
}
// 44B76C: using guessed type int dword_44B76C;
// 455BEC: using guessed type int dword_455BEC;

//----- (00416950) --------------------------------------------------------
char __cdecl sub_416950(float *a1)
{
  JUMPOUT((flt_44B750 - a1[10]) * a1[18] + (flt_44B748 - a1[8]) * a1[17], 0.0, std::codecvt_base::do_always_noconv);
  return 0;
}
// 44B748: using guessed type float flt_44B748;
// 44B750: using guessed type float flt_44B750;

//----- (00416990) --------------------------------------------------------
int __cdecl sub_416990(int a1)
{
  char v1; // al

  v1 = *(_BYTE *)(a1 + 5);
  if ( v1 )
    *(_BYTE *)(a1 + 5) = v1 - 1;
  return sub_41EF70(a1 + 32);
}

//----- (004169B0) --------------------------------------------------------
int __cdecl sub_4169B0(_DWORD *a1)
{
  int result; // eax

  *(_DWORD *)(a1[6] + 56) = 1065353216;
  *(_DWORD *)(a1[6] + 68) = 0;
  *(_DWORD *)(a1[6] + 80) = 0;
  *(_DWORD *)(a1[6] + 60) = 0;
  *(_DWORD *)(a1[6] + 72) = 1065353216;
  *(_DWORD *)(a1[6] + 84) = 0;
  *(_DWORD *)(a1[6] + 64) = 0;
  *(_DWORD *)(a1[6] + 76) = 0;
  *(_DWORD *)(a1[6] + 88) = 1065353216;
  *(_DWORD *)(a1[6] + 92) = a1[8];
  *(_DWORD *)(a1[6] + 96) = a1[9];
  result = a1[10];
  *(_DWORD *)(a1[6] + 100) = result;
  return result;
}

//----- (00416A10) --------------------------------------------------------
void sub_416A10()
{
  int i; // esi
  int v1; // ecx
  double v2; // st7
  double v3; // st6
  unsigned __int8 v4; // al
  char (__usercall *v5)@<al>(char *@<ebx>, int); // eax
  int v6; // eax
  bool v7; // al
  char v8; // al
  int v9; // esi
  int v10; // edi
  unsigned __int8 v11; // bl
  int v12; // edx
  double v13; // st7
  char v14; // cl
  double v15; // st6
  int v16; // eax
  _BYTE *v17; // eax
  unsigned __int8 v18; // al
  int v19; // eax
  char v20; // [esp+Fh] [ebp-15h]
  float v21; // [esp+10h] [ebp-14h]
  float v22; // [esp+10h] [ebp-14h]
  float v23; // [esp+14h] [ebp-10h]
  int v24; // [esp+18h] [ebp-Ch]
  float v25; // [esp+1Ch] [ebp-8h]
  float v26; // [esp+20h] [ebp-4h]

  v23 = 256.0;
  if ( dword_455BF8 == 8 && dword_44B7C0 )
    v23 = 128.0;
  v24 = LODWORD(dword_44B73C);
  v26 = dword_44B744;
  v25 = dword_44B740 - flt_44B7A8 * 0.5;
  if ( byte_44B818
    && ((unsigned __int8)byte_44B818 >= 0x11u && (unsigned __int8)byte_44B818 <= 0x13u || byte_44B818 == 32)
    && (dword_455BF8 != 8 || byte_44B818 == 32) )
  {
    byte_44B818 = 0;
  }
  for ( i = dword_455C7C; i; i = *(_DWORD *)i )
  {
    v1 = *(_DWORD *)(i + 12);
    if ( !(v1 & 0x40000000) )
      goto LABEL_86;
    if ( !(v1 & 0x2000) )
    {
      v2 = *(float *)(i + 32) - *(float *)&dword_448A08;
      if ( v2 < 0.0 )
        v2 = -v2;
      v3 = *(float *)(i + 36) - *(float *)&dword_448A0C;
      v21 = v3;
      if ( v3 < 0.0 )
        v21 = -v21;
      if ( v2 > 2048.0 || v21 > 1536.0 )
      {
        v4 = *(_BYTE *)(i + 4);
        if ( v4 < 9u || v4 > 0xAu || !*(_BYTE *)(*(_DWORD *)(i + 100) + 182) || v1 >= 0 )
        {
LABEL_86:
          sub_408A30(*(unsigned int **)(i + 20));
          *(_DWORD *)(i + 20) = 0;
          sub_408A30(*(unsigned int **)(i + 24));
          *(_DWORD *)(i + 24) = 0;
        }
      }
    }
    v5 = *(char (__usercall **)@<al>(char *@<ebx>, int))(i + 28);
    if ( (v5 == sub_4174D0 || (char *)v5 == (char *)sub_411420 || (char *)v5 == (char *)sub_419200)
      && !byte_44B818
      && i != dword_44B7C0 )
    {
      v6 = *(_DWORD *)(i + 12);
      if ( !(v6 & 0x4000) && !sub_431C80(i) )
      {
        v7 = sub_415990((int)&dword_44B71C, (float *)(i + 32));
        byte_44B818 = 0;
        if ( v7 )
        {
          if ( sub_430D30((int)&dword_44B73C, i + 32, v23) != v23 )
            byte_44B818 = *(_BYTE *)(i + 4);
          if ( sub_430D30((int)&v24, i + 32, v23) != v23 )
            byte_44B818 = *(_BYTE *)(i + 4);
        }
        else if ( sub_430D30((int)&dword_44B73C, i + 32, 160.0) != 160.0 )
        {
          byte_44B818 = *(_BYTE *)(i + 4);
        }
        v8 = *(_BYTE *)(i + 4);
        if ( byte_44B818 == v8 && dword_455BF8 == 10 && v8 == 18 && *(_BYTE *)(i + 6) != *(_BYTE *)(i + 7) )
          byte_44B818 = 0;
      }
    }
  }
  v9 = dword_455C74;
  dword_455C7C = 0;
  if ( (unsigned int)dword_455C78 > 0 )
  {
    v10 = dword_455C78;
    while ( 1 )
    {
      v11 = *(_BYTE *)(v9 + 4);
      if ( v11 < 0x5Au )
      {
        if ( *(_DWORD *)(v9 + 20) )
        {
          *(_DWORD *)v9 = dword_455C7C;
          dword_455C7C = v9;
          if ( *(_DWORD *)(v9 + 24) )
            sub_4169B0((_DWORD *)v9);
          goto LABEL_83;
        }
        v12 = *(_DWORD *)(v9 + 12);
        if ( v12 & 0x40000000 )
          break;
      }
LABEL_83:
      v9 += 104;
      if ( !--v10 )
        return;
    }
    if ( v12 & 0x2000 )
    {
      v20 = 1;
      v14 = 1;
    }
    else
    {
      v13 = *(float *)(v9 + 32) - *(float *)&dword_448A08;
      v14 = 0;
      v20 = 0;
      if ( v13 < 0.0 )
        v13 = -v13;
      v15 = *(float *)(v9 + 36) - *(float *)&dword_448A0C;
      v22 = v15;
      if ( v15 < 0.0 )
        v22 = -v22;
      if ( v13 < 4096.0 && v22 < 3328.0 )
      {
        v20 = 1;
        if ( v13 < 2048.0 && v22 < 1536.0 )
          v14 = 1;
      }
    }
    if ( (v11 == 9 || v11 == 10) && *(_BYTE *)(*(_DWORD *)(v9 + 100) + 182) && v12 < 0 )
    {
      v20 = 1;
    }
    else if ( !v14 )
    {
LABEL_76:
      if ( v20 )
      {
        *(_DWORD *)v9 = dword_455C7C;
        dword_455C7C = v9;
        if ( *(_DWORD *)(v9 + 24) )
          sub_4169B0((_DWORD *)v9);
        if ( *(_WORD *)(v9 + 60) != -1 )
          sub_415A20(v9);
      }
      goto LABEL_83;
    }
    if ( v12 & 0x1000 )
      v16 = *(unsigned __int8 *)(v9 + 7);
    else
      v16 = *(unsigned __int8 *)(v9 + 6);
    v17 = sub_4089F0(dword_448AC4 + 48 * v16);
    *(_DWORD *)(v9 + 20) = v17;
    if ( v17 )
    {
      v18 = *(_BYTE *)(v9 + 4);
      *(_DWORD *)(v9 + 16) = 0;
      if ( v18 >= 1u && v18 <= 2u )
        sub_415B50(v9);
      v19 = *(_DWORD *)(v9 + 12);
      if ( v19 & 0x800 )
        *(_DWORD *)(v9 + 24) = sub_4089F0(dword_455C8C);
    }
    goto LABEL_76;
  }
}
// 448A08: using guessed type int dword_448A08;
// 448A0C: using guessed type int dword_448A0C;
// 448AC4: using guessed type int dword_448AC4;
// 44B7A8: using guessed type float flt_44B7A8;
// 44B7C0: using guessed type int dword_44B7C0;
// 44B818: using guessed type char byte_44B818;
// 455BF8: using guessed type int dword_455BF8;
// 455C74: using guessed type int dword_455C74;
// 455C78: using guessed type int dword_455C78;
// 455C7C: using guessed type int dword_455C7C;
// 455C8C: using guessed type int dword_455C8C;

//----- (00416E40) --------------------------------------------------------
char sub_416E40()
{
  int v0; // esi
  int v1; // edi
  char v2; // al
  void (__cdecl *v3)(int); // eax
  int v4; // eax
  int v5; // eax
  int v6; // ecx
  int i; // esi
  unsigned __int8 v8; // al
  void (__cdecl *v9)(int); // eax
  int v10; // eax
  char result; // al

  v0 = dword_455C74;
  v1 = 0;
  if ( dword_455C78 )
  {
    do
    {
      v2 = *(_BYTE *)(v0 + 4);
      if ( v2 == 9 || v2 == 10 )
      {
        v3 = *(void (__cdecl **)(int))(v0 + 28);
        if ( v3 )
          v3(v0);
        v4 = *(_DWORD *)(v0 + 12);
        if ( !(v4 & 0x4000) )
        {
          if ( *(_DWORD *)(v0 + 20) )
            sub_408A50(*(_DWORD *)(v0 + 20));
          if ( !(*(_DWORD *)(v0 + 12) & 0x800000) )
          {
            v5 = *(_DWORD *)(v0 + 100);
            v6 = *(_DWORD *)(v5 + 8);
            if ( v6 )
            {
              if ( *(_DWORD *)(v5 + 28) != -1 && !(**(_BYTE **)(v5 + 24) & 0x24) )
                sub_408A50(v6);
            }
          }
        }
      }
      v0 += 104;
      ++v1;
    }
    while ( (unsigned __int16)v1 < (unsigned int)dword_455C78 );
  }
  for ( i = dword_455C7C; i; i = *(_DWORD *)i )
  {
    v8 = *(_BYTE *)(i + 4);
    if ( v8 < 0x5Au && v8 != 9 && v8 != 10 )
    {
      if ( !byte_44B793 || (_BYTE)dword_44B814 == 2 )
      {
        v9 = *(void (__cdecl **)(int))(i + 28);
        if ( v9 )
          v9(i);
      }
      v10 = *(_DWORD *)(i + 12);
      if ( !(v10 & 0x4000) )
      {
        if ( *(_DWORD *)(i + 20) )
          sub_408A50(*(_DWORD *)(i + 20));
        if ( *(_DWORD *)(i + 24) )
          sub_408A50(*(_DWORD *)(i + 24));
      }
    }
  }
  result = dword_44B814;
  if ( (_BYTE)dword_44B814 )
  {
    result = HIBYTE(dword_44B804);
    if ( HIBYTE(dword_44B804) )
    {
      if ( LODWORD(dword_44B708) && byte_44B791 && !byte_44B812 && (_WORD)dword_44B784 == -1 )
        sub_408A50(SLODWORD(dword_44B708));
      result = HIBYTE(dword_44B804);
      if ( HIBYTE(dword_44B804) )
      {
        result = LOBYTE(dword_44B704);
        if ( LODWORD(dword_44B704) )
        {
          if ( byte_44B78F && !byte_44B78E && !(_BYTE)dword_44B7BC )
            result = sub_408A50(SLODWORD(dword_44B704));
        }
      }
    }
  }
  return result;
}
// 44B784: using guessed type int dword_44B784;
// 44B78E: using guessed type char byte_44B78E;
// 44B78F: using guessed type char byte_44B78F;
// 44B791: using guessed type char byte_44B791;
// 44B793: using guessed type char byte_44B793;
// 44B7BC: using guessed type int dword_44B7BC;
// 44B804: using guessed type int dword_44B804;
// 44B812: using guessed type char byte_44B812;
// 44B814: using guessed type int dword_44B814;
// 455C74: using guessed type int dword_455C74;
// 455C78: using guessed type int dword_455C78;
// 455C7C: using guessed type int dword_455C7C;

//----- (00416FB0) --------------------------------------------------------
int sub_416FB0()
{
  int result; // eax

  sub_401380(dword_455C74);
  result = 0;
  dword_455C78 = 0;
  dword_455C74 = 0;
  dword_455C7C = 0;
  return result;
}
// 455C74: using guessed type int dword_455C74;
// 455C78: using guessed type int dword_455C78;
// 455C7C: using guessed type int dword_455C7C;

//----- (00416FD0) --------------------------------------------------------
char __cdecl sub_416FD0(int a1)
{
  void *v1; // edi

  dword_455C7C = 0;
  dword_455C78 = 0;
  if ( a1 )
  {
    v1 = (void *)sub_401250(104 * a1);
    dword_455C74 = (int)v1;
    if ( !v1 )
      return 0;
    dword_455C78 = a1;
    memset(v1, 0, 104 * a1);
  }
  return 1;
}
// 455C74: using guessed type int dword_455C74;
// 455C78: using guessed type int dword_455C78;
// 455C7C: using guessed type int dword_455C7C;

//----- (00417040) --------------------------------------------------------
char __cdecl sub_417040(int a1)
{
  void *v1; // edi

  dword_455C88 = 0;
  if ( a1 )
  {
    v1 = (void *)sub_401250(12 * a1);
    dword_455C84 = (int)v1;
    if ( !v1 )
      return 0;
    dword_455C88 = a1;
    memset(v1, 0, 12 * a1);
  }
  return 1;
}
// 455C84: using guessed type int dword_455C84;
// 455C88: using guessed type int dword_455C88;

//----- (004170A0) --------------------------------------------------------
char sub_4170A0()
{
  unsigned int v0; // edi
  unsigned int *v1; // esi
  char result; // al

  v0 = 0;
  if ( dword_455C88 )
  {
    v1 = (unsigned int *)(dword_455C84 + 4);
    do
    {
      sub_401380(*v1);
      v1 += 3;
      ++v0;
    }
    while ( v0 < dword_455C88 );
  }
  result = sub_401380(dword_455C84);
  dword_455C84 = 0;
  dword_455C88 = 0;
  return result;
}
// 455C84: using guessed type int dword_455C84;
// 455C88: using guessed type int dword_455C88;

//----- (00417100) --------------------------------------------------------
char __cdecl sub_417100(int a1, int a2)
{
  int v2; // eax

  *(_WORD *)(a1 + 2) = 0;
  if ( a2 )
  {
    v2 = sub_401250(12 * a2);
    *(_DWORD *)(a1 + 4) = v2;
    if ( !v2 )
      return 0;
    *(_WORD *)(a1 + 2) = a2;
  }
  return 1;
}

//----- (00417140) --------------------------------------------------------
char __cdecl sub_417140(int a1)
{
  void *v1; // edi

  dword_455C94 = 0;
  if ( a1 )
  {
    v1 = (void *)sub_401250(16 * a1);
    dword_455C90 = (int)v1;
    if ( !v1 )
      return 0;
    dword_455C94 = a1;
    memset(v1, 0, 16 * a1);
  }
  return 1;
}
// 455C90: using guessed type int dword_455C90;
// 455C94: using guessed type int dword_455C94;

//----- (004171A0) --------------------------------------------------------
int sub_4171A0()
{
  int result; // eax

  sub_401380(dword_455C90);
  result = 0;
  dword_455C90 = 0;
  dword_455C94 = 0;
  return result;
}
// 455C90: using guessed type int dword_455C90;
// 455C94: using guessed type int dword_455C94;

//----- (004171C0) --------------------------------------------------------
__int16 sub_4171C0()
{
  int v0; // esi
  int v1; // eax
  int v2; // esi
  int v3; // edi
  int v4; // edx

  BYTE2(dword_455C98) = 0;
  v0 = dword_448ACC + 12;
  byte_455C15 = 0;
  sub_409F10(dword_448ACC + 12, 0x82u);
  v1 = *(unsigned __int16 *)(v0 + 10);
  if ( (_WORD)v1 )
  {
    v2 = *(_DWORD *)(v0 + 4) + 14;
    v3 = v1;
    do
    {
      *(_WORD *)(v2 - 2) = 38;
      *(_WORD *)v2 = 38;
      v1 = sub_401000(0, 1, 896, 256);
      *(_DWORD *)(v2 - 6) = v1;
      v4 = *(_DWORD *)(v2 - 10);
      BYTE1(v4) |= 1u;
      *(_DWORD *)(v2 - 10) = v4;
      *(_BYTE *)(v2 + 20) = -96;
      *(_BYTE *)(v2 + 19) = -56;
      *(_BYTE *)(v2 + 18) = -56;
      v2 += 128;
      --v3;
    }
    while ( v3 );
  }
  return v1;
}
// 448ACC: using guessed type int dword_448ACC;
// 455C15: using guessed type char byte_455C15;
// 455C98: using guessed type int dword_455C98;

//----- (00417240) --------------------------------------------------------
char sub_417240()
{
  int v0; // eax
  int v1; // edi
  int v2; // esi
  int v3; // ebp
  double v4; // st7
  double v5; // st7
  double v6; // st7
  double v7; // st7
  double v8; // st7
  char v9; // al
  float v11; // [esp+4h] [ebp-14h]
  float i; // [esp+8h] [ebp-10h]
  float v13; // [esp+Ch] [ebp-Ch]
  float v14; // [esp+10h] [ebp-8h]
  float v15; // [esp+14h] [ebp-4h]

  LOBYTE(v0) = LOBYTE(dword_44B760);
  v1 = dword_455C28;
  v11 = dword_44B760;
  for ( i = dword_44B760 * 0.5; v1; v1 = *(_DWORD *)v1 )
  {
    v0 = *(unsigned __int16 *)(v1 + 58);
    v13 = dword_44B73C - *(float *)(v1 + 60);
    v2 = dword_455C90 + 16 * *(unsigned __int16 *)(v1 + 56);
    v14 = dword_44B740 - *(float *)(v1 + 64);
    v15 = dword_44B744 - *(float *)(v1 + 68);
    if ( (_WORD)v0 )
    {
      v3 = *(unsigned __int16 *)(v1 + 58);
      do
      {
        LOBYTE(v0) = *(_BYTE *)(v2 + 1);
        if ( !(_BYTE)v0 )
        {
          v4 = v13 - *(float *)(v2 + 4);
          if ( v4 < 0.0 )
            v4 = -v4;
          if ( v4 < 110.0 )
          {
            v5 = v15 - *(float *)(v2 + 12);
            if ( v5 < 0.0 )
              v5 = -v5;
            if ( v5 < 110.0 )
            {
              v6 = v14 - *(float *)(v2 + 8);
              if ( v6 < 0.0 )
                v6 = -v6;
              if ( v6 < 110.0 )
                goto LABEL_28;
              v7 = v14 - i - *(float *)(v2 + 8);
              if ( v7 < 0.0 )
                v7 = -v7;
              if ( v7 < 110.0 )
                goto LABEL_28;
              v8 = v14 - v11 - *(float *)(v2 + 8);
              if ( v8 < 0.0 )
                v8 = -v8;
              if ( v8 < 110.0 )
LABEL_28:
                *(_BYTE *)(v2 + 1) = 1;
            }
          }
          LOBYTE(v0) = *(_BYTE *)(v2 + 1);
          if ( (_BYTE)v0 )
          {
            sub_4173E0(1);
            v9 = rand();
            LOBYTE(v0) = sub_407E00(12 * (unsigned __int8)(-3 * v9) + 4475000);
          }
        }
        v2 += 16;
        --v3;
      }
      while ( v3 );
    }
  }
  return v0;
}
// 455C90: using guessed type int dword_455C90;

//----- (004173E0) --------------------------------------------------------
__int16 __cdecl sub_4173E0(__int16 a1)
{
  __int16 result; // ax

  result = a1;
  LOWORD(dword_455C98) = 10;
  word_44B7FE += a1;
  return result;
}
// 44B7FE: using guessed type __int16 word_44B7FE;
// 455C98: using guessed type int dword_455C98;

//----- (00417400) --------------------------------------------------------
int __cdecl sub_417400(__int16 a1, int *a2, int a3)
{
  int v3; // ecx
  int result; // eax
  int v5; // edx
  int *v6; // esi

  v3 = dword_455C74;
  result = 0;
  v5 = 0;
  if ( dword_455C78 )
  {
    v6 = a2;
    do
    {
      if ( a1 == *(unsigned __int8 *)(v3 + 4) )
      {
        *v6 = v3;
        ++result;
        ++v6;
        if ( result == a3 )
          break;
      }
      v3 += 104;
      ++v5;
    }
    while ( (unsigned __int16)v5 < (unsigned int)dword_455C78 );
  }
  return result;
}
// 455C74: using guessed type int dword_455C74;
// 455C78: using guessed type int dword_455C78;

//----- (00417460) --------------------------------------------------------
int *__cdecl sub_417460(int a1)
{
  int v1; // ecx
  int v2; // eax
  int v3; // ecx
  int *v4; // ecx
  int v5; // esi
  int v6; // eax
  int v7; // ecx
  int *result; // eax
  int v9; // edx

  v1 = *(_DWORD *)(a1 + 20);
  LOWORD(v2) = *(_WORD *)(v1 + 160);
  v3 = *(_DWORD *)(v1 + 164);
  if ( (_WORD)v2 )
  {
    v4 = (int *)(v3 + 4);
    v2 = (unsigned __int16)v2;
    do
    {
      v5 = *v4;
      v4 += 26;
      --v2;
      *(v4 - 26) = v5 | 0x100;
    }
    while ( v2 );
  }
  v6 = *(_DWORD *)(a1 + 20);
  LOWORD(v7) = *(_WORD *)(v6 + 162);
  result = *(int **)(v6 + 168);
  if ( (_WORD)v7 )
  {
    ++result;
    v7 = (unsigned __int16)v7;
    do
    {
      v9 = *result;
      result += 33;
      BYTE1(v9) |= 1u;
      --v7;
      *(result - 33) = v9;
    }
    while ( v7 );
  }
  return result;
}

//----- (004174D0) --------------------------------------------------------
char __usercall sub_4174D0@<al>(char *a1@<ebx>, int a2)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  __int16 v6; // ax
  int v7; // edx
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // edx
  double v12; // st7
  int v13; // eax

  if ( !a2 )
    return 1;
  v3 = *(_DWORD *)(a2 + 20);
  if ( v3 )
  {
    *(_DWORD *)(v3 + 92) = *(_DWORD *)(a2 + 32);
    *(_DWORD *)(*(_DWORD *)(a2 + 20) + 96) = *(_DWORD *)(a2 + 36);
    *(_DWORD *)(*(_DWORD *)(a2 + 20) + 100) = *(_DWORD *)(a2 + 40);
    if ( byte_455C14 )
      sub_4083F0(*(int **)(a2 + 20));
  }
  if ( *(_DWORD *)(a2 + 20) )
  {
    v4 = *(_DWORD *)(a2 + 12);
    if ( (v4 & 0x8000) != 0 )
    {
      if ( dword_455BF8 != 10 || *(_BYTE *)(a2 + 4) != 18 )
      {
        sub_4159D0(a2);
        if ( dword_455BF8 == 16 && *(_BYTE *)(a2 + 4) == 19 )
        {
          v5 = *(_DWORD *)(a2 + 12);
          BYTE1(v5) |= 0x40u;
          *(_DWORD *)(a2 + 12) = v5;
        }
      }
      v6 = sub_431960((float *)(a2 + 32), 0, a1);
      v7 = *(_DWORD *)(a2 + 12);
      *(_WORD *)(a2 + 60) = v6;
      BYTE1(v7) &= 0x7Fu;
      *(_DWORD *)(a2 + 12) = v7;
      v8 = v7;
      if ( dword_455BF8 == 3 )
      {
        if ( *(_BYTE *)(a2 + 4) != 19 )
          goto LABEL_19;
        BYTE1(v8) |= 0x40u;
        *(_DWORD *)(a2 + 12) = v8;
      }
    }
  }
  if ( dword_455BF8 != 5 || *(_BYTE *)(a2 + 4) != 17 )
  {
LABEL_19:
    if ( *(_BYTE *)(a2 + 4) == 19 && !*(_DWORD *)(a2 + 16) )
    {
      *(_DWORD *)(a2 + 16) = dword_455BE0;
      if ( *((_BYTE *)&dword_44B81A + dword_455BF8) & 1 )
        sub_417460(a2);
    }
    goto LABEL_23;
  }
  sub_408670(*(float *)(a2 + 20), 0, 0);
LABEL_23:
  v9 = *(_DWORD *)(a2 + 12);
  if ( v9 & 0x400 )
  {
    BYTE1(v9) &= 0xBBu;
    *(_DWORD *)(a2 + 12) = v9;
    if ( dword_455BF8 == 3 && *(_BYTE *)(a2 + 4) == 19 && *(_DWORD *)(*(_DWORD *)(dword_44EAA4 + 1104) + 12) & 0x800000 )
    {
      BYTE1(v9) |= 0x40u;
      *(_DWORD *)(a2 + 12) = v9;
    }
    v10 = *(_DWORD *)(a2 + 20);
    if ( v10 )
      *(_DWORD *)(v10 + 4) = 0;
    v11 = *(_DWORD *)(a2 + 48);
    v12 = *(float *)(a2 + 44);
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
    v13 = *(_DWORD *)(a2 + 20);
    *(float *)(a2 + 32) = v12;
    *(_DWORD *)(a2 + 36) = v11;
    if ( v13 )
    {
      *(float *)(v13 + 92) = v12;
      *(_DWORD *)(*(_DWORD *)(a2 + 20) + 96) = *(_DWORD *)(a2 + 36);
      *(_DWORD *)(*(_DWORD *)(a2 + 20) + 100) = *(_DWORD *)(a2 + 40);
    }
    if ( dword_455BF8 != 10 || *(_BYTE *)(a2 + 4) != 18 || *(_BYTE *)(a2 + 6) == *(_BYTE *)(a2 + 7) )
      sub_4159D0(a2);
  }
  return 0;
}
// 4174D0: could not find valid save-restore pair for ebx
// 44B81A: using guessed type int dword_44B81A;
// 44EAA4: using guessed type int dword_44EAA4;
// 455BE0: using guessed type int dword_455BE0;
// 455BF8: using guessed type int dword_455BF8;
// 455C14: using guessed type char byte_455C14;

//----- (00417680) --------------------------------------------------------
char __cdecl sub_417680(int a1)
{
  int v2; // eax
  int v3; // eax
  int v4; // edx
  int v5; // eax
  int v6; // edx
  signed int *v7; // ecx
  float *v8; // edx
  double v9; // st7
  double v10; // st6
  signed int v11; // eax
  char v12; // bl
  float *v13; // edx
  double v14; // st7
  double v15; // st6
  signed int v16; // eax
  unsigned int v17; // ecx
  int v18; // [esp+Ch] [ebp-Ch]
  int v19; // [esp+10h] [ebp-8h]
  float v20; // [esp+14h] [ebp-4h]

  if ( !a1 )
    return 1;
  v2 = *(_DWORD *)(a1 + 20);
  if ( v2 )
  {
    *(_DWORD *)(v2 + 92) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 96) = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 100) = *(_DWORD *)(a1 + 40);
    if ( byte_455C14 )
      sub_4083F0(*(int **)(a1 + 20));
  }
  v3 = *(_DWORD *)(a1 + 12);
  if ( (v3 & 0x8000) == 0 )
  {
    if ( v3 & 0x10000 )
    {
      sub_408670(*(float *)(a1 + 20), 0, 0);
      if ( *(_DWORD *)(a1 + 16) )
      {
        v7 = (signed int *)dword_443D44;
      }
      else
      {
        v6 = *(_DWORD *)(a1 + 20);
        *(_DWORD *)(a1 + 16) = dword_455BE0;
        v7 = (signed int *)dword_443D44;
        v8 = *(float **)(v6 + 180);
        v9 = v8[36];
        v10 = v8[37];
        if ( v10 > 0.0 )
        {
          flt_44B4B0 = v8[35] * (double)*((signed int *)dword_443D44 + 3) / v10
                     + (double)(*((_DWORD *)dword_443D44 + 2) / 2);
          v11 = *((_DWORD *)dword_443D44 + 3);
          dword_44B4B8 = 0;
          flt_44B4B4 = (double)v11 * v9 / v10 + (double)(v11 / 2);
        }
        flt_44B4D0 = *(float *)&dword_44B4C0 - flt_44B4B0;
      }
      v12 = byte_44B4CC;
      if ( byte_44B4CC )
      {
        if ( byte_44B4CC != 10 )
        {
          v13 = *(float **)(*(_DWORD *)(a1 + 20) + 180);
          v14 = v13[36];
          v15 = v13[37];
          if ( v15 > 0.0 )
          {
            flt_44B4B0 = v13[35] * (double)v7[3] / v15 + (double)(v7[2] / 2);
            v16 = v7[3];
            dword_44B4B8 = 0;
            flt_44B4B4 = (double)v16 * v14 / v15 + (double)(v16 / 2);
          }
          sub_40C270(flt_44B4D0, flt_44B4B0, flt_44B4B4, dword_44B4B8, byte_44B4CC);
          v12 = byte_44B4CC;
        }
        byte_44B4CC = v12 - 1;
      }
      if ( !byte_44B812 )
      {
        v17 = *(_DWORD *)(a1 + 12) & 0xFFFEFFFF;
        BYTE1(v17) |= 0x80u;
        *(_DWORD *)(a1 + 12) = v17;
        word_44B7F2 = 0;
      }
    }
  }
  else
  {
    if ( v3 & 2 )
    {
      BYTE1(v3) |= 0x40u;
      *(_DWORD *)(a1 + 12) = v3;
    }
    else
    {
      sub_408670(*(float *)(a1 + 20), 0, 0);
    }
    if ( byte_44B812 && sub_41F420(&dword_44B73C, (float *)(a1 + 32)) < 2048.0 )
    {
      v4 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 16) = 0;
      BYTE1(v4) &= 0x3Fu;
      *(_DWORD *)(a1 + 12) = v4 | 0x10000;
      dword_44B4C0 = LODWORD(dword_44B7E4);
      dword_44B4C4 = LODWORD(flt_44B7E8);
      dword_44B4C8 = 0;
      byte_44B4CC = 10;
      v5 = *(_DWORD *)(a1 + 36);
      v18 = *(_DWORD *)(a1 + 32);
      v19 = v5;
      v20 = dword_44B744;
      sub_41E7B0((float *)&v18, 0, 0);
      return 0;
    }
  }
  return 0;
}
// 44B4B0: using guessed type float flt_44B4B0;
// 44B4B4: using guessed type float flt_44B4B4;
// 44B4B8: using guessed type int dword_44B4B8;
// 44B4C0: using guessed type int dword_44B4C0;
// 44B4C4: using guessed type int dword_44B4C4;
// 44B4C8: using guessed type int dword_44B4C8;
// 44B4CC: using guessed type char byte_44B4CC;
// 44B7E8: using guessed type float flt_44B7E8;
// 44B7F2: using guessed type __int16 word_44B7F2;
// 44B812: using guessed type char byte_44B812;
// 455BE0: using guessed type int dword_455BE0;
// 455C14: using guessed type char byte_455C14;

//----- (00417950) --------------------------------------------------------
char __cdecl sub_417950(float a1)
{
  int v2; // eax
  float v3; // eax
  int v4; // eax
  unsigned __int8 v5; // cl
  int v6; // eax
  int v7; // eax
  _DWORD *v8; // eax
  int v9; // ecx

  if ( a1 == 0.0 )
    return 1;
  if ( byte_455CA5 )
    return 1;
  v2 = *(_DWORD *)(LODWORD(a1) + 20);
  if ( v2 )
  {
    *(_DWORD *)(v2 + 92) = *(_DWORD *)(LODWORD(a1) + 32);
    *(_DWORD *)(*(_DWORD *)(LODWORD(a1) + 20) + 96) = *(_DWORD *)(LODWORD(a1) + 36);
    *(_DWORD *)(*(_DWORD *)(LODWORD(a1) + 20) + 100) = *(_DWORD *)(LODWORD(a1) + 40);
    if ( byte_455C14 )
      sub_4083F0(*(int **)(LODWORD(a1) + 20));
  }
  v3 = *(float *)(LODWORD(a1) + 20);
  if ( v3 != 0.0 )
    sub_408670(v3, 0, 0);
  v4 = *(_DWORD *)(LODWORD(a1) + 12);
  if ( v4 & 0x100000 )
  {
    v5 = *(_BYTE *)(LODWORD(a1) + 5);
    if ( v5 < 0x1Eu )
      *(_BYTE *)(LODWORD(a1) + 5) = v5 + 1;
    if ( !*(_DWORD *)(LODWORD(a1) + 16) )
    {
      LOBYTE(v4) = v4 & 0xDF;
      BYTE1(v4) |= 0x40u;
      *(_DWORD *)(LODWORD(a1) + 16) = dword_455BE0;
      *(_DWORD *)(LODWORD(a1) + 12) = v4;
      sub_415A20(SLODWORD(a1));
    }
    v6 = *(_DWORD *)(LODWORD(a1) + 12);
    if ( v6 < 0 && *(_BYTE *)(LODWORD(a1) + 5) > 0x1Du )
    {
      *(_BYTE *)(LODWORD(a1) + 5) = 1;
      *(_DWORD *)(LODWORD(a1) + 16) = 0;
      *(_DWORD *)(LODWORD(a1) + 12) = v6 & 0xFC043FFF | 0x40000;
      return 0;
    }
  }
  else if ( v4 & 0x40000 )
  {
    if ( *(_WORD *)(LODWORD(a1) + 60) != -1 )
      sub_415E20(a1, *(float *)(LODWORD(a1) + 56));
    if ( BYTE1(dword_44B80C) || (_BYTE)dword_455CB0 )
    {
      v7 = *(_DWORD *)(LODWORD(a1) + 12);
      *(_DWORD *)(LODWORD(a1) + 16) = 0;
      *(_DWORD *)(LODWORD(a1) + 12) = v7 & 0xFC087FFF | 0x80000;
      return 0;
    }
  }
  else
  {
    if ( v4 & 0x80000 )
    {
      *(_DWORD *)(LODWORD(a1) + 16) = 0;
      *(_WORD *)(LODWORD(a1) + 64) = 0;
      *(_DWORD *)(LODWORD(a1) + 12) = v4 & 0x7C003FFF | 0x100000;
      v8 = *(_DWORD **)(dword_455C84 + 12 * *(unsigned __int16 *)(LODWORD(a1) + 60) + 4);
      *(_DWORD *)(LODWORD(a1) + 32) = *v8;
      *(_DWORD *)(LODWORD(a1) + 36) = v8[1];
      *(_DWORD *)(LODWORD(a1) + 40) = v8[2];
      sub_415C80(SLODWORD(a1));
      sub_415A20(SLODWORD(a1));
      return 0;
    }
    if ( v4 & 0x20000 )
    {
      sub_41ED70(2u);
      sub_42CBE0((int)&dword_44B71C, 25);
      sub_434530();
      v9 = *(_DWORD *)(LODWORD(a1) + 12);
      *(_DWORD *)(LODWORD(a1) + 16) = 0;
      *(_DWORD *)(LODWORD(a1) + 12) = v9 & 0xFC087FFF | 0x80020;
    }
  }
  return 0;
}
// 44B80C: using guessed type int dword_44B80C;
// 455BE0: using guessed type int dword_455BE0;
// 455C14: using guessed type char byte_455C14;
// 455C84: using guessed type int dword_455C84;
// 455CA5: using guessed type char byte_455CA5;
// 455CB0: using guessed type int dword_455CB0;

//----- (00417B00) --------------------------------------------------------
char __cdecl sub_417B00(float a1)
{
  char result; // al
  int v2; // eax
  int v3; // eax
  int v4; // eax
  float v5; // eax
  unsigned __int16 *v6; // ecx
  char v7; // cl
  int v8; // eax
  int v9; // ecx
  unsigned __int16 *v10; // edx
  unsigned int *v11; // edx
  float v12; // ST04_4
  int v13; // eax
  int v14; // ecx
  unsigned __int16 *v15; // ecx
  int v16; // ecx
  int v17; // eax
  char v18; // dl
  int *v19; // eax
  double v20; // st7
  double v21; // st7
  float v22; // [esp+8h] [ebp-Ch]
  int v23; // [esp+Ch] [ebp-8h]
  int v24; // [esp+10h] [ebp-4h]

  if ( a1 == 0.0 )
    return 1;
  if ( byte_455CA5 )
    return 1;
  v2 = *(_DWORD *)(LODWORD(a1) + 20);
  if ( v2 )
  {
    *(_DWORD *)(v2 + 92) = *(_DWORD *)(LODWORD(a1) + 32);
    *(_DWORD *)(*(_DWORD *)(LODWORD(a1) + 20) + 96) = *(_DWORD *)(LODWORD(a1) + 36);
    *(_DWORD *)(*(_DWORD *)(LODWORD(a1) + 20) + 100) = *(_DWORD *)(LODWORD(a1) + 40);
    if ( byte_455C14 )
      sub_4083F0(*(int **)(LODWORD(a1) + 20));
  }
  v3 = *(_DWORD *)(LODWORD(a1) + 12);
  if ( v3 & 0x400 )
  {
    BYTE1(v3) &= 0xFBu;
    *(_DWORD *)(LODWORD(a1) + 12) = v3;
    if ( dword_455BF8 == 9 && *(_BYTE *)(LODWORD(a1) + 4) == 20 )
    {
      sub_408670(*(float *)(LODWORD(a1) + 20), 1, 0);
      sub_408670(*(float *)(LODWORD(a1) + 20), 0, 0);
    }
  }
  v4 = *(_DWORD *)(LODWORD(a1) + 12);
  if ( v4 & 0x100000 )
  {
    v5 = *(float *)(LODWORD(a1) + 20);
    if ( v5 != 0.0
      && (v6 = *(unsigned __int16 **)(LODWORD(v5) + 184)) != 0
      && *(unsigned __int16 *)(LODWORD(v5) + 174) == *v6 - 1
      && dword_455BF8 == 5 )
    {
      if ( *(_BYTE *)(LODWORD(a1) + 4) == 20 && !sub_407E30((AGLSOUNDBUFFER **)&dword_444920) )
        sub_407E00((int)&dword_444920);
      sub_408670(*(float *)(LODWORD(a1) + 20), 0, 0);
    }
    else
    {
      sub_408670(v5, 0, 0);
    }
    if ( !*(_DWORD *)(LODWORD(a1) + 16) )
    {
      if ( *(_BYTE *)(LODWORD(a1) + 4) == 20 && dword_455BF8 == 5 )
      {
        if ( !sub_407E30((AGLSOUNDBUFFER **)&dword_444920) )
          sub_407E00((int)&dword_444920);
        sub_408670(*(float *)(LODWORD(a1) + 20), 0, 0);
      }
      *(_DWORD *)(LODWORD(a1) + 16) = dword_455BE0;
      return 0;
    }
    v4 = *(_DWORD *)(LODWORD(a1) + 12);
    if ( v4 < 0 )
    {
      v7 = *(_BYTE *)(LODWORD(a1) + 4);
      if ( v7 == 20 && dword_455BF8 == 10 || v7 == 21 && dword_455BF8 == 10 )
      {
        *(_DWORD *)(LODWORD(a1) + 16) = 0;
        *(_DWORD *)(LODWORD(a1) + 12) = v4 & 0xFC027FFF | 0x20000;
        return 0;
      }
      goto LABEL_92;
    }
    return 0;
  }
  if ( v4 & 0x10000 )
  {
    if ( !*(_DWORD *)(LODWORD(a1) + 16) )
    {
      *(_DWORD *)(LODWORD(a1) + 16) = dword_455BE0;
      if ( (v4 & 0x80u) != 0 )
      {
        *(_DWORD *)(LODWORD(a1) + 16) = 0;
        *(_DWORD *)(LODWORD(a1) + 12) = v4 & 0xFC207FFF | 0x200000;
      }
      sub_408670(*(float *)(LODWORD(a1) + 20), 1, 0);
      if ( dword_455BF8 == 3 && *(_BYTE *)(LODWORD(a1) + 4) == 21 && !sub_407E30((AGLSOUNDBUFFER **)&dword_444908) )
        sub_407E00((int)&dword_444908);
    }
    if ( *(_WORD *)(LODWORD(a1) + 60) != -1 )
    {
      sub_415E20(a1, 1200.0);
      return 0;
    }
    v8 = *(_DWORD *)(LODWORD(a1) + 12);
    if ( v8 & 0x10 )
    {
      v9 = *(_DWORD *)(LODWORD(a1) + 20);
      if ( v9 )
      {
        v10 = *(unsigned __int16 **)(v9 + 184);
        if ( v10 )
        {
          if ( *(unsigned __int16 *)(v9 + 174) == *v10 - 1 )
          {
            *(_DWORD *)(LODWORD(a1) + 16) = 0;
            *(_DWORD *)(LODWORD(a1) + 12) = v8 & 0xFC017FFF | 0x10000;
            if ( dword_455BF8 == 3 && *(_BYTE *)(LODWORD(a1) + 4) == 21 && !sub_407E30((AGLSOUNDBUFFER **)&dword_444908) )
            {
              sub_407E00((int)&dword_444908);
              return 0;
            }
          }
        }
      }
    }
    return 0;
  }
  if ( v4 & 0x1000000 )
  {
    if ( v4 & 0x20 )
    {
      v11 = *(unsigned int **)(LODWORD(a1) + 20);
      *(_BYTE *)(LODWORD(a1) + 5) = 0;
      *(_DWORD *)(LODWORD(a1) + 12) = 0;
      sub_408A30(v11);
      *(_DWORD *)(LODWORD(a1) + 20) = 0;
      return 0;
    }
    goto LABEL_89;
  }
  if ( v4 & 0x40000 )
  {
    if ( !*(_DWORD *)(LODWORD(a1) + 16) )
    {
      v12 = *(float *)(LODWORD(a1) + 20);
      *(_DWORD *)(LODWORD(a1) + 16) = dword_455BE0;
      sub_408670(v12, 2, 0);
    }
    sub_415E20(a1, 10.0);
    result = 0;
  }
  else
  {
    if ( !(v4 & 0x20000) )
    {
      if ( v4 & 0x80000 )
      {
        *(_DWORD *)(LODWORD(a1) + 16) = 0;
        *(_DWORD *)(LODWORD(a1) + 12) = v4 & 0x7C007FFF | 0x100000;
        return 0;
      }
      if ( !(v4 & 0x200000) )
      {
        if ( v4 & 0x2000000 )
        {
LABEL_92:
          *(_DWORD *)(LODWORD(a1) + 16) = 0;
          *(_DWORD *)(LODWORD(a1) + 12) = v4 & 0xFC017FFF | 0x10000;
        }
        return 0;
      }
      sub_408670(*(float *)(LODWORD(a1) + 20), 1, 0);
      v4 = *(_DWORD *)(LODWORD(a1) + 12);
      if ( v4 < 0 )
        return 0;
      if ( *(_WORD *)(LODWORD(a1) + 60) == -1 )
      {
        *(_DWORD *)(LODWORD(a1) + 16) = 0;
        *(_DWORD *)(LODWORD(a1) + 12) = v4 & 0xFC087FFF | 0x80000;
        return 0;
      }
LABEL_89:
      *(_DWORD *)(LODWORD(a1) + 16) = 0;
      *(_DWORD *)(LODWORD(a1) + 12) = v4 & 0xFC047FFF | 0x40000;
      return 0;
    }
    if ( !*(_DWORD *)(LODWORD(a1) + 16) )
      sub_408670(*(float *)(LODWORD(a1) + 20), 1, 0);
    v13 = *(_DWORD *)(LODWORD(a1) + 20);
    if ( v13 )
    {
      v15 = *(unsigned __int16 **)(v13 + 184);
      if ( v15 && *(unsigned __int16 *)(v13 + 174) == *v15 - 1 )
      {
        v16 = *(_DWORD *)(LODWORD(a1) + 12);
        *(_DWORD *)(LODWORD(a1) + 16) = 0;
        *(_DWORD *)(LODWORD(a1) + 12) = v16 & 0xFC087FFF | 0x80000;
      }
      if ( v13 )
      {
        if ( (v17 = *(_DWORD *)(LODWORD(a1) + 16), v17 == 34) && *(_BYTE *)(LODWORD(a1) + 4) == 20
          || v17 == 21 && *(_BYTE *)(LODWORD(a1) + 4) == 21 )
        {
          if ( !sub_407E30((AGLSOUNDBUFFER **)&dword_444938) && !(_BYTE)dword_455004 )
            sub_407E00((int)&dword_444938);
          v18 = *(_BYTE *)(LODWORD(a1) + 4);
          if ( v18 == 20 )
            v19 = (int *)(*(_DWORD *)(*(_DWORD *)(LODWORD(a1) + 20) + 180) + 1888);
          else
            v19 = (int *)(*(_DWORD *)(*(_DWORD *)(LODWORD(a1) + 20) + 180) + 2124);
          v22 = *((float *)v19 + 23);
          v20 = v22;
          v23 = v19[24];
          v24 = v19[25];
          if ( v18 == 20 )
            v21 = v20 + 1280.0;
          else
            v21 = v20 - 1280.0;
          v22 = v21;
          sub_4194A0(v19 + 23, (int *)&v22, 3000, 0);
        }
      }
    }
    else
    {
      v14 = *(_DWORD *)(LODWORD(a1) + 12);
      *(_DWORD *)(LODWORD(a1) + 16) = 0;
      *(_DWORD *)(LODWORD(a1) + 12) = v14 & 0xFC087FFF | 0x80000;
    }
    ++*(_DWORD *)(LODWORD(a1) + 16);
    result = 0;
  }
  return result;
}
// 444908: using guessed type int dword_444908;
// 444920: using guessed type int dword_444920;
// 444938: using guessed type int dword_444938;
// 455004: using guessed type int dword_455004;
// 455BE0: using guessed type int dword_455BE0;
// 455BF8: using guessed type int dword_455BF8;
// 455C14: using guessed type char byte_455C14;
// 455CA5: using guessed type char byte_455CA5;

//----- (00418020) --------------------------------------------------------
char __cdecl sub_418020(char a1, char a2)
{
  char result; // al
  unsigned __int8 v3; // [esp+Ch] [ebp+8h]

  if ( a1 == 70 )
  {
    result = dword_455BF8;
    switch ( dword_455BF8 )
    {
      case 0:
        if ( !a2 )
          goto LABEL_23;
        result = a2 - 1;
        if ( a2 == 1 )
        {
          v3 = 41;
          goto LABEL_30;
        }
        break;
      case 3:
        if ( !a2 )
        {
LABEL_23:
          v3 = 39;
          goto LABEL_30;
        }
        result = a2 - 1;
        if ( a2 == 1 )
        {
          v3 = 37;
          goto LABEL_30;
        }
        break;
      case 5:
        if ( !a2 )
        {
          v3 = 47;
          goto LABEL_30;
        }
        result = a2 - 1;
        if ( a2 == 1 )
        {
          v3 = 48;
          goto LABEL_30;
        }
        break;
      case 10:
        result = a2;
        if ( !a2 )
        {
LABEL_29:
          v3 = 45;
LABEL_30:
          result = sub_407E30((AGLSOUNDBUFFER **)(12 * v3 + 4474712));
          if ( !result )
            result = sub_407E00(12 * v3 + 4474712);
        }
        break;
      default:
        return result;
    }
  }
  else
  {
    result = a1 - 71;
    if ( a1 == 71 )
    {
      result = dword_455BF8;
      switch ( dword_455BF8 )
      {
        case 0:
        case 2:
          if ( !a2 )
            goto LABEL_10;
          result = a2 - 1;
          if ( a2 == 1 )
            goto LABEL_6;
          break;
        case 3:
          if ( !a2 )
          {
LABEL_10:
            v3 = 40;
            goto LABEL_30;
          }
          result = a2 - 1;
          if ( a2 == 1 )
          {
            v3 = 38;
            goto LABEL_30;
          }
          break;
        case 7:
          result = a2 - 1;
          if ( a2 == 1 )
            goto LABEL_29;
          break;
        case 10:
          if ( !a2 )
          {
LABEL_6:
            v3 = 42;
            goto LABEL_30;
          }
          result = a2 - 1;
          if ( a2 == 1 )
          {
            v3 = 44;
            goto LABEL_30;
          }
          break;
        default:
          return result;
      }
    }
  }
  return result;
}
// 455BF8: using guessed type int dword_455BF8;

//----- (004181C0) --------------------------------------------------------
char __cdecl sub_4181C0(int a1)
{
  int v1; // esi
  char result; // al
  int v3; // eax
  int v4; // eax
  int v5; // eax
  float v6; // ST20_4
  double v7; // st7
  char v8; // al
  unsigned int v9; // eax
  int v10; // edx
  unsigned int v11; // ecx
  unsigned int v12; // edx
  float *v13; // edi
  double v14; // st7
  int v15; // ecx
  float v16; // esi
  unsigned __int16 *v17; // eax
  int v18; // eax
  int v19; // edx
  int v20; // eax
  unsigned __int16 *v21; // ecx
  int v22; // eax
  float v23; // ST1C_4
  unsigned int v24; // ecx
  unsigned __int8 v25; // cl
  _BYTE *v26; // eax
  float v27; // ST1C_4
  unsigned __int8 v28; // cl
  int v29; // eax

  v1 = a1;
  if ( !a1 )
    return 1;
  v3 = *(_DWORD *)(a1 + 20);
  if ( v3 )
  {
    *(_DWORD *)(v3 + 92) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(*(_DWORD *)(v1 + 20) + 96) = *(_DWORD *)(v1 + 36);
    *(_DWORD *)(*(_DWORD *)(v1 + 20) + 100) = *(_DWORD *)(v1 + 40);
    if ( byte_455C14 )
      sub_4083F0(*(int **)(v1 + 20));
  }
  v4 = *(_DWORD *)(v1 + 12);
  if ( v4 & 0x400 )
  {
    BYTE1(v4) &= 0xFBu;
    *(_DWORD *)(v1 + 12) = v4;
    if ( !(v4 & 0x40000) )
    {
      BYTE1(v4) |= 0x80u;
      *(_DWORD *)(v1 + 12) = v4;
    }
    v5 = *(_DWORD *)(v1 + 12);
    if ( v5 & 0x20000 )
      *(_DWORD *)(v1 + 12) = v5 & 0xFFFD7FFF | 0x40000;
    byte_44B4BC = 0;
    LOBYTE(dword_44B4D4) = 0;
    BYTE2(dword_44B80C) = 0;
    byte_44B818 = 0;
    return 0;
  }
  if ( (v4 & 0x8000) != 0 )
  {
    if ( !*(_DWORD *)(v1 + 16) )
    {
      BYTE2(dword_44B80C) = 0;
      byte_44B818 = 0;
      sub_41BB60(0);
      v6 = *(float *)(v1 + 20);
      *(_DWORD *)(v1 + 16) = dword_455BE0;
      sub_408670(v6, 0, 2);
    }
    if ( *(_BYTE *)(v1 + 4) != 72 || !dword_455BF8 || (a1 = 256, dword_455BF8 == 2) )
      a1 = 512;
    v7 = sub_41F420(&dword_44B73C, (float *)(v1 + 32));
    if ( (double)a1 <= v7 )
    {
      if ( *(_BYTE *)(v1 + 4) == 72 && byte_44B818 == 72 )
      {
        byte_44B818 = 0;
        return 0;
      }
    }
    else
    {
      if ( sub_41BB30() )
      {
        v8 = *(_BYTE *)(v1 + 4);
        if ( *(unsigned __int8 *)(v1 + 4) - *(unsigned __int8 *)(dword_44B7C0 + 4) == 53 )
        {
          if ( dword_455BF8 != 5 || v8 != 71 )
          {
            if ( v8 == 72 )
              HIBYTE(dword_455C98) = 1;
            byte_455CB4 = 1;
            sub_431F50(dword_44B7C0);
            sub_41BB60(3);
            v11 = *(_DWORD *)(v1 + 12) & 0xFC027FFF;
            *(_DWORD *)(v1 + 16) = 0;
            *(_DWORD *)(v1 + 12) = v11 | 0x20000;
            result = 0;
          }
          else
          {
            v9 = *(_DWORD *)(v1 + 12) & 0xFC047FFF;
            *(_DWORD *)(v1 + 16) = 0;
            *(_DWORD *)(v1 + 12) = v9 | 0x40000;
            sub_431F50(dword_44B7C0);
            flt_44B7E0 = dword_44B744;
            flt_44B7D8 = dword_44B73C;
            *(float *)&dword_44B7DC = flt_44B770 - 30.0;
            v10 = *(_DWORD *)(dword_44B7C0 + 12);
            BYTE1(v10) |= 0x40u;
            *(_DWORD *)(dword_44B7C0 + 12) = v10;
            *(_DWORD *)(dword_44B7C0 + 12) &= 0xBFFFFFFF;
            dword_44B7C0 = 0;
            LOBYTE(dword_44B7BC) = 0;
            result = 0;
          }
          return result;
        }
      }
      if ( sub_4168A0(v1, 0) )
      {
        v12 = *(_DWORD *)(v1 + 12) & 0xFC017FFF;
        *(_DWORD *)(v1 + 16) = 0;
        *(_DWORD *)(v1 + 12) = v12 | 0x10000;
        return 0;
      }
      if ( *(_BYTE *)(v1 + 4) == 72 )
      {
        byte_44B818 = 72;
        return 0;
      }
    }
    return 0;
  }
  if ( v4 & 0x10000 )
  {
    if ( !*(_DWORD *)(v1 + 16) )
    {
      *(_DWORD *)(v1 + 16) = dword_455BE0;
      if ( dword_455BF8 == 5 && *(_BYTE *)(v1 + 4) == 71 )
        sub_407E00((int)&unk_444980);
      sub_408670(*(float *)(v1 + 20), 1, 0);
      sub_418020(*(_BYTE *)(v1 + 4), 0);
    }
    v13 = (float *)(v1 + 32);
    a1 = dword_455BF8 != 5 ? 512 : 7000;
    v14 = sub_41F420(&dword_44B73C, (float *)(v1 + 32));
    if ( (double)a1 <= v14 )
    {
      v15 = *(_DWORD *)(v1 + 12);
      *(_DWORD *)(v1 + 16) = 0;
      v15 &= 0xFC00FFFF;
      BYTE1(v15) |= 0x80u;
      *(_DWORD *)(v1 + 12) = v15;
      if ( dword_455BF8 == 5 )
      {
        if ( sub_407E30((AGLSOUNDBUFFER **)&unk_444980) )
          sub_407E50((AGLSOUNDBUFFER **)&unk_444980);
      }
    }
    byte_44B818 = *(_BYTE *)(v1 + 4);
    if ( dword_455BF8 != 5 || *(_BYTE *)(v1 + 4) != 71 )
    {
      if ( sub_4168A0(v1, 0) )
      {
        if ( *(_BYTE *)(v1 + 4) != 72 )
        {
          if ( dword_44B73C >= (double)*v13 )
            BYTE2(dword_44B80C) = 1;
          else
            BYTE2(dword_44B80C) = 2;
        }
      }
      else
      {
        if ( BYTE2(dword_44B80C) )
          BYTE2(dword_44B80C) = 0;
        if ( *(_BYTE *)(v1 + 4) != 72 )
          byte_44B818 = 0;
        v18 = *(_DWORD *)(v1 + 12);
        *(_DWORD *)(v1 + 16) = 0;
        v18 &= 0xFC00FFFF;
        BYTE1(v18) |= 0x80u;
        *(_DWORD *)(v1 + 12) = v18;
      }
      if ( dword_455BF8 == 3 && *(_BYTE *)(v1 + 4) == 71 || byte_44B793 )
      {
        BYTE2(dword_44B80C) = 0;
        return 0;
      }
      return 0;
    }
    v16 = *(float *)(v1 + 20);
    if ( v16 != 0.0 )
    {
      v17 = *(unsigned __int16 **)(LODWORD(v16) + 184);
      if ( v17 )
      {
        if ( *(unsigned __int16 *)(LODWORD(v16) + 174) == *v17 - 1 )
          sub_408670(v16, 3, 0);
      }
    }
    if ( *v13 + 200.0 >= dword_44B73C )
    {
      BYTE2(dword_44B80C) = 0;
      byte_44B818 = 0;
    }
    else
    {
      BYTE2(dword_44B80C) = 2;
    }
    result = 0;
  }
  else
  {
    if ( !(v4 & 0x20000) )
    {
      if ( v4 & 0x40000 )
        sub_408670(*(float *)(v1 + 20), 2, 0);
      return 0;
    }
    if ( *(_DWORD *)(v1 + 16) || (_BYTE)dword_44B4D4 == 4 )
    {
      *(_DWORD *)(v1 + 16) = dword_455BE0;
    }
    else
    {
      *(_DWORD *)(v1 + 16) = dword_455BE0;
      LOBYTE(dword_44B4D4) = 0;
    }
    switch ( (unsigned __int8)dword_44B4D4 )
    {
      case 0u:
        LOBYTE(dword_44B4D4) = dword_44B4D4 + 1;
        *(float *)&dword_44B7DC = flt_44B770 - 30.0;
        byte_44B4BC = 0;
        flt_44B7D8 = dword_44B73C;
        flt_44B7E0 = dword_44B744;
        return 0;
      case 1u:
        if ( (unsigned __int8)byte_44B4BC < 0x28u )
        {
          byte_44B4BC += 4;
          sub_4122C0(0xFFu, 1, byte_44B4BC);
        }
        else
        {
          LOBYTE(dword_44B4D4) = dword_44B4D4 + 1;
          byte_44B4BC = 40;
          sub_4122C0(0xFFu, 1, 0x28u);
        }
        return 0;
      case 2u:
        v19 = *(_DWORD *)(dword_44B7C0 + 12);
        BYTE1(v19) |= 0x40u;
        *(_DWORD *)(dword_44B7C0 + 12) = v19;
        *(_DWORD *)(dword_44B7C0 + 12) &= 0xBFFFFFFF;
        dword_44B7C0 = 0;
        LOBYTE(dword_44B7BC) = 0;
        sub_408670(*(float *)(v1 + 20), 3, 0);
        sub_418020(*(_BYTE *)(v1 + 4), 1);
        LOBYTE(dword_44B4D4) = dword_44B4D4 + 1;
        sub_4122C0(0xFFu, 1, 0x28u);
        return 0;
      case 3u:
        v20 = *(_DWORD *)(v1 + 20);
        if ( v20 )
        {
          v21 = *(unsigned __int16 **)(v20 + 184);
          if ( v21 )
          {
            if ( *(unsigned __int16 *)(v20 + 174) == *v21 - 1 )
            {
              if ( *(_BYTE *)(v1 + 4) == 72 )
              {
                LOBYTE(dword_44B4D4) = 9;
              }
              else
              {
                LOBYTE(dword_44B4D4) = dword_44B4D4 + 1;
                if ( dword_455BF8 == 3 )
                {
                  if ( *(_BYTE *)(v1 + 4) == 71 )
                    sub_431FC0();
                }
                else if ( dword_455BF8 == 10 )
                {
                  if ( *(_BYTE *)(v1 + 4) == 70 )
                  {
                    sub_434690(4u, 0);
                    sub_434530();
                    byte_44B790 = 0;
                    sub_41E7B0((float *)(dword_455C80 + 32), 0, 1);
                    sub_42D130((int)&dword_44B71C, dword_455C80);
                    HIBYTE(dword_44B808) = 1;
                    v22 = *(_DWORD *)(v1 + 12);
                    BYTE1(v22) |= 0x20u;
                    *(_DWORD *)(v1 + 12) = v22;
                  }
                }
                else if ( dword_455BF8 == 2 && *(_BYTE *)(v1 + 4) == 70 )
                {
                  sub_407E00((int)&unk_4447A0);
                  sub_434690(1u, 1);
                  v23 = *(float *)(v1 + 36) - 75.0;
                  sub_40CA50(*(float *)(v1 + 32), v23, *(float *)(v1 + 40), 24, 1130102784, 1137836032);
                }
              }
              sub_408670(*(float *)(v1 + 20), 2, 0);
            }
          }
        }
        sub_4122C0(0xFFu, 1, 0x28u);
        return 0;
      case 4u:
        if ( !(_BYTE)dword_455004 && (_WORD)dword_44B784 == -1 )
        {
          if ( dword_455BF8 == 10 && *(_BYTE *)(v1 + 4) == 70 )
          {
            LOWORD(dword_44B4D4) = 263;
            byte_44B4BC += 4;
          }
          if ( byte_44B4BC )
          {
            byte_44B4BC -= 4;
          }
          else
          {
            byte_44B4BC = 0;
            LOBYTE(dword_44B4D4) = dword_44B4D4 + 1;
          }
        }
        goto LABEL_118;
      case 5u:
        byte_455CB4 = 0;
        v24 = *(_DWORD *)(v1 + 12) & 0xFC047FFF | 0x40000;
        *(_DWORD *)(v1 + 16) = 0;
        *(_DWORD *)(v1 + 12) = v24;
        sub_41BB60(0);
        result = 0;
        break;
      case 7u:
        switch ( BYTE1(dword_44B4D4) )
        {
          case 1u:
            v25 = BYTE2(dword_44B4D4) + 1;
            HIBYTE(dword_44B814) = 1;
            ++BYTE2(dword_44B4D4);
            if ( !(_BYTE)dword_455004 && v25 > 0x1Eu )
            {
              ++BYTE1(dword_44B4D4);
              *(_WORD *)((char *)&dword_44B4D4 + 1) = BYTE1(dword_44B4D4);
            }
            break;
          case 2u:
            HIBYTE(dword_44B814) = 1;
            sub_434530();
            sub_417400(18, &a1, 1);
            *(_BYTE *)(a1 + 6) = *(_BYTE *)(a1 + 7);
            sub_408A30(*(unsigned int **)(a1 + 20));
            v26 = sub_4089F0(dword_448AC4 + 48 * *(unsigned __int8 *)(a1 + 7));
            *(_DWORD *)(a1 + 20) = v26;
            sub_4159D0(a1);
            sub_434500(0x78u);
            sub_434690(1u, 1);
            sub_407E00((int)&unk_4447AC);
            sub_407E00((int)&unk_444878);
            v27 = *(float *)(a1 + 36) - 80.0;
            sub_40CA50(*(float *)(a1 + 32), v27, *(float *)(a1 + 40), 16, 1128792064, 1137180672);
            ++BYTE1(dword_44B4D4);
            *(_WORD *)((char *)&dword_44B4D4 + 1) = BYTE1(dword_44B4D4);
            break;
          case 3u:
            v28 = BYTE2(dword_44B4D4) + 1;
            HIBYTE(dword_44B814) = 1;
            ++BYTE2(dword_44B4D4);
            if ( !(_BYTE)dword_455004 && v28 > 0x1Fu )
            {
              sub_434530();
              ++BYTE1(dword_44B4D4);
              sub_434690(1u, 0);
              HIBYTE(dword_44B808) = 0;
              HIBYTE(dword_44B814) = 0;
            }
            break;
          case 4u:
            HIBYTE(dword_44B814) = 0;
            if ( ++BYTE2(dword_44B4D4) > 0x1Eu )
            {
              if ( byte_44B4BC )
              {
                byte_44B4BC -= 4;
              }
              else
              {
                byte_44B4BC = 0;
                LOBYTE(dword_44B4D4) = 5;
                v29 = *(_DWORD *)(v1 + 12);
                BYTE1(v29) &= 0xDFu;
                *(_DWORD *)(v1 + 12) = v29;
              }
            }
            break;
          default:
            break;
        }
LABEL_118:
        sub_4122C0(0xFFu, 1, byte_44B4BC);
        result = 0;
        break;
      case 9u:
        byte_455C12 = 1;
        sub_4122C0(0xFFu, 1, 0x28u);
        result = 0;
        break;
      default:
        return 0;
    }
  }
  return result;
}
// 448AC4: using guessed type int dword_448AC4;
// 44B4BC: using guessed type char byte_44B4BC;
// 44B4D4: using guessed type int dword_44B4D4;
// 44B784: using guessed type int dword_44B784;
// 44B790: using guessed type char byte_44B790;
// 44B793: using guessed type char byte_44B793;
// 44B7BC: using guessed type int dword_44B7BC;
// 44B7C0: using guessed type int dword_44B7C0;
// 44B7D8: using guessed type float flt_44B7D8;
// 44B7DC: using guessed type int dword_44B7DC;
// 44B7E0: using guessed type float flt_44B7E0;
// 44B808: using guessed type int dword_44B808;
// 44B80C: using guessed type int dword_44B80C;
// 44B814: using guessed type int dword_44B814;
// 44B818: using guessed type char byte_44B818;
// 455004: using guessed type int dword_455004;
// 455BE0: using guessed type int dword_455BE0;
// 455BF8: using guessed type int dword_455BF8;
// 455C12: using guessed type char byte_455C12;
// 455C14: using guessed type char byte_455C14;
// 455C80: using guessed type int dword_455C80;
// 455C98: using guessed type int dword_455C98;
// 455CB4: using guessed type char byte_455CB4;

//----- (00418B90) --------------------------------------------------------
char __cdecl sub_418B90(int a1)
{
  _DWORD *v2; // eax
  float *v3; // eax
  int v4; // ecx
  float v5; // [esp+8h] [ebp-30h]
  float v6; // [esp+Ch] [ebp-2Ch]
  float v7; // [esp+10h] [ebp-28h]
  float v8; // [esp+14h] [ebp-24h]
  float v9; // [esp+18h] [ebp-20h]
  float v10; // [esp+1Ch] [ebp-1Ch]
  float v11; // [esp+20h] [ebp-18h]
  float v12; // [esp+24h] [ebp-14h]
  float v13; // [esp+28h] [ebp-10h]
  float v14; // [esp+30h] [ebp-8h]
  float v15; // [esp+34h] [ebp-4h]

  if ( !a1 )
    return 1;
  v2 = *(_DWORD **)(a1 + 20);
  if ( v2 )
  {
    if ( !*(_DWORD *)(a1 + 16) )
    {
      if ( *(_WORD *)(a1 + 60) == -1 )
      {
        v2[15] = 0;
        v2[14] = 1065353216;
        v2[16] = 0;
        v2[17] = 0;
        v2[18] = 1065353216;
        v2[19] = 0;
        v2[20] = 0;
        v2[21] = 0;
        v2[22] = 1065353216;
        v2[23] = 0;
        v2[24] = 0;
        v2[25] = 0;
      }
      else
      {
        v3 = *(float **)(dword_455C84 + 12 * *(unsigned __int16 *)(a1 + 60) + 4);
        v11 = *v3 - v3[3];
        v12 = v3[1] - v3[4];
        v13 = v3[2] - v3[5];
        sub_408330(&v11, &v5);
        v12 = -v7;
        v11 = 0.0;
        v13 = v6;
        sub_408330(&v11, &v8);
        v4 = *(_DWORD *)(a1 + 20);
        v14 = v8 * v7 - v10 * v5;
        v15 = v9 * v5 - v8 * v6;
        *(float *)(v4 + 56) = v10 * v6 - v9 * v7;
        *(float *)(*(_DWORD *)(a1 + 20) + 60) = v5;
        *(float *)(*(_DWORD *)(a1 + 20) + 64) = v8;
        *(float *)(*(_DWORD *)(a1 + 20) + 68) = v14;
        *(float *)(*(_DWORD *)(a1 + 20) + 72) = v6;
        *(float *)(*(_DWORD *)(a1 + 20) + 76) = v9;
        *(float *)(*(_DWORD *)(a1 + 20) + 80) = v15;
        *(float *)(*(_DWORD *)(a1 + 20) + 84) = v7;
        *(float *)(*(_DWORD *)(a1 + 20) + 88) = v10;
      }
      *(_DWORD *)(*(_DWORD *)(a1 + 20) + 92) = *(_DWORD *)(a1 + 32);
      *(_DWORD *)(*(_DWORD *)(a1 + 20) + 96) = *(_DWORD *)(a1 + 36);
      *(_DWORD *)(*(_DWORD *)(a1 + 20) + 100) = *(_DWORD *)(a1 + 40);
      *(_DWORD *)(a1 + 16) = 1;
    }
    if ( byte_455C14 )
      sub_4083F0(*(int **)(a1 + 20));
  }
  return 0;
}
// 455C14: using guessed type char byte_455C14;
// 455C84: using guessed type int dword_455C84;

//----- (00418D40) --------------------------------------------------------
char __cdecl sub_418D40(int a1)
{
  int v1; // esi
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  double v7; // st7
  int v8; // ecx
  float v9; // ST08_4
  int v10; // ST14_4
  int v11; // ST08_4
  float v12; // ST04_4
  unsigned int v13; // edx
  float *v14; // edi
  bool v15; // c0
  double v16; // st7
  int v17; // eax
  float *v18; // edi
  bool v19; // c0
  int v20; // eax
  unsigned __int16 *v21; // ecx
  float v22; // ST04_4
  unsigned int v23; // eax
  int v24; // [esp+14h] [ebp-Ch]
  float v25; // [esp+24h] [ebp+4h]

  v1 = a1;
  if ( !a1 )
    return 0;
  v3 = *(_DWORD *)(a1 + 20);
  if ( v3 )
  {
    *(_DWORD *)(v3 + 92) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 96) = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 100) = *(_DWORD *)(a1 + 40);
    if ( byte_455C14 )
      sub_4083F0(*(int **)(a1 + 20));
  }
  v4 = *(_DWORD *)(a1 + 12);
  if ( v4 & 0x400 )
  {
    dword_44B714 = 0;
    v5 = *(_DWORD *)(a1 + 12);
    BYTE1(v5) &= 0xFBu;
    *(_DWORD *)(a1 + 12) = v5;
    return 0;
  }
  if ( (v4 & 0x8000) == 0 )
  {
    if ( v4 & 0x10000 )
    {
      if ( !*(_DWORD *)(a1 + 16) )
      {
        BYTE1(v4) |= 0x40u;
        *(_DWORD *)(a1 + 16) = dword_455BE0;
        *(_DWORD *)(a1 + 12) = v4;
        byte_44B818 = 0;
        sub_408A30(*(unsigned int **)(a1 + 20));
        v17 = *(_DWORD *)(a1 + 12);
        BYTE1(v17) &= 0xDFu;
        *(_DWORD *)(a1 + 12) = v17;
        return 1;
      }
      return 1;
    }
    if ( v4 & 0x80000 )
      goto LABEL_53;
    return 1;
  }
  if ( !*(_DWORD *)(a1 + 20) )
    *(_DWORD *)(a1 + 20) = sub_4089F0(dword_448AC4 + 48 * *(unsigned __int8 *)(a1 + 6));
  sub_408670(*(float *)(a1 + 20), 0, 0);
  if ( dword_44B7C0 && *(_BYTE *)(dword_44B7C0 + 4) == 32 )
  {
    v6 = dword_44B7C0;
    dword_44B714 = dword_44B7C0;
  }
  else
  {
    v6 = dword_44B714;
  }
  if ( dword_455BF8 == 5 )
  {
    if ( !v6 )
    {
LABEL_28:
      v14 = (float *)(a1 + 32);
      sub_430D30(a1 + 32, (int)&dword_44B73C, 256.0);
      if ( dword_455BF8 == 10 )
      {
        v16 = sub_41F420((float *)(a1 + 32), &dword_44B73C);
        if ( v16 < 1300.0 )
        {
          byte_44B818 = *(_BYTE *)(a1 + 4);
          return 1;
        }
        if ( v16 < 5000.0 && byte_44B818 == *(_BYTE *)(a1 + 4) )
        {
          byte_44B818 = 0;
          return 1;
        }
        return 1;
      }
      v25 = sub_430D30(a1 + 32, (int)&dword_44B73C, 360.0);
      if ( dword_455BF8 != 5 && v25 < 256.0 || v25 < 280.0 )
      {
        if ( sub_4168A0(v1, 1) )
        {
          v15 = dword_44B73C < (double)*v14;
          BYTE2(dword_44B80C) = 2;
          if ( !v15 )
            BYTE2(dword_44B80C) = 1;
          byte_44B818 = *(_BYTE *)(v1 + 4);
LABEL_41:
          if ( v25 < 360.0 && dword_455CAC & 0x20 )
          {
            byte_44B818 = 0;
            return 1;
          }
          return 1;
        }
        goto LABEL_40;
      }
      if ( !BYTE2(dword_44B80C) )
        goto LABEL_41;
      if ( dword_455BF8 != 5 && v25 < 340.0 || v25 < 360.0 )
      {
LABEL_40:
        BYTE2(dword_44B80C) = 0;
        byte_44B818 = 0;
        goto LABEL_41;
      }
      return 1;
    }
    if ( dword_44B7C0 != v6 )
    {
      v7 = sub_41F420((float *)(a1 + 32), (float *)(v6 + 32));
      v6 = dword_44B714;
      if ( v7 < 512.0 )
      {
        v8 = *(_DWORD *)(dword_44B714 + 12);
        BYTE1(v8) |= 4u;
        *(_DWORD *)(dword_44B714 + 12) = v8;
        sub_407E00((int)&unk_44477C);
        v9 = *(float *)(a1 + 20);
        *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 12) & 0xFC087FFF | 0x80000;
        *(_DWORD *)(a1 + 16) = 0;
        sub_408670(v9, 1, 0);
LABEL_53:
        v18 = (float *)(a1 + 32);
        if ( sub_41F420((float *)(a1 + 32), &dword_44B73C) < 256.0 && sub_4168A0(a1, 1) )
        {
          v19 = dword_44B73C < (double)*v18;
          BYTE2(dword_44B80C) = 2;
          if ( !v19 )
            BYTE2(dword_44B80C) = 1;
          byte_44B818 = *(_BYTE *)(a1 + 4);
        }
        else
        {
          BYTE2(dword_44B80C) = 0;
          byte_44B818 = 0;
        }
        v20 = *(_DWORD *)(a1 + 20);
        if ( v20 )
        {
          v21 = *(unsigned __int16 **)(v20 + 184);
          if ( v21 )
          {
            if ( *(unsigned __int16 *)(v20 + 174) == *v21 - 1 )
            {
              BYTE2(dword_44B80C) = 0;
              byte_44B818 = 0;
              sub_434690(1u, 1);
              if ( dword_455BF8 == 5 )
                sub_407E00((int)&unk_4447A0);
              v22 = *(float *)(a1 + 36) - 80.0;
              sub_40CA50(*v18, v22, *(float *)(a1 + 40), 16, 1128792064, 1137180672);
              v23 = *(_DWORD *)(a1 + 12) & 0xFC017FFF;
              *(_DWORD *)(a1 + 16) = 0;
              *(_DWORD *)(a1 + 12) = v23 | 0x10000;
            }
          }
        }
        return 1;
      }
    }
  }
  if ( !v6 || !(*(_BYTE *)(v6 + 12) & 1) || sub_430D30(a1 + 32, v6 + 32, 512.0) == 512.0 )
    goto LABEL_28;
  sub_435281((int)asc_441234, v24);
  sub_435281((int)aBoom, v10);
  sub_435281((int)aFlagsD, *(_DWORD *)(a1 + 12));
  sub_435281((int)asc_441234, v11);
  if ( *(_WORD *)(a1 + 62) )
    sub_40AC20(*(unsigned __int16 *)(a1 + 62), 1);
  sub_434690(1u, 1);
  if ( dword_455BF8 == 5 )
    sub_407E00((int)&unk_4447A0);
  v12 = *(float *)(a1 + 36) - 80.0;
  sub_40CA50(*(float *)(a1 + 32), v12, *(float *)(a1 + 40), 16, 1128792064, 1137180672);
  v13 = *(_DWORD *)(a1 + 12) & 0xFC017FFF;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 12) = v13 | 0x10000;
  return 0;
}
// 448AC4: using guessed type int dword_448AC4;
// 44B714: using guessed type int dword_44B714;
// 44B7C0: using guessed type int dword_44B7C0;
// 44B80C: using guessed type int dword_44B80C;
// 44B818: using guessed type char byte_44B818;
// 455BE0: using guessed type int dword_455BE0;
// 455BF8: using guessed type int dword_455BF8;
// 455C14: using guessed type char byte_455C14;
// 455CAC: using guessed type int dword_455CAC;

//----- (00419200) --------------------------------------------------------
char __cdecl sub_419200(int a1)
{
  char result; // al
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // edx
  int v6; // eax
  unsigned int v7; // ecx
  int v8; // eax
  int v9; // edx
  int v10; // ecx
  int v11; // edx
  unsigned int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // ecx
  unsigned int v16; // edx
  int v17; // ecx
  int v18; // edx
  double v19; // st7
  unsigned int v20; // eax
  float v21; // ST08_4
  double v22; // st7
  float v23; // ecx
  float v24; // ST04_4

  if ( !a1 )
    return 0;
  v2 = *(_DWORD *)(a1 + 20);
  if ( v2 )
  {
    *(_DWORD *)(v2 + 92) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 96) = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 100) = *(_DWORD *)(a1 + 40);
    if ( byte_455C14 )
      sub_4083F0(*(int **)(a1 + 20));
  }
  v3 = *(_DWORD *)(a1 + 12);
  if ( v3 & 0x400 )
  {
    BYTE1(v3) &= 0xFBu;
    *(_DWORD *)(a1 + 12) = v3;
    v4 = *(_DWORD *)(a1 + 20);
    if ( v4 )
      *(_DWORD *)(v4 + 4) = 0;
    if ( *(_DWORD *)(a1 + 20) && dword_44B7C0 && *(_BYTE *)(dword_44B7C0 + 4) == 17 )
    {
      LOBYTE(dword_44B7BC) = 0;
      dword_44B7C0 = 0;
    }
    *(_DWORD *)(a1 + 92) = 0;
    byte_44B4E0 = 0;
    *(_DWORD *)(a1 + 12) &= 0xFEFFBFFF;
    sub_4159D0(a1);
    v5 = *(_DWORD *)(a1 + 48);
    v6 = *(_DWORD *)(a1 + 52);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 44);
    v7 = *(_DWORD *)(a1 + 12) & 0xFC107FFF;
    *(_DWORD *)(a1 + 36) = v5;
    *(_DWORD *)(a1 + 40) = v6;
    *(_DWORD *)(a1 + 12) = v7 | 0x100000;
    *(_DWORD *)(a1 + 16) = 0;
    result = 0;
  }
  else
  {
    if ( !dword_44B7C0 && byte_44B4E0 )
    {
      *(_DWORD *)(a1 + 12) = v3 & 0xFDFFFFFF;
      byte_44B4E0 = 0;
    }
    if ( *(_DWORD *)(a1 + 12) & 0x1000000 )
    {
      v8 = *(_DWORD *)(a1 + 20);
      if ( v8 )
        *(_DWORD *)(v8 + 4) = 0;
      if ( *(_DWORD *)(a1 + 20) && dword_44B7C0 && *(_BYTE *)(dword_44B7C0 + 4) == 17 )
      {
        LOBYTE(dword_44B7BC) = 0;
        dword_44B7C0 = 0;
      }
      v9 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 92) = 0;
      v9 &= 0xFEFFFFFF;
      BYTE1(v9) |= 0x40u;
      *(_DWORD *)(a1 + 12) = v9;
      dword_44B4DC = sub_4336A0();
      v10 = *(_DWORD *)(a1 + 48);
      v11 = *(_DWORD *)(a1 + 52);
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 44);
      v12 = *(_DWORD *)(a1 + 12) & 0xFC807FFF;
      *(_DWORD *)(a1 + 36) = v10;
      *(_DWORD *)(a1 + 40) = v11;
      *(_DWORD *)(a1 + 12) = v12 | 0x800000;
      *(_DWORD *)(a1 + 16) = 0;
    }
    v13 = *(_DWORD *)(a1 + 12);
    if ( (v13 & 0x8000) != 0 )
    {
      sub_4080B0(2048, *(_DWORD *)(a1 + 20) + 56);
      v14 = *(_DWORD *)(a1 + 36);
      v15 = *(_DWORD *)(a1 + 40);
      *(_DWORD *)(a1 + 44) = *(_DWORD *)(a1 + 32);
      v16 = *(_DWORD *)(a1 + 12) & 0xFC107FFF;
      *(_DWORD *)(a1 + 48) = v14;
      *(_DWORD *)(a1 + 52) = v15;
      *(_DWORD *)(a1 + 12) = v16 | 0x100000;
      *(_DWORD *)(a1 + 16) = 0;
      return 1;
    }
    if ( v13 & 0x100000 )
    {
      if ( dword_44B7C0 == a1 && !byte_44B4E0 )
      {
        *(_DWORD *)(a1 + 12) = v13 | 0x2000000;
        byte_44B4E0 = 1;
        return 1;
      }
    }
    else if ( v13 & 0x800000 )
    {
      v17 = *(_DWORD *)(a1 + 48);
      v18 = *(_DWORD *)(a1 + 52);
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 44);
      *(_DWORD *)(a1 + 36) = v17;
      *(_DWORD *)(a1 + 40) = v18;
      dword_44B4D8 = sub_4336A0();
      if ( dword_44B4D8 - dword_44B4DC >= 3 )
      {
        v19 = *(float *)(a1 + 40) - 50.0;
        v20 = *(_DWORD *)(a1 + 12) & 0xFC103FFF | 0x100000;
        *(_DWORD *)(a1 + 16) = 0;
        v21 = v19;
        v22 = *(float *)(a1 + 36) - 16.0;
        v23 = *(float *)(a1 + 32);
        *(_DWORD *)(a1 + 12) = v20;
        v24 = v22;
        sub_40C9D0(v23, v24, v21, 8, 1120403456, 1124073472);
      }
    }
    result = 1;
  }
  return result;
}
// 44B4D8: using guessed type int dword_44B4D8;
// 44B4DC: using guessed type int dword_44B4DC;
// 44B4E0: using guessed type char byte_44B4E0;
// 44B7BC: using guessed type int dword_44B7BC;
// 44B7C0: using guessed type int dword_44B7C0;
// 455C14: using guessed type char byte_455C14;

//----- (00419450) --------------------------------------------------------
int *sub_419450()
{
  signed int v0; // eax
  int *result; // eax

  dword_44B62C[0] = 0;
  v0 = sub_40A5E0(67);
  if ( v0 != -1 )
    dword_44B62C[0] = dword_448AC4 + 48 * v0;
  result = dword_44B4E8;
  do
  {
    *result = 0;
    result += 8;
  }
  while ( (signed int)result < (signed int)&dword_44B628 );
  dword_44B628 = dword_455BE0;
  return result;
}
// 448AC4: using guessed type int dword_448AC4;
// 44B4E8: using guessed type int dword_44B4E8[];
// 44B628: using guessed type int dword_44B628;
// 44B62C: using guessed type int dword_44B62C[];
// 455BE0: using guessed type int dword_455BE0;

//----- (004194A0) --------------------------------------------------------
char __cdecl sub_4194A0(int *a1, int *a2, __int16 a3, _BYTE *a4)
{
  int *v4; // esi
  int v5; // ebx
  _BYTE *v7; // eax
  int v8; // eax

  v4 = dword_44B4E8;
  if ( a4 )
    *a4 = -1;
  v5 = 0;
  while ( *v4 )
  {
    v4 += 8;
    if ( ++v5 >= 10 )
      return 0;
  }
  v7 = sub_4089F0(dword_44B62C[0]);
  *v4 = (int)v7;
  if ( !v7 )
    return 0;
  if ( a4 )
    *a4 = v5;
  v4[1] = *a1;
  v4[2] = a1[1];
  v4[3] = a1[2];
  v4[4] = *a2;
  v4[5] = a2[1];
  v8 = a2[2];
  *((_WORD *)v4 + 14) = a3;
  v4[6] = v8;
  *((_BYTE *)v4 + 30) = 0;
  return 1;
}
// 44B4E8: using guessed type int dword_44B4E8[];
// 44B62C: using guessed type int dword_44B62C[];

//----- (00419520) --------------------------------------------------------
unsigned int *sub_419520()
{
  int v0; // ebx
  float *v1; // esi
  float v2; // ST18_4
  double v3; // st7
  double v4; // st6
  unsigned int *result; // eax

  v0 = 0;
  v1 = (float *)&unk_44B4EC;
  do
  {
    if ( *((_DWORD *)v1 - 1) )
    {
      v2 = sub_41F420(v1, v1 + 3) * 256.0;
      v3 = AGLSqrt(v2);
      v4 = (double)*((unsigned __int16 *)v1 + 12) * 5.1199999 * 0.00390625;
      if ( v3 != 0.0 )
      {
        *v1 = (v1[3] - *v1) * v4 / v3 + *v1;
        v1[1] = (v1[4] - v1[1]) * v4 / v3 + v1[1];
        v1[2] = (v1[5] - v1[2]) * v4 / v3 + v1[2];
      }
      if ( v3 < 50.0 && !sub_419630(v0) )
      {
        sub_419640(v0, 1);
        sub_419660(v0);
      }
    }
    if ( dword_455BF8 == 11 && HIBYTE(dword_455CB0) || (LOBYTE(result) = sub_41F2C0(), (_BYTE)result) )
    {
      sub_419640(v0, 1);
      result = sub_419660(v0);
    }
    v1 += 8;
    ++v0;
  }
  while ( (signed int)v1 < (signed int)dword_44B62C );
  dword_44B628 = dword_455BE0;
  return result;
}
// 44B628: using guessed type int dword_44B628;
// 44B62C: using guessed type int dword_44B62C[];
// 455BE0: using guessed type int dword_455BE0;
// 455BF8: using guessed type int dword_455BF8;
// 455CB0: using guessed type int dword_455CB0;

//----- (00419630) --------------------------------------------------------
char __cdecl sub_419630(int a1)
{
  return byte_44B506[32 * a1];
}

//----- (00419640) --------------------------------------------------------
int __cdecl sub_419640(int a1, char a2)
{
  int result; // eax

  result = 32 * a1;
  byte_44B506[32 * a1] = a2;
  return result;
}

//----- (00419660) --------------------------------------------------------
unsigned int *__cdecl sub_419660(int a1)
{
  unsigned int *result; // eax

  result = (unsigned int *)dword_44B4E8[8 * a1];
  if ( result )
    result = sub_408A30((unsigned int *)dword_44B4E8[8 * a1]);
  dword_44B4E8[8 * a1] = 0;
  return result;
}
// 44B4E8: using guessed type int dword_44B4E8[];

//----- (00419690) --------------------------------------------------------
int sub_419690()
{
  int *v0; // ebx
  int result; // eax
  int v2; // [esp-2Ch] [ebp-38h]
  int v3; // [esp-28h] [ebp-34h]
  int v4; // [esp-24h] [ebp-30h]
  int v5; // [esp-20h] [ebp-2Ch]
  int v6; // [esp-1Ch] [ebp-28h]
  int v7; // [esp-18h] [ebp-24h]
  int v8; // [esp-14h] [ebp-20h]
  int v9; // [esp-10h] [ebp-1Ch]
  float v10; // [esp-Ch] [ebp-18h]
  int v11; // [esp-8h] [ebp-14h]
  float v12; // [esp-4h] [ebp-10h]

  v0 = dword_44B4E8;
  do
  {
    result = *v0;
    if ( *v0 )
    {
      *(_DWORD *)(result + 92) = v0[1];
      *(_DWORD *)(*v0 + 96) = v0[2];
      *(_DWORD *)(*v0 + 100) = v0[3];
      v10 = *((float *)v0 + 4);
      v11 = v0[5];
      v12 = *((float *)v0 + 6);
      qmemcpy(&v2, v0, 0x20u);
      sub_419700(v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12);
      result = sub_408A50(*v0);
    }
    v0 += 8;
  }
  while ( (signed int)v0 < (signed int)&dword_44B628 );
  return result;
}
// 44B4E8: using guessed type int dword_44B4E8[];
// 44B628: using guessed type int dword_44B628;

//----- (00419700) --------------------------------------------------------
int __cdecl sub_419700(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, float a9, int a10, float a11)
{
  __int16 v11; // cx
  signed __int64 v12; // rax

  v12 = (signed __int64)(atan2(*(float *)(a1 + 92) - a9, *(float *)(a1 + 100) - a11) * 4096.0 * 0.15915494);
  v11 = v12 & 0xFFF;
  LOWORD(v12) = v12 & 0xFFF;
  if ( *(float *)(a1 + 92) >= (double)a9 )
    LODWORD(v12) = -v11;
  return sub_408060(v12, a1 + 56);
}

//----- (00419760) --------------------------------------------------------
char __cdecl sub_419760(int a1)
{
  char result; // al
  int v2; // eax
  int v3; // eax
  __int16 *v4; // edx
  int v5; // eax
  signed int v6; // esi
  int v7; // ecx
  int v8; // eax
  __int16 *v9; // edx
  int v10; // eax
  signed int v11; // esi
  int v12; // ecx
  char v13; // bl
  __int16 *v14; // edi
  int v15; // esi
  double v16; // st7
  int v17; // eax
  int v18; // eax
  float v19; // ecx
  unsigned __int16 *v20; // edx
  int v21; // eax
  signed int v22; // [esp+4h] [ebp-4h]

  if ( !a1 )
    return 0;
  v2 = *(_DWORD *)(a1 + 20);
  if ( v2 )
  {
    *(_DWORD *)(v2 + 92) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 96) = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 100) = *(_DWORD *)(a1 + 40);
    if ( byte_455C14 )
      sub_4083F0(*(int **)(a1 + 20));
  }
  v3 = *(_DWORD *)(a1 + 12);
  if ( v3 & 0x400 )
  {
    sub_416160(a1);
    v4 = &word_44B654;
    v5 = 0;
    v6 = 3;
    do
    {
      v7 = dword_44B640[v5];
      ++v5;
      *(_DWORD *)(v7 + 12) |= 0x40000000u;
      v4 = (__int16 *)((char *)v4 + 1);
      *(_DWORD *)(dword_44B62C[v5] + 12) &= 0xBFFFFFFF;
      *((_BYTE *)v4 - 1) = 0;
      --v6;
    }
    while ( v6 );
    dword_44B64C = sub_4336A0();
  }
  v8 = *(_DWORD *)(a1 + 12);
  if ( (v8 & 0x8000) == 0 )
  {
    if ( v8 & 0x10000 )
    {
      v13 = 0;
      v14 = &word_44B654;
      v15 = 0;
      v22 = 3;
      do
      {
        if ( !*(_BYTE *)v14 )
        {
          v16 = sub_41F420((float *)(dword_44B63C + 32), (float *)(dword_44B640[v15] + 32));
          if ( *(_BYTE *)(dword_44B63C + 12) & 1 && v16 < 1500.0 )
          {
            *(_DWORD *)(dword_44B640[v15] + 12) &= 0xBFFFFFFF;
            *(_DWORD *)(dword_44B630[v15] + 12) |= 0x40000000u;
            *(_BYTE *)v14 = 1;
          }
          if ( !v13 && sub_419A00(dword_44B640[v15]) )
          {
            v17 = dword_44B640[v15];
            if ( *(_DWORD *)(v17 + 12) & 0x40000000 )
            {
              if ( word_44B7EC > 1 || word_44B7EE > 29 && word_44B7EC == 1 )
                v13 = *(_BYTE *)(v17 + 4);
            }
          }
        }
        v14 = (__int16 *)((char *)v14 + 1);
        ++v15;
        --v22;
      }
      while ( v22 );
      byte_44B818 = v13;
      v18 = sub_4336A0();
      dword_44B64C = v18;
      v19 = *(float *)(a1 + 20);
      if ( v19 != 0.0 )
      {
        v20 = *(unsigned __int16 **)(LODWORD(v19) + 184);
        if ( v20 )
        {
          if ( *(unsigned __int16 *)(LODWORD(v19) + 174) == *v20 - 1 )
          {
            if ( v18 - dword_44B650 >= 30 )
            {
              v21 = sub_4336A0();
              dword_44B64C = v21;
              dword_44B650 = v21;
              sub_408670(*(float *)(a1 + 20), 1, 0);
              return 1;
            }
            sub_408670(v19, 0, 0);
          }
        }
      }
    }
    result = 1;
  }
  else
  {
    sub_417400(60, dword_44B640, 3);
    sub_417400(61, dword_44B630, 3);
    sub_417400(32, &dword_44B63C, 1);
    v9 = &word_44B654;
    v10 = 0;
    v11 = 3;
    do
    {
      v12 = dword_44B640[v10];
      ++v10;
      *(_DWORD *)(v12 + 12) |= 0x40000000u;
      v9 = (__int16 *)((char *)v9 + 1);
      *(_DWORD *)(dword_44B62C[v10] + 12) &= 0xBFFFFFFF;
      *((_BYTE *)v9 - 1) = 0;
      --v11;
    }
    while ( v11 );
    sub_408670(*(float *)(a1 + 20), 0, 0);
    dword_44B650 = sub_4336A0();
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 12) & 0xFC017FFF | 0x10000;
    *(_DWORD *)(a1 + 16) = 0;
    result = 1;
  }
  return result;
}
// 44B62C: using guessed type int dword_44B62C[];
// 44B630: using guessed type int dword_44B630[];
// 44B63C: using guessed type int dword_44B63C;
// 44B640: using guessed type int dword_44B640[];
// 44B64C: using guessed type int dword_44B64C;
// 44B650: using guessed type int dword_44B650;
// 44B654: using guessed type __int16 word_44B654;
// 44B7EC: using guessed type __int16 word_44B7EC;
// 44B7EE: using guessed type __int16 word_44B7EE;
// 44B818: using guessed type char byte_44B818;
// 455C14: using guessed type char byte_455C14;

//----- (00419A00) --------------------------------------------------------
bool __cdecl sub_419A00(int a1)
{
  return sub_41F420(&dword_44B73C, (float *)(a1 + 32)) < 1000.0;
}

//----- (00419A30) --------------------------------------------------------
char __cdecl sub_419A30(float a1)
{
  char result; // al
  int v2; // eax
  int v3; // eax
  int v4; // eax
  unsigned int *v5; // ST0C_4
  _BYTE *v6; // eax
  int v7; // ecx
  unsigned int v8; // edx
  int v9; // eax
  int v10; // eax
  _BYTE *v11; // eax
  int v12; // edx
  unsigned int v13; // ecx
  int v14; // eax
  int v15; // ecx
  int v16; // eax
  int v17; // eax
  unsigned int v18; // eax
  int v19; // ecx
  int v20; // edx
  int v21; // eax
  unsigned __int16 *v22; // ecx
  unsigned int *v23; // ST0C_4
  _BYTE *v24; // eax
  int v25; // ecx
  unsigned int v26; // edx
  int v27; // eax
  int v28; // edx

  if ( a1 == 0.0 )
    return 0;
  if ( !(_BYTE)dword_455CB0 && !byte_455CA5 )
  {
    if ( HIBYTE(dword_455CB0) )
    {
      v2 = *(_DWORD *)(LODWORD(a1) + 12);
      LOBYTE(v2) = v2 | 0x20;
      *(_DWORD *)(LODWORD(a1) + 12) = v2;
    }
    v3 = *(_DWORD *)(LODWORD(a1) + 20);
    if ( v3 )
    {
      *(_DWORD *)(v3 + 92) = *(_DWORD *)(LODWORD(a1) + 32);
      *(_DWORD *)(*(_DWORD *)(LODWORD(a1) + 20) + 96) = *(_DWORD *)(LODWORD(a1) + 36);
      *(_DWORD *)(*(_DWORD *)(LODWORD(a1) + 20) + 100) = *(_DWORD *)(LODWORD(a1) + 40);
      if ( byte_455C14 )
        sub_4083F0(*(int **)(LODWORD(a1) + 20));
    }
    v4 = *(_DWORD *)(LODWORD(a1) + 12);
    if ( v4 & 0x400 )
    {
      BYTE1(v4) &= 0xFBu;
      v5 = *(unsigned int **)(LODWORD(a1) + 20);
      *(_DWORD *)(LODWORD(a1) + 12) = v4;
      sub_408A30(v5);
      dword_44B658 = dword_448AC4 + 48 * *(unsigned __int8 *)(LODWORD(a1) + 6);
      v6 = sub_4089F0(dword_44B658);
      v7 = *(_DWORD *)(LODWORD(a1) + 52);
      *(_DWORD *)(LODWORD(a1) + 32) = *(_DWORD *)(LODWORD(a1) + 44);
      v8 = *(_DWORD *)(LODWORD(a1) + 12) & 0xFF9FFFFE;
      *(_DWORD *)(LODWORD(a1) + 20) = v6;
      v9 = *(_DWORD *)(LODWORD(a1) + 48);
      *(_WORD *)(LODWORD(a1) + 64) = 0;
      *(_DWORD *)(LODWORD(a1) + 36) = v9;
      *(_DWORD *)(LODWORD(a1) + 40) = v7;
      *(_DWORD *)(LODWORD(a1) + 12) = v8 | 0x104020;
      sub_419EC0(SLODWORD(a1), 2);
    }
    v10 = *(_DWORD *)(LODWORD(a1) + 12);
    if ( (v10 & 0x8000) != 0 )
    {
      BYTE1(v10) &= 0x7Fu;
      *(_DWORD *)(LODWORD(a1) + 12) = v10;
      sub_408A30(*(unsigned int **)(LODWORD(a1) + 20));
      dword_44B658 = dword_448AC4 + 48 * *(unsigned __int8 *)(LODWORD(a1) + 6);
      v11 = sub_4089F0(dword_44B658);
      v12 = *(_DWORD *)(LODWORD(a1) + 32);
      v13 = *(_DWORD *)(LODWORD(a1) + 12) & 0xFF9FFFDE;
      *(_DWORD *)(LODWORD(a1) + 20) = v11;
      v14 = *(_DWORD *)(LODWORD(a1) + 36);
      *(_DWORD *)(LODWORD(a1) + 12) = v13 | 0x104000;
      v15 = *(_DWORD *)(LODWORD(a1) + 40);
      *(_WORD *)(LODWORD(a1) + 64) = 0;
      *(_DWORD *)(LODWORD(a1) + 44) = v12;
      *(_DWORD *)(LODWORD(a1) + 48) = v14;
      *(_DWORD *)(LODWORD(a1) + 52) = v15;
      sub_419EC0(SLODWORD(a1), 0);
    }
    v16 = *(_DWORD *)(LODWORD(a1) + 12);
    if ( v16 & 0x800000 && *(_BYTE *)(LODWORD(a1) + 8) != 6 )
    {
      *(_DWORD *)(LODWORD(a1) + 12) = v16 & 0xFF7FFFFF;
      sub_419EC0(SLODWORD(a1), 6);
    }
    v17 = *(_DWORD *)(LODWORD(a1) + 12);
    if ( v17 & 0x100000 && *(_BYTE *)(LODWORD(a1) + 8) != 2 )
    {
      v18 = v17 & 0xFF9FFFFF;
      BYTE1(v18) |= 0x40u;
      *(_DWORD *)(LODWORD(a1) + 12) = v18;
      sub_419EC0(SLODWORD(a1), 2);
    }
    if ( *(_DWORD *)(LODWORD(a1) + 12) & 0x200000 && *(_BYTE *)(LODWORD(a1) + 8) != 1 )
      sub_419EC0(SLODWORD(a1), 1);
    if ( *(_DWORD *)(LODWORD(a1) + 12) & 0x400000 && *(_BYTE *)(LODWORD(a1) + 8) != 5 )
    {
      *(_DWORD *)(*(_DWORD *)(LODWORD(a1) + 20) + 4) = 0;
      v19 = *(_DWORD *)(LODWORD(a1) + 48);
      v20 = *(_DWORD *)(LODWORD(a1) + 52);
      *(_DWORD *)(LODWORD(a1) + 32) = *(_DWORD *)(LODWORD(a1) + 44);
      *(_DWORD *)(LODWORD(a1) + 36) = v19;
      *(_DWORD *)(LODWORD(a1) + 40) = v20;
      sub_419EC0(SLODWORD(a1), 5);
    }
    if ( *(_BYTE *)(LODWORD(a1) + 8) == 5 )
    {
      if ( sub_419D60((int)&unk_44492C, (float *)(LODWORD(a1) + 32), 0x1388u) )
      {
        if ( !sub_407E30((AGLSOUNDBUFFER **)&unk_44492C) )
          sub_407E00((int)&unk_44492C);
      }
      else
      {
        sub_407E50((AGLSOUNDBUFFER **)&unk_44492C);
      }
      sub_408670(*(float *)(LODWORD(a1) + 20), 0, 0);
      if ( *(unsigned __int16 *)(LODWORD(a1) + 64) == *(unsigned __int16 *)(dword_44B65C + 2) - 1
        && *(_BYTE *)dword_44B65C & 2 )
      {
        v28 = *(_DWORD *)(LODWORD(a1) + 12);
        *(_DWORD *)(LODWORD(a1) + 16) = 0;
        result = 1;
        *(_DWORD *)(LODWORD(a1) + 12) = v28 & 0xFC807FFF | 0x800020;
        return result;
      }
      if ( *(_WORD *)(LODWORD(a1) + 60) != -1 )
        sub_415E20(a1, 1800.0);
    }
    else if ( *(_BYTE *)(LODWORD(a1) + 8) == 6 )
    {
      v21 = *(_DWORD *)(LODWORD(a1) + 20);
      if ( v21 )
      {
        v22 = *(unsigned __int16 **)(v21 + 184);
        if ( v22 )
        {
          if ( *(unsigned __int16 *)(v21 + 174) == *v22 - 1 )
          {
            v23 = *(unsigned int **)(LODWORD(a1) + 20);
            *(_DWORD *)(LODWORD(a1) + 12) &= 0xFFFFFFFE;
            sub_408A30(v23);
            dword_44B658 = dword_448AC4 + 48 * *(unsigned __int8 *)(LODWORD(a1) + 6);
            v24 = sub_4089F0(dword_44B658);
            v25 = *(_DWORD *)(LODWORD(a1) + 52);
            *(_DWORD *)(LODWORD(a1) + 32) = *(_DWORD *)(LODWORD(a1) + 44);
            v26 = *(_DWORD *)(LODWORD(a1) + 12) & 0xFFBFFFFF;
            *(_DWORD *)(LODWORD(a1) + 20) = v24;
            v27 = *(_DWORD *)(LODWORD(a1) + 48);
            *(_WORD *)(LODWORD(a1) + 64) = 0;
            *(_DWORD *)(LODWORD(a1) + 36) = v27;
            *(_DWORD *)(LODWORD(a1) + 40) = v25;
            *(_DWORD *)(LODWORD(a1) + 12) = v26 | 0x104000;
            sub_419EC0(SLODWORD(a1), 2);
            return 1;
          }
        }
      }
    }
  }
  return 1;
}
// 448AC4: using guessed type int dword_448AC4;
// 44B658: using guessed type int dword_44B658;
// 44B65C: using guessed type int dword_44B65C;
// 455C14: using guessed type char byte_455C14;
// 455CA5: using guessed type char byte_455CA5;
// 455CB0: using guessed type int dword_455CB0;

//----- (00419D60) --------------------------------------------------------
char __cdecl sub_419D60(int a1, float *a2, unsigned int a3)
{
  unsigned int v3; // esi
  double v5; // st7
  double v6; // st6
  float v7; // ST08_4
  double v8; // st7
  double v9; // st7
  int v10; // esi
  float v11; // ST10_4
  double v12; // st7
  float v13; // ST18_4
  float v14; // ST08_4
  double v15; // st7
  float v16; // ST10_4
  double v17; // st7
  signed __int64 v18; // rax
  float v19; // [esp+14h] [ebp-Ch]
  float v20; // [esp+1Ch] [ebp-4h]
  float v21; // [esp+2Ch] [ebp+Ch]

  v3 = a3;
  if ( !a3 )
    return 0;
  v19 = *a2 - *(float *)&dword_448A08;
  v5 = a2[1] - *(float *)&dword_448A0C;
  v6 = a2[2] - *(float *)&dword_448A10;
  v20 = v6;
  v7 = v6 * v20 + v5 * v5 + v19 * v19;
  v21 = AGLSqrt(v7);
  v8 = (double)v3;
  if ( v21 > v8 )
    return 0;
  v9 = 100.0 - v21 * 100.0 / v8;
  if ( v9 == 0.0 )
    return 0;
  v10 = (signed __int64)(v9 * 16383.0 * 0.0099999998);
  v11 = -(*(float *)&dword_448A04 - *(float *)&dword_448A10);
  v12 = *(float *)&dword_4489FC - *(float *)&dword_448A08;
  v13 = v12;
  v14 = v12 * v13 + v11 * v11;
  v15 = 1.0 / AGLSqrt(v14);
  v16 = v15 * v11;
  v17 = (v15 * v13 * v20 + v16 * v19) / v21;
  if ( v17 == 0.0 )
    LODWORD(v18) = 0;
  else
    v18 = (signed __int64)(v17 * 10000.0);
  sub_407C50(a1, v10, v18);
  return 1;
}
// 4489FC: using guessed type int dword_4489FC;
// 448A04: using guessed type int dword_448A04;
// 448A08: using guessed type int dword_448A08;
// 448A0C: using guessed type int dword_448A0C;
// 448A10: using guessed type int dword_448A10;

//----- (00419EC0) --------------------------------------------------------
char __cdecl sub_419EC0(int a1, char a2)
{
  int v2; // eax
  float v3; // ST10_4
  unsigned __int16 v4; // ax
  float v5; // ST10_4
  int v6; // ecx
  unsigned int *v7; // ST10_4
  int v8; // ST20_4
  int v9; // ST24_4
  int v10; // ST28_4
  _BYTE *v11; // eax

  *(_BYTE *)(a1 + 8) = a2;
  LOBYTE(v2) = a2 - 1;
  *(_DWORD *)(a1 + 16) = 0;
  switch ( a2 )
  {
    case 1:
      v3 = *(float *)(a1 + 20);
      *(_DWORD *)(a1 + 12) |= 0x20u;
      LOBYTE(v2) = sub_408670(v3, 0, 0);
      break;
    case 2:
      v4 = *(_WORD *)(a1 + 60);
      *(_DWORD *)(a1 + 12) |= 0x20u;
      dword_44B65C = dword_455C84 + 12 * v4;
      v5 = *(float *)(a1 + 20);
      *(_WORD *)(a1 + 64) = 0;
      LOBYTE(v2) = sub_408670(v5, 0, 0);
      break;
    case 5:
      v6 = *(_DWORD *)(a1 + 12);
      BYTE1(v6) &= 0xBFu;
      *(_WORD *)(a1 + 64) = 0;
      *(_DWORD *)(a1 + 12) = v6;
      sub_415C80(a1);
      v2 = *(_DWORD *)(a1 + 12);
      LOBYTE(v2) = v2 & 0xDF;
      *(_DWORD *)(a1 + 12) = v2;
      break;
    case 6:
      sub_407E50((AGLSOUNDBUFFER **)&unk_44492C);
      sub_407E00((int)&unk_44495C);
      v7 = *(unsigned int **)(a1 + 20);
      *(_DWORD *)(a1 + 12) |= 1u;
      sub_408A30(v7);
      dword_44B658 = dword_448AC4 + 48 * *(unsigned __int8 *)(a1 + 7);
      v8 = *(_DWORD *)(a1 + 32);
      v9 = *(_DWORD *)(a1 + 36);
      v10 = *(_DWORD *)(a1 + 40);
      v11 = sub_4089F0(dword_44B658);
      *(_DWORD *)(a1 + 20) = v11;
      *((_DWORD *)v11 + 23) = v8;
      *(_DWORD *)(*(_DWORD *)(a1 + 20) + 96) = v9;
      *(_DWORD *)(*(_DWORD *)(a1 + 20) + 100) = v10;
      LOBYTE(v2) = sub_408670(*(float *)(a1 + 20), 0, 3);
      break;
    default:
      return v2;
  }
  return v2;
}
// 448AC4: using guessed type int dword_448AC4;
// 44B658: using guessed type int dword_44B658;
// 44B65C: using guessed type int dword_44B65C;
// 455C84: using guessed type int dword_455C84;

//----- (0041A540) --------------------------------------------------------
void sub_41A540()
{
  int v0; // eax
  char v1; // cl
  int v2; // edx

  v0 = dword_44EAAC;
  if ( *(_BYTE *)(dword_44EAAC + 506) )
    dword_44EAB8 = *(_DWORD *)(dword_44EAAC + 4 * *(unsigned __int8 *)(dword_44EAAC + 508) + 184);
  v1 = *(_BYTE *)(dword_44EAAC + 182);
  if ( v1 == 2 )
  {
    if ( *(_BYTE *)(dword_44EAAC + 510) >= 0x32u )
    {
      *(_BYTE *)(dword_44EAAC + 182) = 0;
      v0 = dword_44EAAC;
    }
    ++*(_BYTE *)(v0 + 510);
  }
  else
  {
    sub_431E70(*(_BYTE *)(dword_44EAAC + 180), v1);
    if ( word_44B690[(unsigned __int8)dword_44B660] == -1 )
      sub_41ADA0();
    LOWORD(v2) = word_44B690[(unsigned __int8)dword_44B660];
    if ( word_44EA94 != (_WORD)v2
      || fabs(*(float *)(LODWORD(dword_44EAB0) + 32) - flt_44B668[3 * (unsigned __int8)dword_44B660]) >= 100.0 )
    {
      sub_42F360(v2, 12 * (unsigned __int8)dword_44B660 + 4503144, 0.0, 0.0);
    }
    else
    {
      word_44B690[(unsigned __int8)dword_44B660] = -1;
      *(_BYTE *)(dword_44EAAC + 182) = 2;
      *(_BYTE *)(dword_44EAAC + 510) = 0;
    }
  }
}
// 44B660: using guessed type int dword_44B660;
// 44EA94: using guessed type __int16 word_44EA94;
// 44EAB8: using guessed type int dword_44EAB8;

//----- (0041A640) --------------------------------------------------------
void sub_41A640()
{
  int v0; // edx
  __int16 v1; // ax

  if ( *(_BYTE *)(dword_44EAAC + 506) )
    dword_44EAB8 = *(_DWORD *)(dword_44EAAC + 4 * *(unsigned __int8 *)(dword_44EAAC + 508) + 184);
  sub_431E70(*(_BYTE *)(dword_44EAAC + 180), *(_BYTE *)(dword_44EAAC + 182));
  v1 = word_44B690[(unsigned __int8)dword_44B660];
  if ( v1 == -1 || v1 != (_WORD)dword_44B838 )
    sub_41AE60();
  LOWORD(v0) = word_44B690[(unsigned __int8)dword_44B660];
  if ( word_44EA94 != (_WORD)v0
    || fabs(*(float *)(LODWORD(dword_44EAB0) + 32) - flt_44B668[3 * (unsigned __int8)dword_44B660]) >= 512.0 )
  {
    sub_42F360(v0, 12 * (unsigned __int8)dword_44B660 + 4503144, 0.0, 0.0);
  }
  else
  {
    word_44B690[(unsigned __int8)dword_44B660] = -1;
    *(_BYTE *)(dword_44EAAC + 182) = 2;
    *(_BYTE *)(dword_44EAAC + 510) = 0;
  }
}
// 44B660: using guessed type int dword_44B660;
// 44B838: using guessed type int dword_44B838;
// 44EA94: using guessed type __int16 word_44EA94;
// 44EAB8: using guessed type int dword_44EAB8;

//----- (0041A720) --------------------------------------------------------
void sub_41A720()
{
  float v0; // esi
  float v1; // eax
  unsigned __int16 *v2; // ecx
  bool v3; // dl
  int v4; // eax
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // edx
  int v9; // ecx
  double v10; // st7
  int v11; // edx
  float v12; // [esp+8h] [ebp-Ch]
  int v13; // [esp+Ch] [ebp-8h]
  int v14; // [esp+10h] [ebp-4h]

  *(_DWORD *)LODWORD(dword_44EAB0) = *(_DWORD *)(dword_44EAB4 + 20);
  if ( !*(_DWORD *)LODWORD(dword_44EAB0) )
    return;
  *(_DWORD *)(LODWORD(dword_44EAB0) + 168) = *(_DWORD *)(*(_DWORD *)LODWORD(dword_44EAB0) + 180)
                                           + 236
                                           * *(signed __int16 *)(dword_44EB48
                                                               + 2 * *(unsigned __int8 *)(dword_44EAAC + 181));
  v0 = dword_44EAB0;
  if ( *(_DWORD *)LODWORD(dword_44EAB0) && byte_455C14 )
  {
    sub_4083F0(*(int **)LODWORD(dword_44EAB0));
    v0 = dword_44EAB0;
  }
  v1 = *(float *)LODWORD(v0);
  v3 = 0;
  if ( *(_DWORD *)LODWORD(v0) )
  {
    v2 = *(unsigned __int16 **)(LODWORD(v1) + 184);
    if ( v2 )
    {
      if ( *(unsigned __int16 *)(LODWORD(v1) + 174) == *v2 - 1 )
        v3 = 1;
    }
  }
  v4 = dword_44EAB4;
  v5 = *(_DWORD *)(dword_44EAB4 + 12);
  if ( v5 & 0x400000 )
  {
    if ( !(v5 & 1) )
    {
      sub_4315A0();
      *(_DWORD *)(dword_44EAB4 + 12) |= 1u;
      sub_408670(*(float *)LODWORD(dword_44EAB0), 8, 3);
      return;
    }
    if ( v3 )
    {
      *(_DWORD *)(dword_44EAB4 + 12) = v5 & 0xFFBFFFFE;
      *(_DWORD *)(dword_44EAB4 + 12) &= 0xF7FFFFFF;
      v0 = dword_44EAB0;
      v4 = dword_44EAB4;
    }
    else if ( *(_DWORD *)(*(_DWORD *)(dword_44EAB4 + 20) + 184) )
    {
      return;
    }
  }
  v6 = *(_DWORD *)(v4 + 12);
  if ( v6 & 0x200000 )
  {
    if ( !(v6 & 8) )
    {
      sub_4315A0();
      *(_DWORD *)(dword_44EAB4 + 12) |= 8u;
      sub_408670(*(float *)LODWORD(dword_44EAB0), 7, 3);
      return;
    }
    if ( v3 )
    {
      *(_DWORD *)(v4 + 12) = v6 & 0xFFDFFFF7;
      *(_DWORD *)(dword_44EAB4 + 12) &= 0xF7FFFFFF;
      v0 = dword_44EAB0;
      v4 = dword_44EAB4;
    }
    else if ( *(_DWORD *)(*(_DWORD *)(v4 + 20) + 184) )
    {
      return;
    }
  }
  if ( byte_44EA9B )
  {
    sub_4315A0();
    *(_DWORD *)(dword_44EAB4 + 12) |= 0x40u;
    sub_408670(*(float *)LODWORD(dword_44EAB0), 6, 3);
    return;
  }
  v7 = *(_DWORD *)(v4 + 12);
  if ( !(v7 & 0x40) )
    goto LABEL_28;
  if ( v3 )
  {
    *(_DWORD *)(v4 + 12) = v7 & 0xFFFFFFBF;
    v0 = dword_44EAB0;
    v4 = dword_44EAB4;
    goto LABEL_28;
  }
  v9 = *(_DWORD *)(v4 + 20);
  if ( !*(_DWORD *)(v9 + 184) )
  {
LABEL_28:
    if ( *(_BYTE *)(LODWORD(v0) + 112) )
    {
      if ( byte_44EA9A )
      {
        sub_4315A0();
        v8 = *(_DWORD *)(dword_44EAB4 + 12);
        LOBYTE(v8) = v8 | 0x80;
        *(_DWORD *)(dword_44EAB4 + 12) = v8;
        if ( *(_DWORD *)(LODWORD(dword_44EAB0) + 164) )
          sub_408670(*(float *)LODWORD(dword_44EAB0), 10, 0);
        else
          sub_408670(*(float *)LODWORD(dword_44EAB0), 3, 0);
      }
      else if ( *(_BYTE *)(v4 + 12) >= 0 )
      {
        sub_4315A0();
        v11 = *(_DWORD *)(dword_44EAB4 + 12);
        LOBYTE(v11) = v11 | 0x80;
        *(_DWORD *)(dword_44EAB4 + 12) = v11;
        if ( *(_DWORD *)(LODWORD(dword_44EAB0) + 164) )
          sub_408670(*(float *)LODWORD(dword_44EAB0), 11, 3);
        else
          sub_408670(*(float *)LODWORD(dword_44EAB0), 4, 3);
      }
      else if ( v3 )
      {
        if ( *(_DWORD *)(LODWORD(v0) + 164) )
          sub_408670(*(float *)LODWORD(v0), 11, 3);
        else
          sub_408670(*(float *)LODWORD(v0), 4, 3);
      }
    }
    else if ( byte_44EA98 || byte_44EA99 )
    {
      sub_4315A0();
      if ( *(_DWORD *)(LODWORD(dword_44EAB0) + 164) )
        sub_408670(*(float *)LODWORD(dword_44EAB0), 9, 3);
      else
        sub_408670(*(float *)LODWORD(dword_44EAB0), 2, 3);
    }
    else if ( *(float *)(LODWORD(v0) + 72) == 0.0 )
    {
      sub_4315A0();
      sub_408670(*(float *)LODWORD(dword_44EAB0), 0, 3);
    }
    return;
  }
  if ( *(_WORD *)(v9 + 174) == 10 )
  {
    v13 = *(_DWORD *)(*(_DWORD *)(LODWORD(v0) + 168) + 96);
    v14 = *(_DWORD *)(*(_DWORD *)(LODWORD(v0) + 168) + 100);
    if ( *(float *)(LODWORD(v0) + 32) >= (double)dword_44B73C )
      v10 = *(float *)(*(_DWORD *)(LODWORD(v0) + 168) + 92) - 2048.0;
    else
      v10 = *(float *)(*(_DWORD *)(LODWORD(v0) + 168) + 92) + 2048.0;
    v12 = v10;
    sub_4194A0((int *)(*(_DWORD *)(LODWORD(v0) + 168) + 92), (int *)&v12, 2802, 0);
    sub_407E00((int)&dword_444944);
  }
}
// 444944: using guessed type int dword_444944;
// 44EA98: using guessed type char byte_44EA98;
// 44EA99: using guessed type char byte_44EA99;
// 44EA9A: using guessed type char byte_44EA9A;
// 44EA9B: using guessed type char byte_44EA9B;
// 44EAB4: using guessed type int dword_44EAB4;
// 44EB48: using guessed type int dword_44EB48;
// 455C14: using guessed type char byte_455C14;

//----- (0041AB30) --------------------------------------------------------
void __cdecl sub_41AB30(float *a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4)
{
  float v4; // ST04_4
  double v5; // st7

  v4 = -(double)a3;
  sub_42CDC0(SLODWORD(dword_44EAB0), v4);
  v5 = (double)a2;
  *(float *)(LODWORD(dword_44EAB0) + 124) = v5;
  *(float *)(LODWORD(dword_44EAB0) + 128) = (double)a4;
  if ( *(float *)(LODWORD(dword_44EAB0) + 32) >= (double)*a1 )
  {
    *(float *)(LODWORD(dword_44EAB0) + 72) = v5;
    byte_44EA98 = 1;
    byte_44EA99 = 0;
  }
  else
  {
    *(float *)(LODWORD(dword_44EAB0) + 72) = -v5;
    byte_44EA98 = 0;
    byte_44EA99 = 1;
  }
}
// 44EA98: using guessed type char byte_44EA98;
// 44EA99: using guessed type char byte_44EA99;

//----- (0041ABD0) --------------------------------------------------------
char __cdecl sub_41ABD0(char a1)
{
  char result; // al
  unsigned __int8 v2; // bl
  int v3; // esi
  int v4; // ecx
  unsigned __int8 v5; // [esp+8h] [ebp-4h]

  result = dword_44EAA8;
  v2 = 0;
  v3 = dword_44EAA4;
  v5 = 0;
  if ( (_BYTE)dword_44EAA8 )
  {
    do
    {
      if ( *(_BYTE *)(v3 + 181) == 1 )
      {
        v4 = *(_DWORD *)(*(_DWORD *)v3 + 12);
        if ( a1 )
        {
          if ( v4 & 0x800000 )
          {
            if ( !byte_455CA9 )
            {
              sub_431610(*(_DWORD *)v3);
              *(_DWORD *)(*(_DWORD *)v3 + 12) &= 0xFF7F3FFF;
              *(_BYTE *)(*(_DWORD *)v3 + 5) = 3;
              word_44B690[v5] = -1;
            }
          }
        }
        else
        {
          *(_DWORD *)(*(_DWORD *)v3 + 12) = v4 | 0x804000;
        }
      }
      result = dword_44EAA8;
      v3 += 552;
      v5 = ++v2;
    }
    while ( v2 < (unsigned __int8)dword_44EAA8 );
  }
  return result;
}
// 44EAA4: using guessed type int dword_44EAA4;
// 44EAA8: using guessed type int dword_44EAA8;
// 455CA9: using guessed type char byte_455CA9;

//----- (0041AC70) --------------------------------------------------------
char __cdecl sub_41AC70(int a1, char a2, float *a3)
{
  int v3; // eax
  int v4; // edx
  int v5; // edx
  int v6; // ecx

  LOBYTE(v3) = a2;
  switch ( a2 )
  {
    case 0:
    case 2:
      LODWORD(dword_44EAB0) = *(_DWORD *)(a1 + 100) + 4;
      sub_41AB30(a3, 0x1388u, 0x1770u, 0x4Bu);
      *(float *)(LODWORD(dword_44EAB0) + 84) = *(float *)(LODWORD(dword_44EAB0) + 84) + 5120.0;
      v4 = *(_DWORD *)(a1 + 12) | 0x300000;
      *(_DWORD *)(a1 + 12) = v4;
      v3 = v4;
      if ( !a2 )
      {
        v5 = *(_DWORD *)(a1 + 100);
        *(_DWORD *)(a1 + 12) = v3 | 0x8000000;
        sub_431CC0(*(_BYTE *)(v5 + 180), 4);
        v3 = *(_DWORD *)(a1 + 12);
        v6 = *(_DWORD *)(a1 + 100);
        LOBYTE(v3) = v3 | 0x20;
        *(_DWORD *)(a1 + 12) = v3;
        byte_44B664[*(unsigned __int8 *)(v6 + 180)] = byte_44EA98;
        LOBYTE(v3) = byte_44EA99;
        byte_44B68C[*(unsigned __int8 *)(*(_DWORD *)(a1 + 100) + 180)] = byte_44EA99;
      }
      break;
    case 1:
      LOBYTE(v3) = a1;
      *(_DWORD *)(a1 + 12) |= 0x804000u;
      break;
    case 3:
      LOBYTE(v3) = a1;
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 12) & 0xFFEFFFFF | 0x804000;
      break;
    default:
      return v3;
  }
  return v3;
}
// 44EA98: using guessed type char byte_44EA98;
// 44EA99: using guessed type char byte_44EA99;

//----- (0041AD70) --------------------------------------------------------
int sub_41AD70()
{
  int v0; // ecx
  signed int v1; // edx
  int result; // eax

  v0 = 0;
  v1 = 3;
  do
  {
    result = *(_DWORD *)(v0 + dword_44EAA4);
    if ( *(int (**)())(result + 28) == sub_41A010 )
      *(_BYTE *)(result + 8) = 1;
    v0 += 552;
    --v1;
  }
  while ( v1 );
  return result;
}
// 41A010: using guessed type int sub_41A010();
// 44EAA4: using guessed type int dword_44EAA4;

//----- (0041ADA0) --------------------------------------------------------
int sub_41ADA0()
{
  int v0; // esi
  unsigned int v1; // ecx
  int v2; // esi
  float *v3; // edi
  float *v4; // ecx
  int v5; // edx
  int result; // eax

  v0 = dword_455C38;
  do
    v1 = (dword_455C3C - 1) * rand() / 0x7FFFu;
  while ( *(_BYTE *)(v0 + 12 * v1) < 0 );
  v2 = v0 + 12 * v1;
  v3 = (float *)(dword_455C20 + 120 * *(unsigned __int8 *)(v2 + 3));
  word_44B690[(unsigned __int8)dword_44B660] = v1;
  if ( rand() / 0x4000 )
    v4 = (float *)(*(_DWORD *)(v2 + 8) + 44);
  else
    v4 = (float *)(*(_DWORD *)(v2 + 8) + 44 * *(unsigned __int8 *)(v2 + 2) - 44);
  v5 = 3 * (unsigned __int8)dword_44B660;
  flt_44B668[v5] = v3[15] + *v4;
  result = 4 * v5 + 4503144;
  *(float *)(result + 4) = v3[16] + v4[1];
  *(float *)(result + 8) = v3[17] + v4[2];
  return result;
}
// 44B660: using guessed type int dword_44B660;
// 455C20: using guessed type int dword_455C20;
// 455C38: using guessed type int dword_455C38;
// 455C3C: using guessed type int dword_455C3C;

//----- (0041AE60) --------------------------------------------------------
_DWORD *sub_41AE60()
{
  int v0; // edx
  _DWORD *result; // eax

  v0 = 3 * (unsigned __int8)dword_44B660;
  word_44B690[(unsigned __int8)dword_44B660] = dword_44B838;
  result = (_DWORD *)(4 * v0 + 4503144);
  *result = dword_44B83C;
  result[1] = dword_44B840;
  result[2] = dword_44B844;
  return result;
}
// 44B660: using guessed type int dword_44B660;
// 44B838: using guessed type int dword_44B838;
// 44B83C: using guessed type int dword_44B83C;
// 44B840: using guessed type int dword_44B840;
// 44B844: using guessed type int dword_44B844;

//----- (0041AEA0) --------------------------------------------------------
char __cdecl sub_41AEA0(int a1)
{
  int *v1; // edx
  int v2; // et1
  int v3; // et1
  double v5; // st7
  unsigned __int8 v6; // c0
  unsigned __int8 v7; // c3

  v1 = *(int **)(dword_455C84 + 12 * *(unsigned __int16 *)(a1 + 60) + 4);
  v2 = *v1;
  v3 = v1[3 * *(unsigned __int16 *)(dword_455C84 + 12 * *(unsigned __int16 *)(a1 + 60) + 2) - 3];
  v5 = *(float *)(a1 + 56);
  if ( v6 | v7 )
  {
    if ( v5 <= 0.0 || *(float *)(a1 + 32) >= (double)flt_44B748 )
    {
      if ( *(float *)(a1 + 56) < 0.0 && *(float *)(a1 + 32) > (double)flt_44B748 )
        return 1;
      return 0;
    }
    return 1;
  }
  if ( v5 < 0.0 && *(float *)(a1 + 32) < (double)flt_44B748
    || *(float *)(a1 + 56) > 0.0 && *(float *)(a1 + 32) > (double)flt_44B748 )
  {
    return 1;
  }
  return 0;
}
// 44B748: using guessed type float flt_44B748;
// 455C84: using guessed type int dword_455C84;

//----- (0041AF60) --------------------------------------------------------
char __cdecl sub_41AF60(float a1)
{
  float v1; // esi
  char v2; // bl
  int v4; // eax
  int v5; // ebp
  int v6; // eax
  int v7; // eax
  int v8; // ecx
  int v9; // ecx
  int v10; // eax
  double v11; // st7
  double v12; // st7
  double v13; // st7
  unsigned int v14; // eax
  int v15; // eax
  int v16; // ecx
  unsigned __int16 *v17; // ecx
  int v18; // ecx
  int v19; // ecx
  int *v20; // eax
  double v22; // st7
  char v23; // c0
  double v24; // st7
  double v25; // st7
  int v26; // eax
  unsigned __int16 *v27; // ecx
  int v28; // ecx
  unsigned int v29; // edx
  unsigned __int8 v30; // al
  unsigned int v31; // eax
  int v32; // ecx
  int v33; // ecx
  unsigned __int16 *v34; // edx
  int v35; // ecx
  unsigned __int16 *v36; // edx
  unsigned int v37; // edx
  int v38; // ecx
  double v39; // st7
  double v41; // st7
  unsigned __int8 v42; // c0
  unsigned __int8 v43; // c3
  double v44; // st7
  char v46; // c0
  int v47; // eax
  int v48; // et1
  double v50; // st7
  char v51; // c0
  int v52; // [esp+10h] [ebp-10h]
  float v53; // [esp+14h] [ebp-Ch]
  int v54; // [esp+18h] [ebp-8h]
  int v55; // [esp+1Ch] [ebp-4h]
  float v56; // [esp+24h] [ebp+4h]

  v1 = a1;
  v2 = 1;
  if ( a1 == 0.0 )
    return 0;
  if ( byte_455CA5 || (_BYTE)dword_455CB0 )
    return 1;
  v4 = *(_DWORD *)(LODWORD(a1) + 20);
  if ( v4 )
  {
    *(_DWORD *)(v4 + 92) = *(_DWORD *)(LODWORD(a1) + 32);
    *(_DWORD *)(*(_DWORD *)(LODWORD(a1) + 20) + 96) = *(_DWORD *)(LODWORD(a1) + 36);
    *(_DWORD *)(*(_DWORD *)(LODWORD(a1) + 20) + 100) = *(_DWORD *)(LODWORD(a1) + 40);
    if ( byte_455C14 )
      sub_4083F0(*(int **)(LODWORD(a1) + 20));
  }
  v5 = dword_455C84 + 12 * *(unsigned __int16 *)(LODWORD(a1) + 60);
  v52 = dword_455C84 + 12 * *(unsigned __int16 *)(LODWORD(a1) + 60);
  if ( !*(_DWORD *)(LODWORD(a1) + 20) && *(_DWORD *)(LODWORD(a1) + 12) & 0x800000 )
  {
    sub_4166E0(SLODWORD(a1));
    return 1;
  }
  v6 = *(_DWORD *)(LODWORD(a1) + 12);
  if ( v6 & 0x400 )
  {
    BYTE1(v6) &= 0xFBu;
    *(_DWORD *)(LODWORD(a1) + 12) = v6;
    if ( !(_BYTE)dword_44B814 )
    {
      sub_416160(SLODWORD(a1));
      *(_DWORD *)(LODWORD(a1) + 12) &= 0x7FFFFFFFu;
    }
  }
  v7 = *(_DWORD *)(LODWORD(a1) + 12);
  if ( v7 & 0x100000 )
  {
    v2 = 0;
    sub_408670(*(float *)(LODWORD(a1) + 20), 4, 0);
    if ( *(_DWORD *)(LODWORD(a1) + 12) < 0 )
    {
      if ( dword_455BF8 != 2 || *(_BYTE *)(LODWORD(a1) + 4) != 4 )
      {
        sub_415C80(SLODWORD(a1));
      }
      else
      {
        if ( !sub_407E30((AGLSOUNDBUFFER **)&unk_44492C) )
          sub_407E00((int)&unk_44492C);
        v2 = 1;
      }
      v8 = *(_DWORD *)(LODWORD(a1) + 12);
      *(_DWORD *)(LODWORD(a1) + 16) = 0;
      *(_DWORD *)(LODWORD(a1) + 12) = v8 & 0xFC017FFF | 0x10000;
    }
    goto LABEL_193;
  }
  if ( (v7 & 0x8000) != 0 )
  {
    *(_WORD *)(LODWORD(a1) + 64) = 0;
    v2 = 0;
    *(_DWORD *)(LODWORD(a1) + 44) = **(_DWORD **)(v5 + 4);
    *(_DWORD *)(LODWORD(a1) + 48) = *(_DWORD *)(*(_DWORD *)(v5 + 4) + 4);
    v9 = *(_DWORD *)(*(_DWORD *)(v5 + 4) + 8);
    *(_DWORD *)(LODWORD(a1) + 12) = v7 & 0xFC017FFF | 0x10000;
    *(_DWORD *)(LODWORD(a1) + 52) = v9;
    *(_DWORD *)(LODWORD(a1) + 16) = 0;
    goto LABEL_193;
  }
  if ( !(v7 & 0x10000) )
  {
    if ( v7 & 0x20000 )
    {
      v2 = 0;
      if ( !*(_DWORD *)(LODWORD(a1) + 16) )
      {
        if ( dword_455BF8 == 7 && !sub_407E30((AGLSOUNDBUFFER **)&unk_44492C) && *(_BYTE *)(LODWORD(a1) + 4) == 4 )
          sub_407E00((int)&unk_44492C);
        sub_408670(*(float *)(LODWORD(a1) + 20), 3, 0);
      }
      v15 = *(_DWORD *)(LODWORD(a1) + 20);
      if ( v15 )
      {
        v17 = *(unsigned __int16 **)(v15 + 184);
        if ( v17 && *(unsigned __int16 *)(v15 + 174) == *v17 - 1 )
        {
          v18 = *(_DWORD *)(LODWORD(a1) + 12);
          *(_DWORD *)(LODWORD(a1) + 16) = 0;
          *(_DWORD *)(LODWORD(a1) + 12) = v18 & 0xFC017FFF | 0x10000;
        }
      }
      else
      {
        v16 = *(_DWORD *)(LODWORD(a1) + 12);
        *(_DWORD *)(LODWORD(a1) + 16) = 0;
        *(_DWORD *)(LODWORD(a1) + 12) = v16 & 0xFC017FFF | 0x10000;
      }
      v19 = *(_DWORD *)(LODWORD(a1) + 16);
      if ( v19 == 38 && v15 )
      {
        if ( dword_455BF8 != 10 )
          goto LABEL_109;
        goto LABEL_104;
      }
      if ( v19 == 10 && dword_455BF8 == 10 )
      {
LABEL_104:
        if ( !sub_407E30((AGLSOUNDBUFFER **)&dword_444920) && *(_BYTE *)(LODWORD(a1) + 4) == 4 )
          sub_407E00((int)&dword_444920);
        if ( dword_455BF8 == 10 )
        {
          v20 = (int *)(*(_DWORD *)(*(_DWORD *)(LODWORD(a1) + 20) + 180) + 6844);
LABEL_110:
          v53 = *((float *)v20 + 23);
          v54 = v20[24];
          v22 = v53;
          v55 = v20[25];
          if ( v23 )
            v24 = v22 - 768.0;
          else
            v24 = v22 + 768.0;
          v53 = v24;
          sub_4194A0(v20 + 23, (int *)&v53, 3300, 0);
          goto LABEL_192;
        }
LABEL_109:
        v20 = (int *)(*(_DWORD *)(*(_DWORD *)(LODWORD(a1) + 20) + 180) + 4720);
        goto LABEL_110;
      }
LABEL_192:
      ++*(_DWORD *)(LODWORD(a1) + 16);
      goto LABEL_193;
    }
    if ( !(v7 & 0x200000) )
    {
      if ( v7 & 0x400000 )
      {
        v2 = 0;
        if ( *(_DWORD *)(LODWORD(a1) + 16) )
        {
          v33 = *(_DWORD *)(LODWORD(a1) + 20);
          if ( v33 )
          {
            v34 = *(unsigned __int16 **)(v33 + 184);
            if ( v34 )
            {
              if ( *(unsigned __int16 *)(v33 + 174) == *v34 - 1 )
              {
                *(_BYTE *)(LODWORD(a1) + 8) = 0;
                *(_DWORD *)(LODWORD(a1) + 16) = 0;
                *(_DWORD *)(LODWORD(a1) + 12) = v7 & 0xF4017FFF | 0x10000;
              }
            }
          }
        }
        else if ( *(_BYTE *)(LODWORD(a1) + 8) )
        {
          *(_DWORD *)(LODWORD(a1) + 56) = *(_DWORD *)(LODWORD(a1) + 88);
          *(_DWORD *)(LODWORD(a1) + 12) = v7 & 0xF4017FFF | 0x10000;
          *(_DWORD *)(LODWORD(a1) + 16) = 0;
          *(_BYTE *)(LODWORD(a1) + 8) = 0;
        }
        else if ( sub_408670(*(float *)(LODWORD(a1) + 20), 2, 1) )
        {
          v32 = *(_DWORD *)(LODWORD(a1) + 12) | 0x8000000;
          *(_DWORD *)(LODWORD(a1) + 16) = dword_455BE0;
          *(_DWORD *)(LODWORD(a1) + 12) = v32;
          if ( dword_455BF8 != 5 || sub_407E30((AGLSOUNDBUFFER **)&unk_44492C) || *(_BYTE *)(LODWORD(a1) + 4) != 4 )
          {
            if ( dword_455BF8 != 7 || sub_407E30((AGLSOUNDBUFFER **)&dword_444920) || *(_BYTE *)(LODWORD(a1) + 4) != 4 )
            {
              if ( !sub_407E30((AGLSOUNDBUFFER **)&unk_4448E4) )
                sub_407E00((int)&unk_4448E4);
            }
            else
            {
              sub_407E00((int)&dword_444920);
            }
          }
          else
          {
            sub_407E00((int)&unk_44492C);
          }
          sub_416990(SLODWORD(a1));
          if ( *(_BYTE *)(LODWORD(a1) + 5) < 1u )
          {
            *(_BYTE *)(LODWORD(a1) + 84) = 0;
            if ( dword_455BF8 == 7 && *(_BYTE *)(LODWORD(a1) + 4) == 4 )
            {
              sub_407E50((AGLSOUNDBUFFER **)&unk_44492C);
              sub_407E50((AGLSOUNDBUFFER **)&dword_444920);
            }
            sub_4166E0(SLODWORD(a1));
          }
        }
        goto LABEL_193;
      }
      if ( v7 & 0x2000000 )
      {
        v35 = *(_DWORD *)(LODWORD(a1) + 20);
        v2 = 1;
        if ( !v35
          || (v36 = *(unsigned __int16 **)(v35 + 184)) != 0 && (v2 = 1, *(unsigned __int16 *)(v35 + 174) == *v36 - 1)
          || !v35 )
        {
          *(_DWORD *)(LODWORD(a1) + 12) = v7 & 0xF7FFFFFF;
          sub_416760(SLODWORD(a1));
          sub_416710(SLODWORD(a1));
          v37 = *(_DWORD *)(LODWORD(a1) + 12) & 0xFC017FFF;
          *(_DWORD *)(LODWORD(a1) + 16) = 0;
          *(_BYTE *)(LODWORD(a1) + 8) = 0;
          *(_DWORD *)(LODWORD(a1) + 12) = v37 | 0x10000;
        }
        goto LABEL_193;
      }
      if ( !(v7 & 0x800000) )
        goto LABEL_193;
      v2 = 0;
      if ( !*(_DWORD *)(LODWORD(a1) + 16) )
      {
        if ( dword_455BF8 == 7 && *(_BYTE *)(LODWORD(a1) + 4) == 4 )
        {
          sub_407E50((AGLSOUNDBUFFER **)&unk_44492C);
          sub_407E50((AGLSOUNDBUFFER **)&dword_444920);
        }
        sub_408670(*(float *)(LODWORD(a1) + 20), 6, 0);
        if ( *(_DWORD *)(LODWORD(a1) + 20) )
          sub_407E00((int)&unk_4448F0);
        dword_44B6A0 = 1123024896;
        v38 = *(_DWORD *)(LODWORD(a1) + 12);
        BYTE1(v38) &= 0xF7u;
        *(_DWORD *)(LODWORD(a1) + 12) = v38 | 0x20;
        v39 = sub_4167F0(SLODWORD(a1));
        flt_44B69C = -1.0;
        if ( v39 >= 0.0 )
          flt_44B69C = 1.0;
        sub_408010(400, *(_DWORD *)(LODWORD(a1) + 20) + 56);
      }
      if ( *(_DWORD *)(LODWORD(a1) + 20) )
      {
        *(float *)(LODWORD(a1) + 32) = *(float *)(LODWORD(a1) + 32) - flt_44B69C * 60.0;
        *(float *)(LODWORD(a1) + 36) = *(float *)(LODWORD(a1) + 36) - *(float *)&dword_44B6A0;
        *(float *)(LODWORD(a1) + 40) = *(float *)(LODWORD(a1) + 40) - 56.0;
        v41 = *(float *)&dword_44B6A0;
        if ( v42 | v43 )
        {
          v44 = v41 - 24.0;
          *(float *)&dword_44B6A0 = v44;
          if ( v46 )
            v44 = -v44;
          if ( v44 > 30720.0 )
            dword_44B6A0 = -957349888;
        }
        else
        {
          *(float *)&dword_44B6A0 = v41 - 40.0;
        }
      }
      goto LABEL_192;
    }
    if ( *(_DWORD *)(LODWORD(a1) + 16) )
    {
LABEL_138:
      v26 = *(_DWORD *)(LODWORD(a1) + 20);
      if ( v26 && (v27 = *(unsigned __int16 **)(v26 + 184)) != 0 && *(unsigned __int16 *)(v26 + 174) == *v27 - 1 )
      {
        v28 = *(_DWORD *)(LODWORD(a1) + 88);
        *(_DWORD *)(LODWORD(a1) + 12) &= 0xF7FFFFFF;
        *(_DWORD *)(LODWORD(a1) + 56) = v28;
        sub_416760(SLODWORD(a1));
        v29 = *(_DWORD *)(LODWORD(a1) + 12) & 0xFC017FFF;
        *(_DWORD *)(LODWORD(a1) + 16) = 0;
        *(_BYTE *)(LODWORD(a1) + 8) = 0;
        *(_DWORD *)(LODWORD(a1) + 12) = v29 | 0x10000;
      }
      else
      {
        sub_416790(SLODWORD(a1), 250.0);
      }
      v30 = *(_BYTE *)(LODWORD(a1) + 5);
      ++*(_DWORD *)(LODWORD(a1) + 16);
      if ( v30 < 1u )
      {
        v2 = 0;
        v31 = *(_DWORD *)(LODWORD(a1) + 12) & 0xFC807FFF;
        *(_BYTE *)(LODWORD(a1) + 84) = 0;
        *(_DWORD *)(LODWORD(a1) + 16) = 0;
        *(_DWORD *)(LODWORD(a1) + 12) = v31 | 0x800000;
      }
      goto LABEL_193;
    }
    if ( *(_BYTE *)(LODWORD(a1) + 8) )
    {
      *(_DWORD *)(LODWORD(a1) + 56) = *(_DWORD *)(LODWORD(a1) + 88);
      *(_DWORD *)(LODWORD(a1) + 12) = v7 & 0xF4017FFF | 0x10000;
      *(_DWORD *)(LODWORD(a1) + 16) = 0;
      *(_BYTE *)(LODWORD(a1) + 8) = 0;
      goto LABEL_138;
    }
    if ( !sub_408670(*(float *)(LODWORD(a1) + 20), 1, 3) )
      goto LABEL_138;
    *(_BYTE *)(LODWORD(a1) + 8) = 1;
    sub_416990(SLODWORD(a1));
    *(_DWORD *)(LODWORD(a1) + 12) |= 0x8000000u;
    if ( dword_455BF8 == 5 )
    {
      if ( !sub_407E30((AGLSOUNDBUFFER **)&unk_44492C) && *(_BYTE *)(LODWORD(a1) + 4) == 4 )
      {
        sub_407E00((int)&unk_44492C);
        goto LABEL_133;
      }
      if ( dword_455BF8 == 5 && !sub_407E30((AGLSOUNDBUFFER **)&dword_444938) && *(_BYTE *)(LODWORD(a1) + 4) == 2 )
      {
        sub_407E00((int)&dword_444938);
LABEL_133:
        v25 = *(float *)(LODWORD(a1) + 56);
        *(_DWORD *)(LODWORD(a1) + 88) = *(_DWORD *)(LODWORD(a1) + 56);
        if ( v25 >= 0.0 )
          *(_DWORD *)(LODWORD(a1) + 56) = 1167867904;
        else
          *(_DWORD *)(LODWORD(a1) + 56) = -979615744;
        if ( sub_41AEA0(SLODWORD(a1)) )
          sub_415C00(SLODWORD(a1));
        goto LABEL_138;
      }
    }
    if ( dword_455BF8 != 7 || sub_407E30((AGLSOUNDBUFFER **)&unk_44492C) || *(_BYTE *)(LODWORD(a1) + 4) != 4 )
    {
      if ( !sub_407E30((AGLSOUNDBUFFER **)&unk_4448E4) )
        sub_407E00((int)&unk_4448E4);
    }
    else
    {
      sub_407E00((int)&unk_44492C);
    }
    goto LABEL_133;
  }
  v2 = 0;
  if ( v7 < 0 )
  {
    if ( *(_DWORD *)(LODWORD(a1) + 16) )
      goto LABEL_57;
    if ( dword_455BF8 == 1 )
    {
      if ( !sub_407E30((AGLSOUNDBUFFER **)&dword_444908) && *(_BYTE *)(LODWORD(a1) + 4) == 8 )
      {
        sub_407E00((int)&dword_444908);
        v10 = *(_DWORD *)(LODWORD(a1) + 12);
        BYTE1(v10) |= 0x20u;
        *(_DWORD *)(LODWORD(a1) + 12) = v10;
      }
      if ( sub_407E30((AGLSOUNDBUFFER **)&dword_444944) || *(_BYTE *)(LODWORD(a1) + 4) != 4 )
        goto LABEL_56;
    }
    else
    {
      if ( dword_455BF8 != 6 )
      {
        if ( dword_455BF8 == 10
          && !sub_407E30((AGLSOUNDBUFFER **)&unk_444998)
          && *(_BYTE *)(LODWORD(a1) + 4) == 4
          && !(_BYTE)dword_455004 )
        {
          sub_407E00((int)&unk_444998);
        }
        goto LABEL_56;
      }
      if ( !sub_407E30((AGLSOUNDBUFFER **)&unk_444968) && *(_BYTE *)(LODWORD(a1) + 4) == 1 )
        sub_407E00((int)&unk_444968);
      if ( !sub_407E30((AGLSOUNDBUFFER **)&dword_444920) && *(_BYTE *)(LODWORD(a1) + 4) == 4 )
        sub_407E00((int)&dword_444920);
      if ( !sub_407E30((AGLSOUNDBUFFER **)&unk_44492C) && *(_BYTE *)(LODWORD(a1) + 4) == 5 )
        sub_407E00((int)&unk_44492C);
      if ( !sub_407E30((AGLSOUNDBUFFER **)&dword_444938) && *(_BYTE *)(LODWORD(a1) + 4) == 6 )
        sub_407E00((int)&dword_444938);
      if ( sub_407E30((AGLSOUNDBUFFER **)&dword_444944) || *(_BYTE *)(LODWORD(a1) + 4) != 7 )
        goto LABEL_56;
    }
    sub_407E00((int)&dword_444944);
LABEL_56:
    *(_DWORD *)(LODWORD(a1) + 16) = dword_455BE0;
LABEL_57:
    if ( dword_455BF8 == 6
      && !sub_407E30((AGLSOUNDBUFFER **)&unk_444974)
      && *(_BYTE *)(LODWORD(a1) + 4) == 8
      && !(_BYTE)dword_455004
      && *(_DWORD *)(LODWORD(a1) + 20) )
    {
      sub_407E00((int)&unk_444974);
    }
    if ( dword_455BF8 == 10
      && !sub_407E30((AGLSOUNDBUFFER **)&dword_444944)
      && *(_BYTE *)(LODWORD(a1) + 4) == 6
      && !(_BYTE)dword_455004
      && *(_DWORD *)(LODWORD(a1) + 20) )
    {
      sub_407E00((int)&dword_444944);
    }
    v2 = 1;
    if ( *(_BYTE *)(LODWORD(a1) + 4) == 4
      && (dword_455BF8 == 7 || dword_455BF8 == 10)
      && sub_416950((float *)LODWORD(a1))
      && !byte_44B812 )
    {
      v11 = dword_44B73C - *(float *)(LODWORD(a1) + 32);
      if ( v11 < 0.0 )
        v11 = -v11;
      if ( v11 <= 3000.0 )
      {
        v12 = dword_44B740 - *(float *)(LODWORD(a1) + 36);
        if ( v12 < 0.0 )
          v12 = -v12;
        if ( v12 <= 100.0 )
        {
          v13 = dword_44B744 - *(float *)(LODWORD(a1) + 40);
          if ( v13 < 0.0 )
            v13 = -v13;
          if ( v13 <= 3000.0 && sub_41F420(&dword_44B73C, (float *)(LODWORD(a1) + 32)) <= 3000.0 )
          {
            flt_44B69C = sub_4167F0(SLODWORD(a1));
            v2 = 0;
            v14 = *(_DWORD *)(LODWORD(a1) + 12) & 0xFC027FFF | 0x20000;
            *(_DWORD *)(LODWORD(a1) + 16) = 0;
            *(_DWORD *)(LODWORD(a1) + 12) = v14;
          }
        }
      }
    }
    sub_408670(*(float *)(LODWORD(a1) + 20), 0, 3);
  }
LABEL_193:
  v47 = *(unsigned __int16 *)(LODWORD(a1) + 64);
  if ( (unsigned __int16)v47 == *(unsigned __int16 *)(v52 + 2) - 1
    && *(_BYTE *)v52 & 2
    && !(_BYTE)dword_44B814
    && sub_41F420((float *)(LODWORD(a1) + 32), (float *)(*(_DWORD *)(v52 + 4) + 12 * v47)) < 100.0 )
  {
    sub_4166E0(SLODWORD(a1));
  }
  if ( *(_WORD *)(LODWORD(a1) + 60) != -1 && v2 )
  {
    v48 = *(_DWORD *)(LODWORD(a1) + 56);
    v50 = *(float *)(LODWORD(a1) + 56);
    if ( v51 )
      v50 = -v50;
    v56 = v50;
    sub_415E20(v1, v56);
  }
  return 1;
}
// 444908: using guessed type int dword_444908;
// 444920: using guessed type int dword_444920;
// 444938: using guessed type int dword_444938;
// 444944: using guessed type int dword_444944;
// 44B69C: using guessed type float flt_44B69C;
// 44B6A0: using guessed type int dword_44B6A0;
// 44B812: using guessed type char byte_44B812;
// 44B814: using guessed type int dword_44B814;
// 455004: using guessed type int dword_455004;
// 455BE0: using guessed type int dword_455BE0;
// 455BF8: using guessed type int dword_455BF8;
// 455C14: using guessed type char byte_455C14;
// 455C84: using guessed type int dword_455C84;
// 455CA5: using guessed type char byte_455CA5;
// 455CB0: using guessed type int dword_455CB0;

//----- (0041BAF0) --------------------------------------------------------
_DWORD *sub_41BAF0()
{
  _DWORD *result; // eax
  float *v1; // esi

  result = sub_40B8D0();
  dword_44B85C = (int)result;
  if ( result )
  {
    v1 = *(float **)(LODWORD(dword_44B71C) + 180);
    sub_40C520((int)result, *(_DWORD *)(LODWORD(dword_44B71C) + 180));
    result = (_DWORD *)sub_40B920(dword_44B85C, v1[23], v1[24], v1[25]);
  }
  return result;
}

//----- (0041BB30) --------------------------------------------------------
bool sub_41BB30()
{
  char v0; // al
  bool result; // al

  result = 0;
  if ( (_BYTE)dword_44B814 )
  {
    if ( dword_44B7C0 )
    {
      v0 = *(_BYTE *)(dword_44B7C0 + 4);
      if ( v0 == 17 || v0 == 18 || v0 == 19 )
        result = 1;
    }
  }
  return result;
}
// 44B7C0: using guessed type int dword_44B7C0;
// 44B814: using guessed type int dword_44B814;

//----- (0041BB60) --------------------------------------------------------
char __cdecl sub_41BB60(char a1)
{
  char result; // al

  result = a1;
  byte_44B78D = 0;
  BYTE1(dword_44B80C) = a1;
  if ( a1 )
    dword_44B764 = 0;
  return result;
}
// 44B764: using guessed type int dword_44B764;
// 44B78D: using guessed type char byte_44B78D;
// 44B80C: using guessed type int dword_44B80C;

//----- (0041BB80) --------------------------------------------------------
char sub_41BB80()
{
  char result; // al

  result = byte_44B78C;
  if ( !byte_44B78C )
  {
    result = 1;
    byte_44B78D = 0;
    byte_44B78F &= 1u;
    if ( (_BYTE)dword_44B814 )
      dword_44B768 = 1151336448;
    dword_44B760 = 281.0;
    byte_44B78E = 1;
  }
  return result;
}
// 44B768: using guessed type int dword_44B768;
// 44B78C: using guessed type char byte_44B78C;
// 44B78D: using guessed type char byte_44B78D;
// 44B78E: using guessed type char byte_44B78E;
// 44B78F: using guessed type char byte_44B78F;
// 44B814: using guessed type int dword_44B814;

//----- (0041BBD0) --------------------------------------------------------
void sub_41BBD0()
{
  byte_44B78E = 0;
  dword_44B768 = 1164967936;
  dword_44B760 = 384.0;
}
// 44B768: using guessed type int dword_44B768;
// 44B78E: using guessed type char byte_44B78E;

//----- (0041BBF0) --------------------------------------------------------
char __cdecl sub_41BBF0(unsigned __int8 a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // eax
  int v3; // esi
  double v4; // st7
  double v5; // st7
  float v6; // ST04_4
  int v7; // esi
  double v8; // st7
  float v10; // [esp+0h] [ebp-10h]
  float v11; // [esp+4h] [ebp-Ch]
  float v12; // [esp+4h] [ebp-Ch]
  float v13; // [esp+8h] [ebp-8h]
  float v14; // [esp+8h] [ebp-8h]

  sub_41F940((int)&dword_44B71C);
  if ( byte_44B802 )
    LOBYTE(dword_455CB0) = 5;
  LOBYTE(v1) = dword_455CB0 - 1;
  switch ( (unsigned __int8)dword_455CB0 )
  {
    case 1u:
      sub_41BB60(3);
      LOBYTE(v1) = dword_455CB0 + 1;
      LOBYTE(dword_455CB0) = dword_455CB0 + 1;
      break;
    case 2u:
      sub_4122C0(0xFFu, 0, byte_44B963);
      if ( (unsigned __int8)byte_44B963 >= 0x28u )
      {
        byte_44B963 = 40;
        dword_44B964 = dword_455BE0;
        LOBYTE(dword_455CB0) = dword_455CB0 + 1;
      }
      else
      {
        byte_44B963 += 4;
      }
      v2 = sub_40B8D0();
      v3 = (int)v2;
      if ( v2 )
      {
        sub_40CAD0((int)v2);
        v4 = dword_44B744;
        if ( dword_455BF8 == 16 )
        {
          v13 = v4 - 500.0;
          v11 = dword_44B740 - 140.0;
          v5 = dword_44B73C - 350.0;
        }
        else
        {
          v13 = v4 - 800.0;
          v11 = dword_44B740 - 250.0;
          v5 = dword_44B73C - 400.0 + *(float *)&dword_4412A4;
        }
        v6 = v5;
        sub_40B920(v3, v6, v11, v13);
      }
      v1 = sub_40B8D0();
      v7 = (int)v1;
      if ( v1 )
      {
        sub_40CD50((int)v1);
        v8 = dword_44B744;
        if ( dword_455BF8 == 16 )
        {
          v14 = v8 - 500.0;
          v12 = dword_44B740 - 140.0;
          v10 = dword_44B73C - 350.0;
        }
        else
        {
          v14 = v8 - 800.0;
          v12 = dword_44B740 - 250.0;
          v10 = dword_44B73C - 400.0 + *(float *)&dword_4412A4;
        }
        LOBYTE(v1) = sub_40B920(v7, v10, v12, v14);
      }
      break;
    case 3u:
      LOBYTE(v1) = sub_4122C0(a1, 0, 0x28u);
      if ( !(_BYTE)v1 || (unsigned int)(dword_455BE0 - dword_44B964) > 0x12C )
      {
        if ( sub_4329B0() == BYTE1(dword_455CB0) )
        {
          LOBYTE(v1) = dword_455CB0 + 1;
          LOBYTE(dword_455CB0) = dword_455CB0 + 1;
        }
        else
        {
          ++BYTE1(dword_455CB0);
          LOBYTE(v1) = dword_455BE0;
          dword_44B964 = dword_455BE0;
        }
      }
      break;
    case 4u:
      sub_4122C0(0xFFu, 0, byte_44B963);
      if ( byte_44B963 )
      {
        LOBYTE(v1) = byte_44B963 - 4;
        byte_44B963 -= 4;
      }
      else
      {
        byte_44B963 = 0;
        LOBYTE(v1) = dword_455CB0 + 1;
        LOBYTE(dword_455CB0) = dword_455CB0 + 1;
      }
      break;
    case 5u:
      LOBYTE(v1) = sub_41BB60(0);
      LOBYTE(dword_455CB0) = 0;
      break;
    default:
      return (char)v1;
  }
  return (char)v1;
}
// 4412A4: using guessed type int dword_4412A4;
// 44B802: using guessed type char byte_44B802;
// 44B963: using guessed type char byte_44B963;
// 44B964: using guessed type int dword_44B964;
// 455BE0: using guessed type int dword_455BE0;
// 455BF8: using guessed type int dword_455BF8;
// 455CB0: using guessed type int dword_455CB0;

//----- (0041BE80) --------------------------------------------------------
char sub_41BE80()
{
  __int16 v0; // ax

  if ( *(_BYTE *)dword_44B730 & 8 )
  {
    byte_44B78D = 0;
    if ( !byte_44B790 )
    {
      sub_41ED70(1u);
      sub_42CBE0((int)&dword_44B71C, 25);
    }
  }
  v0 = *(_WORD *)dword_44B730;
  if ( *(_WORD *)dword_44B730 & 8 )
  {
    if ( v0 & 0x800 )
    {
      LOBYTE(v0) = sub_42CDC0((int)&dword_44B71C, -10000.0);
      dword_44B764 = 0;
    }
    else
    {
      LOBYTE(v0) = sub_42CDC0((int)&dword_44B71C, dword_44B7A4);
    }
  }
  else if ( v0 & 0x800 )
  {
    sub_42CDC0((int)&dword_44B71C, -10000.0);
    dword_44B764 = 0;
    switch ( dword_455BF8 )
    {
      case 3:
      case 5:
        sub_407E00((int)&unk_444974);
        break;
      case 7:
      case 10:
        sub_407E00((int)&unk_44495C);
        break;
      default:
        break;
    }
    LOBYTE(v0) = dword_44B814;
    byte_44B819 = 1;
    if ( !(_BYTE)dword_44B814 )
      LOBYTE(v0) = sub_434530();
    byte_44B962 = 1;
  }
  return v0;
}
// 44B730: using guessed type int dword_44B730;
// 44B764: using guessed type int dword_44B764;
// 44B78D: using guessed type char byte_44B78D;
// 44B790: using guessed type char byte_44B790;
// 44B814: using guessed type int dword_44B814;
// 44B819: using guessed type char byte_44B819;
// 44B962: using guessed type char byte_44B962;
// 455BF8: using guessed type int dword_455BF8;

//----- (0041BF80) --------------------------------------------------------
void sub_41BF80()
{
  signed __int16 v0; // bx
  int v1; // eax
  _DWORD *v2; // eax
  int v3; // ecx
  _DWORD *v4; // eax
  int v5; // ecx
  _DWORD *v6; // eax
  int v7; // eax
  int v8; // eax
  double v9; // st7
  double v10; // st7
  double v11; // st7
  double v12; // st7
  double v14; // st7
  unsigned __int8 v15; // c0
  unsigned __int8 v16; // c3
  double v17; // st7
  double v19; // st7
  unsigned __int8 v20; // c0
  unsigned __int8 v21; // c3
  bool v22; // c3
  double v23; // st7
  bool v24; // c3
  double v25; // st7
  char v26; // al
  int v27; // eax
  double v28; // st7
  float v29; // ST20_4
  double v30; // st6
  signed __int64 v31; // rax
  double v32; // st7
  __int16 v33; // ax
  int v34; // eax
  double v35; // st7
  float v36; // [esp+8h] [ebp-Ch]
  float v37; // [esp+8h] [ebp-Ch]
  int v38; // [esp+10h] [ebp-4h]

  if ( !byte_455C14 && !(_BYTE)dword_455CB0 )
    return;
  byte_44B792 = 0;
  if ( (_WORD)dword_44B784 != -1 )
  {
    if ( sub_42D1A0(COERCE_FLOAT(&dword_44B71C)) )
      return;
  }
  if ( BYTE1(dword_44B80C) == 3 )
  {
    sub_42CC70((int)&dword_44B71C);
    v0 = 0;
  }
  else
  {
    v0 = dword_455BEC;
  }
  if ( dword_44B738 )
  {
    v36 = *(float *)(dword_44B738 + 40);
    if ( v36 == 0.0 )
      v36 = 65535.0;
    v1 = *(_DWORD *)(dword_44B728 + 4);
    if ( v1 & 0x100 && !(_BYTE)dword_44B814 )
      v0 = 32;
  }
  else
  {
    v36 = 65535.0;
  }
  if ( !byte_44B78E && (_BYTE)dword_44B814 )
    dword_44B768 = 1164967936;
  if ( (_BYTE)dword_455CB0 )
  {
    sub_41BBF0(BYTE1(dword_455CB0));
    return;
  }
  if ( !(v0 & 0x40) || byte_44B78F )
  {
    LOBYTE(dword_44B80C) = 0;
    if ( byte_44B78E )
    {
      if ( v36 < 384.0 )
        sub_41BB80();
      else
        sub_41BBD0();
    }
  }
  else
  {
    sub_41BB80();
    if ( !(_BYTE)dword_44B814 && !(_BYTE)dword_44B80C )
    {
      LOBYTE(dword_44B80C) = 1;
      HIBYTE(v0) &= 0x7Fu;
    }
  }
  byte_44B810 = (v0 & 0x1000) != 0;
  if ( (_BYTE)dword_44B814 == 1 && dword_455BF8 != 16 )
  {
    if ( byte_44B813 )
    {
      if ( byte_44B78C )
        goto LABEL_63;
      if ( v0 & 0x1000 )
      {
        sub_434530();
        v2 = sub_40B8D0();
        dword_44B850 = (int)v2;
        if ( v2 )
        {
          if ( !byte_44B812 && !byte_44B848 )
          {
            sub_40C370((int)v2, 0);
            byte_44B848 = 1;
            byte_44B790 = 0;
            if ( !sub_407E30((AGLSOUNDBUFFER **)&unk_444800) )
              sub_407E00((int)&unk_444800);
          }
        }
        v0 = 0;
        byte_44B812 = 1;
        dword_44B764 = 0;
        LOWORD(dword_44B7BC) = 0;
        sub_42CC70((int)&dword_44B71C);
        if ( dword_44B7C0 )
        {
          v3 = *(_DWORD *)(dword_44B7C0 + 12);
          BYTE1(v3) |= 0x40u;
          *(_DWORD *)(dword_44B7C0 + 12) = v3;
        }
        goto LABEL_63;
      }
      if ( !byte_44B812 )
        goto LABEL_63;
      if ( !(dword_455BE8 & 0x1000)
        && dword_455BF8 != 5
        && (!dword_44B714 || !(*(_DWORD *)(dword_44B714 + 12) & 0x800000))
        || !(dword_455BE8 & 0x1000) && dword_455BF8 == 5 && (!dword_44B714 || !(*(_BYTE *)(dword_44B714 + 12) & 1)) )
      {
        if ( byte_44B848 )
        {
          v4 = sub_40B8D0();
          dword_44B850 = (int)v4;
          if ( v4 )
          {
            sub_40C370((int)v4, 0);
            byte_44B848 = 0;
          }
        }
        if ( byte_44B812 )
        {
          byte_44B812 = 0;
          sub_407E00((int)&unk_444788);
        }
        if ( dword_44B7C0 && !byte_44B78F )
        {
          v5 = *(_DWORD *)(dword_44B7C0 + 12);
          BYTE1(v5) &= 0xBFu;
          *(_DWORD *)(dword_44B7C0 + 12) = v5;
        }
        goto LABEL_63;
      }
    }
    else
    {
      if ( !byte_44B812 )
        goto LABEL_63;
      v6 = sub_40B8D0();
      dword_44B850 = (int)v6;
      if ( v6 )
      {
        sub_40C370((int)v6, 0);
        byte_44B848 = 0;
      }
      byte_44B812 = 0;
      dword_44B764 = 0;
    }
    v0 = 0;
  }
LABEL_63:
  if ( dword_455CAC & 0x20 )
  {
    BYTE2(dword_44B80C) = 0;
    goto LABEL_70;
  }
  if ( BYTE2(dword_44B80C) == 1 )
  {
    LOBYTE(v0) = v0 & 0x7F;
  }
  else
  {
    if ( BYTE2(dword_44B80C) != 2 )
      goto LABEL_70;
    v0 &= 0xFFDFu;
  }
  dword_44B764 = 0;
  dword_44B79C = 0;
LABEL_70:
  if ( byte_44B803 )
  {
    if ( byte_44B803 == 1 )
    {
      if ( *(float *)&dword_44B764 < 0.0 )
        dword_44B764 = -1006632960;
      v7 = dword_455BEC;
      v0 &= 0xFFDFu;
      LOBYTE(v7) = dword_455BEC & 0xDF | 0x80;
      LOBYTE(v0) = v0 | 0x80;
      dword_455BEC = v7;
    }
    else
    {
      if ( *(float *)&dword_44B764 > 0.0 )
        dword_44B764 = 1140850688;
      v8 = dword_455BEC;
      LOBYTE(v0) = v0 & 0x7F;
      LOBYTE(v8) = dword_455BEC & 0x7F | 0x20;
      v0 |= 0x20u;
      dword_455BEC = v8;
    }
  }
  if ( (v0 & 0x80u) != 0 )
  {
    sub_41FA40();
    dword_44B79C = 0;
    if ( byte_44B78C )
    {
      v9 = *(float *)&dword_44B764 - 640.0;
    }
    else if ( byte_44B78F )
    {
      if ( *(float *)&dword_44B764 >= 50.0 )
      {
        dword_44B764 = 1112014848;
LABEL_89:
        v11 = -*(float *)&dword_44B768;
        if ( *(float *)&dword_44B764 < v11 )
          *(float *)&dword_44B764 = v11;
        if ( byte_44B797 == 1 )
        {
          if ( dword_44B738 )
          {
            sub_42CEF0((int)&dword_44B71C, *(_WORD *)(dword_44B738 + 24) - 2048);
            if ( *(float *)&dword_44B764 > 45.0 && dword_455BF8 != 4 && !byte_44B78C && !byte_44B78D )
              sub_41BAF0();
          }
        }
        byte_44B797 = -1;
        byte_44B78D = 0;
        goto LABEL_99;
      }
      v9 = *(float *)&dword_44B764 * 0.95999998;
    }
    else
    {
      v10 = *(float *)&dword_44B764;
      if ( BYTE1(dword_44B814) )
        v9 = v10 - 192.0;
      else
        v9 = v10 - 768.0;
    }
    *(float *)&dword_44B764 = v9;
    goto LABEL_89;
  }
LABEL_99:
  if ( !(v0 & 0x20) )
    goto LABEL_129;
  sub_41FB00();
  dword_44B79C = 0;
  if ( byte_44B78C )
  {
    if ( !(_BYTE)dword_44B814 )
    {
      dword_44B764 = 1163575296;
      dword_44B768 = 1163575296;
      goto LABEL_121;
    }
    v12 = *(float *)&dword_44B764 + 640.0;
  }
  else if ( byte_44B78F )
  {
    if ( *(float *)&dword_44B764 <= 50.0 )
    {
      dword_44B764 = 1112014848;
      goto LABEL_113;
    }
    v12 = *(float *)&dword_44B764 - *(float *)&dword_44B764 * 0.039999999;
  }
  else if ( BYTE1(dword_44B814) )
  {
    v12 = *(float *)&dword_44B764 + 192.0;
  }
  else
  {
    if ( !(_BYTE)dword_44B814 )
      goto LABEL_116;
    v12 = *(float *)&dword_44B764 + 768.0;
  }
  *(float *)&dword_44B764 = v12;
LABEL_113:
  if ( (_BYTE)dword_44B814 )
  {
    if ( *(float *)&dword_44B764 > (double)*(float *)&dword_44B768 )
      dword_44B764 = dword_44B768;
    goto LABEL_121;
  }
LABEL_116:
  v14 = *(float *)&dword_44B764;
  if ( v15 | v16 )
  {
    if ( v14 >= *(float *)&dword_44B768 )
      goto LABEL_121;
    v17 = *(float *)&dword_44B764 + 200.0;
  }
  else
  {
    v17 = v14 - 200.0;
  }
  *(float *)&dword_44B764 = v17;
LABEL_121:
  if ( byte_44B797 == -1 )
  {
    if ( dword_44B738 )
    {
      sub_42CEF0((int)&dword_44B71C, *(_WORD *)(dword_44B738 + 24));
      if ( *(float *)&dword_44B764 < -45.0 && dword_455BF8 != 4 && !byte_44B78C && !byte_44B78D )
        sub_41BAF0();
    }
  }
  byte_44B797 = 1;
  byte_44B78D = 0;
LABEL_129:
  if ( !(v0 & 0xA0) )
  {
    v19 = *(float *)&dword_44B764;
    if ( v20 | v21 )
    {
      if ( v19 >= 0.0 )
      {
        dword_44B79C = 0;
      }
      else
      {
        if ( *(float *)&dword_44B764 <= -3840.0 || (v24 = *(float *)&dword_44B79C == 0.0, dword_44B79C = 0, !v24) )
          dword_44B79C = 1065353216;
        if ( byte_44B78F || !BYTE1(dword_44B814) )
          v25 = *(float *)&dword_44B764 + 768.0;
        else
          v25 = *(float *)&dword_44B764 + 192.0;
        *(float *)&dword_44B764 = v25;
        if ( BYTE1(dword_44B814) )
        {
          if ( !byte_44B78C )
          {
            dword_44B79C = 1065353216;
            if ( !sub_407E30((AGLSOUNDBUFFER **)&unk_44480C) )
              sub_407E00((int)&unk_44480C);
          }
        }
        if ( *(float *)&dword_44B764 > 0.0 )
          dword_44B764 = 0;
      }
    }
    else
    {
      if ( v19 >= 3840.0 || (v22 = *(float *)&dword_44B79C == 0.0, dword_44B79C = 0, !v22) )
        dword_44B79C = 1065353216;
      v23 = *(float *)&dword_44B764;
      if ( BYTE1(dword_44B814) )
      {
        *(float *)&dword_44B764 = v23 - 192.0;
        if ( !byte_44B78C )
        {
          dword_44B79C = 1065353216;
          if ( !sub_407E30((AGLSOUNDBUFFER **)&unk_44480C) && !byte_44B78C )
            sub_407E00((int)&unk_44480C);
        }
      }
      else
      {
        *(float *)&dword_44B764 = v23 - 768.0;
      }
      if ( *(float *)&dword_44B764 < 0.0 )
        dword_44B764 = 0;
    }
    sub_41F940((int)&dword_44B71C);
  }
  if ( dword_455BF8 != 16
    && v0 < 0
    && (_BYTE)dword_44B814
    && !byte_44B78F
    && !byte_44B791
    && !byte_44B78D
    && !byte_44B78E
    && !(_BYTE)dword_44B7BC )
  {
    sub_42CC10((int)&dword_44B71C);
    sub_404910(0, 0x8000);
  }
  if ( !(v0 & 0x4000) || (_BYTE)dword_44B7BC )
  {
    if ( byte_44B819 )
    {
      if ( sub_407E30((AGLSOUNDBUFFER **)&unk_444818) )
        sub_407E50((AGLSOUNDBUFFER **)&unk_444818);
      byte_44B819 = 0;
      byte_44B791 = 0;
      if ( !byte_44B794 && byte_44B78C == 1 && *(float *)&dword_44B76C < 0.0 )
        *(float *)&dword_44B76C = *(float *)&dword_44B76C - *(float *)&dword_44B76C * 0.125;
    }
  }
  else if ( byte_44B78C )
  {
    if ( byte_44B794 || byte_44B819 || byte_44B791 || byte_44B78F || byte_44B962 )
    {
      if ( (_BYTE)dword_44B814 )
        byte_44B819 = 1;
    }
    else
    {
      byte_44B791 = 1;
      if ( (_BYTE)dword_44B814 && !sub_407E30((AGLSOUNDBUFFER **)&unk_444818) )
        sub_407E00((int)&unk_444818);
      v0 &= 0x5A9u;
      byte_44B819 = 1;
      byte_44B962 = 1;
      byte_44B78C = 0;
      sub_42CD40((int)&dword_44B71C, -3600.0);
    }
  }
  else if ( v36 >= 384.0 )
  {
    if ( dword_44B730 && *(_BYTE *)(dword_44B730 + 1) & 8 )
    {
      byte_44B794 = 0;
      sub_42CD40((int)&dword_44B71C, -10000.0);
    }
    else
    {
      sub_42CD40((int)&dword_44B71C, dword_44B7A4);
    }
    v26 = rand();
    sub_407E00(12 * (unsigned __int8)(-3 * v26) + 4474952);
    byte_44B819 = 1;
    byte_44B962 = !(_BYTE)dword_44B814 && (sub_434530(), !(_BYTE)dword_44B814);
  }
  if ( v0 & 0x2000 && !(_BYTE)dword_44B7BC && !byte_44B78F && !byte_44B78D && (_BYTE)dword_44B814 && dword_455BF8 != 16 )
  {
    if ( dword_455BF8 == 8 )
    {
      v37 = 256.0;
      if ( dword_44B7C0 )
      {
        sub_4151B0((int)&dword_44B71C, 128.0, 1, (int)&v38, 0);
        goto LABEL_208;
      }
    }
    else
    {
      v37 = fabs(*(float *)&dword_44B764) * 664.0 / *(float *)&dword_44B768 + 256.0;
    }
    sub_4151B0((int)&dword_44B71C, v37, 1, (int)&v38, 0);
LABEL_208:
    if ( BYTE1(dword_44B7BC) )
    {
      LOBYTE(dword_44B7BC) = 1;
      sub_404910(0, 0x2000);
    }
  }
  sub_4155C0((int)&dword_44B71C);
  if ( v0 & 0xF0E0 || byte_44B78C || byte_44B78F )
    word_44B7F2 = 0;
  else
    ++word_44B7F2;
  if ( dword_44B738 )
  {
    flt_44B74C = dword_44B740;
    flt_44B748 = dword_44B73C;
    dword_44B77C = dword_44B778;
    flt_44B750 = dword_44B744;
    dword_44B774 = LODWORD(flt_44B770);
    v27 = 4 * (*(_WORD *)(dword_44B738 + 24) & 0xFFF);
    v28 = -*(float *)((char *)dword_4449D8 + v27);
    v29 = *(float *)((char *)dword_4449D4 + v27);
    v30 = *(float *)&dword_44B764 * 5.1199999 * 0.00390625 + *(float *)&dword_44B778;
    *(float *)&dword_44B778 = v30;
    dword_44B73C = v30 * v28
                 + *(float *)(dword_44B728 + 60)
                 + (double)(signed int)(signed __int64)*(float *)dword_44B738;
    dword_44B744 = *(float *)&dword_44B778 * v29
                 + (double)(signed int)(signed __int64)*(float *)(dword_44B738 + 8)
                 + *(float *)(dword_44B728 + 68);
    v31 = (signed __int64)*(float *)(dword_44B738 + 4);
    flt_44B770 = *(float *)&dword_44B778
               * *(float *)(dword_44B738 + 36)
               / *(float *)(dword_44B738 + 32)
               * *(float *)(dword_44B738 + 16)
               + (double)(signed int)v31
               + *(float *)(dword_44B728 + 64);
    if ( !byte_44B78C )
    {
      dword_44B740 = flt_44B770;
      goto LABEL_241;
    }
    if ( byte_44B791 != 1 || *(float *)&dword_44B76C <= 0.0 )
    {
      v32 = *(float *)&dword_44B76C + 614.40002;
      *(float *)&dword_44B76C = v32;
      if ( v32 > 30720.0 )
        dword_44B76C = 1190133760;
    }
    else
    {
      dword_44B76C = 1158227090;
    }
    dword_44B740 = *(float *)&dword_44B76C * 5.1199999 * 0.00390625 + dword_44B740;
    if ( dword_44B734 == -1 )
      goto LABEL_242;
    if ( dword_44B740 < (double)flt_44B770 )
    {
      if ( !sub_42DAD0(dword_44B738, dword_44B740, flt_44B770, dword_44B760) )
      {
        if ( *(float *)&dword_44B76C < 0.0 )
          dword_44B76C = 0;
        dword_44B764 = 0;
        v35 = flt_44B770 - *(float *)(dword_44B738 + 40);
        dword_44B73C = flt_44B748;
        HIWORD(v31) = HIWORD(dword_44B778);
        dword_44B744 = flt_44B750;
        LODWORD(flt_44B770) = dword_44B774;
        dword_44B77C = dword_44B778;
        dword_44B740 = v35 + dword_44B760;
      }
      goto LABEL_242;
    }
    v33 = *(_WORD *)dword_44B730;
    if ( *(_WORD *)dword_44B730 & 0x120 )
    {
LABEL_242:
      if ( (_BYTE)dword_44B814 == 1 && dword_455BF8 != 16 )
      {
        WORD2(v31) = *(_WORD *)dword_44B730;
        BYTE1(dword_44B814) = (HIDWORD(v31) >> 10) & 1;
      }
      return;
    }
    if ( v33 & 4 )
    {
      if ( !byte_44B793 )
      {
        sub_407E00((int)&unk_44486C);
        byte_44B811 = 1;
        sub_41ED70(0xFFu);
      }
      goto LABEL_242;
    }
    if ( v33 & 0x800 )
      goto LABEL_235;
    if ( (_BYTE)dword_44B814 )
    {
      if ( dword_455BEC & 0x4000 )
      {
        if ( !byte_44B819 )
        {
          sub_42CDE0((int)&dword_44B71C);
LABEL_241:
          sub_41BE80();
          goto LABEL_242;
        }
        goto LABEL_234;
      }
    }
    else if ( byte_44B819 )
    {
LABEL_234:
      sub_404910(0, 0x4000);
      v34 = dword_455BEC;
      BYTE1(v34) &= 0xBFu;
      dword_455BEC = v34;
      goto LABEL_235;
    }
LABEL_235:
    sub_42CDE0((int)&dword_44B71C);
    goto LABEL_241;
  }
}
// 44B714: using guessed type int dword_44B714;
// 44B728: using guessed type int dword_44B728;
// 44B730: using guessed type int dword_44B730;
// 44B734: using guessed type int dword_44B734;
// 44B748: using guessed type float flt_44B748;
// 44B74C: using guessed type float flt_44B74C;
// 44B750: using guessed type float flt_44B750;
// 44B764: using guessed type int dword_44B764;
// 44B768: using guessed type int dword_44B768;
// 44B76C: using guessed type int dword_44B76C;
// 44B774: using guessed type int dword_44B774;
// 44B778: using guessed type int dword_44B778;
// 44B77C: using guessed type int dword_44B77C;
// 44B784: using guessed type int dword_44B784;
// 44B78C: using guessed type char byte_44B78C;
// 44B78D: using guessed type char byte_44B78D;
// 44B78E: using guessed type char byte_44B78E;
// 44B78F: using guessed type char byte_44B78F;
// 44B790: using guessed type char byte_44B790;
// 44B791: using guessed type char byte_44B791;
// 44B792: using guessed type char byte_44B792;
// 44B793: using guessed type char byte_44B793;
// 44B794: using guessed type char byte_44B794;
// 44B797: using guessed type char byte_44B797;
// 44B79C: using guessed type int dword_44B79C;
// 44B7BC: using guessed type int dword_44B7BC;
// 44B7C0: using guessed type int dword_44B7C0;
// 44B7F2: using guessed type __int16 word_44B7F2;
// 44B803: using guessed type char byte_44B803;
// 44B80C: using guessed type int dword_44B80C;
// 44B810: using guessed type char byte_44B810;
// 44B811: using guessed type char byte_44B811;
// 44B812: using guessed type char byte_44B812;
// 44B813: using guessed type char byte_44B813;
// 44B814: using guessed type int dword_44B814;
// 44B819: using guessed type char byte_44B819;
// 44B848: using guessed type char byte_44B848;
// 44B850: using guessed type int dword_44B850;
// 44B962: using guessed type char byte_44B962;
// 455BE8: using guessed type int dword_455BE8;
// 455BEC: using guessed type int dword_455BEC;
// 455BF8: using guessed type int dword_455BF8;
// 455C14: using guessed type char byte_455C14;
// 455CAC: using guessed type int dword_455CAC;
// 455CB0: using guessed type int dword_455CB0;

//----- (0041CE10) --------------------------------------------------------
char __cdecl sub_41CE10(int a1)
{
  char result; // al

  if ( (unsigned __int8)dword_44B80C == 1 )
  {
    result = sub_408670(dword_44B700, a1 + 18, 0);
    word_44B7F4 = a1 + 18;
  }
  else if ( (unsigned __int8)dword_44B80C == 2 )
  {
    result = sub_408670(dword_44B700, 19, 0);
    word_44B7F4 = 19;
  }
  else
  {
    result = dword_44B80C - 3;
    if ( (unsigned __int8)dword_44B80C == 3 )
    {
      result = sub_408670(dword_44B700, a1 + 20, 0);
      word_44B7F4 = a1 + 20;
    }
  }
  return result;
}
// 44B7F4: using guessed type __int16 word_44B7F4;
// 44B80C: using guessed type int dword_44B80C;

//----- (0041CE90) --------------------------------------------------------
void sub_41CE90()
{
  float v0; // edx
  unsigned __int16 *v1; // eax
  signed int v2; // esi
  unsigned __int16 *v3; // eax
  char v4; // al
  __int16 v5; // dx
  int v6; // esi
  _DWORD *v7; // eax
  int v8; // esi
  float v9; // ST14_4
  float v10; // ST10_4
  float v11; // ST0C_4
  _DWORD *v12; // eax
  int v13; // esi
  float v14; // ST14_4
  float v15; // ST10_4
  float v16; // ST0C_4
  int v17; // edi
  signed __int16 v18; // cx
  char v19; // al
  unsigned __int8 v20; // al
  int v21; // edi
  __int16 v22; // si
  int v23; // edi
  int v24; // edi
  int v25; // edi
  __int16 v26; // si
  unsigned __int16 *v27; // eax
  BOOL v28; // esi
  unsigned __int16 *v29; // eax
  BOOL v30; // eax
  int v31; // eax
  float *v32; // edx
  double v33; // st7
  double v34; // st6
  signed int v35; // [esp+14h] [ebp-8h]
  float v36; // [esp+14h] [ebp-8h]
  signed int v37; // [esp+18h] [ebp-4h]

  if ( !LODWORD(dword_44B700) )
    return;
  v0 = dword_44B71C;
  if ( !LODWORD(dword_44B71C) )
    return;
  v1 = *(unsigned __int16 **)(LODWORD(dword_44B700) + 184);
  v2 = 1;
  if ( !v1 || (v35 = 1, *(unsigned __int16 *)(LODWORD(dword_44B700) + 174) != *v1 - 1) )
    v35 = 0;
  v3 = *(unsigned __int16 **)(LODWORD(dword_44B71C) + 184);
  if ( !v3 || *(unsigned __int16 *)(LODWORD(dword_44B71C) + 174) != *v3 - 1 )
    v2 = 0;
  v37 = v2;
  if ( byte_455C14 )
  {
    if ( dword_455C00 != 255 )
    {
      v4 = *((_BYTE *)&dword_44B81A + dword_455C00);
      if ( !(v4 & 0x10) )
      {
        v5 = *(_WORD *)(LODWORD(dword_44B71C) + 174);
        if ( v5 == 56 || v5 == 70 )
        {
          v7 = sub_40B8D0();
          v8 = (int)v7;
          if ( v7 )
          {
            sub_40CAD0((int)v7);
            if ( *(_WORD *)(LODWORD(dword_44B71C) + 174) == 56 )
            {
              sub_40B920(
                v8,
                *(float *)(dword_44B7C4 + 92),
                *(float *)(dword_44B7C4 + 96),
                *(float *)(dword_44B7C4 + 100));
            }
            else
            {
              v9 = dword_44B744 - 500.0;
              v10 = dword_44B740 - 27.0;
              v11 = dword_44B73C + 220.0;
              sub_40B920(v8, v11, v10, v9);
            }
          }
          v12 = sub_40B8D0();
          v13 = (int)v12;
          if ( v12 )
          {
            sub_40CD50((int)v12);
            if ( *(_WORD *)(LODWORD(dword_44B71C) + 174) == 56 )
            {
              sub_40B920(
                v13,
                *(float *)(dword_44B7C4 + 92),
                *(float *)(dword_44B7C4 + 96),
                *(float *)(dword_44B7C4 + 100));
            }
            else
            {
              v14 = dword_44B744 - 500.0;
              v15 = dword_44B740 - 27.0;
              v16 = dword_44B73C + 220.0;
              sub_40B920(v13, v16, v15, v14);
            }
          }
          if ( *(_WORD *)(LODWORD(dword_44B71C) + 174) == 70 )
            LOBYTE(dword_44B804) = dword_44B804 + 1;
          sub_407E00((int)&dword_444938);
          goto LABEL_151;
        }
        if ( !v2 )
          goto LABEL_151;
        *((_BYTE *)&dword_44B81A + dword_455C00) = v4 | 0x10;
      }
      dword_455C00 = 255;
      sub_41BB60(0);
      v0 = dword_44B71C;
    }
    if ( (_WORD)dword_44B784 != -1 )
    {
      LOWORD(v6) = 3;
      sub_408670(v0, 3, 0);
      word_44B7F6 = 3;
      sub_408670(dword_44B700, 3, 0);
LABEL_150:
      word_44B7F4 = v6;
      goto LABEL_151;
    }
    v6 = dword_44B7C0 != 0 ? 0x1E : 0;
    if ( BYTE1(dword_44B80C) && byte_44B793 != 1 )
    {
      if ( dword_455BF8 != 16 || (_BYTE)dword_455CB0 )
      {
        LOWORD(dword_44B7BC) = 0;
        sub_408670(v0, (unsigned __int16)v6, 1);
        word_44B7F6 = v6;
        sub_408670(dword_44B700, (unsigned __int16)v6, 1);
      }
      else
      {
        v17 = (unsigned __int16)v6 + 1;
        sub_408670(v0, v17, 1);
        LOWORD(v6) = v6 + 1;
        word_44B7F6 = v6;
        sub_408670(dword_44B700, v17, 1);
      }
      goto LABEL_150;
    }
    if ( byte_455CA9 )
    {
      sub_4266C0();
      goto LABEL_151;
    }
    if ( (_BYTE)dword_44B7BC )
    {
      if ( byte_44B78C )
      {
        sub_408670(dword_44B71C, 8, 3);
        v18 = 8;
        word_44B7F6 = 8;
      }
      else if ( *(float *)&dword_44B764 == 0.0 )
      {
        if ( !byte_44B78D || byte_44B78F )
        {
          switch ( BYTE1(dword_44B7BC) )
          {
            case 1u:
              sub_408670(dword_44B71C, 15, 0);
              v18 = 15;
              word_44B7F6 = 15;
              break;
            case 2u:
            case 5u:
              sub_408670(dword_44B71C, 13, 0);
              v18 = 13;
              word_44B7F6 = 13;
              break;
            case 3u:
            case 4u:
              sub_408670(dword_44B71C, 44, 0);
              v18 = 44;
              word_44B7F6 = 44;
              break;
            default:
              v18 = word_44B7F6;
              break;
          }
        }
        else
        {
          sub_408670(dword_44B71C, 12, 0);
          v18 = 12;
          word_44B7F6 = 12;
        }
      }
      else
      {
        sub_408670(dword_44B71C, 3, 0);
        v18 = 3;
        word_44B7F6 = 3;
      }
      switch ( (unsigned __int8)dword_44B7BC )
      {
        case 1u:
          switch ( BYTE1(dword_44B7BC) )
          {
            case 1u:
              sub_408670(dword_44B700, 15, 0);
              word_44B7F4 = 15;
              LOBYTE(dword_44B7BC) = dword_44B7BC + 1;
              break;
            case 2u:
            case 5u:
              sub_408670(dword_44B700, 13, 0);
              word_44B7F4 = 13;
              goto LABEL_56;
            case 3u:
            case 4u:
              sub_408670(dword_44B700, 44, 0);
              word_44B7F4 = 44;
              LOBYTE(dword_44B7BC) = dword_44B7BC + 1;
              break;
            default:
LABEL_56:
              LOBYTE(dword_44B7BC) = dword_44B7BC + 1;
              break;
          }
          goto LABEL_152;
        case 2u:
          if ( !v35 )
            goto LABEL_151;
          if ( dword_455BF8 == 8 )
          {
            v36 = 256.0;
            if ( dword_44B7C0 )
            {
              v19 = sub_415360((int)&dword_44B71C, 128.0, 1, 0);
              goto LABEL_63;
            }
          }
          else
          {
            v36 = fabs(*(float *)&dword_44B764) / *(float *)&dword_44B768 * 256.0 + 256.0;
          }
          v19 = sub_415360((int)&dword_44B71C, v36, 1, 0);
LABEL_63:
          if ( !v19 && BYTE1(dword_44B7BC) != 5 && BYTE1(dword_44B7BC) != 2 )
          {
            BYTE1(dword_44B7BC) = 0;
            goto LABEL_76;
          }
          if ( !dword_44B7C0 )
            goto LABEL_76;
          v20 = *(_BYTE *)(dword_44B7C0 + 4);
          if ( v20 < 0x11u || v20 > 0x13u )
            goto LABEL_76;
          if ( dword_455BF8 )
          {
            if ( dword_455BF8 == 5 && v20 == 17 )
            {
LABEL_76:
              LOBYTE(dword_44B7BC) = dword_44B7BC + 1;
LABEL_77:
              switch ( BYTE1(dword_44B7BC) )
              {
                case 0u:
                  if ( !dword_44B7C0 )
                    goto LABEL_84;
                  sub_408670(dword_44B700, 45, 0);
                  goto LABEL_79;
                case 1u:
                  sub_408670(dword_44B700, 45, 0);
LABEL_79:
                  word_44B7F4 = 45;
                  LOBYTE(dword_44B7BC) = dword_44B7BC + 1;
                  goto LABEL_152;
                case 2u:
                case 5u:
                  sub_408670(dword_44B700, 43, 0);
                  word_44B7F4 = 43;
                  LOBYTE(dword_44B7BC) = dword_44B7BC + 1;
                  goto LABEL_152;
                case 3u:
                  sub_408670(dword_44B700, 14, 0);
                  goto LABEL_85;
                case 4u:
LABEL_84:
                  sub_408670(dword_44B700, 14, 0);
LABEL_85:
                  word_44B7F4 = 14;
                  break;
                default:
                  break;
              }
              LOBYTE(dword_44B7BC) = dword_44B7BC + 1;
              goto LABEL_152;
            }
          }
          else if ( v20 == 17 )
          {
            goto LABEL_76;
          }
          sub_407E80(1);
          goto LABEL_76;
        case 3u:
          goto LABEL_77;
        case 4u:
          if ( !v35 )
            goto LABEL_151;
          LOWORD(dword_44B7BC) = 0;
          if ( !byte_44B78C )
            goto LABEL_91;
          sub_408670(dword_44B700, (unsigned __int16)v6 + 8, 0);
          word_44B7F4 = v6 + 8;
          break;
        default:
          goto LABEL_91;
      }
    }
    v18 = word_44B7F6;
LABEL_91:
    if ( !byte_44B78F && *(float *)&dword_44B79C == 1.0 && !byte_44B78C )
    {
      if ( BYTE1(dword_44B814) && *(float *)&dword_44B764 != 0.0 )
      {
        v21 = (unsigned __int16)v6 + 23;
        sub_408670(dword_44B700, v21, 0);
        v22 = v6 + 23;
      }
      else
      {
        v21 = (unsigned __int16)v6 + 4;
        sub_408670(dword_44B700, v21, 0);
        v22 = v6 + 4;
      }
      word_44B7F4 = v22;
      sub_408670(dword_44B71C, v21, 0);
      word_44B7F6 = v22;
      goto LABEL_151;
    }
    if ( byte_44B793 == 1 )
    {
      LOWORD(v6) = 25;
      sub_408670(dword_44B71C, 25, 3);
      word_44B7F6 = 25;
      sub_408670(dword_44B700, 25, 3);
      goto LABEL_150;
    }
    if ( byte_44B78C )
    {
      if ( !byte_44B78F )
      {
        if ( byte_44B791 )
        {
          if ( LODWORD(dword_44B708) )
            sub_4083F0((int *)LODWORD(dword_44B708));
          sub_408670(dword_44B71C, 21, 3);
          word_44B7F6 = 21;
          sub_408670(dword_44B700, (unsigned __int16)v6 + 21, 3);
          LOWORD(v6) = v6 + 21;
        }
        else if ( v18 == 7 && v37 || word_44B7F4 == 16 || word_44B7F4 == 45 )
        {
          sub_408670(dword_44B71C, 8, 3);
          word_44B7F6 = 8;
          sub_408670(dword_44B700, (unsigned __int16)v6 + 8, 3);
          LOWORD(v6) = v6 + 8;
        }
        else
        {
          if ( v18 == 7 || v18 == 8 || *(float *)&dword_44B76C > 0.0 )
          {
            if ( byte_44B794 && *(float *)&dword_44B76C <= 0.0 && v18 != 7 )
            {
              sub_408670(dword_44B71C, 7, 0);
              word_44B7F6 = 7;
              sub_408670(dword_44B700, (unsigned __int16)v6 + 7, 0);
              word_44B7F4 = v6 + 7;
              byte_44B794 = 0;
            }
            goto LABEL_151;
          }
          sub_408670(dword_44B71C, 7, 0);
          word_44B7F6 = 7;
          sub_408670(dword_44B700, (unsigned __int16)v6 + 7, 0);
          LOWORD(v6) = v6 + 7;
        }
        goto LABEL_150;
      }
      sub_408670(dword_44B71C, 19, 0);
      word_44B7F6 = 19;
      sub_408670(dword_44B700, 19, 0);
      word_44B7F4 = 19;
      goto LABEL_109;
    }
    if ( *(float *)&dword_44B764 == 0.0 )
    {
      if ( !byte_44B78E )
      {
        if ( byte_44B78D )
        {
          if ( !byte_44B78F )
          {
            v24 = (unsigned __int16)v6 + 12;
            sub_408670(dword_44B71C, v24, 0);
            LOWORD(v6) = v6 + 12;
            word_44B7F6 = v6;
            sub_408670(dword_44B700, v24, 0);
            goto LABEL_150;
          }
        }
        else if ( !byte_44B78F )
        {
          if ( (unsigned __int16)word_44B7F2 >= 0x96u )
          {
            if ( dword_455CAC >= 0 )
            {
              v25 = (unsigned __int16)v6 + 2;
              sub_408670(dword_44B71C, v25, 3);
              v26 = v6 + 2;
            }
            else
            {
              v25 = (unsigned __int16)v6 + 1;
              sub_408670(dword_44B71C, v25, 3);
              v26 = v6 + 1;
            }
            word_44B7F6 = v26;
            sub_408670(dword_44B700, v25, 3);
            word_44B7F4 = v26;
            word_44B7F2 = 150;
            goto LABEL_151;
          }
          sub_408670(dword_44B71C, (unsigned __int16)v6, 5);
          word_44B7F6 = v6;
          sub_408670(dword_44B700, (unsigned __int16)v6, 5);
          goto LABEL_150;
        }
        sub_408670(dword_44B71C, 19, 0);
        word_44B7F6 = 19;
        sub_408670(dword_44B700, 19, 0);
        word_44B7F4 = 19;
        goto LABEL_109;
      }
      if ( !byte_44B78F )
      {
        sub_408670(dword_44B71C, 5, 3);
        word_44B7F6 = 5;
        sub_408670(dword_44B700, (unsigned __int16)v6 + 5, 3);
        LOWORD(v6) = v6 + 5;
        goto LABEL_150;
      }
      sub_408670(dword_44B71C, 5, 3);
      word_44B7F6 = 5;
      sub_41CE10((unsigned __int16)v6);
    }
    else
    {
      if ( !byte_44B78E )
      {
        if ( byte_44B78D )
        {
          if ( !byte_44B78F )
          {
            v23 = (unsigned __int16)v6 + 12;
            sub_408670(dword_44B71C, v23, 3);
            LOWORD(v6) = v6 + 12;
            word_44B7F6 = v6;
            sub_408670(dword_44B700, v23, 3);
            goto LABEL_150;
          }
        }
        else if ( !byte_44B78F )
        {
          sub_408670(dword_44B700, (unsigned __int16)v6 + 3, 3);
          word_44B7F4 = v6 + 3;
          sub_408670(dword_44B71C, 3, 3);
          word_44B7F6 = 3;
          goto LABEL_151;
        }
        sub_408670(dword_44B700, 19, 3);
        word_44B7F4 = 19;
        sub_408670(dword_44B71C, 19, 3);
        word_44B7F6 = 19;
LABEL_109:
        if ( LODWORD(dword_44B704) )
          sub_4083F0((int *)LODWORD(dword_44B704));
        goto LABEL_151;
      }
      sub_408670(dword_44B71C, 6, 3);
      word_44B7F6 = 6;
      if ( !byte_44B78F )
      {
        sub_408670(dword_44B700, (unsigned __int16)v6 + 6, 3);
        LOWORD(v6) = v6 + 6;
        goto LABEL_150;
      }
      sub_41CE10((unsigned __int16)v6);
    }
LABEL_151:
    sub_4083F0((int *)LODWORD(dword_44B71C));
    sub_4083F0((int *)LODWORD(dword_44B700));
LABEL_152:
    v28 = 0;
    if ( LODWORD(dword_44B700) )
    {
      v27 = *(unsigned __int16 **)(LODWORD(dword_44B700) + 184);
      if ( v27 )
      {
        if ( *(unsigned __int16 *)(LODWORD(dword_44B700) + 174) == *v27 - 1 )
          v28 = 1;
      }
    }
    v30 = 0;
    if ( LODWORD(dword_44B71C) )
    {
      v29 = *(unsigned __int16 **)(LODWORD(dword_44B71C) + 184);
      if ( v29 )
      {
        if ( *(unsigned __int16 *)(LODWORD(dword_44B71C) + 174) == *v29 - 1 )
          v30 = 1;
      }
    }
    if ( byte_44B78D && v30 )
    {
      byte_44B78D = 0;
      dword_44B7AC = 1137508352;
    }
    if ( word_44B7F2 == 150 && v30 )
    {
      word_44B7F2 = 0;
      if ( rand() / 0x4000 )
        v31 = dword_455CAC | 0x80000000;
      else
        v31 = dword_455CAC & 0x7FFFFFFF;
      dword_455CAC = v31;
    }
    if ( byte_44B78F && v28 )
      sub_42CC70((int)&dword_44B71C);
    if ( byte_44B790 )
    {
      if ( !--byte_44B790 )
        sub_434530();
    }
  }
  if ( !(byte_44B790 & 1) )
  {
    if ( (_WORD)dword_44B784 == -1 )
    {
      sub_408A50(SLODWORD(dword_44B71C));
      sub_408A50(SLODWORD(dword_44B700));
    }
    v32 = *(float **)(LODWORD(dword_44B700) + 180);
    v33 = v32[36];
    v34 = v32[37];
    if ( v34 > 0.0 )
    {
      dword_44B7E4 = v32[35] * (double)*((signed int *)dword_443D44 + 3) / v34
                   + (double)(*((_DWORD *)dword_443D44 + 2) / 2);
      flt_44B7E8 = (double)*((signed int *)dword_443D44 + 3) * v33 / v34 + (double)(*((_DWORD *)dword_443D44 + 3) / 2);
    }
    if ( dword_44B734 != -1 && !(*(_WORD *)dword_44B730 & 0x124) && (_WORD)dword_44B784 == -1 )
      sub_408A50(dword_44B720);
  }
  if ( byte_44B795 )
  {
    if ( byte_44B795 == 1 && !byte_44B794 )
      sub_404910(0, 0x4000);
    sub_41EE40();
  }
  sub_41EFC0();
  sub_41F160();
}
// 444938: using guessed type int dword_444938;
// 44B720: using guessed type int dword_44B720;
// 44B730: using guessed type int dword_44B730;
// 44B734: using guessed type int dword_44B734;
// 44B764: using guessed type int dword_44B764;
// 44B768: using guessed type int dword_44B768;
// 44B76C: using guessed type int dword_44B76C;
// 44B784: using guessed type int dword_44B784;
// 44B78C: using guessed type char byte_44B78C;
// 44B78D: using guessed type char byte_44B78D;
// 44B78E: using guessed type char byte_44B78E;
// 44B78F: using guessed type char byte_44B78F;
// 44B790: using guessed type char byte_44B790;
// 44B791: using guessed type char byte_44B791;
// 44B793: using guessed type char byte_44B793;
// 44B794: using guessed type char byte_44B794;
// 44B795: using guessed type char byte_44B795;
// 44B79C: using guessed type int dword_44B79C;
// 44B7AC: using guessed type int dword_44B7AC;
// 44B7BC: using guessed type int dword_44B7BC;
// 44B7C0: using guessed type int dword_44B7C0;
// 44B7C4: using guessed type int dword_44B7C4;
// 44B7E8: using guessed type float flt_44B7E8;
// 44B7F2: using guessed type __int16 word_44B7F2;
// 44B7F4: using guessed type __int16 word_44B7F4;
// 44B7F6: using guessed type __int16 word_44B7F6;
// 44B804: using guessed type int dword_44B804;
// 44B80C: using guessed type int dword_44B80C;
// 44B814: using guessed type int dword_44B814;
// 44B81A: using guessed type int dword_44B81A;
// 455BF8: using guessed type int dword_455BF8;
// 455C00: using guessed type int dword_455C00;
// 455C14: using guessed type char byte_455C14;
// 455CA9: using guessed type char byte_455CA9;
// 455CAC: using guessed type int dword_455CAC;
// 455CB0: using guessed type int dword_455CB0;

//----- (0041DD10) --------------------------------------------------------
signed int __cdecl sub_41DD10(signed int a1)
{
  if ( (unsigned __int16)word_44B7F6 == a1 )
    return 2;
  if ( (unsigned __int16)word_44B7F6 < a1 || (unsigned __int16)word_44B7F6 >= a1 + 5 )
    return 0;
  return 1;
}
// 44B7F6: using guessed type __int16 word_44B7F6;

//----- (0041DD40) --------------------------------------------------------
int sub_41DD40()
{
  int result; // eax
  unsigned __int16 v1; // si
  unsigned __int16 *v2; // eax
  BOOL v3; // ebp
  signed __int16 v4; // si
  double v6; // st7
  unsigned __int8 v7; // c0
  unsigned __int8 v8; // c3
  int v9; // edi
  __int16 v10; // si
  int v11; // eax
  float *v12; // esi
  float *v13; // edi
  _DWORD *v14; // eax
  _DWORD *v15; // eax
  int v16; // edi
  int v17; // eax
  float *v18; // esi
  float *v19; // edi
  __int16 v20; // ax
  char v21; // cl
  _DWORD *v22; // eax
  _DWORD *v23; // eax
  _DWORD *v24; // eax
  _DWORD *v25; // eax
  __int16 *v26; // eax
  __int16 v27; // ax
  unsigned __int16 *v28; // eax
  BOOL v29; // eax
  float *v30; // ecx
  double v31; // st7
  double v32; // st6
  float v33; // [esp+4h] [ebp-4h]

  result = LODWORD(dword_44B700);
  v1 = 0;
  if ( !LODWORD(dword_44B700) || !LODWORD(dword_44B71C) )
    return result;
  v2 = *(unsigned __int16 **)(LODWORD(dword_44B71C) + 184);
  v3 = v2 && *(unsigned __int16 *)(LODWORD(dword_44B71C) + 174) == *v2 - 1;
  if ( byte_455C14 )
  {
    if ( byte_455CA9 )
    {
      dword_44B768 = 1161117696;
      dword_44B764 = 1161117696;
      sub_4266C0();
      byte_44B969 = 0;
      goto LABEL_139;
    }
    if ( *(_BYTE *)dword_44B730 & 4 )
    {
      v4 = 80;
      sub_408670(dword_44B71C, 80, 3);
      goto LABEL_133;
    }
    v33 = *(float *)(dword_44B738 + 16) * 256.0;
    if ( byte_44B790 )
    {
      if ( !byte_44B78C )
        goto LABEL_27;
    }
    else if ( !byte_44B78C )
    {
      if ( dword_455CAC & 0x20 )
        goto LABEL_27;
      v6 = v33;
      if ( v7 | v8 )
      {
        if ( v6 < -100.0 )
        {
          if ( v33 <= -150.0 )
          {
            v1 = 2;
            dword_44B768 = 1154777088;
          }
          else
          {
            v1 = 1;
            dword_44B768 = 1158660096;
          }
          goto LABEL_27;
        }
        v1 = 0;
        dword_44B768 = 1161117696;
      }
      else if ( v6 >= 150.0 )
      {
        v1 = 4;
        dword_44B768 = 1166434304;
      }
      else
      {
        v1 = 3;
        dword_44B768 = 1163575296;
      }
      if ( byte_44B78E )
        *(float *)&dword_44B768 = *(float *)&dword_44B768 + 4000.0;
LABEL_27:
      if ( *(float *)&dword_44B764 == 0.0 )
        goto LABEL_115;
      if ( byte_44B78E )
      {
        v16 = v1 + 87;
        sub_408670(dword_44B71C, v16, 5);
        v10 = v1 + 87;
      }
      else
      {
        if ( byte_44B78D )
        {
          if ( sub_41DD10(81) )
            goto LABEL_55;
          v9 = v1 + 81;
          sub_408670(dword_44B71C, v9, 0);
          v10 = v1 + 81;
          word_44B7F6 = v10;
          sub_408670(dword_44B700, v9, 0);
LABEL_54:
          word_44B7F4 = v10;
LABEL_55:
          if ( dword_455BF8 == 1 )
          {
            v17 = *(_DWORD *)(LODWORD(dword_44B71C) + 180);
            v18 = (float *)(v17 + 2596);
            v19 = (float *)(v17 + 1652);
            v20 = *(_WORD *)dword_44B730;
            if ( !*(_WORD *)dword_44B730 && byte_44B78D )
              goto LABEL_60;
            v21 = byte_44B969;
            if ( byte_44B969 )
            {
              if ( !byte_44B78D )
              {
                if ( !byte_44B969 )
                {
LABEL_63:
                  if ( dword_44B950 )
                  {
                    sub_432BA0(dword_44B950, (int)v18);
                    sub_40B920(dword_44B950, v18[23], v18[24], v18[25]);
                  }
                  else
                  {
                    v22 = sub_40B8D0();
                    dword_44B950 = (int)v22;
                    if ( v22 )
                    {
                      sub_432BA0((int)v22, (int)v18);
                      sub_40B920(dword_44B950, v18[23], v18[24], v18[25]);
                    }
                  }
                  if ( dword_44B954 )
                  {
                    sub_432BA0(dword_44B954, (int)v19);
                    sub_40B920(dword_44B954, v19[23], v19[24], v19[25]);
                  }
                  else
                  {
                    v23 = sub_40B8D0();
                    dword_44B954 = (int)v23;
                    if ( v23 )
                    {
                      sub_432BA0((int)v23, (int)v19);
                      sub_40B920(dword_44B954, v19[23], v19[24], v19[25]);
                    }
                  }
                  if ( sub_407E30((AGLSOUNDBUFFER **)&dword_444920) )
                    sub_407E50((AGLSOUNDBUFFER **)&dword_444920);
                  if ( sub_407E30((AGLSOUNDBUFFER **)&dword_444938) )
                    sub_407E50((AGLSOUNDBUFFER **)&dword_444938);
                  if ( !sub_407E30((AGLSOUNDBUFFER **)&unk_44492C) )
                  {
                    sub_407E50((AGLSOUNDBUFFER **)&unk_44483C);
                    sub_407E00((int)&unk_44492C);
                  }
                  if ( byte_455CA5 && sub_407E30((AGLSOUNDBUFFER **)&unk_44492C) )
                    sub_407E50((AGLSOUNDBUFFER **)&unk_44492C);
                  goto LABEL_115;
                }
LABEL_62:
                byte_44B969 = v21 - 1;
                goto LABEL_63;
              }
LABEL_60:
              v21 = 10;
              goto LABEL_62;
            }
            if ( !byte_44B78D )
            {
              if ( v20 )
              {
                if ( (v20 & 0x80u) == 0 )
                {
                  if ( v20 & 0x40 )
                  {
                    if ( dword_44B950 )
                    {
                      sub_432C50(dword_44B950, (int)v18);
                      sub_40B920(dword_44B950, v18[23], v18[24], v18[25]);
                    }
                    else
                    {
                      v24 = sub_40B8D0();
                      dword_44B950 = (int)v24;
                      if ( v24 )
                      {
                        sub_432C50((int)v24, (int)v18);
                        sub_40B920(dword_44B950, v18[23], v18[24], v18[25]);
                      }
                    }
                    if ( dword_44B954 )
                    {
                      sub_432C50(dword_44B954, (int)v19);
                      sub_40B920(dword_44B954, v19[23], v19[24], v19[25]);
                    }
                    else
                    {
                      v25 = sub_40B8D0();
                      dword_44B954 = (int)v25;
                      if ( v25 )
                      {
                        sub_432C50((int)v25, (int)v19);
                        sub_40B920(dword_44B954, v19[23], v19[24], v19[25]);
                      }
                    }
                    if ( sub_407E30((AGLSOUNDBUFFER **)&unk_44492C) )
                      sub_407E50((AGLSOUNDBUFFER **)&unk_44492C);
                    if ( sub_407E30((AGLSOUNDBUFFER **)&dword_444938) )
                      sub_407E50((AGLSOUNDBUFFER **)&dword_444938);
                    if ( !sub_407E30((AGLSOUNDBUFFER **)&dword_444920) )
                    {
                      sub_407E50((AGLSOUNDBUFFER **)&unk_44483C);
                      sub_407E00((int)&dword_444920);
                    }
                    if ( byte_455CA5 && sub_407E30((AGLSOUNDBUFFER **)&dword_444920) )
                      sub_407E50((AGLSOUNDBUFFER **)&dword_444920);
                  }
                  goto LABEL_115;
                }
                if ( sub_407E30((AGLSOUNDBUFFER **)&dword_444920) )
                  sub_407E50((AGLSOUNDBUFFER **)&dword_444920);
                if ( sub_407E30((AGLSOUNDBUFFER **)&unk_44492C) )
                  sub_407E50((AGLSOUNDBUFFER **)&unk_44492C);
              }
              else
              {
                if ( sub_407E30((AGLSOUNDBUFFER **)&dword_444920) )
                  sub_407E50((AGLSOUNDBUFFER **)&dword_444920);
                if ( sub_407E30((AGLSOUNDBUFFER **)&unk_44492C) )
                  sub_407E50((AGLSOUNDBUFFER **)&unk_44492C);
                if ( !sub_407E30((AGLSOUNDBUFFER **)&dword_444938) )
                {
                  sub_407E50((AGLSOUNDBUFFER **)&unk_44483C);
                  sub_407E00((int)&dword_444938);
                }
                if ( !byte_455CA5 )
                  goto LABEL_115;
              }
              if ( sub_407E30((AGLSOUNDBUFFER **)&dword_444938) )
                sub_407E50((AGLSOUNDBUFFER **)&dword_444938);
            }
          }
LABEL_115:
          v26 = (__int16 *)dword_44B730;
          if ( word_44B6F8 != *(_WORD *)dword_44B730 )
          {
            sub_434530();
            v26 = (__int16 *)dword_44B730;
          }
          word_44B6F8 = *v26;
          v27 = *v26;
          if ( (v27 & 0x80u) == 0 )
          {
            if ( v27 & 0x40 && !sub_434550() )
              sub_434500(0x8Cu);
          }
          else if ( !sub_434550() )
          {
            sub_434500(0x46u);
          }
          goto LABEL_139;
        }
        if ( sub_41DD10(v1 + 81) == 2 && !v3 )
        {
          if ( byte_44B969 )
          {
            v11 = *(_DWORD *)(LODWORD(dword_44B71C) + 180);
            v12 = (float *)(v11 + 2596);
            v13 = (float *)(v11 + 1652);
            if ( byte_44B969 )
              --byte_44B969;
            if ( dword_44B950 )
            {
              sub_432BA0(dword_44B950, (int)v12);
              sub_40B920(dword_44B950, v12[23], v12[24], v12[25]);
            }
            else
            {
              v14 = sub_40B8D0();
              dword_44B950 = (int)v14;
              if ( v14 )
              {
                sub_432BA0((int)v14, (int)v12);
                sub_40B920(dword_44B950, v12[23], v12[24], v12[25]);
              }
            }
            if ( dword_44B954 )
            {
              sub_432BA0(dword_44B954, (int)v13);
              sub_40B920(dword_44B954, v13[23], v13[24], v13[25]);
            }
            else
            {
              v15 = sub_40B8D0();
              dword_44B954 = (int)v15;
              if ( v15 )
              {
                sub_432BA0((int)v15, (int)v13);
                sub_40B920(dword_44B954, v13[23], v13[24], v13[25]);
              }
            }
            if ( sub_407E30((AGLSOUNDBUFFER **)&dword_444920) )
              sub_407E50((AGLSOUNDBUFFER **)&dword_444920);
            if ( sub_407E30((AGLSOUNDBUFFER **)&dword_444938) )
              sub_407E50((AGLSOUNDBUFFER **)&dword_444938);
            if ( !sub_407E30((AGLSOUNDBUFFER **)&unk_44492C) )
            {
              sub_407E50((AGLSOUNDBUFFER **)&unk_44483C);
              sub_407E00((int)&unk_44492C);
            }
          }
          goto LABEL_139;
        }
        v16 = v1 + 60;
        sub_408670(dword_44B71C, v16, 5);
        v10 = v1 + 60;
      }
      word_44B7F6 = v10;
      sub_408670(dword_44B700, v16, 5);
      goto LABEL_54;
    }
    if ( dword_455BF8 == 1 )
    {
      if ( sub_407E30((AGLSOUNDBUFFER **)&dword_444920) )
        sub_407E50((AGLSOUNDBUFFER **)&dword_444920);
      if ( sub_407E30((AGLSOUNDBUFFER **)&unk_44492C) )
        sub_407E50((AGLSOUNDBUFFER **)&unk_44492C);
      if ( sub_407E30((AGLSOUNDBUFFER **)&dword_444938) )
        sub_407E50((AGLSOUNDBUFFER **)&dword_444938);
    }
    v4 = 75;
    if ( !sub_41DD10(75) || !v3 )
    {
      if ( sub_41DD10(75) || word_44B7F6 == 80 || *(float *)&dword_44B76C > 0.0 )
        goto LABEL_139;
      sub_408670(dword_44B71C, 75, 0);
      word_44B7F6 = 75;
      sub_408670(dword_44B700, 75, 0);
      goto LABEL_138;
    }
    v4 = 80;
    sub_408670(dword_44B71C, 80, 3);
LABEL_133:
    word_44B7F6 = 80;
    sub_408670(dword_44B700, 80, 3);
LABEL_138:
    word_44B7F4 = v4;
LABEL_139:
    sub_4083F0((int *)LODWORD(dword_44B71C));
    sub_4083F0((int *)LODWORD(dword_44B700));
    v29 = 0;
    if ( LODWORD(dword_44B71C) )
    {
      v28 = *(unsigned __int16 **)(LODWORD(dword_44B71C) + 184);
      if ( v28 )
      {
        if ( *(unsigned __int16 *)(LODWORD(dword_44B71C) + 174) == *v28 - 1 )
          v29 = 1;
      }
    }
    if ( byte_44B78D && v29 )
    {
      byte_44B78D = 0;
      dword_44B7AC = 1137508352;
    }
    if ( word_44B7F2 == 150 && v29 )
      word_44B7F2 = 0;
    if ( byte_44B790 )
    {
      if ( !--byte_44B790 )
        sub_434530();
    }
  }
  if ( !(byte_44B790 & 1) )
  {
    sub_408A50(SLODWORD(dword_44B71C));
    sub_408A50(SLODWORD(dword_44B700));
    v30 = *(float **)(LODWORD(dword_44B700) + 180);
    v31 = v30[36];
    v32 = v30[37];
    if ( v32 > 0.0 )
    {
      dword_44B7E4 = v30[35] * 256.0 / v32 + (double)(*((_DWORD *)dword_443D44 + 2) / 2);
      flt_44B7E8 = v31 * 256.0 / v32 + (double)(*((_DWORD *)dword_443D44 + 3) / 2);
    }
    if ( dword_44B734 != -1 && !(*(_BYTE *)dword_44B730 & 0x24) )
      sub_408A50(dword_44B720);
  }
  if ( byte_44B795 )
    sub_41EE40();
  return sub_41EFC0();
}
// 444920: using guessed type int dword_444920;
// 444938: using guessed type int dword_444938;
// 44B6F8: using guessed type __int16 word_44B6F8;
// 44B720: using guessed type int dword_44B720;
// 44B730: using guessed type int dword_44B730;
// 44B734: using guessed type int dword_44B734;
// 44B764: using guessed type int dword_44B764;
// 44B768: using guessed type int dword_44B768;
// 44B76C: using guessed type int dword_44B76C;
// 44B78C: using guessed type char byte_44B78C;
// 44B78D: using guessed type char byte_44B78D;
// 44B78E: using guessed type char byte_44B78E;
// 44B790: using guessed type char byte_44B790;
// 44B795: using guessed type char byte_44B795;
// 44B7AC: using guessed type int dword_44B7AC;
// 44B7E8: using guessed type float flt_44B7E8;
// 44B7F2: using guessed type __int16 word_44B7F2;
// 44B7F4: using guessed type __int16 word_44B7F4;
// 44B7F6: using guessed type __int16 word_44B7F6;
// 44B969: using guessed type char byte_44B969;
// 455BF8: using guessed type int dword_455BF8;
// 455C14: using guessed type char byte_455C14;
// 455CA5: using guessed type char byte_455CA5;
// 455CA9: using guessed type char byte_455CA9;
// 455CAC: using guessed type int dword_455CAC;

//----- (0041E780) --------------------------------------------------------
int __cdecl sub_41E780(int a1)
{
  int result; // eax

  dword_44B73C = *(float *)a1;
  dword_44B740 = *(float *)(a1 + 4);
  result = *(_DWORD *)(a1 + 8);
  dword_44B744 = *(float *)(a1 + 8);
  byte_44B792 = 1;
  dword_44B764 = 0;
  return result;
}
// 44B764: using guessed type int dword_44B764;
// 44B792: using guessed type char byte_44B792;

//----- (0041E7B0) --------------------------------------------------------
__int16 __cdecl sub_41E7B0(float *a1, int a2, int a3)
{
  int v3; // ecx
  double v4; // st7
  double v5; // st7
  double v6; // st7
  __int16 result; // ax

  if ( a2 )
  {
    byte_44B790 = 0;
    byte_44B78C = 0;
    byte_44B78D = 0;
    byte_44B78F = 0;
    byte_44B78E = 0;
    byte_44B793 = 0;
    byte_44B811 = 0;
    byte_44B792 = 0;
    byte_44B794 = 0;
    byte_44B796 = 0;
    byte_44B795 = 0;
    dword_44B76C = 0;
    word_44B7F2 = 0;
    dword_44B760 = 384.0;
    dword_44B768 = 1164967936;
    LOBYTE(dword_44B7BC) = 0;
    byte_44B812 = 0;
    BYTE1(dword_44B80C) = 0;
    sub_434530();
    v3 = dword_44B7B8;
    *(_DWORD *)dword_44B7B8 = 0;
    *(_DWORD *)(v3 + 4) = 0;
    *(_DWORD *)(v3 + 8) = 0;
    dword_44B7B4 = 0;
    LOWORD(dword_44B788) = 0;
    byte_44B797 = 1;
    dword_455C18 = dword_455C1C;
  }
  dword_455C28 = 0;
  dword_455C7C = 0;
  v4 = *a1;
  flt_44B748 = *a1;
  dword_44B73C = v4;
  v5 = a1[1];
  flt_44B74C = a1[1];
  dword_44B740 = v5;
  flt_44B770 = v5;
  v6 = a1[2];
  dword_44B778 = 0;
  flt_44B750 = v6;
  dword_44B744 = v6;
  dword_44B724 = -1;
  dword_44B72C = -1;
  dword_44B734 = -1;
  dword_44B728 = 0;
  dword_44B730 = 0;
  dword_44B738 = 0;
  LOWORD(dword_44B784) = -1;
  if ( a3 )
  {
    sub_41F7E0((int)&dword_44B71C);
    word_44B980 = 0;
    byte_44B982 = 0;
    dword_4412A4 = 1135542272;
    dword_4412A8 = -1014398976;
    sub_41F740((int)&dword_44B71C);
    sub_40AD00((int)&dword_4489FC, 5120.0);
  }
  sub_42D4A0((int)&dword_44B71C, 1, 1.0);
  result = HIWORD(dword_44B788);
  LOWORD(dword_44B788) = HIWORD(dword_44B788);
  return result;
}
// 4412A4: using guessed type int dword_4412A4;
// 4412A8: using guessed type int dword_4412A8;
// 4489FC: using guessed type int dword_4489FC;
// 44B724: using guessed type int dword_44B724;
// 44B728: using guessed type int dword_44B728;
// 44B72C: using guessed type int dword_44B72C;
// 44B730: using guessed type int dword_44B730;
// 44B734: using guessed type int dword_44B734;
// 44B748: using guessed type float flt_44B748;
// 44B74C: using guessed type float flt_44B74C;
// 44B750: using guessed type float flt_44B750;
// 44B768: using guessed type int dword_44B768;
// 44B76C: using guessed type int dword_44B76C;
// 44B778: using guessed type int dword_44B778;
// 44B784: using guessed type int dword_44B784;
// 44B788: using guessed type int dword_44B788;
// 44B78C: using guessed type char byte_44B78C;
// 44B78D: using guessed type char byte_44B78D;
// 44B78E: using guessed type char byte_44B78E;
// 44B78F: using guessed type char byte_44B78F;
// 44B790: using guessed type char byte_44B790;
// 44B792: using guessed type char byte_44B792;
// 44B793: using guessed type char byte_44B793;
// 44B794: using guessed type char byte_44B794;
// 44B795: using guessed type char byte_44B795;
// 44B796: using guessed type char byte_44B796;
// 44B797: using guessed type char byte_44B797;
// 44B7B4: using guessed type int dword_44B7B4;
// 44B7B8: using guessed type int dword_44B7B8;
// 44B7BC: using guessed type int dword_44B7BC;
// 44B7F2: using guessed type __int16 word_44B7F2;
// 44B80C: using guessed type int dword_44B80C;
// 44B811: using guessed type char byte_44B811;
// 44B812: using guessed type char byte_44B812;
// 44B980: using guessed type __int16 word_44B980;
// 44B982: using guessed type char byte_44B982;
// 455C18: using guessed type int dword_455C18;
// 455C1C: using guessed type int dword_455C1C;
// 455C7C: using guessed type int dword_455C7C;

//----- (0041E960) --------------------------------------------------------
__int16 sub_41E960()
{
  int v0; // ecx
  signed int v1; // eax
  signed int v2; // eax
  __int16 result; // ax

  dword_44B798 = 1164967936;
  LOBYTE(dword_44B7BC) = 0;
  dword_44B7C0 = 0;
  dword_44B79C = 1136656384;
  dword_44B7A0 = 1142947840;
  dword_44B7A4 = -6050.0;
  flt_44B7A8 = 384.0;
  dword_44B7AC = 1137508352;
  dword_44B7B0 = 1133281280;
  v0 = *(_DWORD *)(LODWORD(dword_44B700) + 180) + 3540;
  byte_44B791 = 0;
  dword_44B7C4 = v0;
  byte_44B78F = 0;
  byte_44B813 = 0;
  byte_44B812 = 0;
  LOBYTE(dword_44B80C) = 0;
  dword_44B7C8 = 25;
  dword_44B7B8 = sub_401250(12);
  byte_44B797 = 1;
  dword_44B720 = (int)sub_4089F0(dword_455C8C);
  if ( (_BYTE)dword_44B814 )
  {
    v1 = sub_40A5E0(93);
    if ( v1 != -1 )
    {
      LODWORD(dword_44B708) = sub_4089F0(dword_448AC4 + 48 * v1);
      *(_DWORD *)(LODWORD(dword_44B708) + 4) = *(_DWORD *)(LODWORD(dword_44B71C) + 180);
      sub_408670(dword_44B708, 0, 0);
    }
    v2 = sub_40A5E0(94);
    if ( v2 != -1 )
    {
      LODWORD(dword_44B704) = sub_4089F0(dword_448AC4 + 48 * v2);
      *(_DWORD *)(LODWORD(dword_44B704) + 4) = *(_DWORD *)(LODWORD(dword_44B71C) + 180);
      sub_408670(dword_44B704, 0, 0);
    }
  }
  byte_44B848 = 0;
  result = sub_41E7B0(&flt_44B7D8, 1, 1);
  word_44B6F8 = 0;
  dword_44B768 = 1164967936;
  return result;
}
// 448AC4: using guessed type int dword_448AC4;
// 44B6F8: using guessed type __int16 word_44B6F8;
// 44B720: using guessed type int dword_44B720;
// 44B768: using guessed type int dword_44B768;
// 44B78F: using guessed type char byte_44B78F;
// 44B791: using guessed type char byte_44B791;
// 44B797: using guessed type char byte_44B797;
// 44B798: using guessed type int dword_44B798;
// 44B79C: using guessed type int dword_44B79C;
// 44B7A0: using guessed type int dword_44B7A0;
// 44B7A8: using guessed type float flt_44B7A8;
// 44B7AC: using guessed type int dword_44B7AC;
// 44B7B0: using guessed type int dword_44B7B0;
// 44B7B8: using guessed type int dword_44B7B8;
// 44B7BC: using guessed type int dword_44B7BC;
// 44B7C0: using guessed type int dword_44B7C0;
// 44B7C4: using guessed type int dword_44B7C4;
// 44B7C8: using guessed type int dword_44B7C8;
// 44B7D8: using guessed type float flt_44B7D8;
// 44B80C: using guessed type int dword_44B80C;
// 44B812: using guessed type char byte_44B812;
// 44B813: using guessed type char byte_44B813;
// 44B814: using guessed type int dword_44B814;
// 44B848: using guessed type char byte_44B848;
// 455C8C: using guessed type int dword_455C8C;

//----- (0041EAE0) --------------------------------------------------------
char __cdecl sub_41EAE0(float *a1)
{
  _DWORD *v2; // esi

  if ( BYTE2(dword_44B804) == 99 )
    return 0;
  ++BYTE2(dword_44B804);
  v2 = sub_40B8D0();
  if ( v2 )
  {
    sub_40B920((int)v2, *a1, a1[1], a1[2]);
    *(_BYTE *)v2 = 11;
    v2[628] = sub_41EB70;
    *((_BYTE *)v2 + 2530) = 5;
    *((_BYTE *)v2 + 2531) = 5;
    *((_WORD *)v2 + 1264) = 0;
    sub_40B9B0((int)v2, 0x28u, 0x28u, 0, 0, 0xFu, 0xFu);
  }
  sub_407E00((int)&unk_4448CC);
  ++word_44B800;
  return 1;
}
// 41EB70: using guessed type int sub_41EB70();
// 44B800: using guessed type __int16 word_44B800;
// 44B804: using guessed type int dword_44B804;

//----- (0041ED70) --------------------------------------------------------
char __cdecl sub_41ED70(unsigned __int8 a1)
{
  char result; // al

  if ( a1 )
  {
    if ( (unsigned __int8)byte_44B793 <= 1u )
    {
      result = sub_434500(0x78u);
      if ( a1 == -1 || !(dword_455CAC & 4) )
      {
        word_44B7F2 = 0;
        if ( a1 == -1 )
        {
          HIBYTE(dword_44B804) = 0;
        }
        else if ( a1 <= HIBYTE(dword_44B804) )
        {
          result = HIBYTE(dword_44B804) - a1;
          HIBYTE(dword_44B804) -= a1;
          if ( HIBYTE(dword_44B804) )
            return result;
        }
        else
        {
          HIBYTE(dword_44B804) = 0;
        }
        if ( BYTE2(dword_44B804) )
        {
          if ( (unsigned __int8)byte_44B793 <= 1u )
            byte_44B793 = 2;
        }
        else if ( (unsigned __int8)byte_44B793 <= 1u )
        {
          byte_44B793 = 3;
        }
        if ( byte_44B811 )
          sub_434690(6u, 0);
        else
          sub_434690(5u, 0);
        sub_42CC70((int)&dword_44B71C);
        result = sub_407C30();
      }
    }
  }
  return result;
}
// 44B793: using guessed type char byte_44B793;
// 44B7F2: using guessed type __int16 word_44B7F2;
// 44B804: using guessed type int dword_44B804;
// 44B811: using guessed type char byte_44B811;
// 455CAC: using guessed type int dword_455CAC;

//----- (0041EE40) --------------------------------------------------------
char sub_41EE40()
{
  int v0; // edi
  char v1; // cl
  __int16 v2; // bp
  signed int v3; // edx
  double v4; // st7
  __int16 v5; // si
  int v6; // eax
  double v7; // st6
  int v8; // eax
  char result; // al
  signed int v10; // [esp+10h] [ebp-Ch]
  int v11; // [esp+14h] [ebp-8h]

  sub_409D20(-180);
  v11 = dword_448ACC;
  v0 = *(_DWORD *)dword_448ACC;
  v1 = -108
     - (((((unsigned __int64)(1717986919i64 * ((unsigned __int8)byte_44B795 << 7)) >> 32) & 0x80000000) != 0i64)
      + ((signed int)((unsigned __int64)(1717986919i64 * ((unsigned __int8)byte_44B795 << 7)) >> 32) >> 2));
  v2 = 0;
  v3 = 0;
  v4 = (double)(15 * (unsigned __int8)byte_44B795);
  v10 = 0;
  v5 = (unsigned __int8)(6 * byte_44B795 + 10);
  do
  {
    v6 = 4 * (v2 & 0xFFF);
    v7 = *(float *)((char *)dword_4449D4 + v6) * v4;
    *(_DWORD *)(v0 + 4) = 0;
    *(float *)v0 = v7;
    *(float *)(v0 + 8) = *(float *)((char *)dword_4449D8 + v6) * v4;
    if ( v10 >= *(unsigned __int16 *)(v11 + 10) )
      v8 = 0;
    else
      v8 = v3 + *(_DWORD *)(v11 + 4);
    *(_BYTE *)(v8 + 34) = v1;
    *(_BYTE *)(v8 + 33) = v1;
    *(_BYTE *)(v8 + 32) = v1;
    *(_WORD *)(v8 + 12) = v5;
    *(_WORD *)(v8 + 14) = v5;
    v2 += 512;
    v0 += 12;
    v3 += 128;
    ++v10;
  }
  while ( v3 < 1024 );
  sub_40A060((_DWORD *)v11, &unk_44B754, 0, 8);
  result = byte_455C14;
  if ( byte_455C14 )
  {
    result = byte_44B795++ + 1;
    if ( (unsigned __int8)byte_44B795 > 0xAu )
      byte_44B795 = 0;
  }
  return result;
}
// 448ACC: using guessed type int dword_448ACC;
// 44B795: using guessed type char byte_44B795;
// 455C14: using guessed type char byte_455C14;

//----- (0041EF70) --------------------------------------------------------
int __cdecl sub_41EF70(int a1)
{
  int result; // eax

  result = 0;
  while ( word_44B6B4 )
  {
    if ( (unsigned int)++result >= 5 )
      return result;
  }
  result = a1;
  word_44B6B4 = 1;
  dword_44B6A8 = *(_DWORD *)a1;
  flt_44B6AC = *(float *)(a1 + 4) - 128.0;
  dword_44B6B0 = *(_DWORD *)(a1 + 8);
  return result;
}
// 44B6A8: using guessed type int dword_44B6A8;
// 44B6AC: using guessed type float flt_44B6AC;
// 44B6B0: using guessed type int dword_44B6B0;
// 44B6B4: using guessed type __int16 word_44B6B4;

//----- (0041EFC0) --------------------------------------------------------
int sub_41EFC0()
{
  int v0; // ebp
  __int16 *v1; // esi
  int v2; // edi
  signed int v3; // ebx
  int v4; // ecx
  int v5; // eax
  unsigned __int8 v6; // ST20_1
  unsigned __int8 v7; // ST28_1
  double v8; // st7
  double v9; // st6
  float v10; // ST34_4
  double v11; // st7
  int result; // eax

  sub_409D20(-255);
  v0 = dword_448ACC;
  v1 = &word_44B6B4;
  v2 = 38;
  v3 = 4864;
  do
  {
    if ( *v1 )
    {
      v4 = (unsigned __int16)(*v1 - 1);
      if ( v2 >= *(unsigned __int16 *)(v0 + 10) )
        v5 = 0;
      else
        v5 = v3 + *(_DWORD *)(v0 + 4);
      *(_BYTE *)(v5 + 34) = byte_441254[5 * v4];
      *(_BYTE *)(v5 + 33) = byte_441255[5 * v4];
      *(_BYTE *)(v5 + 32) = byte_441256[5 * v4];
      v6 = byte_441257[5 * v4];
      v7 = byte_441258[5 * v4];
      v8 = (double)v6 * 0.0039215689;
      *(float *)(v5 + 36) = v8;
      v9 = (double)v7 * 0.0039215689;
      *(float *)(v5 + 40) = v9;
      v10 = (double)(unsigned __int8)(v6 + 47) * 0.0039215689;
      *(float *)(v5 + 64) = v10;
      *(float *)(v5 + 68) = v9;
      *(float *)(v5 + 120) = v10;
      *(float *)(v5 + 92) = v8;
      v11 = (double)(unsigned __int8)(v7 + 47) * 0.0039215689;
      *(float *)(v5 + 96) = v11;
      *(float *)(v5 + 124) = v11;
      sub_40A060((_DWORD *)v0, (_DWORD *)v1 - 3, v2, 1);
      if ( byte_455C14 )
      {
        if ( (unsigned __int16)++*v1 > 5u )
          *v1 = 0;
      }
    }
    v1 += 8;
    v3 += 128;
    result = ++v2 - 38;
  }
  while ( v2 - 38 < 5 );
  return result;
}
// 448ACC: using guessed type int dword_448ACC;
// 44B6B4: using guessed type __int16 word_44B6B4;
// 455C14: using guessed type char byte_455C14;

//----- (0041F120) --------------------------------------------------------
int __cdecl sub_41F120(int *a1)
{
  int result; // eax

  result = 0;
  while ( word_44B86C )
  {
    if ( (unsigned int)++result >= 0xA )
      return result;
  }
  word_44B86C = 1;
  dword_44B860 = *a1;
  dword_44B864 = a1[1];
  result = a1[2];
  dword_44B868 = a1[2];
  return result;
}
// 44B860: using guessed type int dword_44B860;
// 44B864: using guessed type int dword_44B864;
// 44B868: using guessed type int dword_44B868;
// 44B86C: using guessed type __int16 word_44B86C;

//----- (0041F160) --------------------------------------------------------
int sub_41F160()
{
  int v0; // ebp
  __int16 *v1; // esi
  int v2; // edi
  signed int v3; // ebx
  int v4; // ecx
  int v5; // eax
  unsigned __int8 v6; // ST20_1
  unsigned __int8 v7; // ST28_1
  double v8; // st7
  double v9; // st6
  float v10; // ST34_4
  double v11; // st7
  int result; // eax

  sub_409D20(-255);
  v0 = dword_448ACC;
  v1 = &word_44B86C;
  v2 = 43;
  v3 = 5504;
  do
  {
    if ( *v1 )
    {
      v4 = (unsigned __int16)(*v1 - 1);
      if ( v2 >= *(unsigned __int16 *)(v0 + 10) )
        v5 = 0;
      else
        v5 = v3 + *(_DWORD *)(v0 + 4);
      *(_BYTE *)(v5 + 34) = byte_441270[5 * v4];
      *(_BYTE *)(v5 + 33) = byte_441271[5 * v4];
      *(_BYTE *)(v5 + 32) = byte_441272[5 * v4];
      v6 = byte_441273[5 * v4];
      v7 = byte_441274[5 * v4];
      v8 = (double)v6 * 0.0039215689;
      *(float *)(v5 + 36) = v8;
      v9 = (double)v7 * 0.0039215689;
      *(float *)(v5 + 40) = v9;
      v10 = (double)(unsigned __int8)(v6 + 31) * 0.0039215689;
      *(float *)(v5 + 64) = v10;
      *(float *)(v5 + 68) = v9;
      *(float *)(v5 + 120) = v10;
      *(float *)(v5 + 92) = v8;
      v11 = (double)(unsigned __int8)(v7 + 31) * 0.0039215689;
      *(float *)(v5 + 96) = v11;
      *(float *)(v5 + 124) = v11;
      sub_40A060((_DWORD *)v0, (_DWORD *)v1 - 3, v2, 1);
      if ( byte_455C14 )
      {
        if ( (unsigned __int16)++*v1 > 0xAu )
          *v1 = 0;
      }
    }
    v1 += 8;
    v3 += 128;
    result = ++v2 - 43;
  }
  while ( v2 - 43 < 10 );
  return result;
}
// 448ACC: using guessed type int dword_448ACC;
// 44B86C: using guessed type __int16 word_44B86C;
// 455C14: using guessed type char byte_455C14;

//----- (0041F2C0) --------------------------------------------------------
bool sub_41F2C0()
{
  return byte_44B793 == 2 || byte_44B793 == 3 || byte_44B793 == 1;
}
// 44B793: using guessed type char byte_44B793;

//----- (0041F2E0) --------------------------------------------------------
char sub_41F2E0()
{
  _DWORD *v0; // eax
  int *v1; // ecx
  char v2; // dl
  char result; // al

  v0 = (_DWORD *)dword_455C28;
  v1 = &dword_44B900;
  v2 = 1;
  if ( dword_455C28 )
  {
    while ( 1 )
    {
      *v1 = (int)v0;
      v0 = (_DWORD *)*v0;
      ++v1;
      if ( ++v2 == 20 )
        break;
      if ( !v0 )
        goto LABEL_4;
    }
    *v1 = 0;
    result = 0;
  }
  else
  {
LABEL_4:
    *v1 = 0;
    result = 1;
  }
  return result;
}
// 44B900: using guessed type int dword_44B900;

//----- (0041F320) --------------------------------------------------------
int *sub_41F320()
{
  int *v0; // ecx
  int *result; // eax
  int v2; // edx

  v0 = (int *)dword_44B900;
  result = &dword_44B900;
  dword_455C28 = dword_44B900;
  if ( dword_44B900 )
  {
    do
    {
      v2 = result[1];
      ++result;
      *v0 = v2;
      v0 = (int *)*result;
    }
    while ( *result );
  }
  return result;
}
// 44B900: using guessed type int dword_44B900;

//----- (0041F350) --------------------------------------------------------
int sub_41F350()
{
  int result; // eax

  LOBYTE(result) = byte_455CA9;
  *(float *)&dword_448A08 = *(float *)&dword_4412A4 + dword_44B73C;
  if ( byte_455CA9 )
  {
    if ( byte_455CA9 == 42 )
    {
      result = dword_44B970;
      *(float *)(dword_44B970 + 16) = dword_44B740 - 240.0;
    }
  }
  else
  {
    *(float *)&dword_448A0C = *(float *)&dword_4412A8 + dword_44B740;
  }
  dword_448A10 = LODWORD(dword_44B744);
  dword_4489FC = dword_448A08;
  dword_44B974 = 0;
  dword_44B978 = -1027080192;
  *(float *)&dword_448A00 = *(float *)&dword_448A0C - 100.0;
  dword_44B97C = -996802560;
  *(float *)&dword_448A04 = dword_44B744 - 1450.0;
  return result;
}
// 4412A4: using guessed type int dword_4412A4;
// 4412A8: using guessed type int dword_4412A8;
// 4489FC: using guessed type int dword_4489FC;
// 448A00: using guessed type int dword_448A00;
// 448A04: using guessed type int dword_448A04;
// 448A08: using guessed type int dword_448A08;
// 448A0C: using guessed type int dword_448A0C;
// 448A10: using guessed type int dword_448A10;
// 44B970: using guessed type int dword_44B970;
// 44B974: using guessed type int dword_44B974;
// 44B978: using guessed type int dword_44B978;
// 44B97C: using guessed type int dword_44B97C;
// 455CA9: using guessed type char byte_455CA9;

//----- (0041F400) --------------------------------------------------------
void sub_41F400()
{
  dword_4412A4 = 1142292480;
  dword_4412A8 = -1020002304;
}
// 4412A4: using guessed type int dword_4412A4;
// 4412A8: using guessed type int dword_4412A8;

//----- (0041F420) --------------------------------------------------------
double __cdecl sub_41F420(float *a1, float *a2)
{
  double v2; // st7
  double v3; // st6
  double v4; // st5

  v2 = *a2 - *a1;
  v3 = a2[1] - a1[1];
  v4 = a2[2] - a1[2];
  return v4 * v4 * 0.00390625 + v3 * v3 * 0.00390625 + v2 * v2 * 0.00390625;
}

//----- (0041F470) --------------------------------------------------------
int sub_41F470()
{
  double v0; // st7
  int result; // eax
  float v2; // [esp+0h] [ebp-18h]
  int v3; // [esp+4h] [ebp-14h]
  float v4; // [esp+8h] [ebp-10h]
  float v5; // [esp+Ch] [ebp-Ch]
  float v6; // [esp+14h] [ebp-4h]

  v2 = dword_44B73C;
  v4 = dword_44B744;
  v3 = 0;
  sub_408330(&v2, &v5);
  *(float *)dword_44B970 = v5 * 3328.0;
  *(float *)(dword_44B970 + 4) = dword_44B740 - 320.0;
  *(float *)(dword_44B970 + 8) = v6 * 3328.0;
  *(_DWORD *)(dword_44B970 + 12) = 0;
  if ( !byte_455CA9 )
  {
    v0 = dword_44B740 - 740.0;
LABEL_5:
    result = dword_44B970;
    *(float *)(dword_44B970 + 16) = v0;
    *(_DWORD *)(dword_44B970 + 20) = 0;
    return result;
  }
  if ( byte_455CA9 == 42 )
  {
    v0 = dword_44B740 - 240.0;
    goto LABEL_5;
  }
  result = dword_44B970;
  *(_DWORD *)(dword_44B970 + 20) = 0;
  return result;
}
// 44B970: using guessed type int dword_44B970;
// 455CA9: using guessed type char byte_455CA9;

//----- (0041F530) --------------------------------------------------------
char __cdecl sub_41F530(unsigned __int16 a1)
{
  char result; // al

  if ( byte_44BAE4 )
    return 2;
  if ( !byte_44B984 && dword_44B740 - (double)a1 < *(float *)(dword_44B970 + 16) )
  {
    result = 0;
    *(float *)(dword_44B970 + 16) = *(float *)(dword_44B970 + 16) - 30.0;
    return result;
  }
  if ( dword_44B740 - 275.0 <= *(float *)(dword_44B970 + 16) )
    return 2;
  if ( (unsigned __int8)byte_44B984 >= 0x32u )
  {
    if ( byte_44B984 == 50 )
    {
      byte_44B984 = 51;
      result = 1;
    }
    else
    {
      result = 0;
      *(float *)(dword_44B970 + 16) = *(float *)(dword_44B970 + 16) + 30.0;
    }
  }
  else
  {
    result = 0;
    ++byte_44B984;
  }
  return result;
}
// 44B970: using guessed type int dword_44B970;
// 44B984: using guessed type char byte_44B984;
// 44BAE4: using guessed type char byte_44BAE4;

//----- (0041F5D0) --------------------------------------------------------
char sub_41F5D0()
{
  double v0; // st7
  char result; // al

  v0 = dword_44B740 - 740.0;
  if ( v0 >= *(float *)(dword_44B970 + 16) )
  {
    *(float *)(dword_44B970 + 16) = v0;
    result = 1;
  }
  else
  {
    result = 0;
    *(float *)(dword_44B970 + 16) = *(float *)(dword_44B970 + 16) - 10.0;
  }
  return result;
}
// 44B970: using guessed type int dword_44B970;

//----- (0041F610) --------------------------------------------------------
int __cdecl sub_41F610(int a1)
{
  int result; // eax

  *(float *)(dword_44B970 + 12) = *(float *)&dword_4412A4 + *(float *)(a1 + 32);
  *(float *)(dword_44B970 + 16) = *(float *)&dword_4412A8 + *(float *)(a1 + 36);
  *(_DWORD *)(dword_44B970 + 20) = *(_DWORD *)(a1 + 40);
  result = dword_455BF8;
  if ( dword_455BF8 == 16 )
  {
    dword_4489FC = dword_448A08;
    *(float *)&dword_448A00 = *(float *)&dword_448A0C - 100.0;
    *(float *)&dword_448A04 = *(float *)&dword_448A10 - 1200.0;
  }
  else
  {
    if ( dword_455BF8 != 8 && dword_455BF8 != 10 && *(float *)&dword_44B97C != -1600.0 )
    {
      if ( *(float *)&dword_44B97C >= -1607.0 )
        dword_44B97C = -993525760;
      else
        *(float *)&dword_44B97C = (double)(abs((unsigned int)(signed __int64)(-1600.0 - *(float *)&dword_44B97C)) / 7)
                                + *(float *)&dword_44B97C;
    }
    result = dword_44B970;
    *(float *)&dword_4489FC = *(float *)&dword_44B974 + *(float *)(dword_44B970 + 12);
    *(float *)&dword_448A00 = *(float *)&dword_44B978 + *(float *)(dword_44B970 + 16);
    *(float *)&dword_448A04 = *(float *)&dword_44B97C + *(float *)(dword_44B970 + 20);
  }
  return result;
}
// 4412A4: using guessed type int dword_4412A4;
// 4412A8: using guessed type int dword_4412A8;
// 4489FC: using guessed type int dword_4489FC;
// 448A00: using guessed type int dword_448A00;
// 448A04: using guessed type int dword_448A04;
// 448A08: using guessed type int dword_448A08;
// 448A0C: using guessed type int dword_448A0C;
// 448A10: using guessed type int dword_448A10;
// 44B970: using guessed type int dword_44B970;
// 44B974: using guessed type int dword_44B974;
// 44B978: using guessed type int dword_44B978;
// 44B97C: using guessed type int dword_44B97C;
// 455BF8: using guessed type int dword_455BF8;

//----- (0041F740) --------------------------------------------------------
float __usercall sub_41F740@<eax>(int a1)
{
  int v1; // eax
  int v2; // edx
  float result; // eax

  v1 = *(_DWORD *)(a1 + 12);
  if ( v1 && (v2 = *(_DWORD *)(v1 + 4), BYTE1(v2) & 1) )
  {
    *(float *)(dword_44B970 + 16) = *(float *)&dword_4412A8 + *(float *)(a1 + 36);
    result = sub_40A9F0((float *)&dword_4489FC);
  }
  else if ( dword_455BF8 == 4 )
  {
    sub_41F470();
    result = sub_40A9F0((float *)&dword_4489FC);
  }
  else if ( dword_455BF8 == 8 || dword_455BF8 == 11 )
  {
    sub_41F350();
    if ( byte_455CA9 == 42 )
      *(float *)(dword_44B970 + 16) = dword_44B740 - 240.0;
    result = sub_40A9F0((float *)&dword_4489FC);
  }
  else
  {
    sub_41F610(a1);
    result = sub_40A9F0((float *)&dword_4489FC);
  }
  return result;
}
// 4412A8: using guessed type int dword_4412A8;
// 4489FC: using guessed type int dword_4489FC;
// 44B970: using guessed type int dword_44B970;
// 455BF8: using guessed type int dword_455BF8;
// 455CA9: using guessed type char byte_455CA9;

//----- (0041F7E0) --------------------------------------------------------
bool __cdecl sub_41F7E0(int a1)
{
  int v1; // eax
  bool result; // al

  *(float *)&dword_448A08 = *(float *)&dword_4412A4 + *(float *)(a1 + 32);
  *(float *)&dword_448A0C = *(float *)&dword_4412A8 + *(float *)(a1 + 36);
  v1 = *(_DWORD *)(a1 + 40);
  dword_44B974 = 0;
  dword_448A10 = v1;
  dword_44B978 = -1010302976;
  result = sub_41BB30();
  if ( !result )
    dword_44B97C = -993525760;
  *(float *)&dword_4489FC = *(float *)&dword_44B974 + *(float *)&dword_448A08;
  *(float *)&dword_448A00 = *(float *)&dword_44B978 + *(float *)&dword_448A0C;
  *(float *)&dword_448A04 = *(float *)&dword_44B97C + *(float *)&dword_448A10;
  return result;
}
// 4412A4: using guessed type int dword_4412A4;
// 4412A8: using guessed type int dword_4412A8;
// 4489FC: using guessed type int dword_4489FC;
// 448A00: using guessed type int dword_448A00;
// 448A04: using guessed type int dword_448A04;
// 448A08: using guessed type int dword_448A08;
// 448A0C: using guessed type int dword_448A0C;
// 448A10: using guessed type int dword_448A10;
// 44B974: using guessed type int dword_44B974;
// 44B978: using guessed type int dword_44B978;
// 44B97C: using guessed type int dword_44B97C;

//----- (0041F870) --------------------------------------------------------
float __usercall sub_41F870@<eax>()
{
  memset(&dword_4489FC, 0, 0xB0u);
  byte_44B982 = 0;
  dword_4412A4 = 1135542272;
  dword_4412A8 = -1014398976;
  word_44B980 = 0;
  sub_41F7E0((int)&dword_44B71C);
  dword_448A18 = 0;
  dword_44B970 = (int)&dword_4489FC;
  return sub_41F740((int)&dword_44B71C);
}
// 4412A4: using guessed type int dword_4412A4;
// 4412A8: using guessed type int dword_4412A8;
// 4489FC: using guessed type int dword_4489FC;
// 448A18: using guessed type int dword_448A18;
// 44B970: using guessed type int dword_44B970;
// 44B980: using guessed type __int16 word_44B980;
// 44B982: using guessed type char byte_44B982;

//----- (0041F8D0) --------------------------------------------------------
char __cdecl sub_41F8D0(int a1)
{
  void *v1; // edi

  dword_455C4C = 0;
  if ( a1 )
  {
    v1 = (void *)sub_401250(32 * a1);
    dword_455C48 = (int)v1;
    if ( v1 )
    {
      memset(v1, 0, 32 * a1);
      dword_455C4C = a1;
    }
  }
  return 1;
}
// 455C48: using guessed type int dword_455C48;
// 455C4C: using guessed type int dword_455C4C;

//----- (0041F920) --------------------------------------------------------
int sub_41F920()
{
  int result; // eax

  sub_401380(dword_455C48);
  result = 0;
  dword_455C4C = 0;
  dword_455C48 = 0;
  return result;
}
// 455C48: using guessed type int dword_455C48;
// 455C4C: using guessed type int dword_455C4C;

//----- (0041F940) --------------------------------------------------------
void __cdecl sub_41F940(int a1)
{
  if ( !(_BYTE)dword_455CB0 && !sub_41BB30() )
  {
    if ( dword_455BF8 == 16 )
      dword_4412A4 = 0;
    if ( !(byte_44B982 & 6) )
    {
      if ( byte_44B813 && byte_44B810 || sub_41BB30() )
      {
        if ( *(float *)&dword_4412A4 != 0.0 )
          *(float *)&dword_4412A4 = *(float *)&dword_4412A4 - *(float *)&dword_4412A4 * 0.050000001;
      }
      else
      {
        if ( *(float *)&dword_4412A4 < 215.0 && *(_BYTE *)(a1 + 123) == 1 )
          *(float *)&dword_4412A4 = (215.0 - *(float *)&dword_4412A4) * 0.050000001 + *(float *)&dword_4412A4;
        if ( *(float *)&dword_4412A4 > -215.0 && *(_BYTE *)(a1 + 123) == -1 )
          *(float *)&dword_4412A4 = *(float *)&dword_4412A4 - (*(float *)&dword_4412A4 + 215.0) * 0.050000001;
      }
    }
  }
}
// 4412A4: using guessed type int dword_4412A4;
// 44B810: using guessed type char byte_44B810;
// 44B813: using guessed type char byte_44B813;
// 44B982: using guessed type char byte_44B982;
// 455BF8: using guessed type int dword_455BF8;
// 455CB0: using guessed type int dword_455CB0;

//----- (0041FA40) --------------------------------------------------------
void sub_41FA40()
{
  double v0; // st7
  double v1; // st7

  if ( sub_41BB30() && dword_455BF8 != 8 && (_BYTE)dword_455CB0 && dword_455BF8 != 10 )
  {
    if ( *(float *)&dword_4412A4 < 0.0 )
    {
      v0 = *(float *)&dword_4412A4 + 25.0;
      *(float *)&dword_4412A4 = v0;
      if ( v0 > 0.0 )
        dword_4412A4 = 0;
    }
  }
  else
  {
    if ( dword_455BF8 == 16 )
      dword_4412A4 = 0;
    if ( !(byte_44B982 & 6) && *(float *)&dword_4412A4 > -350.0 )
    {
      v1 = *(float *)&dword_4412A4 - 25.0;
      *(float *)&dword_4412A4 = v1;
      if ( v1 < -350.0 )
        dword_4412A4 = -1011941376;
    }
  }
}
// 4412A4: using guessed type int dword_4412A4;
// 44B982: using guessed type char byte_44B982;
// 455BF8: using guessed type int dword_455BF8;
// 455CB0: using guessed type int dword_455CB0;

//----- (0041FB00) --------------------------------------------------------
void sub_41FB00()
{
  double v0; // st7
  double v1; // st7

  if ( sub_41BB30() && dword_455BF8 != 8 && (_BYTE)dword_455CB0 && dword_455BF8 != 10 )
  {
    if ( *(float *)&dword_4412A4 > 0.0 )
    {
      v0 = *(float *)&dword_4412A4 - 25.0;
      *(float *)&dword_4412A4 = v0;
      if ( v0 < 0.0 )
        dword_4412A4 = 0;
    }
  }
  else
  {
    if ( dword_455BF8 == 16 )
      dword_4412A4 = 0;
    if ( !(byte_44B982 & 6) && *(float *)&dword_4412A4 < 350.0 )
    {
      v1 = *(float *)&dword_4412A4 + 25.0;
      *(float *)&dword_4412A4 = v1;
      if ( v1 > 350.0 )
        dword_4412A4 = 1135542272;
    }
  }
}
// 4412A4: using guessed type int dword_4412A4;
// 44B982: using guessed type char byte_44B982;
// 455BF8: using guessed type int dword_455BF8;
// 455CB0: using guessed type int dword_455CB0;

//----- (0041FBC0) --------------------------------------------------------
float __usercall sub_41FBC0@<eax>()
{
  float result; // eax

  result = dword_44B73C;
  dword_4412A4 = 0;
  dword_448A08 = LODWORD(dword_44B73C);
  dword_448A10 = LODWORD(dword_44B744);
  *(float *)&dword_448A0C = *(float *)&dword_4412A8 + dword_44B740;
  dword_4489FC = LODWORD(dword_44B73C);
  dword_44B974 = 0;
  dword_44B978 = -1027080192;
  dword_44B97C = -996802560;
  *(float *)&dword_448A00 = *(float *)&dword_448A0C - 100.0;
  *(float *)&dword_448A04 = dword_44B744 - 1200.0;
  return result;
}
// 4412A4: using guessed type int dword_4412A4;
// 4412A8: using guessed type int dword_4412A8;
// 4489FC: using guessed type int dword_4489FC;
// 448A00: using guessed type int dword_448A00;
// 448A04: using guessed type int dword_448A04;
// 448A08: using guessed type int dword_448A08;
// 448A0C: using guessed type int dword_448A0C;
// 448A10: using guessed type int dword_448A10;
// 44B974: using guessed type int dword_44B974;
// 44B978: using guessed type int dword_44B978;
// 44B97C: using guessed type int dword_44B97C;

//----- (0041FC40) --------------------------------------------------------
char *sub_41FC40()
{
  int v0; // ecx
  __int16 *v1; // esi
  char *result; // eax
  char v3; // dl

  byte_44B994 = 5;
  v0 = 0;
  v1 = word_44B9DC;
  result = (char *)&unk_4423B0;
  do
  {
    v3 = *(result - 2);
    *(v1 - 32) = 0;
    byte_44B9BC[v0] = v3;
    byte_44B9CC[v0] = *result;
    *v1 = 0;
    result += 44;
    ++v0;
    ++v1;
    dword_44B9F8 = 0;
  }
  while ( result < (char *)&unk_4425C0 );
  return result;
}
// 44B994: using guessed type char byte_44B994;
// 44B9F8: using guessed type int dword_44B9F8;

//----- (0041FC90) --------------------------------------------------------
int sub_41FC90()
{
  int result; // eax
  int v1; // ecx
  __int16 *v2; // edx
  bool v3; // zf

  BYTE1(result) = BYTE1(dword_44B990);
  word_44B7FE = dword_44B990;
  dword_455BF0 = (unsigned __int16)dword_44B9F8;
  BYTE2(dword_44B804) = 5;
  v1 = 0;
  v2 = word_44B99C;
  do
  {
    LOBYTE(result) = *(_BYTE *)v2;
    v3 = (*(_BYTE *)v2 & 1) == 0;
    *((_BYTE *)&dword_44B81A + v1) = *(_BYTE *)v2;
    if ( !v3 )
    {
      LOBYTE(result) = result | 0x10;
      *((_BYTE *)&dword_44B81A + v1) = result;
    }
    ++v2;
    ++v1;
  }
  while ( v2 < (__int16 *)&unk_44B9B4 );
  return result;
}
// 44B7FE: using guessed type __int16 word_44B7FE;
// 44B804: using guessed type int dword_44B804;
// 44B81A: using guessed type int dword_44B81A;
// 44B990: using guessed type int dword_44B990;
// 44B9F8: using guessed type int dword_44B9F8;
// 455BF0: using guessed type int dword_455BF0;

//----- (0041FCE0) --------------------------------------------------------
char __cdecl sub_41FCE0(char a1)
{
  __int16 *v1; // eax
  int v2; // ecx

  byte_44B9FC = BYTE1(dword_455CB8);
  byte_44B9FE = dword_455CB8;
  byte_44B9FF = byte_455CB7;
  byte_44BA00 = byte_455CB5;
  byte_44BA01 = byte_455CB6;
  byte_44B994 = BYTE2(dword_44B804);
  LOBYTE(v1) = a1;
  byte_44B988 = 2 * BYTE2(dword_455CB8);
  dword_44B990 = (unsigned __int16)word_44B7FE;
  dword_44B9F8 = dword_455BF0;
  dword_44B98C = 1979666;
  dword_44B998 = 78564554;
  dword_44B9B8 = 32575514;
  dword_44B9C8 = 79218987;
  dword_44B9D8 = 12071978;
  dword_44B9F4 = 816128;
  if ( a1 != 1 )
  {
    v2 = 0;
    v1 = word_44B99C;
    do
    {
      *v1 = *((unsigned __int8 *)&dword_44B81A + v2);
      ++v1;
      ++v2;
    }
    while ( v1 < (__int16 *)&unk_44B9B4 );
  }
  return (char)v1;
}
// 44B7FE: using guessed type __int16 word_44B7FE;
// 44B804: using guessed type int dword_44B804;
// 44B81A: using guessed type int dword_44B81A;
// 44B988: using guessed type char byte_44B988;
// 44B98C: using guessed type int dword_44B98C;
// 44B990: using guessed type int dword_44B990;
// 44B994: using guessed type char byte_44B994;
// 44B998: using guessed type int dword_44B998;
// 44B9B8: using guessed type int dword_44B9B8;
// 44B9C8: using guessed type int dword_44B9C8;
// 44B9D8: using guessed type int dword_44B9D8;
// 44B9F4: using guessed type int dword_44B9F4;
// 44B9F8: using guessed type int dword_44B9F8;
// 44B9FC: using guessed type char byte_44B9FC;
// 44B9FE: using guessed type char byte_44B9FE;
// 44B9FF: using guessed type char byte_44B9FF;
// 44BA00: using guessed type char byte_44BA00;
// 44BA01: using guessed type char byte_44BA01;
// 455BF0: using guessed type int dword_455BF0;
// 455CB5: using guessed type char byte_455CB5;
// 455CB6: using guessed type char byte_455CB6;
// 455CB7: using guessed type char byte_455CB7;
// 455CB8: using guessed type int dword_455CB8;

//----- (0041FDB0) --------------------------------------------------------
char sub_41FDB0()
{
  AGLFILE *v0; // eax
  AGLFILE *v1; // esi
  char result; // al
  __int16 v3; // [esp+8h] [ebp-18h]
  int v4; // [esp+Ch] [ebp-14h]
  __int16 v5; // [esp+10h] [ebp-10h]
  int v6; // [esp+14h] [ebp-Ch]
  __int16 v7; // [esp+18h] [ebp-8h]
  int v8; // [esp+1Ch] [ebp-4h]

  v0 = sub_403630((int)aDataSavePinkyP, 20);
  v1 = v0;
  if ( v0 )
  {
    sub_403700(v0);
    sub_4036D0(v1, &byte_44B988, 0x7Cu);
    sub_403690(v1);
    v6 = 0x10000000;
    v8 = 0x10000000;
    v3 = -1;
    v4 = 0;
    v5 = 45;
    v7 = 64;
    sub_41FEF0((int)&v3, 0x4000u);
    result = 0;
  }
  else
  {
    v3 = -1;
    v4 = 0;
    v5 = 46;
    v6 = 0x10000000;
    v7 = 64;
    v8 = 0x10000000;
    sub_41FEF0((int)&v3, 0x4000u);
    result = 1;
  }
  return result;
}
// 44B988: using guessed type char byte_44B988;

//----- (0041FE80) --------------------------------------------------------
char sub_41FE80()
{
  AGLFILE *v0; // eax
  AGLFILE *v1; // esi

  v0 = sub_403630((int)aDataSavePinkyP, 2);
  v1 = v0;
  if ( !v0 )
    return 0;
  sub_403700(v0);
  sub_4036A0(v1, &byte_44B988, 0x7Cu);
  sub_403690(v1);
  return 1;
}
// 44B988: using guessed type char byte_44B988;

//----- (0041FEC0) --------------------------------------------------------
char sub_41FEC0()
{
  unsigned __int8 v0; // al
  unsigned __int8 v2; // [esp+0h] [ebp-4h]

  v0 = 0;
  v2 = 0;
  while ( !word_44B99C[v2] )
  {
    v2 = ++v0;
    if ( v0 >= 0xCu )
      return 1;
  }
  return 0;
}

//----- (0041FEF0) --------------------------------------------------------
int __cdecl sub_41FEF0(int a1, unsigned __int16 a2)
{
  unsigned int *v2; // esi
  unsigned int v3; // ebp
  __int16 v4; // cx
  unsigned int v5; // esi
  int v6; // ebx
  _DWORD *v7; // eax
  int v8; // esi
  double v9; // st7
  float v10; // ST64_4
  unsigned __int16 v11; // dx
  _DWORD *v12; // eax
  int v13; // esi
  unsigned __int16 v14; // cx
  int v15; // esi
  int v16; // ebx
  _DWORD *v17; // eax
  int v18; // esi
  double v19; // st7
  float v20; // ST64_4
  unsigned __int16 v21; // dx
  unsigned __int16 v22; // cx
  int v24; // [esp+10h] [ebp-ACh]
  signed int v25; // [esp+18h] [ebp-A4h]

  dword_4441C8 = (int (*)(void))nullsub_1;
  sub_402A90();
  v25 = 2;
  do
  {
    sub_401580(0);
    byte_443AF2 = -1;
    byte_443AF1 = -1;
    v2 = (unsigned int *)(a1 + 4);
    byte_443AF0 = -1;
    v3 = 0;
    v24 = a1 + 4;
    do
    {
      v4 = *((_WORD *)v2 - 2);
      if ( v4 == 39 )
      {
        v5 = *v2;
        if ( v5 == 0x10000000 )
          v6 = (*((_DWORD *)dword_443D44 + 2)
              - (unsigned __int16)dword_443AE4 * ((unsigned __int16)dword_44EC4C + (unsigned __int16)dword_44EC44 + 8))
             / 2;
        else
          v6 = v5;
        v7 = dword_443D2C;
        v8 = *((_DWORD *)dword_443D2C + 16032);
        v9 = (double)(unsigned int)v6;
        *((_DWORD *)dword_443D2C + 16032) = v8 + 128;
        *(_DWORD *)(v8 + 4) = 0;
        *(_DWORD *)v8 = v7[30];
        v7[30] = v8;
        *(float *)(v8 + 16) = v9;
        *(_BYTE *)(v8 + 34) = -1;
        *(_BYTE *)(v8 + 33) = -1;
        *(_BYTE *)(v8 + 32) = -1;
        *(_DWORD *)(v8 + 4) = 5;
        *(float *)(v8 + 20) = (double)(v3 * (HIWORD(dword_443AE4) + 15) + 188);
        v10 = (double)(unsigned int)(v6 + 32);
        *(float *)(v8 + 44) = v10;
        *(float *)(v8 + 48) = (double)(v3 * (HIWORD(dword_443AE4) + 15) + 188);
        *(float *)(v8 + 72) = v9;
        LOWORD(v7) = HIWORD(dword_443AE4);
        *(float *)(v8 + 100) = v10;
        *(float *)(v8 + 76) = (double)(v3 * ((unsigned __int16)v7 + 15) + 219);
        v11 = HIWORD(dword_443AE4);
        *(_DWORD *)(v8 + 28) = 1065353216;
        *(_DWORD *)(v8 + 56) = 1065353216;
        *(_DWORD *)(v8 + 84) = 1065353216;
        *(_DWORD *)(v8 + 112) = 1065353216;
        *(_DWORD *)(v8 + 40) = 1039726841;
        *(_DWORD *)(v8 + 68) = 1039726841;
        *(float *)(v8 + 104) = (double)(v3 * (v11 + 15) + 219);
        *(_DWORD *)(v8 + 24) = 0;
        *(_DWORD *)(v8 + 52) = 0;
        *(_DWORD *)(v8 + 80) = 0;
        *(_DWORD *)(v8 + 108) = 0;
        *(_DWORD *)(v8 + 36) = 1060945085;
        *(_DWORD *)(v8 + 64) = 1062918875;
        *(_DWORD *)(v8 + 92) = 1060945085;
        *(_DWORD *)(v8 + 96) = 1047589105;
        *(_DWORD *)(v8 + 120) = 1062918875;
        *(_DWORD *)(v8 + 124) = 1047589105;
        *(_DWORD *)(v8 + 8) = sub_401000(0, 0, 1263, 31);
        byte_443AF2 = -1;
        byte_443AF1 = -1;
        byte_443AF0 = -1;
        sub_4015D0(
          v6 + 2 * (unsigned __int16)dword_443AE4,
          v3 * (HIWORD(dword_443AE4) + 15) + 188,
          (unsigned __int16)dword_443AE4,
          HIWORD(dword_443AE4),
          0,
          0x10u);
        sub_401D10();
        v12 = dword_443D2C;
        v13 = *((_DWORD *)dword_443D2C + 16032);
        *((_DWORD *)dword_443D2C + 16032) = v13 + 128;
        *(_DWORD *)(v13 + 4) = 0;
        *(_DWORD *)v13 = v12[30];
        v12[30] = v13;
        *(_BYTE *)(v13 + 34) = -1;
        *(_BYTE *)(v13 + 33) = -1;
        *(_BYTE *)(v13 + 32) = -1;
        *(_DWORD *)(v13 + 4) = 5;
        *(float *)(v13 + 16) = (double)(v6
                                      + (unsigned __int16)dword_443AE4
                                      * ((unsigned int)(unsigned __int16)dword_44EC44 + 6));
        *(float *)(v13 + 20) = (double)(v3 * (HIWORD(dword_443AE4) + 15) + 188);
        *(float *)(v13 + 44) = (double)((unsigned __int16)dword_443AE4
                                      * ((unsigned int)(unsigned __int16)dword_44EC44 + 6)
                                      + v6
                                      + 32);
        *(float *)(v13 + 48) = (double)(v3 * (HIWORD(dword_443AE4) + 15) + 188);
        *(float *)(v13 + 72) = (double)(v6
                                      + (unsigned __int16)dword_443AE4
                                      * ((unsigned int)(unsigned __int16)dword_44EC44 + 6));
        *(float *)(v13 + 76) = (double)(v3 * (HIWORD(dword_443AE4) + 15) + 219);
        *(float *)(v13 + 100) = (double)((unsigned __int16)dword_443AE4
                                       * ((unsigned int)(unsigned __int16)dword_44EC44 + 6)
                                       + v6
                                       + 32);
        v14 = HIWORD(dword_443AE4);
        *(_DWORD *)(v13 + 28) = 1065353216;
        *(_DWORD *)(v13 + 56) = 1065353216;
        *(_DWORD *)(v13 + 84) = 1065353216;
        *(_DWORD *)(v13 + 112) = 1065353216;
        *(_DWORD *)(v13 + 36) = 1060945085;
        *(_DWORD *)(v13 + 92) = 1060945085;
        *(float *)(v13 + 104) = (double)(v3 * (v14 + 15) + 219);
        *(_DWORD *)(v13 + 24) = 0;
        *(_DWORD *)(v13 + 52) = 0;
        *(_DWORD *)(v13 + 80) = 0;
        *(_DWORD *)(v13 + 108) = 0;
        *(_DWORD *)(v13 + 40) = 0;
        *(_DWORD *)(v13 + 64) = 1062918875;
        *(_DWORD *)(v13 + 68) = 0;
        *(_DWORD *)(v13 + 96) = 1038674153;
        *(_DWORD *)(v13 + 120) = 1062918875;
        *(_DWORD *)(v13 + 124) = 1038674153;
        *(_DWORD *)(v13 + 8) = sub_401000(0, 0, 1263, 0);
        byte_443AF2 = -1;
        byte_443AF1 = -1;
        byte_443AF0 = -1;
        sub_4015D0(
          v6 + (unsigned __int16)dword_443AE4 * ((unsigned __int16)dword_44EC44 + 8),
          v3 * (HIWORD(dword_443AE4) + 15) + 188,
          (unsigned __int16)dword_443AE4,
          HIWORD(dword_443AE4),
          0,
          0x11u);
        v2 = (unsigned int *)v24;
      }
      else if ( v4 == 64 )
      {
        v15 = *v2;
        if ( v15 == 0x10000000 )
          v16 = (*((_DWORD *)dword_443D44 + 2)
               - (unsigned __int16)dword_443AE4 * ((unsigned __int16)dword_44EC4C + (unsigned __int16)dword_44EC44 + 8))
              / 2;
        else
          v16 = v15;
        v17 = dword_443D2C;
        v18 = *((_DWORD *)dword_443D2C + 16032);
        v19 = (double)(unsigned int)v16;
        *((_DWORD *)dword_443D2C + 16032) = v18 + 128;
        *(_DWORD *)(v18 + 4) = 0;
        *(_DWORD *)v18 = v17[30];
        v17[30] = v18;
        *(float *)(v18 + 16) = v19;
        *(_BYTE *)(v18 + 34) = -1;
        *(_BYTE *)(v18 + 33) = -1;
        *(_BYTE *)(v18 + 32) = -1;
        *(_DWORD *)(v18 + 4) = 5;
        *(float *)(v18 + 20) = (double)(v3 * (HIWORD(dword_443AE4) + 15) + 188);
        v20 = (double)(unsigned int)(v16 + 32);
        *(float *)(v18 + 44) = v20;
        *(float *)(v18 + 48) = (double)(v3 * (HIWORD(dword_443AE4) + 15) + 188);
        *(float *)(v18 + 72) = v19;
        v21 = HIWORD(dword_443AE4);
        *(float *)(v18 + 100) = v20;
        *(float *)(v18 + 76) = (double)(v3 * (v21 + 15) + 219);
        v22 = HIWORD(dword_443AE4);
        *(_DWORD *)(v18 + 28) = 1065353216;
        *(_DWORD *)(v18 + 56) = 1065353216;
        *(_DWORD *)(v18 + 84) = 1065353216;
        *(_DWORD *)(v18 + 112) = 1065353216;
        *(_DWORD *)(v18 + 40) = 1039726841;
        *(_DWORD *)(v18 + 68) = 1039726841;
        *(float *)(v18 + 104) = (double)(v3 * (v22 + 15) + 219);
        *(_DWORD *)(v18 + 24) = 0;
        *(_DWORD *)(v18 + 52) = 0;
        *(_DWORD *)(v18 + 80) = 0;
        *(_DWORD *)(v18 + 108) = 0;
        *(_DWORD *)(v18 + 36) = 1060945085;
        *(_DWORD *)(v18 + 64) = 1062918875;
        *(_DWORD *)(v18 + 92) = 1060945085;
        *(_DWORD *)(v18 + 96) = 1047589105;
        *(_DWORD *)(v18 + 120) = 1062918875;
        *(_DWORD *)(v18 + 124) = 1047589105;
        *(_DWORD *)(v18 + 8) = sub_401000(0, 0, 1263, 31);
        byte_443AF2 = -1;
        byte_443AF1 = -1;
        byte_443AF0 = -1;
        sub_4015D0(
          v16 + 2 * (unsigned __int16)dword_443AE4,
          v3 * (HIWORD(dword_443AE4) + 15) + 188,
          (unsigned __int16)dword_443AE4,
          HIWORD(dword_443AE4),
          0,
          0x40u);
        sub_401D10();
        v2 = (unsigned int *)v24;
      }
      else if ( v4 != -1 )
      {
        sub_4015D0(
          *v2,
          v3 * (HIWORD(dword_443AE4) + 15) + 100,
          (unsigned __int16)dword_443AE4,
          HIWORD(dword_443AE4),
          0,
          *((unsigned __int16 *)v2 - 2));
      }
      sub_401D10();
      ++v3;
      v2 += 2;
      v24 = (int)v2;
    }
    while ( v3 < 3 );
    sub_401D10();
    sub_401580(0);
    byte_443AF2 = -59;
    byte_443AF1 = 63;
    byte_443AF0 = 103;
    byte_443C1D = -59;
    byte_443C1E = 63;
    byte_443C1C = 103;
    sub_401E50(0, 0, 640, 480, 2);
    sub_401D10();
    sub_402A90();
    --v25;
  }
  while ( v25 );
  if ( a2 )
  {
    sub_404530();
    while ( 1 )
    {
      sub_434560();
      if ( (unsigned __int16)dword_455BEC & a2 )
        break;
      sub_404530();
    }
    sub_407E00((int)&dword_444758);
    sub_404910(0, a2);
  }
  dword_4441C8 = (int (*)(void))__inc_tmpoff;
  return (unsigned __int16)dword_455BEC & a2;
}
// 433690: using guessed type int __inc_tmpoff();
// 434B40: using guessed type int __cdecl nullsub_1(_DWORD);
// 443AE4: using guessed type int dword_443AE4;
// 443AF0: using guessed type char byte_443AF0;
// 443AF1: using guessed type char byte_443AF1;
// 443AF2: using guessed type char byte_443AF2;
// 443C1C: using guessed type char byte_443C1C;
// 443C1D: using guessed type char byte_443C1D;
// 443C1E: using guessed type char byte_443C1E;
// 4441C8: using guessed type int (*dword_4441C8)(void);
// 44EC44: using guessed type int dword_44EC44;
// 44EC4C: using guessed type int dword_44EC4C;
// 455BEC: using guessed type int dword_455BEC;

//----- (004206D0) --------------------------------------------------------
int __cdecl sub_4206D0(int a1)
{
  int result; // eax

  memset(&dword_44BA10, 0, 0x84u);
  *((_WORD *)&dword_44BA10 + 66) = 0;
  dword_44BAA4 = (void *)sub_401250(0x10000);
  dword_44BA08 = 0x10000;
  sub_402EB0(1);
  result = a1;
  dword_44BA9C = (int (__cdecl *)(_DWORD, _DWORD))a1;
  return result;
}
// 44BA08: using guessed type int dword_44BA08;
// 44BA10: using guessed type int dword_44BA10;
// 44BA9C: using guessed type int (__cdecl *dword_44BA9C)(_DWORD, _DWORD);

//----- (00420710) --------------------------------------------------------
char sub_420710()
{
  char result; // al

  if ( dword_44BA9C )
    dword_44BA9C(dword_44BAA0, dword_44BAA0);
  result = sub_401380((unsigned int)dword_44BAA4);
  dword_44BAA4 = 0;
  dword_44BA08 = 0;
  return result;
}
// 44BA9C: invalid function type has been ignored
// 44BA08: using guessed type int dword_44BA08;
// 44BA9C: using guessed type int (__cdecl *dword_44BA9C)(_DWORD, _DWORD);
// 44BAA0: using guessed type int dword_44BAA0;

//----- (00420750) --------------------------------------------------------
char __cdecl sub_420750(int a1)
{
  AGLFILE *v1; // eax
  int v2; // ebp
  int v4; // ebx
  unsigned __int8 *v5; // esi
  unsigned __int16 i; // si
  unsigned __int16 j; // si
  unsigned __int16 k; // si
  unsigned __int16 l; // si
  unsigned __int16 m; // si
  unsigned __int16 n; // si
  unsigned __int16 ii; // si
  int v13; // ebx
  unsigned int v14; // edi
  _BYTE *v15; // eax
  unsigned int v16; // [esp+8h] [ebp-B0h]
  char v17; // [esp+Ch] [ebp-ACh]
  __int16 v18; // [esp+Eh] [ebp-AAh]
  int v19; // [esp+52h] [ebp-66h]
  unsigned __int16 v20; // [esp+56h] [ebp-62h]
  int v21; // [esp+58h] [ebp-60h]
  int v22; // [esp+5Eh] [ebp-5Ah]
  int v23; // [esp+62h] [ebp-56h]
  int v24; // [esp+66h] [ebp-52h]
  unsigned __int16 v25; // [esp+6Ah] [ebp-4Eh]
  int v26; // [esp+6Ch] [ebp-4Ch]
  int v27; // [esp+78h] [ebp-40h]
  int v28; // [esp+B0h] [ebp-8h]
  int v29; // [esp+B4h] [ebp-4h]

  v1 = sub_403630(a1, 2);
  v2 = 0;
  dword_44BA98 = v1;
  if ( !v1 )
    return 0;
  dword_44BAAC = 0;
  dword_44BA08 = 0x10000;
  dword_44BAA0 = sub_403700(v1);
  sub_420CE0(&v17, 0xACu);
  nullsub_1(asc_441318);
  nullsub_1(aOpeningS);
  nullsub_1(asc_4412E4);
  nullsub_1(aNbtpageD);
  nullsub_1(aNbclutD);
  v4 = 0;
  v5 = (unsigned __int8 *)sub_401250(131080);
  if ( (unsigned __int16)v19 > 0u )
  {
    do
    {
      sub_420CE0((char *)v5, 0x20008u);
      if ( v18 )
        sub_402F20(
          (unsigned __int16 *)v5 + 4,
          *v5,
          *((unsigned __int16 *)v5 + 1),
          *((unsigned __int16 *)v5 + 2),
          0x100u,
          252,
          0);
      else
        sub_402F20(
          (unsigned __int16 *)v5 + 4,
          *v5,
          *((unsigned __int16 *)v5 + 1),
          *((unsigned __int16 *)v5 + 2),
          0x100u,
          *((unsigned __int16 *)v5 + 3),
          0);
      ++v4;
    }
    while ( (unsigned __int16)v4 < (unsigned __int16)v19 );
  }
  sub_401380((unsigned int)v5);
  if ( v18 )
  {
    if ( v18 == 1 )
    {
      v13 = 0;
      if ( v25 )
      {
        v14 = v16;
        do
        {
          if ( byte_44BA14[(unsigned __int16)v13] )
          {
            sub_422270(v2, v13, 1);
            v15 = (_BYTE *)(dword_448AC4 + 48 * (unsigned __int16)v2);
            *v15 = v13;
            switch ( (unsigned __int16)v13 )
            {
              case 0x23u:
                v14 = 0;
                sub_40A240((int)v15, 0);
                ++v2;
                break;
              case 0x43u:
                if ( dword_455BF8 != 11 )
                  goto LABEL_42;
                v14 = 10;
                sub_40A240((int)v15, 0xAu);
                ++v2;
                break;
              case 0x4Au:
                switch ( dword_455BF8 )
                {
                  case 0:
                  case 2:
                  case 7:
                  case 10:
                    v14 = 2;
                    sub_40A240((int)v15, 2u);
                    ++v2;
                    break;
                  case 3:
                    v14 = 1;
                    sub_40A240((int)v15, 1u);
                    ++v2;
                    break;
                  case 5:
                    v14 = 6;
                    sub_40A240((int)v15, 6u);
                    ++v2;
                    break;
                  default:
                    goto LABEL_45;
                }
                break;
              case 0x5Cu:
                v14 = 12;
                dword_455C8C = (int)v15;
                sub_40A240((int)v15, 0xCu);
                ++v2;
                break;
              default:
LABEL_42:
                if ( (unsigned __int8)byte_44BA14[(unsigned __int16)v13] >= 3u )
                {
                  v14 = 3;
LABEL_45:
                  sub_40A240((int)v15, v14);
                  ++v2;
                }
                else
                {
                  v14 = (unsigned __int8)byte_44BA14[(unsigned __int16)v13];
                  sub_40A240((int)v15, v14);
                  ++v2;
                }
                break;
            }
          }
          else
          {
            sub_422270(0, 0, 0);
          }
          ++v13;
        }
        while ( (unsigned __int16)v13 < v25 );
      }
    }
  }
  else
  {
    if ( v27 )
    {
      sub_420DF0();
      byte_455C13 = 1;
    }
    else
    {
      byte_455C13 = 0;
    }
    sub_409100(v28, v29);
    sub_40A830(HIWORD(v19));
    for ( i = 0; i < HIWORD(v19); ++i )
      sub_421470(i);
    sub_40AB70((unsigned __int16)v21);
    sub_40ACA0(v20);
    for ( j = 0; j < v20; ++j )
      sub_421CD0(j);
    for ( k = 0; k < (unsigned __int16)v21; ++k )
      sub_421E80(k);
    if ( sub_421FE0(HIWORD(v21)) )
      sub_420CE0((char *)dword_455C40, 32 * dword_455C44);
    sub_420CE0((char *)&dword_44BA10, 0x86u);
    sub_40A730(HIWORD(dword_44BA10));
    sub_416FD0((unsigned __int16)dword_44BA10);
    for ( l = 0; l < (unsigned __int16)dword_44BA10; ++l )
      sub_422160(l);
    sub_41F8D0((unsigned __int16)v22);
    sub_4226C0(dword_455C48, v22);
    sub_422890(HIWORD(v22));
    sub_420CE0((char *)dword_455C50, 16 * HIWORD(v22));
    sub_422970((unsigned __int16)v23);
    sub_4227F0(dword_455C58, v23);
    sub_422900(HIWORD(v23));
    sub_422750(dword_455C60, HIWORD(v23));
    sub_417040((unsigned __int16)v24);
    for ( m = 0; m < (unsigned __int16)v24; ++m )
      sub_4221E0(m);
    sub_417140(HIWORD(v24));
    for ( n = 0; n < HIWORD(v24); ++n )
      sub_4220F0(n);
    sub_40B5B0((unsigned __int16)v26);
    for ( ii = 0; ii < (unsigned __int16)v26; ++ii )
      sub_422050(ii);
  }
  sub_403690(dword_44BA98);
  return 1;
}
// 434B40: using guessed type int __cdecl nullsub_1(_DWORD);
// 448AC4: using guessed type int dword_448AC4;
// 44BA08: using guessed type int dword_44BA08;
// 44BA10: using guessed type int dword_44BA10;
// 44BAA0: using guessed type int dword_44BAA0;
// 44BAAC: using guessed type int dword_44BAAC;
// 455BF8: using guessed type int dword_455BF8;
// 455C13: using guessed type char byte_455C13;
// 455C40: using guessed type int dword_455C40;
// 455C44: using guessed type int dword_455C44;
// 455C48: using guessed type int dword_455C48;
// 455C50: using guessed type int dword_455C50;
// 455C58: using guessed type int dword_455C58;
// 455C60: using guessed type int dword_455C60;
// 455C8C: using guessed type int dword_455C8C;

//----- (00420CE0) --------------------------------------------------------
char __cdecl sub_420CE0(char *a1, unsigned int a2)
{
  unsigned int v2; // ebp
  char *v3; // ebx
  unsigned int v4; // ecx
  unsigned int v5; // eax
  char *v6; // esi
  char *v7; // edi

  if ( !dword_44BAA4 || !dword_44BA98 )
    return 0;
  v2 = a2;
  v3 = a1;
  dword_44BAAC += a2;
  if ( a2 )
  {
    v4 = dword_44BA08;
    while ( 1 )
    {
      if ( v4 >= 0x10000 )
      {
        sub_4036A0(dword_44BA98, dword_44BAA4, 0x10000u);
        v4 = 0;
        dword_44BA08 = 0;
        if ( dword_44BA9C )
        {
          dword_44BA9C(dword_44BAAC, dword_44BAA0);
          v4 = dword_44BA08;
        }
      }
      v5 = 0x10000 - v4;
      v6 = (char *)dword_44BAA4 + v4;
      if ( v2 <= 0x10000 - v4 )
        break;
      if ( v3 )
      {
        qmemcpy(v3, v6, 4 * (v5 >> 2));
        v7 = &v3[4 * (v5 >> 2)];
        v3 += v5;
        qmemcpy(v7, &v6[4 * ((0x10000 - v4) >> 2)], -(char)v4 & 3);
      }
      v4 = 0x10000;
      v2 -= v5;
      dword_44BA08 = 0x10000;
      if ( !v2 )
        return 1;
    }
    if ( v3 )
    {
      qmemcpy(v3, v6, v2);
      v4 = dword_44BA08;
    }
    dword_44BA08 = v2 + v4;
  }
  return 1;
}
// 44BA08: using guessed type int dword_44BA08;
// 44BA9C: using guessed type int (__cdecl *dword_44BA9C)(_DWORD, _DWORD);
// 44BAA0: using guessed type int dword_44BAA0;
// 44BAAC: using guessed type int dword_44BAAC;

//----- (00420DF0) --------------------------------------------------------
signed int sub_420DF0()
{
  int v1; // [esp+0h] [ebp-8h]
  int v2; // [esp+4h] [ebp-4h]

  sub_420CE0((char *)&v1, 8u);
  sub_4088E0(v1, HIWORD(v1), v2);
  sub_420E50((float *)dword_448AD4, v1);
  sub_420EC0(dword_448AE0, *(int *)((char *)&v1 + 2), 1);
  return sub_4212F0(dword_448AE4, v2);
}
// 448AD4: using guessed type int dword_448AD4;
// 448AE0: using guessed type int dword_448AE0;
// 448AE4: using guessed type int dword_448AE4;

//----- (00420E50) --------------------------------------------------------
signed int __cdecl sub_420E50(float *a1, unsigned __int16 a2)
{
  float *v2; // esi
  int v3; // edi
  signed int v4; // edx
  signed int result; // eax
  __int16 v6; // [esp+4h] [ebp-8h]
  __int16 v7; // [esp+6h] [ebp-6h]
  __int16 v8; // [esp+8h] [ebp-4h]

  if ( a2 )
  {
    v2 = a1;
    v3 = a2;
    do
    {
      sub_420CE0((char *)&v6, 6u);
      v4 = v7;
      result = v8;
      *v2 = (double)v6;
      v2 += 3;
      --v3;
      *(v2 - 2) = (double)v4;
      *(v2 - 1) = (double)result;
    }
    while ( v3 );
  }
  return result;
}

//----- (00420EC0) --------------------------------------------------------
int __cdecl sub_420EC0(int a1, int a2, char a3)
{
  int result; // eax
  int v4; // esi
  char v5; // cl
  unsigned __int16 v6; // dx
  __int16 v7; // ax
  double v8; // st7
  signed int v9; // edx
  __int16 v10; // ax
  signed int v11; // ecx
  signed int v12; // edx
  signed int v13; // eax
  signed int v14; // ecx
  signed int v15; // edx
  double v16; // st7
  signed int v17; // edx
  signed int v18; // eax
  signed int v19; // ecx
  double v20; // st7
  signed int v21; // edx
  double v22; // st7
  signed int v23; // eax
  double v24; // st7
  signed int v25; // ecx
  char v26; // [esp+4h] [ebp-30h]
  char v27; // [esp+8h] [ebp-2Ch]
  char v28; // [esp+9h] [ebp-2Bh]
  char v29; // [esp+Ah] [ebp-2Ah]
  int v30; // [esp+Bh] [ebp-29h]
  int v31; // [esp+10h] [ebp-24h]
  __int16 v32; // [esp+14h] [ebp-20h]
  __int16 v33; // [esp+16h] [ebp-1Eh]
  unsigned __int8 v34; // [esp+18h] [ebp-1Ch]
  unsigned __int8 v35; // [esp+19h] [ebp-1Bh]
  int v36; // [esp+1Ah] [ebp-1Ah]
  __int16 v37; // [esp+1Eh] [ebp-16h]
  int v38; // [esp+20h] [ebp-14h]
  __int16 v39; // [esp+24h] [ebp-10h]
  __int16 v40; // [esp+26h] [ebp-Eh]
  int v41; // [esp+28h] [ebp-Ch]
  __int16 v42; // [esp+2Ch] [ebp-8h]
  __int16 v43; // [esp+2Eh] [ebp-6h]
  __int16 v44; // [esp+30h] [ebp-4h]
  __int16 v45; // [esp+32h] [ebp-2h]
  signed int v46; // [esp+38h] [ebp+4h]
  signed int v47; // [esp+38h] [ebp+4h]
  signed int v48; // [esp+38h] [ebp+4h]
  signed int v49; // [esp+38h] [ebp+4h]
  signed int v50; // [esp+38h] [ebp+4h]
  signed int v51; // [esp+38h] [ebp+4h]
  signed int v52; // [esp+38h] [ebp+4h]
  signed int v53; // [esp+38h] [ebp+4h]
  int v54; // [esp+3Ch] [ebp+8h]

  result = a2;
  if ( (_WORD)a2 )
  {
    v4 = a1;
    v54 = (unsigned __int16)a2;
    do
    {
      sub_420CE0(&v26, 0x30u);
      v5 = v30;
      v6 = v36;
      *(_DWORD *)(v4 + 4) = 5;
      v7 = v42;
      *(_DWORD *)(v4 + 4) = ((v5 & 2) << 7) | 5;
      *(_WORD *)(v4 + 130) = v43;
      *(_DWORD *)(v4 + 8) = v6;
      v8 = (double)*(signed __int16 *)((char *)&v30 + 1);
      *(_WORD *)(v4 + 132) = v44;
      *(_WORD *)(v4 + 128) = v7;
      v9 = *(signed __int16 *)((char *)&v30 + 3);
      *(float *)(v4 + 16) = v8;
      v10 = v45;
      v11 = v33;
      *(float *)(v4 + 20) = (double)v9;
      *(_WORD *)(v4 + 134) = v10;
      v46 = v32;
      *(_DWORD *)(v4 + 24) = 0;
      v12 = SHIWORD(v36);
      *(float *)(v4 + 44) = (double)v46;
      *(_DWORD *)(v4 + 28) = 1065353216;
      v13 = v37;
      *(float *)(v4 + 48) = (double)v11;
      *(_DWORD *)(v4 + 52) = 0;
      v14 = v39;
      *(float *)(v4 + 72) = (double)v12;
      v47 = v13;
      LOBYTE(v13) = v27;
      v15 = v40;
      *(float *)(v4 + 76) = (double)v47;
      v48 = v14;
      LOBYTE(v14) = v28;
      v16 = (double)v48;
      v49 = v15;
      LOBYTE(v15) = v29;
      *(float *)(v4 + 100) = v16;
      *(_BYTE *)(v4 + 34) = 2 * v13;
      *(float *)(v4 + 104) = (double)v49;
      *(_DWORD *)(v4 + 56) = 1065353216;
      *(_DWORD *)(v4 + 80) = 0;
      *(_DWORD *)(v4 + 84) = 1065353216;
      *(_DWORD *)(v4 + 108) = 0;
      *(_DWORD *)(v4 + 112) = 1065353216;
      *(_BYTE *)(v4 + 33) = 2 * v14;
      *(_BYTE *)(v4 + 32) = 2 * v15;
      if ( a3 )
      {
        sub_421110((unsigned __int8 *)&v26, (float *)v4);
      }
      else
      {
        v50 = BYTE1(v31);
        v17 = v34;
        v18 = v35;
        v19 = (unsigned __int8)v38;
        *(float *)(v4 + 36) = (double)(unsigned __int8)v31 * 0.0039215689;
        v20 = (double)v50;
        v51 = v17;
        v21 = BYTE1(v38);
        *(float *)(v4 + 40) = v20 * 0.0039215689;
        v22 = (double)v51;
        v52 = v18;
        v23 = (unsigned __int8)v41;
        *(float *)(v4 + 64) = v22 * 0.0039215689;
        v24 = (double)v52;
        v53 = v19;
        v25 = BYTE1(v41);
        *(float *)(v4 + 68) = v24 * 0.0039215689;
        *(float *)(v4 + 92) = (double)v53 * 0.0039215689;
        *(float *)(v4 + 96) = (double)v21 * 0.0039215689;
        *(float *)(v4 + 120) = (double)v23 * 0.0039215689;
        *(float *)(v4 + 124) = (double)v25 * 0.0039215689;
      }
      v4 += 136;
      result = v54-- - 1;
    }
    while ( v54 );
  }
  return result;
}

//----- (00421110) --------------------------------------------------------
float *__cdecl sub_421110(unsigned __int8 *a1, float *a2)
{
  signed int v2; // edx
  signed int v3; // ecx
  double v4; // st7
  signed int v5; // edx
  double v6; // st7
  signed int v7; // ecx
  double v8; // st7
  signed int v9; // edx
  double v10; // st7
  signed int v11; // ecx
  double v12; // st7
  signed int v13; // edx
  unsigned int v14; // eax
  double v15; // st7
  double v16; // st6
  unsigned int v17; // esi
  float v18; // ST0C_4
  float v19; // ST00_4
  double v20; // st7
  float v21; // ST08_4
  float v22; // ST00_4
  float *result; // eax
  float v24; // [esp+10h] [ebp-24h]
  float v25; // [esp+14h] [ebp-20h]
  float v26; // [esp+18h] [ebp-1Ch]
  float v27; // [esp+1Ch] [ebp-18h]
  float v28; // [esp+20h] [ebp-14h]
  float v29; // [esp+24h] [ebp-10h]
  float v30; // [esp+28h] [ebp-Ch]
  float v31; // [esp+2Ch] [ebp-8h]
  float v32; // [esp+30h] [ebp-4h]
  float v33; // [esp+38h] [ebp+4h]

  v2 = a1[20];
  v3 = a1[28];
  v25 = (double)a1[12];
  v4 = (double)v2;
  v5 = a1[36];
  v26 = v4;
  v6 = (double)v3;
  v7 = a1[13];
  v27 = v6;
  v8 = (double)v5;
  v9 = a1[21];
  v28 = v8;
  v10 = (double)v7;
  v11 = a1[29];
  v29 = v10;
  v12 = (double)v9;
  v13 = a1[37];
  v14 = 0;
  v30 = v12;
  v31 = (double)v11;
  v32 = (double)v13;
  v15 = 0.0;
  v16 = 0.0;
  do
  {
    v16 = v16 + *(float *)((char *)&v25 + v14);
    v15 = v15 + *(float *)((char *)&v29 + v14);
    v14 += 4;
  }
  while ( v14 < 0x10 );
  v17 = 0;
  v24 = v15 * 0.25;
  do
  {
    v33 = *(float *)((char *)&v25 + v17);
    v18 = v16 * 0.25;
    v19 = v33 - v18;
    v20 = sub_4212B0(v19);
    v21 = *(float *)((char *)&v29 + v17);
    *(float *)((char *)&v25 + v17) = v33 - v20 * 0.60000002;
    v22 = v21 - v24;
    v17 += 4;
    *(float *)((char *)&v28 + v17) = v21 - sub_4212B0(v22) * 0.60000002;
  }
  while ( v17 < 0x10 );
  result = a2;
  a2[9] = v25 * 0.0039215689;
  a2[16] = v26 * 0.0039215689;
  a2[23] = v27 * 0.0039215689;
  a2[30] = v28 * 0.0039215689;
  a2[10] = v29 * 0.0039215689;
  a2[17] = v30 * 0.0039215689;
  a2[24] = v31 * 0.0039215689;
  a2[31] = v32 * 0.0039215689;
  return result;
}

//----- (004212B0) --------------------------------------------------------
double __cdecl sub_4212B0(float a1)
{
  if ( a1 < 0.0 )
    return -1.0;
  if ( a1 <= 0.0 )
    return 0.0;
  return 1.0;
}

//----- (004212F0) --------------------------------------------------------
signed int __cdecl sub_4212F0(int a1, unsigned __int16 a2)
{
  int v2; // ebp
  int v3; // esi
  __int16 v4; // cx
  int v5; // edx
  __int16 v6; // ax
  signed int v7; // edx
  __int16 v8; // ax
  signed int v9; // ecx
  signed int v10; // eax
  signed int v11; // edx
  signed int v12; // ecx
  signed int v13; // edx
  double v14; // st7
  double v15; // st7
  signed int result; // eax
  char v17; // [esp+8h] [ebp-2Ch]
  char v18; // [esp+Ch] [ebp-28h]
  char v19; // [esp+Dh] [ebp-27h]
  char v20; // [esp+Eh] [ebp-26h]
  int v21; // [esp+Fh] [ebp-25h]
  char v22; // [esp+14h] [ebp-20h]
  char v23; // [esp+15h] [ebp-1Fh]
  char v24; // [esp+16h] [ebp-1Eh]
  __int16 v25; // [esp+18h] [ebp-1Ch]
  __int16 v26; // [esp+1Ah] [ebp-1Ah]
  char v27; // [esp+1Ch] [ebp-18h]
  char v28; // [esp+1Dh] [ebp-17h]
  char v29; // [esp+1Eh] [ebp-16h]
  __int16 v30; // [esp+20h] [ebp-14h]
  __int16 v31; // [esp+22h] [ebp-12h]
  char v32; // [esp+24h] [ebp-10h]
  char v33; // [esp+25h] [ebp-Fh]
  char v34; // [esp+26h] [ebp-Eh]
  __int16 v35; // [esp+28h] [ebp-Ch]
  __int16 v36; // [esp+2Ah] [ebp-Ah]
  __int16 v37; // [esp+2Ch] [ebp-8h]
  __int16 v38; // [esp+2Eh] [ebp-6h]
  __int16 v39; // [esp+30h] [ebp-4h]
  __int16 v40; // [esp+32h] [ebp-2h]
  signed int v41; // [esp+3Ch] [ebp+8h]
  signed int v42; // [esp+3Ch] [ebp+8h]
  signed int v43; // [esp+3Ch] [ebp+8h]

  if ( a2 )
  {
    v2 = a2;
    v3 = a1 + 4;
    do
    {
      sub_420CE0(&v17, 0x2Cu);
      v4 = v38;
      v5 = v21 & 2;
      *(_DWORD *)v3 = 135;
      v5 <<= 7;
      LOBYTE(v5) = v5 | 0x87;
      v6 = v37;
      *(_DWORD *)v3 = v5;
      LOWORD(v5) = v39;
      *(_WORD *)(v3 + 86) = v4;
      *(_WORD *)(v3 + 88) = v5;
      v7 = *(signed __int16 *)((char *)&v21 + 3);
      v41 = *(signed __int16 *)((char *)&v21 + 1);
      *(_WORD *)(v3 + 84) = v6;
      v8 = v40;
      v9 = v26;
      *(float *)(v3 + 4) = (double)v41;
      *(_WORD *)(v3 + 90) = v8;
      *(_DWORD *)(v3 + 12) = 0;
      v10 = v25;
      *(float *)(v3 + 8) = (double)v7;
      *(_DWORD *)(v3 + 16) = 1065353216;
      v11 = v30;
      *(float *)(v3 + 24) = (double)v10;
      *(_DWORD *)(v3 + 32) = 0;
      result = v31;
      *(float *)(v3 + 28) = (double)v9;
      *(_DWORD *)(v3 + 36) = 1065353216;
      v12 = v35;
      *(float *)(v3 + 44) = (double)v11;
      v13 = v36;
      v14 = (double)result;
      v42 = v12;
      LOBYTE(v12) = v19;
      *(_BYTE *)(v3 + 22) = v18;
      LOBYTE(result) = v22;
      *(float *)(v3 + 48) = v14;
      v15 = (double)v42;
      v43 = v13;
      LOBYTE(v13) = v20;
      *(_BYTE *)(v3 + 21) = v12;
      LOBYTE(v12) = v23;
      *(float *)(v3 + 64) = v15;
      *(_BYTE *)(v3 + 20) = v13;
      LOBYTE(v13) = v24;
      *(_BYTE *)(v3 + 42) = result;
      LOBYTE(result) = v27;
      *(float *)(v3 + 68) = (double)v43;
      *(_BYTE *)(v3 + 41) = v12;
      LOBYTE(v12) = v28;
      *(_BYTE *)(v3 + 40) = v13;
      LOBYTE(v13) = v29;
      *(_BYTE *)(v3 + 62) = result;
      LOBYTE(result) = v32;
      *(_BYTE *)(v3 + 61) = v12;
      LOBYTE(v12) = v33;
      *(_DWORD *)(v3 + 52) = 0;
      *(_DWORD *)(v3 + 56) = 1065353216;
      *(_DWORD *)(v3 + 72) = 0;
      *(_DWORD *)(v3 + 76) = 1065353216;
      *(_BYTE *)(v3 + 60) = v13;
      *(_BYTE *)(v3 + 82) = result;
      LOBYTE(v13) = v34;
      *(_BYTE *)(v3 + 81) = v12;
      *(_BYTE *)(v3 + 80) = v13;
      v3 += 96;
      --v2;
    }
    while ( v2 );
  }
  return result;
}

//----- (00421470) --------------------------------------------------------
int __cdecl sub_421470(unsigned __int16 a1)
{
  int *v1; // esi
  int result; // eax
  char v3; // [esp+4h] [ebp-2Ch]
  int v4; // [esp+28h] [ebp-8h]
  int v5; // [esp+2Ch] [ebp-4h]

  v1 = (int *)(dword_448AAC + 20 * a1);
  sub_420CE0(&v3, 0x2Cu);
  nullsub_1(aLoadingObjectS);
  sub_408DC0(v1, (unsigned __int16)v4);
  sub_420E50((float *)*v1, v4);
  sub_40A790((int)v1, SHIWORD(v4), v5);
  if ( HIWORD(v4) )
    sub_421510(v1[3], *(int *)((char *)&v4 + 2), 1);
  result = v5;
  if ( (_WORD)v5 )
    result = sub_421890(v1[4], v5, 1);
  return result;
}
// 434B40: using guessed type int __cdecl nullsub_1(_DWORD);
// 448AAC: using guessed type int dword_448AAC;

//----- (00421510) --------------------------------------------------------
int __cdecl sub_421510(int a1, int a2, char a3)
{
  int result; // eax
  int v4; // esi
  char v5; // cl
  unsigned __int16 v6; // dx
  __int16 v7; // ax
  int v8; // ecx
  double v9; // st7
  signed int v10; // edx
  __int16 v11; // ax
  signed int v12; // ecx
  signed int v13; // edx
  signed int v14; // eax
  double v15; // st7
  double v16; // st7
  signed int v17; // eax
  signed int v18; // ecx
  signed int v19; // edx
  double v20; // st7
  signed int v21; // eax
  char v22; // [esp+4h] [ebp-30h]
  char v23; // [esp+8h] [ebp-2Ch]
  char v24; // [esp+9h] [ebp-2Bh]
  char v25; // [esp+Ah] [ebp-2Ah]
  int v26; // [esp+Bh] [ebp-29h]
  int v27; // [esp+10h] [ebp-24h]
  char v28; // [esp+14h] [ebp-20h]
  char v29; // [esp+15h] [ebp-1Fh]
  char v30; // [esp+16h] [ebp-1Eh]
  __int16 v31; // [esp+18h] [ebp-1Ch]
  __int16 v32; // [esp+1Ah] [ebp-1Ah]
  unsigned __int8 v33; // [esp+1Ch] [ebp-18h]
  unsigned __int8 v34; // [esp+1Dh] [ebp-17h]
  int v35; // [esp+1Eh] [ebp-16h]
  char v36; // [esp+22h] [ebp-12h]
  __int16 v37; // [esp+24h] [ebp-10h]
  __int16 v38; // [esp+26h] [ebp-Eh]
  int v39; // [esp+28h] [ebp-Ch]
  __int16 v40; // [esp+2Ch] [ebp-8h]
  __int16 v41; // [esp+2Eh] [ebp-6h]
  __int16 v42; // [esp+30h] [ebp-4h]
  __int16 v43; // [esp+32h] [ebp-2h]
  signed int v44; // [esp+38h] [ebp+4h]
  signed int v45; // [esp+38h] [ebp+4h]
  signed int v46; // [esp+38h] [ebp+4h]
  signed int v47; // [esp+38h] [ebp+4h]
  signed int v48; // [esp+38h] [ebp+4h]
  int v49; // [esp+3Ch] [ebp+8h]

  result = a2;
  if ( (_WORD)a2 )
  {
    v4 = a1;
    v49 = (unsigned __int16)a2;
    do
    {
      sub_420CE0(&v22, 0x30u);
      v5 = v26;
      v6 = v35;
      *(_DWORD *)(v4 + 4) = 136;
      v7 = v40;
      v8 = (v5 & 2) << 7;
      LOBYTE(v8) = v8 | 0x88;
      *(_DWORD *)(v4 + 4) = v8;
      *(_WORD *)(v4 + 98) = v41;
      *(_DWORD *)(v4 + 8) = v6;
      v9 = (double)*(signed __int16 *)((char *)&v26 + 1);
      *(_WORD *)(v4 + 100) = v42;
      *(_WORD *)(v4 + 96) = v7;
      v10 = *(signed __int16 *)((char *)&v26 + 3);
      *(float *)(v4 + 12) = v9;
      v11 = v43;
      v12 = v32;
      *(float *)(v4 + 16) = (double)v10;
      *(_WORD *)(v4 + 102) = v11;
      v44 = v31;
      *(_DWORD *)(v4 + 20) = 0;
      v13 = v37;
      *(float *)(v4 + 40) = (double)v44;
      v14 = v38;
      v15 = (double)v12;
      v45 = v13;
      LOBYTE(v13) = v24;
      LOBYTE(v12) = 2 * v23;
      *(float *)(v4 + 44) = v15;
      v16 = (double)v45;
      v46 = v14;
      LOBYTE(v14) = v25;
      *(float *)(v4 + 68) = v16;
      *(_BYTE *)(v4 + 30) = v12;
      LOBYTE(v12) = v28;
      *(_BYTE *)(v4 + 29) = 2 * v13;
      LOBYTE(v13) = v29;
      *(_BYTE *)(v4 + 28) = 2 * v14;
      LOBYTE(v14) = v30;
      *(float *)(v4 + 72) = (double)v46;
      *(_BYTE *)(v4 + 58) = 2 * v12;
      LOBYTE(v12) = BYTE2(v35);
      *(_BYTE *)(v4 + 57) = 2 * v13;
      LOBYTE(v13) = HIBYTE(v35);
      *(_BYTE *)(v4 + 56) = 2 * v14;
      *(_BYTE *)(v4 + 84) = 2 * v36;
      *(_DWORD *)(v4 + 24) = 1065353216;
      *(_DWORD *)(v4 + 48) = 0;
      *(_DWORD *)(v4 + 52) = 1065353216;
      *(_DWORD *)(v4 + 76) = 0;
      *(_DWORD *)(v4 + 80) = 1065353216;
      *(_BYTE *)(v4 + 86) = 2 * v12;
      *(_BYTE *)(v4 + 85) = 2 * v13;
      if ( a3 )
      {
        sub_421730((unsigned __int8 *)&v22, (float *)v4);
      }
      else
      {
        v47 = BYTE1(v27);
        v17 = v33;
        v18 = v34;
        v19 = (unsigned __int8)v39;
        *(float *)(v4 + 32) = (double)(unsigned __int8)v27 * 0.0039215689;
        v20 = (double)v47;
        v48 = v17;
        v21 = BYTE1(v39);
        *(float *)(v4 + 36) = v20 * 0.0039215689;
        *(float *)(v4 + 60) = (double)v48 * 0.0039215689;
        *(float *)(v4 + 64) = (double)v18 * 0.0039215689;
        *(float *)(v4 + 88) = (double)v19 * 0.0039215689;
        *(float *)(v4 + 92) = (double)v21 * 0.0039215689;
      }
      v4 += 104;
      result = v49-- - 1;
    }
    while ( v49 );
  }
  return result;
}

//----- (00421730) --------------------------------------------------------
float *__cdecl sub_421730(unsigned __int8 *a1, float *a2)
{
  signed int v2; // edx
  signed int v3; // ecx
  double v4; // st7
  signed int v5; // edx
  double v6; // st7
  signed int v7; // ecx
  double v8; // st7
  signed int v9; // edx
  unsigned int v10; // eax
  double v11; // st7
  double v12; // st6
  unsigned int v13; // esi
  float v14; // ST0C_4
  float v15; // ST00_4
  double v16; // st7
  float v17; // ST08_4
  float v18; // ST00_4
  float *result; // eax
  float v20; // [esp+10h] [ebp-1Ch]
  float v21; // [esp+14h] [ebp-18h]
  float v22; // [esp+18h] [ebp-14h]
  float v23; // [esp+1Ch] [ebp-10h]
  float v24; // [esp+20h] [ebp-Ch]
  float v25; // [esp+24h] [ebp-8h]
  float v26; // [esp+28h] [ebp-4h]
  float v27; // [esp+30h] [ebp+4h]

  v2 = a1[24];
  v3 = a1[36];
  v21 = (double)a1[12];
  v4 = (double)v2;
  v5 = a1[13];
  v22 = v4;
  v6 = (double)v3;
  v7 = a1[25];
  v23 = v6;
  v8 = (double)v5;
  v9 = a1[37];
  v10 = 0;
  v24 = v8;
  v25 = (double)v7;
  v26 = (double)v9;
  v11 = 0.0;
  v12 = 0.0;
  do
  {
    v12 = v12 + *(float *)((char *)&v21 + v10);
    v11 = v11 + *(float *)((char *)&v24 + v10);
    v10 += 4;
  }
  while ( v10 < 0xC );
  v13 = 0;
  v20 = v11 * 0.33333334;
  do
  {
    v27 = *(float *)((char *)&v21 + v13);
    v14 = v12 * 0.33333334;
    v15 = v27 - v14;
    v16 = sub_4212B0(v15);
    v17 = *(float *)((char *)&v24 + v13);
    *(float *)((char *)&v21 + v13) = v27 - v16 * 0.60000002;
    v18 = v17 - v20;
    v13 += 4;
    *(float *)((char *)&v23 + v13) = v17 - sub_4212B0(v18) * 0.60000002;
  }
  while ( v13 < 0xC );
  result = a2;
  a2[8] = v21 * 0.0039215689;
  a2[15] = v22 * 0.0039215689;
  a2[22] = v23 * 0.0039215689;
  a2[9] = v24 * 0.0039215689;
  a2[16] = v25 * 0.0039215689;
  a2[23] = v26 * 0.0039215689;
  return result;
}

//----- (00421890) --------------------------------------------------------
int __cdecl sub_421890(int a1, int a2, char a3)
{
  int result; // eax
  int v4; // esi
  char v5; // cl
  unsigned __int16 v6; // dx
  __int16 v7; // ax
  int v8; // ecx
  double v9; // st7
  signed int v10; // edx
  __int16 v11; // ax
  signed int v12; // ecx
  signed int v13; // edx
  signed int v14; // eax
  signed int v15; // ecx
  signed int v16; // edx
  double v17; // st7
  double v18; // st7
  signed int v19; // edx
  signed int v20; // eax
  signed int v21; // ecx
  double v22; // st7
  signed int v23; // edx
  double v24; // st7
  signed int v25; // eax
  double v26; // st7
  signed int v27; // ecx
  char v28; // [esp+4h] [ebp-3Ch]
  char v29; // [esp+8h] [ebp-38h]
  char v30; // [esp+9h] [ebp-37h]
  char v31; // [esp+Ah] [ebp-36h]
  int v32; // [esp+Bh] [ebp-35h]
  int v33; // [esp+10h] [ebp-30h]
  char v34; // [esp+14h] [ebp-2Ch]
  char v35; // [esp+15h] [ebp-2Bh]
  char v36; // [esp+16h] [ebp-2Ah]
  __int16 v37; // [esp+18h] [ebp-28h]
  __int16 v38; // [esp+1Ah] [ebp-26h]
  unsigned __int8 v39; // [esp+1Ch] [ebp-24h]
  unsigned __int8 v40; // [esp+1Dh] [ebp-23h]
  int v41; // [esp+1Eh] [ebp-22h]
  char v42; // [esp+22h] [ebp-1Eh]
  __int16 v43; // [esp+24h] [ebp-1Ch]
  __int16 v44; // [esp+26h] [ebp-1Ah]
  int v45; // [esp+28h] [ebp-18h]
  char v46; // [esp+2Ch] [ebp-14h]
  char v47; // [esp+2Dh] [ebp-13h]
  char v48; // [esp+2Eh] [ebp-12h]
  __int16 v49; // [esp+30h] [ebp-10h]
  __int16 v50; // [esp+32h] [ebp-Eh]
  int v51; // [esp+34h] [ebp-Ch]
  __int16 v52; // [esp+38h] [ebp-8h]
  __int16 v53; // [esp+3Ah] [ebp-6h]
  __int16 v54; // [esp+3Ch] [ebp-4h]
  __int16 v55; // [esp+3Eh] [ebp-2h]
  signed int v56; // [esp+44h] [ebp+4h]
  signed int v57; // [esp+44h] [ebp+4h]
  signed int v58; // [esp+44h] [ebp+4h]
  signed int v59; // [esp+44h] [ebp+4h]
  signed int v60; // [esp+44h] [ebp+4h]
  signed int v61; // [esp+44h] [ebp+4h]
  signed int v62; // [esp+44h] [ebp+4h]
  int v63; // [esp+48h] [ebp+8h]

  result = a2;
  if ( (_WORD)a2 )
  {
    v4 = a1;
    v63 = (unsigned __int16)a2;
    do
    {
      sub_420CE0(&v28, 0x3Cu);
      v5 = v32;
      v6 = v41;
      *(_DWORD *)(v4 + 4) = 137;
      v7 = v52;
      v8 = (v5 & 2) << 7;
      LOBYTE(v8) = v8 | 0x89;
      *(_DWORD *)(v4 + 4) = v8;
      *(_WORD *)(v4 + 126) = v53;
      *(_DWORD *)(v4 + 8) = v6;
      v9 = (double)*(signed __int16 *)((char *)&v32 + 1);
      *(_WORD *)(v4 + 128) = v54;
      *(_WORD *)(v4 + 124) = v7;
      v10 = *(signed __int16 *)((char *)&v32 + 3);
      *(float *)(v4 + 12) = v9;
      v11 = v55;
      v12 = v38;
      *(float *)(v4 + 16) = (double)v10;
      *(_WORD *)(v4 + 130) = v11;
      v56 = v37;
      *(_DWORD *)(v4 + 20) = 0;
      v13 = v43;
      *(float *)(v4 + 40) = (double)v56;
      *(_DWORD *)(v4 + 24) = 1065353216;
      v14 = v44;
      *(float *)(v4 + 44) = (double)v12;
      *(_DWORD *)(v4 + 48) = 0;
      v15 = v49;
      *(float *)(v4 + 68) = (double)v13;
      v16 = v50;
      v17 = (double)v14;
      v57 = v15;
      LOBYTE(v15) = v30;
      LOBYTE(v14) = 2 * v29;
      *(float *)(v4 + 72) = v17;
      v18 = (double)v57;
      v58 = v16;
      LOBYTE(v16) = v31;
      *(float *)(v4 + 96) = v18;
      *(_BYTE *)(v4 + 30) = v14;
      LOBYTE(v14) = v34;
      *(float *)(v4 + 100) = (double)v58;
      *(_BYTE *)(v4 + 29) = 2 * v15;
      LOBYTE(v15) = v35;
      *(_BYTE *)(v4 + 28) = 2 * v16;
      LOBYTE(v16) = 2 * v36;
      *(_DWORD *)(v4 + 52) = 1065353216;
      *(_DWORD *)(v4 + 76) = 0;
      *(_DWORD *)(v4 + 80) = 1065353216;
      *(_DWORD *)(v4 + 104) = 0;
      *(_DWORD *)(v4 + 108) = 1065353216;
      *(_BYTE *)(v4 + 58) = 2 * v14;
      *(_BYTE *)(v4 + 57) = 2 * v15;
      *(_BYTE *)(v4 + 56) = v16;
      LOBYTE(v15) = HIBYTE(v41);
      LOBYTE(v16) = v42;
      *(_BYTE *)(v4 + 86) = 2 * BYTE2(v41);
      LOBYTE(v14) = 2 * v46;
      *(_BYTE *)(v4 + 85) = 2 * v15;
      LOBYTE(v15) = v47;
      *(_BYTE *)(v4 + 84) = 2 * v16;
      LOBYTE(v16) = v48;
      *(_BYTE *)(v4 + 114) = v14;
      *(_BYTE *)(v4 + 113) = 2 * v15;
      *(_BYTE *)(v4 + 112) = 2 * v16;
      if ( a3 )
      {
        sub_421B30((unsigned __int8 *)&v28, (float *)v4);
      }
      else
      {
        v59 = BYTE1(v33);
        v19 = v39;
        v20 = v40;
        v21 = (unsigned __int8)v45;
        *(float *)(v4 + 32) = (double)(unsigned __int8)v33 * 0.0039215689;
        v22 = (double)v59;
        v60 = v19;
        v23 = BYTE1(v45);
        *(float *)(v4 + 36) = v22 * 0.0039215689;
        v24 = (double)v60;
        v61 = v20;
        v25 = (unsigned __int8)v51;
        *(float *)(v4 + 60) = v24 * 0.0039215689;
        v26 = (double)v61;
        v62 = v21;
        v27 = BYTE1(v51);
        *(float *)(v4 + 64) = v26 * 0.0039215689;
        *(float *)(v4 + 88) = (double)v62 * 0.0039215689;
        *(float *)(v4 + 92) = (double)v23 * 0.0039215689;
        *(float *)(v4 + 116) = (double)v25 * 0.0039215689;
        *(float *)(v4 + 120) = (double)v27 * 0.0039215689;
      }
      v4 += 132;
      result = v63-- - 1;
    }
    while ( v63 );
  }
  return result;
}

//----- (00421B30) --------------------------------------------------------
float *__cdecl sub_421B30(unsigned __int8 *a1, float *a2)
{
  signed int v2; // edx
  signed int v3; // ecx
  double v4; // st7
  signed int v5; // edx
  double v6; // st7
  signed int v7; // ecx
  double v8; // st7
  signed int v9; // edx
  double v10; // st7
  signed int v11; // ecx
  double v12; // st7
  signed int v13; // edx
  unsigned int v14; // eax
  double v15; // st7
  double v16; // st6
  unsigned int v17; // esi
  float v18; // ST0C_4
  float v19; // ST00_4
  double v20; // st7
  float v21; // ST08_4
  float v22; // ST00_4
  float *result; // eax
  float v24; // [esp+10h] [ebp-24h]
  float v25; // [esp+14h] [ebp-20h]
  float v26; // [esp+18h] [ebp-1Ch]
  float v27; // [esp+1Ch] [ebp-18h]
  float v28; // [esp+20h] [ebp-14h]
  float v29; // [esp+24h] [ebp-10h]
  float v30; // [esp+28h] [ebp-Ch]
  float v31; // [esp+2Ch] [ebp-8h]
  float v32; // [esp+30h] [ebp-4h]
  float v33; // [esp+38h] [ebp+4h]

  v2 = a1[24];
  v3 = a1[36];
  v25 = (double)a1[12];
  v4 = (double)v2;
  v5 = a1[48];
  v26 = v4;
  v6 = (double)v3;
  v7 = a1[13];
  v27 = v6;
  v8 = (double)v5;
  v9 = a1[25];
  v28 = v8;
  v10 = (double)v7;
  v11 = a1[37];
  v29 = v10;
  v12 = (double)v9;
  v13 = a1[49];
  v14 = 0;
  v30 = v12;
  v31 = (double)v11;
  v32 = (double)v13;
  v15 = 0.0;
  v16 = 0.0;
  do
  {
    v16 = v16 + *(float *)((char *)&v25 + v14);
    v15 = v15 + *(float *)((char *)&v29 + v14);
    v14 += 4;
  }
  while ( v14 < 0x10 );
  v17 = 0;
  v24 = v15 * 0.25;
  do
  {
    v33 = *(float *)((char *)&v25 + v17);
    v18 = v16 * 0.25;
    v19 = v33 - v18;
    v20 = sub_4212B0(v19);
    v21 = *(float *)((char *)&v29 + v17);
    *(float *)((char *)&v25 + v17) = v33 - v20 * 0.60000002;
    v22 = v21 - v24;
    v17 += 4;
    *(float *)((char *)&v28 + v17) = v21 - sub_4212B0(v22) * 0.60000002;
  }
  while ( v17 < 0x10 );
  result = a2;
  a2[8] = v25 * 0.0039215689;
  a2[15] = v26 * 0.0039215689;
  a2[22] = v27 * 0.0039215689;
  a2[29] = v28 * 0.0039215689;
  a2[9] = v29 * 0.0039215689;
  a2[16] = v30 * 0.0039215689;
  a2[23] = v31 * 0.0039215689;
  a2[30] = v32 * 0.0039215689;
  return result;
}

//----- (00421CD0) --------------------------------------------------------
__int16 __cdecl sub_421CD0(unsigned __int16 a1)
{
  int v1; // esi
  double v2; // st7
  double v3; // st7
  int v4; // ecx
  _BYTE *v5; // eax
  __int16 result; // ax
  char v7; // [esp+Ch] [ebp-38h]
  int v8; // [esp+10h] [ebp-34h]
  int v9; // [esp+14h] [ebp-30h]
  int v10; // [esp+18h] [ebp-2Ch]
  int v11; // [esp+1Ch] [ebp-28h]
  __int16 v12; // [esp+20h] [ebp-24h]
  __int16 v13; // [esp+22h] [ebp-22h]
  __int16 v14; // [esp+24h] [ebp-20h]
  __int16 v15; // [esp+26h] [ebp-1Eh]
  __int16 v16; // [esp+28h] [ebp-1Ch]
  __int16 v17; // [esp+2Ah] [ebp-1Ah]
  __int16 v18; // [esp+2Ch] [ebp-18h]
  __int16 v19; // [esp+2Eh] [ebp-16h]
  int v20; // [esp+30h] [ebp-14h]
  __int16 v21; // [esp+34h] [ebp-10h]
  __int16 v22; // [esp+36h] [ebp-Eh]
  __int16 v23; // [esp+38h] [ebp-Ch]
  __int16 v24; // [esp+3Ah] [ebp-Ah]
  __int16 v25; // [esp+3Ch] [ebp-8h]
  __int16 v26; // [esp+3Eh] [ebp-6h]
  __int16 v27; // [esp+40h] [ebp-4h]
  __int16 v28; // [esp+42h] [ebp-2h]

  v1 = dword_455C20 + 120 * a1;
  sub_420CE0(&v7, 0x38u);
  nullsub_1(aLoadingBlocD);
  *(float *)(v1 + 8) = (double)v12;
  *(float *)(v1 + 12) = (double)v13;
  *(float *)(v1 + 24) = (double)v16;
  *(float *)(v1 + 16) = (double)v14;
  *(float *)(v1 + 20) = (double)v15;
  *(float *)(v1 + 28) = (double)v17;
  *(float *)(v1 + 60) = (double)v9;
  *(float *)(v1 + 64) = (double)v10;
  *(float *)(v1 + 68) = (double)v11;
  v2 = (double)(v10 + v13);
  if ( v2 < flt_455C08 )
    flt_455C08 = v2;
  v3 = (double)(v10 + v15);
  if ( v3 > flt_455C0C )
    flt_455C0C = v3;
  *(_DWORD *)(v1 + 4) = v8;
  *(_DWORD *)(v1 + 32) = v20;
  v4 = HIWORD(v20);
  if ( HIWORD(v20) )
  {
    v5 = (_BYTE *)(dword_455C38 + 12 * (unsigned __int16)v20 + 3);
    do
    {
      *v5 = a1;
      v5 += 12;
      --v4;
    }
    while ( v4 );
  }
  *(_WORD *)(v1 + 36) = v18;
  *(_WORD *)(v1 + 38) = v19;
  *(_WORD *)(v1 + 40) = v21;
  *(_WORD *)(v1 + 42) = v22;
  *(_WORD *)(v1 + 48) = v23;
  *(_WORD *)(v1 + 50) = v24;
  *(_WORD *)(v1 + 52) = v25;
  *(_WORD *)(v1 + 54) = v26;
  *(_WORD *)(v1 + 56) = v27;
  result = v28;
  *(_WORD *)(v1 + 58) = v28;
  return result;
}
// 434B40: using guessed type int __cdecl nullsub_1(_DWORD);
// 455C08: using guessed type float flt_455C08;
// 455C0C: using guessed type float flt_455C0C;
// 455C20: using guessed type int dword_455C20;
// 455C38: using guessed type int dword_455C38;

//----- (00421E80) --------------------------------------------------------
char __cdecl sub_421E80(unsigned __int16 a1)
{
  int v1; // esi
  char result; // al
  int v3; // esi
  int v4; // edi
  int v5; // [esp+8h] [ebp-20h]
  __int16 v6; // [esp+Ch] [ebp-1Ch]
  __int16 v7; // [esp+Eh] [ebp-1Ah]
  __int16 v8; // [esp+10h] [ebp-18h]
  __int16 v9; // [esp+12h] [ebp-16h]
  __int16 v10; // [esp+14h] [ebp-14h]
  __int16 v11; // [esp+16h] [ebp-12h]
  __int16 v12; // [esp+18h] [ebp-10h]
  __int16 v13; // [esp+1Ah] [ebp-Eh]
  __int16 v14; // [esp+1Ch] [ebp-Ch]
  __int16 v15; // [esp+1Eh] [ebp-Ah]
  __int16 v16; // [esp+20h] [ebp-8h]
  __int16 v17; // [esp+22h] [ebp-6h]
  int v18; // [esp+24h] [ebp-4h]

  v1 = dword_455C38 + 12 * a1;
  sub_420CE0((char *)&v5, 8u);
  *(_WORD *)v1 = v5;
  if ( !(v5 & 0x100) )
    *(_WORD *)v1 = v5 & 0xFFDF;
  *(_WORD *)(v1 + 4) = v6;
  *(_WORD *)(v1 + 6) = v7;
  result = sub_40AB30(v1, HIWORD(v5));
  v3 = *(_DWORD *)(v1 + 8);
  v4 = 0;
  if ( HIWORD(v5) )
  {
    do
    {
      sub_420CE0((char *)&v8, 0x16u);
      v3 += 44;
      *(float *)(v3 - 44) = (double)v8;
      *(float *)(v3 - 40) = (double)v9;
      *(float *)(v3 - 36) = (double)v10;
      *(float *)(v3 - 32) = (double)v11 * 0.00024414062;
      *(float *)(v3 - 28) = (double)v12 * 0.00024414062;
      *(float *)(v3 - 24) = (double)v13 * 0.00024414062;
      ++v4;
      *(float *)(v3 - 4) = (double)(unsigned __int16)v18;
      *(_WORD *)(v3 - 20) = v14;
      *(float *)(v3 - 8) = (double)v17;
      *(float *)(v3 - 12) = (double)v16;
      result = v15;
      *(float *)(v3 - 16) = (double)v15;
    }
    while ( (unsigned __int16)v4 < HIWORD(v5) );
  }
  return result;
}
// 455C38: using guessed type int dword_455C38;

//----- (00421FE0) --------------------------------------------------------
char __cdecl sub_421FE0(int a1)
{
  char result; // al
  void *v2; // edi

  dword_455C44 = 0;
  dword_455C40 = 0;
  if ( !a1 )
    return 0;
  v2 = (void *)sub_401250(32 * a1);
  dword_455C40 = (int)v2;
  if ( !v2 )
    return 0;
  result = 1;
  dword_455C44 = a1;
  memset(v2, 0, 32 * a1);
  return result;
}
// 455C40: using guessed type int dword_455C40;
// 455C44: using guessed type int dword_455C44;

//----- (00422050) --------------------------------------------------------
char __cdecl sub_422050(unsigned __int16 a1)
{
  int v1; // ebx
  __int16 v3; // [esp+Ch] [ebp-30h]
  char v4; // [esp+Eh] [ebp-2Eh]
  int v5; // [esp+10h] [ebp-2Ch]
  char v6; // [esp+14h] [ebp-28h]

  v1 = dword_455C2C + 56 * a1;
  sub_420CE0((char *)&v3, 0x30u);
  *(_WORD *)v1 = v3;
  *(_BYTE *)(v1 + 2) = v4;
  qmemcpy((void *)(v1 + 8), &v6, 0x28u);
  sub_40B610(v1, (unsigned __int16)v5, HIWORD(v5));
  sub_420CE0(*(char **)(v1 + 48), 8 * (unsigned __int16)v5);
  return sub_420CE0(*(char **)(v1 + 52), 10 * HIWORD(v5));
}
// 455C2C: using guessed type int dword_455C2C;

//----- (004220F0) --------------------------------------------------------
int __cdecl sub_4220F0(unsigned __int16 a1)
{
  int v1; // esi
  int result; // eax
  char v3; // [esp+4h] [ebp-8h]
  __int16 v4; // [esp+6h] [ebp-6h]
  __int16 v5; // [esp+8h] [ebp-4h]
  __int16 v6; // [esp+Ah] [ebp-2h]
  signed int v7; // [esp+10h] [ebp+4h]

  v1 = dword_455C90 + 16 * a1;
  sub_420CE0(&v3, 8u);
  *(float *)(v1 + 4) = (double)v4;
  *(float *)(v1 + 8) = (double)v5;
  result = v6;
  v7 = v6;
  *(_BYTE *)(v1 + 1) = 0;
  *(float *)(v1 + 12) = (double)v7;
  *(_BYTE *)v1 = v3;
  ++word_455C10;
  return result;
}
// 455C10: using guessed type __int16 word_455C10;
// 455C90: using guessed type int dword_455C90;

//----- (00422160) --------------------------------------------------------
__int16 __cdecl sub_422160(unsigned __int16 a1)
{
  int v1; // esi
  __int16 result; // ax
  char v3; // [esp+4h] [ebp-18h]
  char v4; // [esp+6h] [ebp-16h]
  char v5; // [esp+7h] [ebp-15h]
  int v6; // [esp+8h] [ebp-14h]
  __int16 v7; // [esp+Ch] [ebp-10h]
  __int16 v8; // [esp+Eh] [ebp-Eh]
  int v9; // [esp+10h] [ebp-Ch]
  int v10; // [esp+14h] [ebp-8h]
  int v11; // [esp+18h] [ebp-4h]

  v1 = dword_455C74 + 104 * a1;
  sub_420CE0(&v3, 0x18u);
  *(_BYTE *)(v1 + 4) = v3;
  *(_BYTE *)(v1 + 6) = v4;
  *(_BYTE *)(v1 + 7) = v5;
  *(_WORD *)(v1 + 60) = v7;
  result = v8;
  *(_WORD *)(v1 + 62) = v8;
  *(_DWORD *)(v1 + 12) = (unsigned __int16)v6;
  *(float *)(v1 + 32) = (double)v9;
  *(float *)(v1 + 36) = (double)v10;
  *(float *)(v1 + 40) = (double)v11;
  return result;
}
// 455C74: using guessed type int dword_455C74;

//----- (004221E0) --------------------------------------------------------
char __cdecl sub_4221E0(unsigned __int16 a1)
{
  int v1; // esi
  char result; // al
  int v3; // esi
  int v4; // edi
  __int16 v5; // [esp+8h] [ebp-14h]
  unsigned __int16 v6; // [esp+Ah] [ebp-12h]
  __int16 v7; // [esp+Ch] [ebp-10h]
  int v8; // [esp+10h] [ebp-Ch]
  int v9; // [esp+14h] [ebp-8h]
  int v10; // [esp+18h] [ebp-4h]

  v1 = dword_455C84 + 12 * a1;
  sub_420CE0((char *)&v5, 8u);
  *(_WORD *)v1 = v5;
  *(_WORD *)(v1 + 8) = v7;
  result = sub_417100(v1, v6);
  v3 = *(_DWORD *)(v1 + 4);
  v4 = 0;
  if ( v6 )
  {
    do
    {
      result = sub_420CE0((char *)&v8, 0xCu);
      v3 += 12;
      ++v4;
      *(float *)(v3 - 12) = (double)v8;
      *(float *)(v3 - 8) = (double)v9;
      *(float *)(v3 - 4) = (double)v10;
    }
    while ( (unsigned __int16)v4 < v6 );
  }
  return result;
}
// 455C84: using guessed type int dword_455C84;

//----- (00422270) --------------------------------------------------------
char __cdecl sub_422270(unsigned __int16 a1, int a2, int a3)
{
  unsigned int v3; // ebx
  char result; // al
  int v5; // edi
  int v6; // esi
  int v7; // edx
  int v8; // esi
  int v9; // esi
  unsigned int i; // ebp
  bool v11; // cf
  float *v12; // esi
  int v13; // [esp+Ch] [ebp-60h]
  __int16 v14; // [esp+10h] [ebp-5Ch]
  int v15; // [esp+12h] [ebp-5Ah]
  char v16; // [esp+18h] [ebp-54h]
  __int16 v17; // [esp+1Ch] [ebp-50h]
  int v18; // [esp+1Eh] [ebp-4Eh]
  int v19; // [esp+24h] [ebp-48h]
  int v20; // [esp+28h] [ebp-44h]
  int v21; // [esp+2Ch] [ebp-40h]
  int v22; // [esp+30h] [ebp-3Ch]
  int v23; // [esp+34h] [ebp-38h]
  int v24; // [esp+38h] [ebp-34h]
  int v25; // [esp+5Ch] [ebp-10h]
  int v26; // [esp+60h] [ebp-Ch]
  int v27; // [esp+64h] [ebp-8h]
  int v28; // [esp+74h] [ebp+8h]
  unsigned int v29; // [esp+78h] [ebp+Ch]
  int v30; // [esp+78h] [ebp+Ch]

  sub_420CE0((char *)&v24, 0x30u);
  v3 = 0;
  if ( !a3 )
    return sub_420CE0(0, v24 - 48);
  nullsub_1(aItemDLoadingMe);
  v5 = dword_448AC4 + 48 * a1;
  sub_408DC0((int *)(v5 + 4), (unsigned __int16)v25);
  sub_420E50(*(float **)(v5 + 4), v25);
  sub_409190(v5, HIWORD(v25), v26);
  if ( HIWORD(v25) )
    sub_421510(*(_DWORD *)(v5 + 16), *(int *)((char *)&v25 + 2), 1);
  if ( (_WORD)v26 )
    sub_421890(*(_DWORD *)(v5 + 20), v26, 1);
  sub_40A1B0(v5, HIWORD(v26));
  v29 = 0;
  if ( HIWORD(v26) > 0u )
  {
    v6 = *(_DWORD *)(v5 + 32) + 16;
    do
    {
      sub_420CE0((char *)&v19, 0x14u);
      *(_DWORD *)(v6 - 12) = (unsigned __int16)v19;
      *(_WORD *)(v6 + 136) = HIWORD(v19);
      v7 = (unsigned __int16)v20 / 3;
      if ( 3 * (unsigned __int16)v7 < (unsigned __int16)v20 )
        LOWORD(v7) = v7 + 1;
      *(_WORD *)(v6 + 138) = v7;
      *(_DWORD *)(v6 - 8) = 1065353216;
      *(_DWORD *)(v6 - 4) = 0;
      *(_DWORD *)v6 = 0;
      *(_DWORD *)(v6 + 4) = 0;
      *(_DWORD *)(v6 + 8) = 1065353216;
      *(_DWORD *)(v6 + 12) = 0;
      *(_DWORD *)(v6 + 16) = 0;
      *(_DWORD *)(v6 + 20) = 0;
      *(_DWORD *)(v6 + 24) = 1065353216;
      *(_DWORD *)(v6 + 28) = 0;
      *(_DWORD *)(v6 + 32) = 0;
      *(_DWORD *)(v6 + 36) = 0;
      if ( !(_WORD)v27 )
      {
        *(float *)(v6 + 28) = (double)v21;
        *(float *)(v6 + 32) = (double)v22;
        *(float *)(v6 + 36) = (double)v23;
      }
      *(_DWORD *)(v6 + 40) = 1065353216;
      *(_DWORD *)(v6 + 44) = 0;
      *(_DWORD *)(v6 + 48) = 0;
      *(_DWORD *)(v6 + 52) = 0;
      *(_DWORD *)(v6 + 56) = 1065353216;
      *(_DWORD *)(v6 + 60) = 0;
      *(_DWORD *)(v6 + 64) = 0;
      *(_DWORD *)(v6 + 68) = 0;
      *(_DWORD *)(v6 + 72) = 1065353216;
      *(_DWORD *)(v6 + 76) = 0;
      *(_DWORD *)(v6 + 80) = 0;
      *(_DWORD *)(v6 + 84) = 0;
      *(_DWORD *)(v6 + 88) = 1065353216;
      *(_DWORD *)(v6 + 92) = 0;
      *(_DWORD *)(v6 + 96) = 0;
      *(_DWORD *)(v6 + 100) = 0;
      *(_DWORD *)(v6 + 104) = 1065353216;
      *(_DWORD *)(v6 + 108) = 0;
      *(_DWORD *)(v6 + 112) = 0;
      *(_DWORD *)(v6 + 116) = 0;
      *(_DWORD *)(v6 + 120) = 1065353216;
      *(_DWORD *)(v6 + 124) = 0;
      *(_DWORD *)(v6 + 128) = 0;
      *(_DWORD *)(v6 + 132) = 0;
      v6 += 236;
      ++v29;
    }
    while ( v29 < HIWORD(v26) );
  }
  sub_40A0B0(v5, (unsigned __int16)v27);
  v8 = *(_DWORD *)(v5 + 36);
  v28 = *(_DWORD *)(v5 + 36);
  v30 = 0;
  if ( *(_WORD *)(v5 + 26) )
  {
    while ( 1 )
    {
      sub_420CE0(&v16, 8u);
      *(_WORD *)v8 = v17;
      v9 = *(_DWORD *)(v8 + 4);
      for ( i = 0; i < (unsigned __int16)v18; ++i )
      {
        sub_420CE0((char *)&v13, 4u);
        sub_40A170(v9, (unsigned __int16)v13);
        sub_4225B0(*(_DWORD *)(v9 + 8), v13);
        v9 += 12;
      }
      v11 = v30 + 1 < (unsigned int)*(unsigned __int16 *)(v5 + 26);
      v28 += 8;
      ++v30;
      if ( !v11 )
        break;
      v8 = v28;
    }
  }
  result = sub_40A200(v5, HIWORD(v27));
  v12 = *(float **)(v5 + 40);
  if ( *(_WORD *)(v5 + 28) > 0u )
  {
    do
    {
      sub_420CE0((char *)&v14, 8u);
      *(_WORD *)v12 = v14;
      v12 += 5;
      ++v3;
      *(v12 - 4) = (double)(unsigned __int16)v15;
      result = BYTE2(v15);
      *((_WORD *)v12 - 9) = HIWORD(v15);
    }
    while ( v3 < *(unsigned __int16 *)(v5 + 28) );
  }
  return result;
}
// 434B40: using guessed type int __cdecl nullsub_1(_DWORD);
// 448AC4: using guessed type int dword_448AC4;

//----- (004225B0) --------------------------------------------------------
signed int __cdecl sub_4225B0(int a1, unsigned __int16 a2)
{
  int v2; // esi
  int v3; // edi
  double v4; // st7
  signed int v5; // ecx
  signed int v6; // edx
  signed int v7; // eax
  double v8; // st7
  signed int v9; // ecx
  signed int v10; // edx
  double v11; // st7
  signed int result; // eax
  int v13; // [esp+4h] [ebp-14h]
  __int16 v14; // [esp+8h] [ebp-10h]
  __int16 v15; // [esp+Ah] [ebp-Eh]
  __int16 v16; // [esp+Ch] [ebp-Ch]
  __int16 v17; // [esp+Eh] [ebp-Ah]
  __int16 v18; // [esp+10h] [ebp-8h]
  __int16 v19; // [esp+12h] [ebp-6h]
  __int16 v20; // [esp+14h] [ebp-4h]
  signed int v21; // [esp+20h] [ebp+8h]
  signed int v22; // [esp+20h] [ebp+8h]
  signed int v23; // [esp+20h] [ebp+8h]

  if ( a2 )
  {
    v2 = a1;
    v3 = a2;
    do
    {
      sub_420CE0((char *)&v13, 0x12u);
      v4 = (double)SHIWORD(v13);
      v21 = v14;
      *(_DWORD *)v2 = (unsigned __int16)v13;
      v5 = v15;
      *(float *)(v2 + 4) = v4 * 0.00024414062;
      v6 = v16;
      v2 += 36;
      v7 = v17;
      *(float *)(v2 - 28) = (double)v21 * 0.00024414062;
      v8 = (double)v5;
      v22 = v6;
      --v3;
      v9 = v18;
      v10 = v19;
      *(float *)(v2 - 24) = v8 * 0.00024414062;
      v11 = (double)v22;
      v23 = v7;
      result = v20;
      *(float *)(v2 - 20) = v11 * 0.00024414062;
      *(float *)(v2 - 16) = (double)v23 * 0.00024414062;
      *(float *)(v2 - 12) = (double)v9 * 0.00024414062 * 256.0;
      *(float *)(v2 - 8) = (double)v10 * 0.00024414062 * 256.0;
      *(float *)(v2 - 4) = (double)result * 0.00024414062 * 256.0;
    }
    while ( v3 );
  }
  return result;
}

//----- (004226C0) --------------------------------------------------------
int __cdecl sub_4226C0(int a1, unsigned __int16 a2)
{
  int v2; // esi
  int v3; // edi
  int result; // eax
  double v5; // st7
  signed int v6; // ecx
  __int16 v7; // [esp+4h] [ebp-20h]
  __int16 v8; // [esp+6h] [ebp-1Eh]
  __int16 v9; // [esp+8h] [ebp-1Ch]
  __int16 v10; // [esp+Ah] [ebp-1Ah]
  int v11; // [esp+Ch] [ebp-18h]
  int v12; // [esp+10h] [ebp-14h]
  int v13; // [esp+14h] [ebp-10h]
  int v14; // [esp+18h] [ebp-Ch]
  signed int v15; // [esp+2Ch] [ebp+8h]

  if ( a2 )
  {
    v2 = a1;
    v3 = a2;
    do
    {
      sub_420CE0((char *)&v7, 0x20u);
      result = v9;
      v5 = (double)v8;
      v15 = v9;
      *(_WORD *)v2 = v7;
      v6 = v10;
      *(float *)(v2 + 4) = v5;
      *(_DWORD *)(v2 + 28) = v14;
      *(float *)(v2 + 8) = (double)v15;
      v2 += 32;
      --v3;
      *(float *)(v2 - 20) = (double)v6;
      *(float *)(v2 - 16) = (double)v11;
      *(float *)(v2 - 12) = (double)v12;
      *(float *)(v2 - 8) = (double)v13;
    }
    while ( v3 );
  }
  return result;
}

//----- (00422750) --------------------------------------------------------
signed int __cdecl sub_422750(int a1, unsigned __int16 a2)
{
  int v2; // esi
  int v3; // edi
  signed int v4; // edx
  char v5; // cl
  double v6; // st7
  unsigned __int16 v7; // cx
  signed int result; // eax
  int v9; // edx
  __int16 v10; // [esp+4h] [ebp-10h]
  __int16 v11; // [esp+6h] [ebp-Eh]
  __int16 v12; // [esp+8h] [ebp-Ch]
  char v13; // [esp+Ah] [ebp-Ah]
  char v14; // [esp+Bh] [ebp-9h]
  __int16 v15; // [esp+Ch] [ebp-8h]
  int v16; // [esp+Eh] [ebp-6h]
  signed int v17; // [esp+1Ch] [ebp+8h]
  signed int v18; // [esp+1Ch] [ebp+8h]

  if ( a2 )
  {
    v2 = a1;
    v3 = a2;
    do
    {
      sub_420CE0((char *)&v10, 0x10u);
      v4 = v11;
      v5 = v13;
      result = v12;
      *(float *)v2 = (double)v10;
      v17 = v4;
      LOBYTE(v4) = v14;
      v6 = (double)v17;
      v18 = result;
      *(_BYTE *)(v2 + 12) = v5;
      v7 = v16;
      LOWORD(result) = v15;
      *(float *)(v2 + 4) = v6;
      *(_BYTE *)(v2 + 13) = v4;
      v9 = *(int *)((char *)&v16 + 2);
      *(float *)(v2 + 8) = (double)v18;
      *(_WORD *)(v2 + 14) = result;
      *(_DWORD *)(v2 + 20) = v9;
      *(float *)(v2 + 16) = (double)v7;
      v2 += 24;
      --v3;
    }
    while ( v3 );
  }
  return result;
}

//----- (004227F0) --------------------------------------------------------
__int16 __cdecl sub_4227F0(int a1, unsigned __int16 a2)
{
  int v2; // esi
  int v3; // edi
  signed int v4; // edx
  char v5; // cl
  signed int v6; // eax
  double v7; // st7
  __int16 v8; // cx
  __int16 result; // ax
  int v10; // ecx
  __int16 v11; // [esp+4h] [ebp-14h]
  __int16 v12; // [esp+6h] [ebp-12h]
  __int16 v13; // [esp+8h] [ebp-10h]
  char v14; // [esp+Ah] [ebp-Eh]
  char v15; // [esp+Bh] [ebp-Dh]
  __int16 v16; // [esp+Ch] [ebp-Ch]
  __int16 v17; // [esp+Eh] [ebp-Ah]
  __int16 v18; // [esp+10h] [ebp-8h]
  __int16 v19; // [esp+12h] [ebp-6h]
  int v20; // [esp+14h] [ebp-4h]
  signed int v21; // [esp+20h] [ebp+8h]
  signed int v22; // [esp+20h] [ebp+8h]

  if ( a2 )
  {
    v2 = a1;
    v3 = a2;
    do
    {
      sub_420CE0((char *)&v11, 0x14u);
      v4 = v12;
      v5 = v14;
      v6 = v13;
      *(float *)v2 = (double)v11;
      v21 = v4;
      LOBYTE(v4) = v15;
      v7 = (double)v21;
      v22 = v6;
      LOWORD(v6) = v16;
      *(_BYTE *)(v2 + 12) = v5;
      v8 = v19;
      *(float *)(v2 + 4) = v7;
      *(_BYTE *)(v2 + 13) = v4;
      LOWORD(v4) = v17;
      *(_WORD *)(v2 + 14) = v6;
      result = v18;
      *(float *)(v2 + 8) = (double)v22;
      *(_WORD *)(v2 + 16) = v8;
      v10 = v20;
      *(_WORD *)(v2 + 18) = v4;
      *(_WORD *)(v2 + 20) = result;
      *(_DWORD *)(v2 + 22) = v10;
      v2 += 28;
      --v3;
    }
    while ( v3 );
  }
  return result;
}

//----- (00422890) --------------------------------------------------------
char __cdecl sub_422890(int a1)
{
  void *v1; // edi

  dword_455C54 = 0;
  if ( a1 )
  {
    v1 = (void *)sub_401250(16 * a1);
    dword_455C50 = (int)v1;
    if ( v1 )
    {
      memset(v1, 0, 16 * a1);
      dword_455C54 = a1;
    }
  }
  return 1;
}
// 455C50: using guessed type int dword_455C50;
// 455C54: using guessed type int dword_455C54;

//----- (004228E0) --------------------------------------------------------
int sub_4228E0()
{
  int result; // eax

  sub_401380(dword_455C50);
  result = 0;
  dword_455C50 = 0;
  dword_455C54 = 0;
  return result;
}
// 455C50: using guessed type int dword_455C50;
// 455C54: using guessed type int dword_455C54;

//----- (00422900) --------------------------------------------------------
char __cdecl sub_422900(int a1)
{
  void *v1; // edi

  dword_455C64 = 0;
  if ( a1 )
  {
    v1 = (void *)sub_401250(24 * a1);
    dword_455C60 = (int)v1;
    if ( v1 )
    {
      memset(v1, 0, 24 * a1);
      dword_455C64 = a1;
    }
  }
  return 1;
}
// 455C60: using guessed type int dword_455C60;
// 455C64: using guessed type int dword_455C64;

//----- (00422950) --------------------------------------------------------
int sub_422950()
{
  int result; // eax

  sub_401380(dword_455C60);
  result = 0;
  dword_455C60 = 0;
  dword_455C64 = 0;
  return result;
}
// 455C60: using guessed type int dword_455C60;
// 455C64: using guessed type int dword_455C64;

//----- (00422970) --------------------------------------------------------
char __cdecl sub_422970(int a1)
{
  void *v1; // edi

  dword_455C5C = 0;
  if ( a1 )
  {
    v1 = (void *)sub_401250(28 * a1);
    dword_455C58 = (int)v1;
    if ( v1 )
    {
      memset(v1, 0, 28 * a1);
      dword_455C5C = a1;
    }
  }
  return 1;
}
// 455C58: using guessed type int dword_455C58;
// 455C5C: using guessed type int dword_455C5C;

//----- (004229D0) --------------------------------------------------------
int sub_4229D0()
{
  int result; // eax

  sub_401380(dword_455C58);
  result = 0;
  dword_455C58 = 0;
  dword_455C5C = 0;
  return result;
}
// 455C58: using guessed type int dword_455C58;
// 455C5C: using guessed type int dword_455C5C;

//----- (004229F0) --------------------------------------------------------
double __cdecl sub_4229F0(float *a1, float *a2)
{
  return a1[2] * a2[2] + a1[1] * a2[1] + *a1 * *a2;
}

//----- (00422A10) --------------------------------------------------------
char __cdecl sub_422A10(float a1, int a2, int a3)
{
  int v3; // esi
  double v4; // st7
  char result; // al
  double v6; // st7
  float v7; // [esp+8h] [ebp-Ch]
  float v8; // [esp+Ch] [ebp-8h]
  float v9; // [esp+10h] [ebp-4h]
  float v10; // [esp+18h] [ebp+4h]
  float v11; // [esp+18h] [ebp+4h]
  int v12; // [esp+20h] [ebp+Ch]

  v3 = a3;
  v7 = *(float *)a3 - *(float *)LODWORD(a1);
  v8 = *(float *)(a3 + 4) - *(float *)(LODWORD(a1) + 4);
  v9 = *(float *)(a3 + 8) - *(float *)(LODWORD(a1) + 8);
  *(float *)&v12 = sub_4229F0(&v7, (float *)a2);
  v10 = *(float *)(v3 + 12) * *(float *)(v3 + 12);
  v4 = v10 - (sub_4229F0(&v7, &v7) - *(float *)&v12 * *(float *)&v12);
  if ( v4 < 0.0 )
    return 0;
  v11 = v4;
  v6 = *(float *)&v12 - AGLSqrt(v11);
  result = 1;
  *(float *)a2 = v6 * *(float *)a2;
  *(float *)(a2 + 4) = v6 * *(float *)(a2 + 4);
  *(float *)(a2 + 8) = v6 * *(float *)(a2 + 8);
  return result;
}

//----- (00422AC0) --------------------------------------------------------
char __cdecl sub_422AC0(float *a1, int a2, int a3)
{
  int v3; // eax
  int v4; // eax
  float *v6; // esi
  int v7; // et1
  double v9; // st7
  unsigned __int8 v10; // c0
  unsigned __int8 v11; // c3
  double v12; // st7
  double v13; // st7
  int v14; // et1
  double v16; // st7
  unsigned __int8 v17; // c0
  unsigned __int8 v18; // c3
  double v19; // st7
  double v20; // st7
  float v21; // et1
  double v23; // st7
  unsigned __int8 v24; // c0
  unsigned __int8 v25; // c3
  double v26; // st7
  double v27; // st7
  float v28; // [esp+4h] [ebp-Ch]
  float v29; // [esp+8h] [ebp-8h]
  float v30; // [esp+Ch] [ebp-4h]

  v3 = *(unsigned __int16 *)(a3 + 20);
  if ( (_WORD)v3 )
  {
    v4 = v3 - 1;
    if ( v4 )
    {
      if ( v4 != 1 )
        return 0;
      v6 = (float *)a2;
      v7 = *(_DWORD *)(a2 + 8);
      v9 = *(float *)(a3 + 8);
      if ( v10 | v11 )
      {
        if ( v9 > a1[2] )
          return 0;
        if ( a1[2] + *(float *)(a2 + 8) > *(float *)(a3 + 8) )
          return 0;
      }
      else
      {
        if ( v9 < a1[2] )
          return 0;
        if ( a1[2] + *(float *)(a2 + 8) < *(float *)(a3 + 8) )
          return 0;
      }
      v29 = 0.0;
      v28 = 0.0;
      v30 = *(float *)(a3 + 8) - a1[2];
      if ( v30 != 0.0 )
      {
        v28 = v30 * *(float *)a2 / *(float *)(a2 + 8);
        v29 = v30 * *(float *)(a2 + 4) / *(float *)(a2 + 8);
      }
      v12 = v28 + *a1;
      if ( v12 > *(float *)(a3 + 12) + *(float *)a3 )
        return 0;
      if ( v12 < *(float *)a3 - *(float *)(a3 + 12) )
        return 0;
      v13 = v29 + a1[1];
      if ( v13 > *(float *)(a3 + 4) + *(float *)(a3 + 16) )
        return 0;
      if ( v13 < *(float *)(a3 + 4) - *(float *)(a3 + 16) )
        return 0;
    }
    else
    {
      v6 = (float *)a2;
      v14 = *(_DWORD *)(a2 + 4);
      v16 = *(float *)(a3 + 4);
      if ( v17 | v18 )
      {
        if ( v16 > a1[1] )
          return 0;
        if ( *(float *)(a2 + 4) + a1[1] > *(float *)(a3 + 4) )
          return 0;
      }
      else
      {
        if ( v16 < a1[1] )
          return 0;
        if ( *(float *)(a2 + 4) + a1[1] < *(float *)(a3 + 4) )
          return 0;
      }
      v30 = 0.0;
      v28 = 0.0;
      v29 = *(float *)(a3 + 4) - a1[1];
      if ( v29 != 0.0 )
      {
        v28 = v29 * *(float *)a2 / *(float *)(a2 + 4);
        v30 = v29 * *(float *)(a2 + 8) / *(float *)(a2 + 4);
      }
      v19 = v28 + *a1;
      if ( v19 > *(float *)(a3 + 16) + *(float *)a3 )
        return 0;
      if ( v19 < *(float *)a3 - *(float *)(a3 + 16) )
        return 0;
      v20 = v30 + a1[2];
      if ( v20 > *(float *)(a3 + 12) + *(float *)(a3 + 8) )
        return 0;
      if ( v20 < *(float *)(a3 + 8) - *(float *)(a3 + 12) )
        return 0;
    }
  }
  else
  {
    v6 = (float *)a2;
    v21 = *(float *)a2;
    v23 = *(float *)a3;
    if ( v24 | v25 )
    {
      if ( v23 > *a1 )
        return 0;
      if ( *a1 + *(float *)a2 > *(float *)a3 )
        return 0;
    }
    else
    {
      if ( v23 < *a1 )
        return 0;
      if ( *a1 + *(float *)a2 < *(float *)a3 )
        return 0;
    }
    v30 = 0.0;
    v29 = 0.0;
    v28 = *(float *)a3 - *a1;
    if ( v28 != 0.0 )
    {
      v29 = v28 * *(float *)(a2 + 4) / *(float *)a2;
      v30 = v28 * *(float *)(a2 + 8) / *(float *)a2;
    }
    v26 = v29 + a1[1];
    if ( v26 > *(float *)(a3 + 4) + *(float *)(a3 + 16) )
      return 0;
    if ( v26 < *(float *)(a3 + 4) - *(float *)(a3 + 16) )
      return 0;
    v27 = v30 + a1[2];
    if ( v27 > *(float *)(a3 + 12) + *(float *)(a3 + 8) )
      return 0;
    if ( v27 < *(float *)(a3 + 8) - *(float *)(a3 + 12) )
      return 0;
  }
  *v6 = v28;
  v6[1] = v29;
  v6[2] = v30;
  return 1;
}

//----- (00422E60) --------------------------------------------------------
bool __cdecl sub_422E60(float *a1, float *a2)
{
  float v3; // [esp+8h] [ebp-Ch]
  float v4; // [esp+Ch] [ebp-8h]
  float v5; // [esp+10h] [ebp-4h]

  v3 = *a1 - *a2;
  v4 = a1[1] - a2[1];
  v5 = a1[2] - a2[2];
  return sub_4083C0(&v3) - a1[3] - a2[3] <= 0.0;
}
// 4083C0: using guessed type double __cdecl sub_4083C0(_DWORD);

//----- (00422EC0) --------------------------------------------------------
bool __cdecl sub_422EC0(float a1, int a2, int a3, char a4)
{
  double v4; // st7
  double v5; // st6
  double v6; // st5
  double v7; // st4
  char v9; // c0
  int v10; // et1
  unsigned __int8 v12; // c0
  unsigned __int8 v13; // c3
  int v14; // et1
  unsigned __int8 v16; // c0
  unsigned __int8 v17; // c3
  int v18; // et1
  unsigned __int8 v20; // c0
  unsigned __int8 v21; // c3
  double v22; // st7
  bool result; // al
  float v24; // ecx
  double v25; // st7
  float v26; // edx
  float v27; // [esp+Ch] [ebp-28h]
  float v28; // [esp+10h] [ebp-24h]
  float v29; // [esp+14h] [ebp-20h]
  float v30; // [esp+18h] [ebp-1Ch]
  float v31; // [esp+1Ch] [ebp-18h]
  float v32; // [esp+20h] [ebp-14h]
  int v33; // [esp+24h] [ebp-10h]
  float v34; // [esp+28h] [ebp-Ch]
  float v35; // [esp+2Ch] [ebp-8h]
  float v36; // [esp+30h] [ebp-4h]

  if ( !a4 )
  {
    sub_408330((float *)a3, &v30);
    v4 = (*(float *)a2 - *(float *)LODWORD(a1)) * v30
       + (*(float *)(a2 + 4) - *(float *)(LODWORD(a1) + 4)) * v31
       + (*(float *)(a2 + 8) - *(float *)(LODWORD(a1) + 8)) * v32;
    v27 = *(float *)a2 - v4 * *(float *)LODWORD(a1);
    v28 = *(float *)(a2 + 8) - v4 * *(float *)(LODWORD(a1) + 4);
    v29 = *(float *)(a2 + 4) - v4 * *(float *)(LODWORD(a1) + 8);
    v5 = v28 - *(float *)(a2 + 4);
    v6 = v29 - *(float *)(a2 + 8);
    v7 = *(float *)(LODWORD(a1) + 12) + *(float *)(a2 + 12);
    if ( v9 )
    {
      if ( *(float *)a3 == 0.0 )
      {
        if ( *(float *)(a3 + 4) == 0.0 )
        {
          if ( *(float *)(a3 + 8) != 0.0 )
          {
            v18 = *(_DWORD *)(a3 + 8);
            if ( v20 | v21 )
            {
              if ( v29 < (double)*(float *)(LODWORD(a1) + 8) && *(float *)(LODWORD(a1) + 8) + *(float *)(a3 + 8) < v29 )
                goto LABEL_28;
            }
            else if ( v29 > (double)*(float *)(LODWORD(a1) + 8)
                   && *(float *)(LODWORD(a1) + 8) + *(float *)(a3 + 8) > v29 )
            {
              goto LABEL_28;
            }
          }
        }
        else
        {
          v14 = *(_DWORD *)(a3 + 4);
          if ( v16 | v17 )
          {
            if ( v28 < (double)*(float *)(LODWORD(a1) + 4) && *(float *)(LODWORD(a1) + 4) + *(float *)(a3 + 4) < v28 )
              goto LABEL_28;
          }
          else if ( v28 > (double)*(float *)(LODWORD(a1) + 4) && *(float *)(LODWORD(a1) + 4) + *(float *)(a3 + 4) > v28 )
          {
            goto LABEL_28;
          }
        }
      }
      else
      {
        v10 = *(_DWORD *)a3;
        if ( v12 | v13 )
        {
          if ( v27 < (double)*(float *)LODWORD(a1) && *(float *)LODWORD(a1) + *(float *)a3 < v27 )
            goto LABEL_28;
        }
        else if ( v27 > (double)*(float *)LODWORD(a1) && *(float *)LODWORD(a1) + *(float *)a3 > v27 )
        {
          goto LABEL_28;
        }
      }
    }
  }
  if ( sub_422E60((float *)LODWORD(a1), (float *)a2)
    || (v22 = *(float *)LODWORD(a1) + *(float *)a3,
        v36 = *(float *)(LODWORD(a1) + 12),
        *(float *)&v33 = v22,
        v34 = *(float *)(LODWORD(a1) + 4) + *(float *)(a3 + 4),
        v35 = *(float *)(LODWORD(a1) + 8) + *(float *)(a3 + 8),
        (result = sub_422E60((float *)&v33, (float *)a2)) != 0) )
  {
LABEL_28:
    v24 = *(float *)(a2 + 4);
    v25 = *(float *)(LODWORD(a1) + 12) + *(float *)(a2 + 12);
    v26 = *(float *)(a2 + 8);
    v33 = *(int *)a2;
    v34 = v24;
    v36 = v25;
    v35 = v26;
    sub_422A10(a1, a3, (int)&v33);
    result = 1;
  }
  return result;
}

//----- (00423120) --------------------------------------------------------
char __cdecl sub_423120(float *a1, int a2)
{
  int v2; // eax
  int v3; // eax
  double v5; // st7
  double v6; // st6
  float *v7; // edx

  v2 = *(unsigned __int16 *)(a2 + 20);
  if ( (_WORD)v2 )
  {
    v3 = v2 - 1;
    if ( v3 )
    {
      if ( v3 == 1 )
      {
        if ( a1[2] + a1[5] < *(float *)(a2 + 8) || a1[2] - a1[5] > *(float *)(a2 + 8) )
          return 0;
        if ( *(float *)a2 <= (double)*a1 )
        {
          if ( *(float *)(a2 + 12) + *(float *)a2 >= *a1 - a1[3] )
          {
LABEL_10:
            if ( *(float *)(a2 + 4) > (double)a1[1] )
            {
              if ( *(float *)(a2 + 4) - *(float *)(a2 + 16) <= a1[4] + a1[1] )
                return 1;
              return 0;
            }
            v5 = a1[1] - a1[4];
            v6 = *(float *)(a2 + 16) + *(float *)(a2 + 4);
LABEL_14:
            if ( v6 < v5 )
              return 0;
            return 1;
          }
        }
        else if ( *(float *)a2 - *(float *)(a2 + 12) <= a1[3] + *a1 )
        {
          goto LABEL_10;
        }
        return 0;
      }
      return 1;
    }
    v7 = a1;
    if ( a1[1] + a1[4] < *(float *)(a2 + 4) || a1[1] - a1[4] > *(float *)(a2 + 4) )
      return 0;
    if ( *(float *)a2 <= (double)*a1 )
    {
      if ( *(float *)(a2 + 16) + *(float *)a2 < *a1 - a1[3] )
        return 0;
    }
    else if ( *(float *)a2 - *(float *)(a2 + 16) > a1[3] + *a1 )
    {
      return 0;
    }
    if ( *(float *)(a2 + 8) <= (double)a1[2] )
    {
      v5 = a1[2] - a1[5];
      v6 = *(float *)(a2 + 12) + *(float *)(a2 + 8);
      goto LABEL_14;
    }
  }
  else
  {
    v7 = a1;
    if ( *a1 + a1[3] < *(float *)a2 || *a1 - a1[3] > *(float *)a2 )
      return 0;
    if ( *(float *)(a2 + 4) <= (double)a1[1] )
    {
      if ( *(float *)(a2 + 4) + *(float *)(a2 + 16) < a1[1] - a1[4] )
        return 0;
    }
    else if ( *(float *)(a2 + 4) - *(float *)(a2 + 16) > a1[4] + a1[1] )
    {
      return 0;
    }
    if ( *(float *)(a2 + 8) <= (double)a1[2] )
    {
      if ( *(float *)(a2 + 8) + *(float *)(a2 + 16) < a1[2] - a1[5] )
        return 0;
      return 1;
    }
  }
  if ( *(float *)(a2 + 8) - *(float *)(a2 + 12) > v7[5] + v7[2] )
    return 0;
  return 1;
}

//----- (00423300) --------------------------------------------------------
char __cdecl sub_423300(float *a1, int a2, float *a3)
{
  __int16 v3; // dx
  double v4; // st7
  double v5; // st7
  float v6; // edi
  double v7; // st7
  int v8; // edi
  double v9; // st7
  int v10; // edi
  char v11; // al
  double v13; // st7
  double v14; // st7
  float v15; // edi
  double v16; // st7
  int v17; // edi
  double v18; // st7
  int v19; // edi
  double v20; // st7
  float v21; // edi
  double v22; // st7
  int v23; // edi
  double v24; // st7
  int v25; // edi
  float v26; // [esp+8h] [ebp-24h]
  float v27; // [esp+Ch] [ebp-20h]
  float v28; // [esp+10h] [ebp-1Ch]
  int v29; // [esp+14h] [ebp-18h]
  int v30; // [esp+18h] [ebp-14h]
  int v31; // [esp+1Ch] [ebp-10h]
  float v32; // [esp+20h] [ebp-Ch]
  float v33; // [esp+24h] [ebp-8h]
  __int16 v34; // [esp+28h] [ebp-4h]

  v3 = *(_WORD *)(a2 + 20);
  if ( *(_WORD *)(a2 + 20) )
  {
    if ( *(_WORD *)(a2 + 20) == 1 )
    {
      if ( a3[1] <= 0.0 )
        v13 = a1[1] - a1[4];
      else
        v13 = a1[4] + a1[1];
      v27 = v13;
      v14 = a1[5];
      v15 = *a1;
      v34 = v3;
      v16 = v14 + *(float *)(a2 + 12);
      v26 = v15;
      v28 = a1[2];
      v29 = *(_DWORD *)a2;
      v17 = *(_DWORD *)(a2 + 4);
      v32 = v16;
      v18 = a1[3] + *(float *)(a2 + 16);
      v30 = v17;
      v19 = *(_DWORD *)(a2 + 8);
      v33 = v18;
      v31 = v19;
      v11 = sub_422AC0(&v26, (int)a3, (int)&v29);
    }
    else
    {
      if ( *(_WORD *)(a2 + 20) != 2 )
        return 0;
      if ( a3[2] <= 0.0 )
        v4 = a1[2] - a1[5];
      else
        v4 = a1[5] + a1[2];
      v28 = v4;
      v5 = a1[3];
      v6 = *a1;
      v34 = v3;
      v7 = v5 + *(float *)(a2 + 12);
      v26 = v6;
      v27 = a1[1];
      v29 = *(_DWORD *)a2;
      v8 = *(_DWORD *)(a2 + 4);
      v32 = v7;
      v9 = a1[4] + *(float *)(a2 + 16);
      v30 = v8;
      v10 = *(_DWORD *)(a2 + 8);
      v33 = v9;
      v31 = v10;
      v11 = sub_422AC0(&v26, (int)a3, (int)&v29);
    }
  }
  else
  {
    if ( *a3 <= 0.0 )
      v20 = *a1 - a1[3];
    else
      v20 = a1[3] + *a1;
    v26 = v20;
    v21 = a1[1];
    v34 = 0;
    v22 = a1[5] + *(float *)(a2 + 12);
    v27 = v21;
    v28 = a1[2];
    v29 = *(_DWORD *)a2;
    v23 = *(_DWORD *)(a2 + 4);
    v32 = v22;
    v24 = a1[4] + *(float *)(a2 + 16);
    v30 = v23;
    v25 = *(_DWORD *)(a2 + 8);
    v33 = v24;
    v31 = v25;
    v11 = sub_422AC0(&v26, (int)a3, (int)&v29);
  }
  if ( v11 )
    return 1;
  return 0;
}

//----- (004234A0) --------------------------------------------------------
int __cdecl sub_4234A0(unsigned __int16 *a1, int a2)
{
  int result; // eax
  int v3; // ecx
  unsigned int v4; // ecx
  char v5; // cl
  signed int v6; // edi
  int v7; // esi

  result = a1[1] - 1;
  switch ( a1[1] )
  {
    case 1u:
      result = dword_455C74 + 104 * *a1;
      v3 = *(_DWORD *)(result + 12);
      if ( (_BYTE)a2 )
        v4 = v3 | 0x80000000;
      else
        v4 = v3 & 0x7FFFFFFF;
      *(_DWORD *)(result + 12) = v4;
      break;
    case 2u:
      result = dword_455C60 + 24 * *a1;
      v5 = *(_BYTE *)(result + 13);
      if ( !(_BYTE)a2 )
        goto LABEL_10;
      *(_BYTE *)(result + 13) = v5 | 0x80;
      break;
    case 3u:
      result = dword_455C58 + 28 * *a1;
      v5 = *(_BYTE *)(result + 13);
      if ( (_BYTE)a2 )
        *(_BYTE *)(result + 13) = v5 | 0x80;
      else
LABEL_10:
        *(_BYTE *)(result + 13) = v5 & 0x7F;
      break;
    case 4u:
      v6 = 4;
      v7 = dword_455C50 + 16 * *a1;
      do
      {
        result = sub_4234A0(v7, a2);
        v7 += 4;
        --v6;
      }
      while ( v6 );
      break;
    default:
      return result;
  }
  return result;
}
// 455C50: using guessed type int dword_455C50;
// 455C58: using guessed type int dword_455C58;
// 455C60: using guessed type int dword_455C60;
// 455C74: using guessed type int dword_455C74;

//----- (00423580) --------------------------------------------------------
void sub_423580()
{
  int v0; // ecx
  char *v1; // eax
  char v2; // bl
  char *v3; // eax
  int v4; // ecx
  char v5; // bl
  int v6; // edi
  unsigned __int16 *v7; // esi
  int v8; // edi
  unsigned __int16 *v9; // esi

  v0 = dword_455C64;
  if ( dword_455C64 > 0 )
  {
    v1 = (char *)(dword_455C60 + 13);
    do
    {
      v2 = *v1;
      v1 += 24;
      --v0;
      *(v1 - 24) = v2 | 0x80;
    }
    while ( v0 );
    v0 = dword_455C64;
  }
  if ( dword_455C5C > 0 )
  {
    v3 = (char *)(dword_455C58 + 13);
    v4 = dword_455C5C;
    do
    {
      v5 = *v3;
      v3 += 28;
      --v4;
      *(v3 - 28) = v5 | 0x80;
    }
    while ( v4 );
    v0 = dword_455C64;
  }
  if ( v0 > 0 )
  {
    v6 = v0;
    v7 = (unsigned __int16 *)(dword_455C60 + 20);
    do
    {
      if ( *((_BYTE *)v7 - 8) == 1 )
        sub_4234A0(v7, 0);
      v7 += 12;
      --v6;
    }
    while ( v6 );
  }
  v8 = dword_455C5C;
  if ( dword_455C5C > 0 )
  {
    v9 = (unsigned __int16 *)(dword_455C58 + 22);
    do
    {
      if ( *((_BYTE *)v9 - 10) == 1 )
        sub_4234A0(v9, 0);
      v9 += 14;
      --v8;
    }
    while ( v8 );
  }
}
// 455C58: using guessed type int dword_455C58;
// 455C5C: using guessed type int dword_455C5C;
// 455C60: using guessed type int dword_455C60;
// 455C64: using guessed type int dword_455C64;

//----- (00423630) --------------------------------------------------------
char __cdecl sub_423630(int a1, int a2, __int16 a3, __int16 a4)
{
  int v4; // ebp
  int v5; // esi
  int v6; // eax
  unsigned __int16 v7; // ax
  char v8; // dl
  int v9; // eax
  int v10; // edi
  __int16 *v11; // ecx
  unsigned __int16 v12; // ax
  int v13; // ecx
  int v14; // eax
  int v15; // ecx
  int v16; // eax
  int v17; // ebp
  unsigned __int16 *v18; // edi
  int v19; // ecx
  unsigned __int16 v20; // ax
  int *v21; // eax
  int v22; // eax
  int v23; // ecx
  int v24; // edx
  char v25; // al
  double v26; // st7
  int v27; // eax
  char v29; // c0
  int v30; // eax
  char v32; // [esp+Ch] [ebp-44h]
  __int16 *v33; // [esp+10h] [ebp-40h]
  int v34; // [esp+14h] [ebp-3Ch]
  int v35; // [esp+18h] [ebp-38h]
  int v36; // [esp+1Ch] [ebp-34h]
  int v37; // [esp+20h] [ebp-30h]
  int v38; // [esp+24h] [ebp-2Ch]
  float v39; // [esp+28h] [ebp-28h]
  float v40; // [esp+2Ch] [ebp-24h]
  int v41; // [esp+30h] [ebp-20h]
  int v42; // [esp+34h] [ebp-1Ch]
  int v43; // [esp+38h] [ebp-18h]
  int v44; // [esp+3Ch] [ebp-14h]
  float v45; // [esp+40h] [ebp-10h]
  int v46; // [esp+44h] [ebp-Ch]
  int v47; // [esp+48h] [ebp-8h]
  int v48; // [esp+4Ch] [ebp-4h]
  char v49; // [esp+58h] [ebp+8h]

  v4 = a1;
  if ( !a1 )
    return 1;
  v5 = a2;
  v6 = *(_DWORD *)(a2 + 12);
  if ( v6 & 0x4000 || v6 & 0x20 )
    return 1;
  v7 = *(_WORD *)(a1 + 178);
  HIWORD(v10) = 0;
  v8 = 1;
  *(float *)&v38 = dword_44B73C - flt_44B748;
  v49 = 1;
  v9 = dword_448AC4 + 48 * v7;
  v36 = 0;
  v39 = dword_44B740 - flt_44B74C;
  v40 = dword_44B744 - flt_44B750;
  LOWORD(v10) = *(_WORD *)(v9 + 28);
  v11 = *(__int16 **)(v9 + 40);
  v35 = (unsigned __int16)v10;
  v33 = *(__int16 **)(v9 + 40);
  if ( (signed int)(unsigned __int16)v10 > 0 )
  {
    while ( v8 )
    {
      if ( *((float *)v11 + 1) != 0.0 )
      {
        v48 = *((_DWORD *)v11 + 1);
        v12 = *v11;
        v34 = 0;
        v13 = *(_DWORD *)(v4 + 180);
        HIWORD(v17) = 0;
        v14 = v13 + 236 * v12;
        v45 = *(float *)(v14 + 92);
        v46 = *(_DWORD *)(v14 + 96);
        v15 = *(_DWORD *)(v5 + 20);
        v47 = *(_DWORD *)(v14 + 100);
        v37 = v15;
        v16 = dword_448AC4 + 48 * *(unsigned __int16 *)(v15 + 178);
        LOWORD(v17) = *(_WORD *)(v16 + 28);
        v18 = *(unsigned __int16 **)(v16 + 40);
        if ( (signed int)(unsigned __int16)v17 > 0 )
        {
          while ( v8 )
          {
            if ( *((float *)v18 + 1) != 0.0 && (v18[1] == a4 || a4 == 2) )
            {
              v19 = *(_DWORD *)(v15 + 180);
              v20 = *v18;
              v44 = *((_DWORD *)v18 + 1);
              v21 = (int *)(v19 + 236 * v20);
              v41 = v21[23];
              v42 = v21[24];
              v43 = v21[25];
              if ( sub_422EC0(COERCE_FLOAT(&v45), (int)&v41, (int)&v38, 1) )
              {
                v49 = 0;
                switch ( *(unsigned __int8 *)(v5 + 4) )
                {
                  case 0x14u:
                  case 0x15u:
                  case 0x16u:
                  case 0x17u:
                  case 0x18u:
                  case 0x19u:
                  case 0x43u:
                    goto LABEL_29;
                  case 0x21u:
                  case 0x22u:
                  case 0x24u:
                  case 0x28u:
                    v22 = *(_DWORD *)(v5 + 12);
                    *(_DWORD *)(v5 + 16) = 0;
                    v22 &= 0xFC007FFF;
                    LOBYTE(v22) = v22 | 1;
                    *(_DWORD *)(v5 + 12) = v22;
                    break;
                  case 0x3Au:
                    v23 = *(_DWORD *)(v5 + 12);
                    *(_DWORD *)(v5 + 16) = 0;
                    *(_DWORD *)(v5 + 12) = v23 & 0xFC027FFF | 0x20000;
                    break;
                  case 0x3Eu:
                  case 0x3Fu:
                    v24 = *(_DWORD *)(v5 + 12);
                    *(_DWORD *)(v5 + 16) = 0;
                    *(_DWORD *)(v5 + 12) = v24 & 0xFC807FFF | 0x800020;
                    goto LABEL_25;
                  case 0x47u:
LABEL_25:
                    if ( dword_455BF8 != 5 )
                      goto LABEL_29;
                    if ( *(_DWORD *)(v5 + 12) & 0x40000 )
                      break;
                    if ( !byte_44B790 )
                    {
                      sub_41ED70(2u);
                      sub_42CDC0((int)&dword_44B71C, -4000.0);
                      sub_42CBE0((int)&dword_44B71C, 25);
                      dword_44B764 = -974127104;
                      break;
                    }
LABEL_29:
                    sub_42CC70((int)&dword_44B71C);
LABEL_30:
                    v32 = -1;
                    if ( (_BYTE)dword_455CB0 )
                      break;
                    if ( byte_44B78C && *(float *)&dword_44B76C > 0.0 )
                    {
                      if ( !v18[1] )
                      {
                        if ( !v33[1] )
                          goto LABEL_40;
LABEL_39:
                        v32 = 0;
                        goto LABEL_40;
                      }
                      if ( byte_44B78F || !v33[1] )
                        v32 = 1;
                      else
                        v32 = a3 != 2 ? 0 : 2;
                    }
                    else
                    {
                      if ( v33[1] && !byte_44B78F )
                        goto LABEL_39;
                      v25 = *(_BYTE *)(v5 + 4);
                      if ( v25 == 62 || v25 == 63 )
                        goto LABEL_39;
                      if ( v18[1] )
                      {
                        if ( byte_44B78F )
                          v32 = 1;
                      }
                      else
                      {
                        v32 = 3;
                      }
                    }
LABEL_40:
                    switch ( v32 )
                    {
                      case 0:
                        LOWORD(dword_455CB0) = 0;
                        if ( !byte_44B790 && !(*(_DWORD *)(v5 + 12) & 0x8000000) )
                        {
                          if ( !sub_407E30((AGLSOUNDBUFFER **)&unk_4447D0) )
                            sub_407E00((int)&unk_4447D0);
                          sub_41ED70(2u);
                          if ( (_BYTE)dword_44B814 )
                            sub_42CBE0((int)&dword_44B71C, 40);
                          else
                            sub_42CBE0((int)&dword_44B71C, 25);
                        }
                        if ( (_BYTE)dword_44B814 )
                        {
                          sub_42CDC0((int)&dword_44B71C, -4000.0);
                          sub_408670(dword_44B71C, 21, 3);
                          word_44B7F6 = 21;
                          v26 = sub_4167F0(v5);
                          dword_44B764 = -1006632960;
                          if ( v26 >= 0.0 )
                            dword_44B764 = 1140850688;
                        }
                        else
                        {
                          sub_42CDC0((int)&dword_44B71C, -7000.0);
                          sub_408670(dword_44B71C, 92, 3);
                          word_44B7F6 = 92;
                          if ( sub_4167F0(v5) >= 0.0 )
                            dword_44B764 = 1157627904;
                          else
                            dword_44B764 = -989855744;
                        }
                        if ( !(*(_DWORD *)(v5 + 12) & 0x86A0000)
                          && (_BYTE)dword_44B814
                          && dword_455BF8 != 10
                          && *(_BYTE *)(v5 + 4) != 6 )
                        {
                          sub_416130(v5);
                        }
                        if ( dword_455BF8 == 6 && *(_BYTE *)(v5 + 4) == 8 )
                        {
                          sub_434690(2u, 1);
                          sub_4166E0(v5);
                        }
                        break;
                      case 1:
                        v27 = *(_DWORD *)(v5 + 12);
                        if ( v27 & 0x10000000 && !(v27 & 0xA600000) )
                        {
                          *(_DWORD *)(v5 + 16) = 0;
                          *(_DWORD *)(v5 + 12) = v27 & 0xFC207FFF | 0x8200000;
                        }
                        sub_4167F0(v5);
                        if ( v29 )
                        {
                          if ( *(float *)&dword_44B764 != 0.0 )
                            dword_44B764 = -1006632960;
                          byte_44B803 = 1;
                        }
                        else
                        {
                          if ( *(float *)&dword_44B764 != 0.0 )
                            dword_44B764 = 1140850688;
                          byte_44B803 = 2;
                        }
                        break;
                      case 2:
                        sub_42CDC0((int)&dword_44B71C, -4000.0);
                        sub_408670(dword_44B71C, 21, 3);
                        word_44B7F6 = 21;
                        v30 = *(_DWORD *)(v5 + 12);
                        if ( v30 & 0xFFFFFF7F && !(v30 & 0x8600000) && v30 & 0x10000000 )
                        {
                          *(_DWORD *)(v5 + 16) = 0;
                          *(_DWORD *)(v5 + 12) = v30 & 0xFC407FFF | 0x400000;
                        }
                        break;
                      case 3:
                        sub_423CE0();
                        break;
                      default:
                        goto LABEL_85;
                    }
                    break;
                  case 0x49u:
                    if ( LODWORD(dword_44B704) != a1 && (_WORD)dword_44B784 == -1 && *(_DWORD *)(v5 + 12) < 0 )
                    {
                      sub_434530();
                      byte_44B790 = 0;
                      byte_44B78F = 0;
                      LOBYTE(dword_44B80C) = 0;
                      sub_42D130((int)&dword_44B71C, v5);
                    }
                    break;
                  default:
                    goto LABEL_30;
                }
              }
            }
LABEL_85:
            v8 = v49;
            v18 += 10;
            if ( ++v34 >= v17 )
              break;
            v15 = v37;
          }
        }
        v11 = v33;
        v10 = v35;
      }
      v11 += 10;
      v33 = v11;
      if ( ++v36 >= v10 )
        break;
      v4 = a1;
    }
  }
  return v8;
}
// 448AC4: using guessed type int dword_448AC4;
// 44B748: using guessed type float flt_44B748;
// 44B74C: using guessed type float flt_44B74C;
// 44B750: using guessed type float flt_44B750;
// 44B764: using guessed type int dword_44B764;
// 44B76C: using guessed type int dword_44B76C;
// 44B784: using guessed type int dword_44B784;
// 44B78C: using guessed type char byte_44B78C;
// 44B78F: using guessed type char byte_44B78F;
// 44B790: using guessed type char byte_44B790;
// 44B7F6: using guessed type __int16 word_44B7F6;
// 44B803: using guessed type char byte_44B803;
// 44B80C: using guessed type int dword_44B80C;
// 44B814: using guessed type int dword_44B814;
// 455BF8: using guessed type int dword_455BF8;
// 455CB0: using guessed type int dword_455CB0;

//----- (00423CE0) --------------------------------------------------------
int sub_423CE0()
{
  return sub_42CC70((int)&dword_44B71C);
}

//----- (00423CF0) --------------------------------------------------------
char __cdecl sub_423CF0(int a1, __int16 a2)
{
  int v2; // edx
  int v4; // eax
  char v5; // cl
  int v6; // ebx
  unsigned __int16 *v7; // ebp
  int v8; // edi
  int *v9; // esi
  _DWORD *v10; // eax
  int v11; // edx
  int v12; // eax
  bool v13; // c0
  char v14; // [esp+3h] [ebp-25h]
  int v15; // [esp+4h] [ebp-24h]
  int v16; // [esp+8h] [ebp-20h]
  int v17; // [esp+Ch] [ebp-1Ch]
  int v18; // [esp+10h] [ebp-18h]
  int v19; // [esp+14h] [ebp-14h]
  int v20; // [esp+18h] [ebp-10h]
  int v21; // [esp+1Ch] [ebp-Ch]
  int v22; // [esp+20h] [ebp-8h]
  int v23; // [esp+24h] [ebp-4h]

  v2 = a1;
  if ( !a1 )
    return 1;
  HIWORD(v6) = 0;
  v4 = dword_448AC4 + 48 * *(unsigned __int16 *)(a1 + 178);
  v5 = 1;
  v14 = 1;
  LOWORD(v6) = *(_WORD *)(v4 + 28);
  v7 = *(unsigned __int16 **)(v4 + 40);
  v15 = 0;
  if ( (signed int)(unsigned __int16)v6 > 0 )
  {
    while ( v5 )
    {
      if ( *((float *)v7 + 1) != 0.0 && (v7[1] == a2 || a2 == 2) )
      {
        v8 = 0;
        v9 = (int *)&unk_44B4F0;
        v10 = (_DWORD *)(*(_DWORD *)(v2 + 180) + 236 * *v7);
        v23 = *((_DWORD *)v7 + 1);
        v20 = v10[23];
        v21 = v10[24];
        v22 = v10[25];
        do
        {
          if ( !v5 )
            break;
          if ( *(v9 - 2) )
          {
            v11 = *v9;
            v12 = v9[1];
            v16 = *(v9 - 1);
            v17 = v11;
            v19 = 1107296256;
            v18 = v12;
            if ( sub_422E60((float *)&v20, (float *)&v16) && (!byte_44B790 || !v7[1]) )
            {
              v14 = 0;
              if ( v7[1] )
              {
                sub_41ED70(1u);
                sub_42CBE0((int)&dword_44B71C, 25);
                v13 = *((float *)v9 + 2) < (double)*((float *)v9 - 1);
                dword_44B764 = -979615744;
                if ( !v13 )
                  dword_44B764 = 1167867904;
              }
              sub_419640(v8, 1);
              sub_419660(v8);
            }
          }
          v5 = v14;
          v9 += 8;
          ++v8;
        }
        while ( (signed int)v9 < (signed int)dword_44B630 );
      }
      v7 += 10;
      if ( ++v15 >= v6 )
        break;
      v2 = a1;
    }
  }
  return v5;
}
// 448AC4: using guessed type int dword_448AC4;
// 44B630: using guessed type int dword_44B630[];
// 44B764: using guessed type int dword_44B764;
// 44B790: using guessed type char byte_44B790;

//----- (00423E90) --------------------------------------------------------
char __cdecl sub_423E90(int a1)
{
  double v1; // st7
  double v2; // st6
  double v3; // st5
  char result; // al

  switch ( *(unsigned __int8 *)(a1 + 4) )
  {
    case 1u:
    case 2u:
    case 4u:
    case 5u:
    case 6u:
    case 7u:
    case 8u:
    case 9u:
    case 0xAu:
      v3 = *(float *)(a1 + 40) - dword_44B744;
      v2 = *(float *)(a1 + 36) - dword_44B740;
      v1 = *(float *)(a1 + 32) - dword_44B73C;
      if ( v3 * v3 + v2 * v2 + v1 * v1 < 262144.0 )
        goto LABEL_4;
      result = 0;
      break;
    default:
LABEL_4:
      result = 1;
      break;
  }
  return result;
}

//----- (00423F10) --------------------------------------------------------
char sub_423F10()
{
  int v0; // eax
  int v1; // edi
  int v2; // edx
  float *v3; // ebp
  float *v4; // esi
  double v6; // st7
  char v7; // c0
  double v8; // st7
  AGLSOUNDBUFFER **v9; // edi
  _BYTE *v10; // edi
  unsigned __int16 v11; // ax
  char v12; // al
  unsigned __int16 v13; // ax
  int v14; // edx
  int v15; // eax
  bool v16; // al
  char result; // al
  int v18; // edi
  unsigned __int16 v19; // ax
  signed int v20; // ebx
  int v21; // esi
  bool v22; // zf
  char v23; // al
  int v24; // edi
  int v25; // ebp
  __int16 v26; // cx
  float *v27; // ecx
  float *v28; // eax
  _DWORD *v29; // esi
  char v30; // al
  char v31; // [esp+2h] [ebp-92h]
  char v32; // [esp+3h] [ebp-91h]
  char v33; // [esp+4h] [ebp-90h]
  char v34; // [esp+5h] [ebp-8Fh]
  char v35; // [esp+6h] [ebp-8Eh]
  char v36; // [esp+7h] [ebp-8Dh]
  signed int v37; // [esp+8h] [ebp-8Ch]
  int v38; // [esp+Ch] [ebp-88h]
  int v39; // [esp+Ch] [ebp-88h]
  int v40; // [esp+10h] [ebp-84h]
  float v41; // [esp+14h] [ebp-80h]
  float v42; // [esp+18h] [ebp-7Ch]
  int v43; // [esp+1Ch] [ebp-78h]
  int v44; // [esp+20h] [ebp-74h]
  int v45; // [esp+24h] [ebp-70h]
  float v46; // [esp+28h] [ebp-6Ch]
  float v47; // [esp+2Ch] [ebp-68h]
  int v48; // [esp+30h] [ebp-64h]
  float v49; // [esp+34h] [ebp-60h]
  float v50; // [esp+38h] [ebp-5Ch]
  float v51; // [esp+3Ch] [ebp-58h]
  float v52; // [esp+40h] [ebp-54h]
  float v53; // [esp+44h] [ebp-50h]
  float v54; // [esp+48h] [ebp-4Ch]
  int v55; // [esp+4Ch] [ebp-48h]
  int v56; // [esp+50h] [ebp-44h]
  float v57; // [esp+54h] [ebp-40h]
  float v58; // [esp+58h] [ebp-3Ch]
  float v59; // [esp+5Ch] [ebp-38h]
  float v60; // [esp+60h] [ebp-34h]
  float v61; // [esp+64h] [ebp-30h]
  __int16 v62; // [esp+68h] [ebp-2Ch]
  float v63; // [esp+6Ch] [ebp-28h]
  float v64; // [esp+70h] [ebp-24h]
  float v65; // [esp+74h] [ebp-20h]
  int v66; // [esp+78h] [ebp-1Ch]
  int v67; // [esp+7Ch] [ebp-18h]
  int v68; // [esp+80h] [ebp-14h]
  int v69; // [esp+84h] [ebp-10h]
  float v70; // [esp+88h] [ebp-Ch]
  int v71; // [esp+8Ch] [ebp-8h]
  int v72; // [esp+90h] [ebp-4h]

  v52 = flt_44B748;
  v54 = flt_44B750;
  v53 = flt_44B74C - 80.0;
  v65 = flt_44B750;
  v63 = flt_44B748;
  v64 = flt_44B74C - 112.0;
  v36 = 0;
  v55 = 1117782016;
  v66 = 1103101952;
  v67 = 1121976320;
  v68 = 1103101952;
  *(float *)&v40 = dword_44B73C - flt_44B748;
  v69 = 0;
  v45 = v40;
  v71 = 0;
  dword_455C68 = 0;
  dword_455C6C = 0;
  v41 = dword_44B740 - flt_44B74C;
  dword_455C70 = 0;
  v46 = v41;
  v70 = v41;
  v42 = dword_44B744 - flt_44B750;
  v47 = v42;
  if ( dword_44B828 )
    dword_44B830 = dword_44B828;
  dword_44B828 = 0;
  v35 = 0;
  if ( dword_44B82C )
    dword_44B834 = dword_44B82C;
  dword_44B82C = 0;
  v33 = 0;
  byte_44B813 = 0;
  word_44B7F8 = 0;
  dword_455BFC = 255;
  dword_455CAC &= 0xBFFFFFFF;
  BYTE2(dword_455CB0) = 0;
  v31 = 0;
  v34 = 1;
  if ( !byte_44B78F || (v32 = 1, !LODWORD(dword_44B704)) )
    v32 = 0;
  v0 = 0;
  v44 = 0;
  do
  {
    v1 = dword_455C28;
    v38 = dword_455C28;
    if ( dword_455C28 )
    {
      do
      {
        v37 = *(unsigned __int16 *)(v1 + 54);
        v2 = 3 * *(unsigned __int16 *)(v1 + 52);
        v56 = 0;
        v3 = (float *)(dword_455C60 + 8 * v2);
        if ( v37 > 0 )
        {
          v4 = v3 + 5;
          do
          {
            if ( *((_BYTE *)v4 - 7) < 0 )
            {
              v43 = (signed __int64)*v3;
              *(float *)&v48 = (double)v43 + *(float *)(v1 + 60);
              v43 = (signed __int64)*(v4 - 4);
              v49 = (double)v43 + *(float *)(v1 + 64);
              v43 = (signed __int64)*(v4 - 3);
              v50 = (double)v43 + *(float *)(v1 + 68);
              v51 = *(v4 - 1);
              switch ( *((unsigned __int8 *)v4 - 8) )
              {
                case 0u:
                  if ( byte_44B78C )
                  {
                    if ( sub_422EC0(COERCE_FLOAT(&v52), (int)&v48, (int)&v69, 1) )
                    {
                      v6 = *(float *)&dword_44B764;
                      v31 = 1;
                      if ( v7 )
                        v8 = v6 - 12.0;
                      else
                        v8 = v6 + 12.0;
                      *(float *)&dword_44B764 = v8;
                      sub_42CD30((int)&dword_44B71C, 0.0);
                    }
                  }
                  else if ( sub_422EC0(COERCE_FLOAT(&v52), (int)&v48, (int)&v45, 1) )
                  {
                    v31 = 1;
                  }
                  break;
                case 1u:
                  if ( sub_422EC0(COERCE_FLOAT(&v52), (int)&v48, (int)&v40, 1) )
                    sub_4234A0((unsigned __int16 *)v4, 1);
                  break;
                case 2u:
                  if ( *(float *)&v40 == 0.0 && v41 == 0.0 && v42 == 0.0 )
                    break;
                  LOBYTE(v72) = *(_BYTE *)v4 + 36;
                  v9 = (AGLSOUNDBUFFER **)(12 * (unsigned __int8)v72 + 4474712);
                  if ( sub_407CB0((int)v9, (int)&v48, v51) )
                  {
                    if ( !sub_407E30(v9) )
                      sub_407E00((int)v9);
                  }
                  else
                  {
                    sub_407E50(v9);
                  }
                  goto LABEL_29;
                case 3u:
                  if ( sub_422EC0(COERCE_FLOAT(&v52), (int)&v48, (int)&v40, 1) )
                  {
                    if ( !(*((_BYTE *)v4 - 7) & 0x40) )
                    {
                      BYTE2(dword_44B814) = 1;
                      if ( !byte_44B810 || byte_44B818 )
                      {
                        *((_BYTE *)v4 - 7) &= 0xBFu;
                        dword_455CAC |= 0x40000000u;
                      }
                      else
                      {
                        dword_455CAC &= 0xBFFFFFFF;
                        v10 = (_BYTE *)sub_424E30(*((_WORD *)v4 + 1), *(_WORD *)v4, (float *)&dword_44B7CC);
                        if ( v10 )
                        {
                          sub_434690(8u, 0);
                          byte_44B802 = 1;
                          BYTE2(dword_44B80C) = 0;
                          byte_44B818 = 0;
                          LOWORD(dword_455CB0) = 0;
                          sub_41BB60(0);
                          *v10 &= 0xBFu;
                          return sub_404910(0, 4096);
                        }
LABEL_29:
                        v1 = v38;
                      }
                    }
                  }
                  else
                  {
                    dword_455CAC &= 0xBFFFFFFF;
                    *((_BYTE *)v4 - 7) &= 0xBFu;
                  }
                  break;
                case 4u:
                  if ( sub_422E60(&v52, (float *)&v48) )
                  {
                    if ( byte_44B790 )
                    {
                      if ( !(_BYTE)dword_44B814 )
                      {
                        sub_42CDC0((int)&dword_44B71C, -7000.0);
                        dword_44B764 = -974127104;
                      }
                    }
                    else
                    {
                      sub_41ED70(*(_BYTE *)v4);
                      sub_42CDC0((int)&dword_44B71C, -7000.0);
                      if ( !(_BYTE)dword_44B814 )
                      {
                        sub_42CBE0((int)&dword_44B71C, 22);
                        dword_44B764 = -974127104;
                      }
                    }
                  }
                  break;
                case 5u:
                  if ( !v36 && sub_422E60(&v52, (float *)&v48) )
                  {
                    v11 = *(_WORD *)v4;
                    if ( dword_455BF8 == 16 )
                    {
                      if ( v11 >= 0x64u )
                      {
                        dword_455BFC = 255;
                        v12 = *((_BYTE *)&dword_44B7B4 + *(unsigned __int16 *)v4 + 2);
                        byte_44B813 = 1;
                        if ( v12 >= 0 )
                        {
                          v13 = word_44129C[*(unsigned __int16 *)v4];
                          word_44B7F8 = word_44129C[*(unsigned __int16 *)v4];
                          if ( dword_455BEC & 0x1000 && (unsigned __int16)word_44B7FE >= v13 )
                          {
                            sub_404910(0, 4096);
                            v14 = dword_455BEC;
                            BYTE1(v14) &= 0xEFu;
                            dword_455BEC = v14;
                            sub_42C0B0(*(unsigned __int16 *)v4);
                            byte_44B7FA = 1;
                            word_44B7FC = word_44B7F8;
                            *((_BYTE *)&dword_44B7B4 + *(unsigned __int16 *)v4 + 2) |= 0x80u;
                            word_44B7F8 = 0;
                            byte_44B813 = 0;
                          }
                        }
                        else
                        {
                          word_44B7F8 = 0;
                          if ( dword_455BEC & 0x2000 )
                          {
                            sub_404910(0, 0x2000);
                            sub_42C0B0(*(unsigned __int16 *)v4);
                            if ( byte_44B7FA )
                              word_44B7FE = word_44BAB0 - word_44BAB2;
                            byte_44B7FA = 0;
                            byte_44BAB4 = 0;
                            sub_41BB60(0);
                          }
                        }
                      }
                      else if ( (_WORD)dword_44B784 == -1 )
                      {
                        v36 = 1;
                        dword_455BFC = *(unsigned __int16 *)v4;
                      }
                    }
                    else if ( v11 )
                    {
                      if ( v11 == 1 )
                      {
                        v15 = dword_455C20 + 120 * *((unsigned __int16 *)v4 - 3);
                        *(float *)&dword_455C68 = *(float *)(dword_455C20 + 120 * *((unsigned __int16 *)v4 - 3) + 60)
                                                + *v3;
                        *(float *)&dword_455C6C = *(float *)(v15 + 64) + *(v4 - 4);
                        *(float *)&dword_455C70 = *(float *)(v15 + 68) + *(v4 - 3);
                      }
                    }
                    else
                    {
                      byte_44B813 = 1;
                    }
                  }
                  break;
                case 6u:
                  if ( !byte_44B790 && sub_422E60(&v52, (float *)&v48) )
                  {
                    sub_41ED70(1u);
                    sub_42CBE0((int)&dword_44B71C, 25);
                    if ( byte_44B797 == -1 )
                      dword_44B764 = 1169915904;
                    else
                      dword_44B764 = -977567744;
                  }
                  break;
                case 7u:
                case 9u:
                  if ( dword_44B828 || byte_44B797 != -1 || *(_WORD *)v4 == -1 )
                    break;
                  v16 = sub_422E60(&v52, (float *)&v48);
                  goto LABEL_94;
                case 8u:
                case 0xAu:
                  if ( !dword_44B828 && byte_44B797 == 1 && *(_WORD *)v4 != -1 )
                  {
                    v16 = sub_422E60(&v52, (float *)&v48);
LABEL_94:
                    if ( v16 )
                    {
                      v35 = 1;
                      if ( v3 != (float *)dword_44B830 )
                        dword_44B828 = (int)v3;
                    }
                  }
                  break;
                case 0xBu:
                  if ( !(dword_455CAC & 0x40)
                    && sub_422E60(&v52, (float *)&v48)
                    && !(_BYTE)dword_455CB0
                    && !byte_44B78C
                    && !BYTE1(dword_44B80C) )
                  {
                    sub_404910(0, 4096);
                    if ( dword_455BEC & 0x400 || !(dword_455BF0 & (1 << sub_432980(*(_WORD *)v4))) )
                    {
                      LOBYTE(dword_455CB0) = 1;
                      BYTE1(dword_455CB0) = *(_BYTE *)v4;
                      dword_455BF0 |= 1 << sub_432980(*(_WORD *)v4);
                    }
                    BYTE2(dword_455CB0) = 1;
                  }
                  break;
                default:
                  break;
              }
            }
            v3 += 6;
            v4 += 6;
            ++v56;
          }
          while ( (unsigned __int16)v56 < v37 );
        }
        v1 = *(_DWORD *)v1;
        v38 = v1;
      }
      while ( v1 );
      v0 = v44;
    }
    if ( byte_44B78E )
      break;
    if ( !(_WORD)v0 )
      v53 = v53 - 160.0;
    v44 = ++v0;
  }
  while ( (unsigned __int16)v0 < 2u );
  v18 = dword_455C28;
  v39 = dword_455C28;
  if ( !dword_455C28 )
  {
LABEL_154:
    if ( !v35 )
      dword_44B830 = 0;
    if ( !v33 )
      dword_44B834 = 0;
    if ( v32 )
    {
      if ( sub_423CF0(SLODWORD(dword_44B71C), 2) )
        sub_423CF0(SLODWORD(dword_44B700), 2);
    }
    else if ( sub_423CF0(SLODWORD(dword_44B71C), 1) )
    {
      sub_423CF0(SLODWORD(dword_44B700), 1);
    }
    sub_417240();
    result = v31;
    if ( v31 )
    {
      *(float *)&v45 = flt_44B748 + *(float *)&v45;
      v46 = v70 + flt_44B74C;
      v47 = v47 + flt_44B750;
      result = sub_41E780((int)&v45);
    }
    return result;
  }
  while ( 1 )
  {
    v19 = *(_WORD *)(v18 + 48);
    v20 = *(unsigned __int16 *)(v18 + 50);
    v44 = 0;
    v21 = dword_455C58 + 28 * v19;
    if ( (signed int)(unsigned __int16)v20 > 0 )
      break;
LABEL_123:
    v29 = (_DWORD *)dword_455C7C;
    if ( dword_455C7C )
    {
      do
      {
        if ( !v34 )
          break;
        if ( v29[5] && !(v29[3] & 0x800000) && sub_423E90((int)v29) )
        {
          if ( v32 )
            sub_423630(SLODWORD(dword_44B704), (int)v29, 2, 2);
          v34 = sub_423630(SLODWORD(dword_44B71C), (int)v29, 2, 2);
          if ( v34 )
            v34 = sub_423630(SLODWORD(dword_44B700), (int)v29, 1, 2);
        }
        v29 = (_DWORD *)*v29;
      }
      while ( v29 );
    }
    v18 = *(_DWORD *)v18;
    v39 = v18;
    if ( !v18 )
      goto LABEL_154;
  }
  while ( 1 )
  {
    v57 = (double)(signed int)(signed __int64)*(float *)v21 + *(float *)(v18 + 60);
    v58 = (double)(signed int)(signed __int64)*(float *)(v21 + 4) + *(float *)(v18 + 64);
    v59 = (double)(signed int)(signed __int64)*(float *)(v21 + 8) + *(float *)(v18 + 68);
    v60 = (double)*(unsigned __int16 *)(v21 + 18);
    v61 = (double)*(unsigned __int16 *)(v21 + 20);
    v62 = *(_WORD *)(v21 + 16);
    if ( *(_BYTE *)(v21 + 13) < 0 )
      break;
LABEL_122:
    v21 += 28;
    if ( (unsigned __int16)++v44 >= v20 )
      goto LABEL_123;
  }
  switch ( *(unsigned __int8 *)(v21 + 12) )
  {
    case 0u:
      if ( sub_423300(&v63, (int)&v57, (float *)&v45) )
        v31 = 1;
      if ( byte_44B78C && *(float *)&dword_44B76C < 0.0 && v62 == 1 && sub_423300(&v63, (int)&v57, (float *)&v69) )
      {
        sub_42CD30((int)&dword_44B71C, 0.0);
        v31 = 1;
      }
      goto LABEL_122;
    case 1u:
      *(float *)&v40 = dword_44B73C - flt_44B748;
      v41 = dword_44B740 - flt_44B74C;
      v42 = dword_44B744 - flt_44B750;
      if ( sub_423300(&v63, (int)&v57, (float *)&v40) )
        sub_4234A0((unsigned __int16 *)(v21 + 22), 1);
      goto LABEL_122;
    case 2u:
      *(float *)&v40 = dword_44B73C - flt_44B748;
      v41 = dword_44B740 - flt_44B74C;
      v42 = dword_44B744 - flt_44B750;
      if ( !sub_423300(&v63, (int)&v57, (float *)&v40) )
        goto LABEL_112;
      goto LABEL_122;
    case 3u:
LABEL_112:
      *(float *)&v40 = dword_44B73C - flt_44B748;
      v41 = dword_44B740 - flt_44B74C;
      v42 = dword_44B744 - flt_44B750;
      v22 = sub_423300(&v63, (int)&v57, (float *)&v40) == 0;
      v23 = *(_BYTE *)(v21 + 13);
      if ( v22 )
      {
        *(_BYTE *)(v21 + 13) = v23 & 0xBF;
        goto LABEL_122;
      }
      if ( v23 & 0x40 )
        goto LABEL_121;
      v24 = 0;
      v25 = 0;
      if ( *(_WORD *)(v21 + 22) == -1 )
        goto LABEL_121;
      v26 = *(_WORD *)(v21 + 24);
      if ( v26 == 2 )
      {
        v24 = dword_455C60 + 24 * *(unsigned __int16 *)(v21 + 22);
        v27 = (float *)v24;
        v28 = (float *)(dword_455C20 + 120 * *(unsigned __int16 *)(v24 + 14));
      }
      else
      {
        if ( v26 != 3 )
        {
LABEL_121:
          v18 = v39;
          goto LABEL_122;
        }
        v25 = dword_455C58 + 28 * *(unsigned __int16 *)(v21 + 22);
        v27 = (float *)(dword_455C58 + 28 * *(unsigned __int16 *)(v21 + 22));
        v28 = (float *)(dword_455C20
                      + 120 * *(unsigned __int16 *)(dword_455C58 + 28 * *(unsigned __int16 *)(v21 + 22) + 14));
      }
      if ( !v27 || !v28 )
        goto LABEL_121;
      *(float *)&v45 = v28[15] + *v27;
      v46 = v28[16] + v27[1];
      v47 = v28[17] + v27[2];
      result = sub_41E7B0((float *)&v45, 0, 1);
      if ( v24 )
      {
        result = *(_BYTE *)(v24 + 13) | 0x40;
        *(_BYTE *)(v24 + 13) = result;
      }
      else if ( v25 )
      {
        result = *(_BYTE *)(v25 + 13) | 0x40;
        *(_BYTE *)(v25 + 13) = result;
      }
      return result;
    case 4u:
      if ( sub_423120(&v63, (int)&v57) )
      {
        HIBYTE(dword_44B804) -= *(_BYTE *)(v21 + 22);
        sub_42CDC0((int)&dword_44B71C, -7000.0);
        if ( !(_BYTE)dword_44B814 )
        {
          sub_42CBE0((int)&dword_44B71C, 25);
          dword_44B764 = -974127104;
        }
      }
      goto LABEL_122;
    case 7u:
    case 9u:
      if ( dword_44B82C || byte_44B797 != -1 || *(_WORD *)(v21 + 22) == -1 )
        goto LABEL_122;
      v30 = sub_423120(&v63, (int)&v57);
      goto LABEL_147;
    case 8u:
    case 0xAu:
      if ( !dword_44B82C && byte_44B797 == 1 && *(_WORD *)(v21 + 22) != -1 )
      {
        v30 = sub_423120(&v63, (int)&v57);
LABEL_147:
        if ( v30 )
        {
          v33 = 1;
          if ( v21 != dword_44B834 )
            dword_44B82C = v21;
        }
      }
      goto LABEL_122;
    default:
      goto LABEL_122;
  }
}
// 44B748: using guessed type float flt_44B748;
// 44B74C: using guessed type float flt_44B74C;
// 44B750: using guessed type float flt_44B750;
// 44B764: using guessed type int dword_44B764;
// 44B76C: using guessed type int dword_44B76C;
// 44B784: using guessed type int dword_44B784;
// 44B78C: using guessed type char byte_44B78C;
// 44B78D: using guessed type char byte_44B78D;
// 44B78E: using guessed type char byte_44B78E;
// 44B78F: using guessed type char byte_44B78F;
// 44B790: using guessed type char byte_44B790;
// 44B797: using guessed type char byte_44B797;
// 44B7B4: using guessed type int dword_44B7B4;
// 44B7CC: using guessed type int dword_44B7CC;
// 44B7F8: using guessed type __int16 word_44B7F8;
// 44B7FA: using guessed type char byte_44B7FA;
// 44B7FC: using guessed type __int16 word_44B7FC;
// 44B7FE: using guessed type __int16 word_44B7FE;
// 44B802: using guessed type char byte_44B802;
// 44B804: using guessed type int dword_44B804;
// 44B80C: using guessed type int dword_44B80C;
// 44B810: using guessed type char byte_44B810;
// 44B813: using guessed type char byte_44B813;
// 44B814: using guessed type int dword_44B814;
// 44B818: using guessed type char byte_44B818;
// 44B828: using guessed type int dword_44B828;
// 44B82C: using guessed type int dword_44B82C;
// 44B830: using guessed type int dword_44B830;
// 44B834: using guessed type int dword_44B834;
// 44BAB0: using guessed type __int16 word_44BAB0;
// 44BAB2: using guessed type __int16 word_44BAB2;
// 44BAB4: using guessed type char byte_44BAB4;
// 455BEC: using guessed type int dword_455BEC;
// 455BF0: using guessed type int dword_455BF0;
// 455BF8: using guessed type int dword_455BF8;
// 455BFC: using guessed type int dword_455BFC;
// 455C20: using guessed type int dword_455C20;
// 455C58: using guessed type int dword_455C58;
// 455C60: using guessed type int dword_455C60;
// 455C68: using guessed type int dword_455C68;
// 455C6C: using guessed type int dword_455C6C;
// 455C70: using guessed type int dword_455C70;
// 455C7C: using guessed type int dword_455C7C;
// 455CAC: using guessed type int dword_455CAC;
// 455CB0: using guessed type int dword_455CB0;

//----- (00424E30) --------------------------------------------------------
int __cdecl sub_424E30(__int16 a1, unsigned __int16 a2, float *a3)
{
  int v3; // eax
  unsigned __int16 v4; // cx
  int result; // eax
  int v6; // ecx
  double v7; // st7
  int v8; // ecx
  int v9; // eax
  unsigned __int16 v10; // cx
  double v11; // st7
  int v12; // ecx

  if ( a2 != -1 )
  {
    if ( a1 == 2 )
    {
      v9 = dword_455C60 + 24 * a2;
      v10 = *(_WORD *)(v9 + 14);
      result = v9 + 13;
      v11 = *(float *)(dword_455C20 + 120 * v10 + 60) + *(float *)(result - 13);
      v12 = dword_455C20 + 120 * v10;
      *a3 = v11;
      a3[1] = *(float *)(v12 + 64) + *(float *)(result - 9);
      a3[2] = *(float *)(v12 + 68) + *(float *)(result - 5);
      return result;
    }
    if ( a1 == 3 )
    {
      v3 = dword_455C58 + 28 * a2;
      v4 = *(_WORD *)(v3 + 14);
      result = v3 + 13;
      v6 = 15 * v4;
      v7 = *(float *)(dword_455C20 + 8 * v6 + 60) + *(float *)(result - 13);
      v8 = dword_455C20 + 8 * v6;
      *a3 = v7;
      a3[1] = *(float *)(v8 + 64) + *(float *)(result - 9);
      a3[2] = *(float *)(v8 + 68) + *(float *)(result - 5);
      return result;
    }
  }
  return 0;
}
// 455C20: using guessed type int dword_455C20;
// 455C58: using guessed type int dword_455C58;
// 455C60: using guessed type int dword_455C60;

//----- (00424F80) --------------------------------------------------------
char sub_424F80()
{
  int v0; // esi
  int v1; // esi
  int v2; // esi
  unsigned __int16 v3; // si
  unsigned __int8 v4; // al
  int v5; // esi
  int v6; // esi
  unsigned __int8 v7; // cl
  int v8; // esi
  unsigned int v9; // edx
  unsigned __int16 v10; // si
  int v11; // edx
  int v12; // esi
  int v13; // esi
  int v14; // esi
  unsigned __int16 v15; // si
  unsigned __int8 v16; // cl
  int v17; // esi
  int v18; // esi
  unsigned __int8 v19; // cl
  int v20; // esi
  unsigned int v21; // edx
  unsigned __int16 v22; // si
  int v23; // edx

  sub_401580(1);
  byte_443AF2 = -1;
  byte_443AF1 = -1;
  byte_443AF0 = -1;
  if ( word_44B7EC >= 10 )
    sub_401870(15, (unsigned __int16)dword_44C720, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, word_44B7EC);
  else
    sub_401870(
      (unsigned __int16)dword_443AE4 + 15,
      (unsigned __int16)dword_44C720,
      (unsigned __int16)dword_443AE4,
      HIWORD(dword_443AE4),
      1,
      word_44B7EC);
  sub_401D10();
  v0 = 2 * dword_443AE4 + 15;
  sub_4015D0(
    (unsigned __int16)(2 * dword_443AE4 + 15),
    (unsigned __int16)dword_44C720,
    (unsigned __int16)dword_443AE4,
    HIWORD(dword_443AE4),
    1,
    0x5Bu);
  sub_401D10();
  v1 = dword_443AE4 + v0;
  if ( word_44B7EE >= 10 )
  {
    sub_401870(
      (unsigned __int16)v1,
      (unsigned __int16)dword_44C720,
      (unsigned __int16)dword_443AE4,
      HIWORD(dword_443AE4),
      1,
      word_44B7EE);
  }
  else
  {
    sub_401870(
      (unsigned __int16)v1,
      (unsigned __int16)dword_44C720,
      (unsigned __int16)dword_443AE4,
      HIWORD(dword_443AE4),
      1,
      0);
    sub_401870(
      (unsigned __int16)dword_443AE4 + (unsigned __int16)v1,
      (unsigned __int16)dword_44C720,
      (unsigned __int16)dword_443AE4,
      HIWORD(dword_443AE4),
      1,
      word_44B7EE);
  }
  sub_401D10();
  v2 = v1 + 2 * dword_443AE4;
  sub_4015D0(
    (unsigned __int16)v2,
    (unsigned __int16)dword_44C720,
    (unsigned __int16)dword_443AE4,
    HIWORD(dword_443AE4),
    1,
    0x5Cu);
  sub_401D10();
  v3 = dword_443AE4 + v2;
  if ( word_44B7F0 / 10 >= 10 )
  {
    sub_401870(
      v3,
      (unsigned __int16)dword_44C720,
      (unsigned __int16)dword_443AE4,
      HIWORD(dword_443AE4),
      1,
      word_44B7F0 / 10);
  }
  else
  {
    sub_401870(v3, (unsigned __int16)dword_44C720, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0);
    sub_401870(
      (unsigned __int16)dword_443AE4 + v3,
      (unsigned __int16)dword_44C720,
      (unsigned __int16)dword_443AE4,
      HIWORD(dword_443AE4),
      1,
      word_44B7F0 / 10);
  }
  sub_401D10();
  if ( dword_455BF8 != 11 )
  {
    v4 = byte_44B9BC[dword_455BF8];
    byte_443AF2 = -1;
    byte_443AF1 = -1;
    byte_443AF0 = 0;
    if ( v4 >= 0xAu )
      sub_401870(165, (unsigned __int16)dword_44C720, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, v4);
    else
      sub_401870(
        (unsigned __int16)dword_443AE4 + 165,
        (unsigned __int16)dword_44C720,
        (unsigned __int16)dword_443AE4,
        HIWORD(dword_443AE4),
        1,
        v4);
    sub_401D10();
    v5 = 2 * dword_443AE4 + 165;
    sub_4015D0(
      (unsigned __int16)(2 * dword_443AE4 + 165),
      (unsigned __int16)dword_44C720,
      (unsigned __int16)dword_443AE4,
      HIWORD(dword_443AE4),
      1,
      0x5Bu);
    sub_401D10();
    v6 = dword_443AE4 + v5;
    v7 = byte_44B9CC[dword_455BF8];
    if ( v7 >= 0xAu )
    {
      sub_401870(
        (unsigned __int16)v6,
        (unsigned __int16)dword_44C720,
        (unsigned __int16)dword_443AE4,
        HIWORD(dword_443AE4),
        1,
        v7);
    }
    else
    {
      sub_401870(
        (unsigned __int16)v6,
        (unsigned __int16)dword_44C720,
        (unsigned __int16)dword_443AE4,
        HIWORD(dword_443AE4),
        1,
        0);
      sub_401870(
        (unsigned __int16)dword_443AE4 + (unsigned __int16)v6,
        (unsigned __int16)dword_44C720,
        (unsigned __int16)dword_443AE4,
        HIWORD(dword_443AE4),
        1,
        (unsigned __int8)byte_44B9CC[dword_455BF8]);
    }
    sub_401D10();
    v8 = v6 + 2 * dword_443AE4;
    sub_4015D0(
      (unsigned __int16)v8,
      (unsigned __int16)dword_44C720,
      (unsigned __int16)dword_443AE4,
      HIWORD(dword_443AE4),
      1,
      0x5Cu);
    sub_401D10();
    v9 = (signed int)(1717986919 * (unsigned __int64)(unsigned __int16)word_44B9DC[dword_455BF8] >> 32) >> 2;
    v10 = dword_443AE4 + v8;
    v11 = (v9 >> 31) + v9;
    if ( v11 >= 10 )
    {
      sub_401870(v10, (unsigned __int16)dword_44C720, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, v11);
    }
    else
    {
      sub_401870(v10, (unsigned __int16)dword_44C720, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0);
      sub_401870(
        (unsigned __int16)dword_443AE4 + v10,
        (unsigned __int16)dword_44C720,
        (unsigned __int16)dword_443AE4,
        HIWORD(dword_443AE4),
        1,
        (unsigned __int16)word_44B9DC[dword_455BF8] / 10);
    }
    sub_401D10();
  }
  sub_401580(2);
  byte_443AF2 = -1;
  byte_443AF1 = -1;
  byte_443AF0 = -1;
  if ( word_44B7EC >= 10 )
    sub_401870(
      17,
      (unsigned __int16)dword_44C720 + 2,
      (unsigned __int16)dword_443AE4,
      HIWORD(dword_443AE4),
      1,
      word_44B7EC);
  else
    sub_401870(
      (unsigned __int16)dword_443AE4 + 17,
      (unsigned __int16)dword_44C720 + 2,
      (unsigned __int16)dword_443AE4,
      HIWORD(dword_443AE4),
      1,
      word_44B7EC);
  sub_401D10();
  v12 = 2 * dword_443AE4 + 17;
  sub_4015D0(
    (unsigned __int16)(2 * dword_443AE4 + 17),
    (unsigned __int16)dword_44C720 + 2,
    (unsigned __int16)dword_443AE4,
    HIWORD(dword_443AE4),
    1,
    0x5Bu);
  sub_401D10();
  v13 = dword_443AE4 + v12;
  if ( word_44B7EE >= 10 )
  {
    sub_401870(
      (unsigned __int16)v13,
      (unsigned __int16)dword_44C720 + 2,
      (unsigned __int16)dword_443AE4,
      HIWORD(dword_443AE4),
      1,
      word_44B7EE);
  }
  else
  {
    sub_401870(
      (unsigned __int16)v13,
      (unsigned __int16)dword_44C720 + 2,
      (unsigned __int16)dword_443AE4,
      HIWORD(dword_443AE4),
      1,
      0);
    sub_401870(
      (unsigned __int16)dword_443AE4 + (unsigned __int16)v13,
      (unsigned __int16)dword_44C720 + 2,
      (unsigned __int16)dword_443AE4,
      HIWORD(dword_443AE4),
      1,
      word_44B7EE);
  }
  sub_401D10();
  v14 = v13 + 2 * dword_443AE4;
  sub_4015D0(
    (unsigned __int16)v14,
    (unsigned __int16)dword_44C720 + 2,
    (unsigned __int16)dword_443AE4,
    HIWORD(dword_443AE4),
    1,
    0x5Cu);
  sub_401D10();
  v15 = dword_443AE4 + v14;
  if ( word_44B7F0 / 10 >= 10 )
  {
    sub_401870(
      v15,
      (unsigned __int16)dword_44C720 + 2,
      (unsigned __int16)dword_443AE4,
      HIWORD(dword_443AE4),
      1,
      word_44B7F0 / 10);
  }
  else
  {
    sub_401870(v15, (unsigned __int16)dword_44C720 + 2, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0);
    sub_401870(
      (unsigned __int16)dword_443AE4 + v15,
      (unsigned __int16)dword_44C720 + 2,
      (unsigned __int16)dword_443AE4,
      HIWORD(dword_443AE4),
      1,
      word_44B7F0 / 10);
  }
  sub_401D10();
  if ( dword_455BF8 != 11 )
  {
    v16 = byte_44B9BC[dword_455BF8];
    byte_443AF2 = -1;
    byte_443AF1 = -1;
    byte_443AF0 = -1;
    if ( v16 >= 0xAu )
      sub_401870(167, (unsigned __int16)dword_44C720 + 2, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, v16);
    else
      sub_401870(
        (unsigned __int16)dword_443AE4 + 167,
        (unsigned __int16)dword_44C720 + 2,
        (unsigned __int16)dword_443AE4,
        HIWORD(dword_443AE4),
        1,
        v16);
    sub_401D10();
    v17 = 2 * dword_443AE4 + 167;
    sub_4015D0(
      (unsigned __int16)(2 * dword_443AE4 + 167),
      (unsigned __int16)dword_44C720 + 2,
      (unsigned __int16)dword_443AE4,
      HIWORD(dword_443AE4),
      1,
      0x5Bu);
    sub_401D10();
    v18 = dword_443AE4 + v17;
    v19 = byte_44B9CC[dword_455BF8];
    if ( v19 >= 0xAu )
    {
      sub_401870(
        (unsigned __int16)v18,
        (unsigned __int16)dword_44C720 + 2,
        (unsigned __int16)dword_443AE4,
        HIWORD(dword_443AE4),
        1,
        v19);
    }
    else
    {
      sub_401870(
        (unsigned __int16)v18,
        (unsigned __int16)dword_44C720 + 2,
        (unsigned __int16)dword_443AE4,
        HIWORD(dword_443AE4),
        1,
        0);
      sub_401870(
        (unsigned __int16)dword_443AE4 + (unsigned __int16)v18,
        (unsigned __int16)dword_44C720 + 2,
        (unsigned __int16)dword_443AE4,
        HIWORD(dword_443AE4),
        1,
        (unsigned __int8)byte_44B9CC[dword_455BF8]);
    }
    sub_401D10();
    v20 = v18 + 2 * dword_443AE4;
    sub_4015D0(
      (unsigned __int16)v20,
      (unsigned __int16)dword_44C720 + 2,
      (unsigned __int16)dword_443AE4,
      HIWORD(dword_443AE4),
      1,
      0x5Cu);
    sub_401D10();
    v21 = (signed int)(1717986919 * (unsigned __int64)(unsigned __int16)word_44B9DC[dword_455BF8] >> 32) >> 2;
    v22 = dword_443AE4 + v20;
    v23 = (v21 >> 31) + v21;
    if ( v23 < 10 )
    {
      sub_401870(v22, (unsigned __int16)dword_44C720 + 2, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0);
      sub_401870(
        (unsigned __int16)dword_443AE4 + v22,
        (unsigned __int16)dword_44C720 + 2,
        (unsigned __int16)dword_443AE4,
        HIWORD(dword_443AE4),
        1,
        (unsigned __int16)word_44B9DC[dword_455BF8] / 10);
      sub_401D10();
      return 1;
    }
    sub_401870(v22, (unsigned __int16)dword_44C720 + 2, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, v23);
    sub_401D10();
  }
  return 1;
}
// 443AE4: using guessed type int dword_443AE4;
// 443AF0: using guessed type char byte_443AF0;
// 443AF1: using guessed type char byte_443AF1;
// 443AF2: using guessed type char byte_443AF2;
// 44B7EC: using guessed type __int16 word_44B7EC;
// 44B7EE: using guessed type __int16 word_44B7EE;
// 44B7F0: using guessed type __int16 word_44B7F0;
// 44C720: using guessed type int dword_44C720;
// 455BF8: using guessed type int dword_455BF8;

//----- (00425A50) --------------------------------------------------------
int __cdecl sub_425A50(__int16 a1, unsigned __int16 a2, unsigned __int8 a3, unsigned __int8 a4, char a5, char a6, char a7, char a8)
{
  int result; // eax
  double v9; // st7
  double v10; // st7
  char v11; // bl
  _DWORD *v12; // ecx
  double v13; // st7
  int v14; // esi
  double v15; // st7
  float v16; // ecx
  double v17; // st7
  double v18; // st7
  signed int v19; // edx
  signed int v20; // ecx
  int v21; // ecx
  int v22; // eax
  float v23; // [esp+0h] [ebp-4h]
  float v24; // [esp+8h] [ebp+4h]
  float v25; // [esp+Ch] [ebp+8h]
  float v26; // [esp+Ch] [ebp+8h]
  float v27; // [esp+20h] [ebp+1Ch]

  result = 0;
  if ( !(_BYTE)dword_455004 && !byte_44B802 )
  {
    if ( dword_455BF8 == 16 )
    {
      v23 = (double)a1 + dword_44B7E4;
      v10 = flt_44B7E8 - (double)a2;
    }
    else
    {
      if ( byte_44B797 == -1 )
        v9 = (double)a1 + dword_44B7E4 + 25.0;
      else
        v9 = (double)a1 + dword_44B7E4;
      v23 = v9;
      v10 = flt_44B7E8 - (double)a2 + 30.0;
    }
    v11 = a7;
    v24 = v10;
    if ( a7 )
    {
      v12 = dword_443D2C;
      v13 = v23;
      v14 = *((_DWORD *)dword_443D2C + 16032);
      *((_DWORD *)dword_443D2C + 16032) = v14 + 128;
      *(_DWORD *)(v14 + 4) = 0;
      *(_DWORD *)v14 = v12[30];
      v12[30] = v14;
      *(_BYTE *)(v14 + 34) = -1;
      *(_BYTE *)(v14 + 33) = -1;
      *(_BYTE *)(v14 + 32) = -1;
      *(_DWORD *)(v14 + 4) = 5;
      if ( dword_455BF8 == 16 )
      {
        v18 = v13 + 2.0;
        *(float *)(v14 + 20) = v24;
        *(float *)(v14 + 48) = v24;
        *(float *)(v14 + 16) = v18;
        v26 = v18 + 63.0;
        *(float *)(v14 + 44) = v26;
        v16 = v26;
        *(float *)(v14 + 72) = v18;
        v17 = v24 + 55.0;
      }
      else
      {
        v15 = v13 - 5.0;
        *(float *)(v14 + 16) = v15;
        v25 = v24 - 6.0;
        *(float *)(v14 + 20) = v25;
        v27 = v15 + 63.0;
        *(float *)(v14 + 44) = v27;
        v16 = v27;
        *(float *)(v14 + 48) = v25;
        *(float *)(v14 + 72) = v15;
        v17 = v25 + 55.0;
      }
      *(float *)(v14 + 76) = v17;
      *(float *)(v14 + 100) = v16;
      *(float *)(v14 + 104) = v17;
      *(_DWORD *)(v14 + 28) = 1065353216;
      *(_DWORD *)(v14 + 56) = 1065353216;
      *(_DWORD *)(v14 + 84) = 1065353216;
      *(_DWORD *)(v14 + 112) = 1065353216;
      *(_DWORD *)(v14 + 24) = 0;
      *(_DWORD *)(v14 + 52) = 0;
      *(_DWORD *)(v14 + 80) = 0;
      *(_DWORD *)(v14 + 108) = 0;
      switch ( a6 )
      {
        case 1:
          *(_DWORD *)(v14 + 36) = 1046799589;
          *(_DWORD *)(v14 + 92) = 1046799589;
          *(_DWORD *)(v14 + 40) = 0;
          *(_DWORD *)(v14 + 64) = 1054661853;
          *(_DWORD *)(v14 + 68) = 0;
          *(_DWORD *)(v14 + 96) = 1045220557;
          *(_DWORD *)(v14 + 120) = 1054661853;
          *(_DWORD *)(v14 + 124) = 1045220557;
          v22 = sub_401000(0, 0, 1166, 0);
          break;
        case 0x11:
        case 0x12:
        case 0x13:
        case 0x20:
          *(_DWORD *)(v14 + 36) = 1054925025;
          *(_DWORD *)(v14 + 92) = 1054925025;
          *(_DWORD *)(v14 + 40) = 1052819649;
          *(_DWORD *)(v14 + 64) = 1059431846;
          *(_DWORD *)(v14 + 68) = 1052819649;
          *(_DWORD *)(v14 + 96) = 1058247572;
          *(_DWORD *)(v14 + 120) = 1059431846;
          *(_DWORD *)(v14 + 124) = 1058247572;
          v22 = sub_401000(0, 0, 1244, 96);
          break;
        case 0x3C:
          v19 = 1044694213;
          *(_DWORD *)(v14 + 36) = 0;
          *(_DWORD *)(v14 + 40) = 0;
          *(_DWORD *)(v14 + 64) = 1044694213;
          *(_DWORD *)(v14 + 68) = 0;
          *(_DWORD *)(v14 + 92) = 0;
          v20 = 1044957385;
          goto LABEL_18;
        case 0x46:
          *(_DWORD *)(v14 + 36) = 1046536417;
          *(_DWORD *)(v14 + 92) = 1046536417;
          *(_DWORD *)(v14 + 40) = 0;
          *(_DWORD *)(v14 + 64) = 1054530267;
          *(_DWORD *)(v14 + 68) = 0;
          *(_DWORD *)(v14 + 96) = 1045220557;
          *(_DWORD *)(v14 + 120) = 1054530267;
          *(_DWORD *)(v14 + 124) = 1045220557;
          v22 = sub_401000(0, 0, 781, 256);
          break;
        case 0x47:
          *(_DWORD *)(v14 + 36) = 1054925025;
          *(_DWORD *)(v14 + 92) = 1054925025;
          *(_DWORD *)(v14 + 40) = 0;
          *(_DWORD *)(v14 + 64) = 1059431846;
          *(_DWORD *)(v14 + 68) = 0;
          *(_DWORD *)(v14 + 96) = 1045220557;
          *(_DWORD *)(v14 + 120) = 1059431846;
          *(_DWORD *)(v14 + 124) = 1045220557;
          v22 = sub_401000(0, 0, 794, 256);
          break;
        case 0x48:
          *(_DWORD *)(v14 + 36) = 1054925025;
          *(_DWORD *)(v14 + 92) = 1054925025;
          *(_DWORD *)(v14 + 40) = 0;
          *(_DWORD *)(v14 + 64) = 1059431846;
          *(_DWORD *)(v14 + 68) = 0;
          *(_DWORD *)(v14 + 96) = 1045220557;
          *(_DWORD *)(v14 + 120) = 1059431846;
          *(_DWORD *)(v14 + 124) = 1045220557;
          v22 = sub_401000(0, 0, 1180, 0);
          break;
        case 0x4A:
          v21 = dword_455BF8;
          *(_DWORD *)(v14 + 36) = 0;
          *(_DWORD *)(v14 + 40) = 0;
          if ( v21 == 8 )
          {
            *(_DWORD *)(v14 + 64) = 1045220557;
            *(_DWORD *)(v14 + 68) = 0;
            *(_DWORD *)(v14 + 92) = 0;
            *(_DWORD *)(v14 + 96) = 1045220557;
            *(_DWORD *)(v14 + 120) = 1045220557;
            *(_DWORD *)(v14 + 124) = 1045220557;
            v22 = sub_401000(0, 0, 768, 256);
          }
          else
          {
            v19 = 1045746901;
            *(_DWORD *)(v14 + 68) = 0;
            *(_DWORD *)(v14 + 64) = 1045746901;
            *(_DWORD *)(v14 + 92) = 0;
            v20 = 1045220557;
LABEL_18:
            *(_DWORD *)(v14 + 96) = v20;
            *(_DWORD *)(v14 + 120) = v19;
            *(_DWORD *)(v14 + 124) = v20;
            v22 = sub_401000(0, 0, 768, 256);
          }
          break;
        default:
          *(_DWORD *)(v14 + 36) = 1046536417;
          *(_DWORD *)(v14 + 92) = 1046536417;
          *(_DWORD *)(v14 + 40) = 1052819649;
          *(_DWORD *)(v14 + 64) = 1054530267;
          *(_DWORD *)(v14 + 68) = 1052819649;
          *(_DWORD *)(v14 + 96) = 1058247572;
          *(_DWORD *)(v14 + 120) = 1054530267;
          *(_DWORD *)(v14 + 124) = 1058247572;
          v22 = sub_401000(0, 0, 1230, 96);
          break;
      }
      *(_DWORD *)(v14 + 8) = v22;
    }
    result = sub_40CFF0((signed __int64)v23, (signed __int64)v24, a3, a4, a5, v11, a8);
  }
  return result;
}
// 44B797: using guessed type char byte_44B797;
// 44B7E8: using guessed type float flt_44B7E8;
// 44B802: using guessed type char byte_44B802;
// 455004: using guessed type int dword_455004;
// 455BF8: using guessed type int dword_455BF8;

//----- (00425E80) --------------------------------------------------------
int sub_425E80()
{
  int result; // eax
  int v1; // esi
  int v2; // edi
  int v3; // ecx
  void (__cdecl *v4)(int); // eax

  result = dword_455C78;
  v1 = dword_455C74;
  v2 = 0;
  if ( dword_455C78 )
  {
    do
    {
      v3 = *(_DWORD *)(v1 + 12);
      v4 = *(void (__cdecl **)(int))(v1 + 28);
      BYTE1(v3) |= 4u;
      *(_DWORD *)(v1 + 12) = v3;
      if ( v4 )
        v4(v1);
      v1 += 104;
      result = (unsigned __int16)++v2;
    }
    while ( (unsigned __int16)v2 < (unsigned int)dword_455C78 );
  }
  return result;
}
// 455C74: using guessed type int dword_455C74;
// 455C78: using guessed type int dword_455C78;

//----- (00425ED0) --------------------------------------------------------
int sub_425ED0()
{
  int result; // eax
  int v1; // esi
  int v2; // edi
  int v3; // edx
  char v4; // al

  result = dword_455C78;
  v1 = 0;
  v2 = dword_455C74;
  if ( dword_455C78 )
  {
    result = 0;
    do
    {
      v3 = 13 * result;
      v4 = *(_BYTE *)(v2 + 104 * result + 4);
      if ( v4 == 1 || v4 == 2 || v4 == 4 || v4 == 5 || v4 == 6 || v4 == 7 || v4 == 8 )
        sub_4166E0(v2 + 8 * v3);
      result = (unsigned __int16)++v1;
    }
    while ( (unsigned __int16)v1 < (unsigned int)dword_455C78 );
  }
  return result;
}
// 455C74: using guessed type int dword_455C74;
// 455C78: using guessed type int dword_455C78;

//----- (00425F30) --------------------------------------------------------
char __cdecl sub_425F30(char a1)
{
  char v1; // al
  char v3; // bl
  char v4; // al
  char v5; // al
  unsigned __int8 v6; // bl
  int v7; // esi
  int v8; // esi
  int v9; // eax
  int v10; // esi
  int v11; // eax
  char v12; // [esp+1h] [ebp-13h]
  unsigned __int8 v13; // [esp+2h] [ebp-12h]
  char v14; // [esp+4h] [ebp-10h]
  int v15; // [esp+8h] [ebp-Ch]
  int v16; // [esp+Ch] [ebp-8h]
  char v17; // [esp+10h] [ebp-4h]

  v12 = 0;
  if ( byte_455CA2 )
  {
    byte_455CA2 = 0;
    sub_404910(0, 0x4000);
  }
  byte_455C14 = 0;
  if ( dword_455BF8 == 16 )
    v12 = 1;
  if ( dword_44C72C )
  {
    if ( dword_44C72C == 25 )
      sub_434500(0x78u);
    if ( !--dword_44C72C )
      sub_434530();
  }
  if ( byte_44C748 )
  {
    v1 = sub_4263E0();
    if ( !v1 )
      return 0;
    byte_44C748 = 0;
    if ( v1 == 2 )
      return (byte_455CA6 == 2) + 2;
  }
  if ( !byte_455CAB || (v13 = 3, !byte_455CA7) )
    v13 = 2;
  v3 = dword_455BEC;
  v16 = dword_455BEC;
  dword_455BEC = 0;
  sub_404910(0, 4096);
  if ( v3 & 0x10 && !(v3 & 0xA0) )
  {
    if ( byte_455CA6 )
    {
      v4 = byte_455CA6-- - 1;
      if ( v12 && v4 == 1 )
        byte_455CA6 = 0;
    }
    else
    {
      byte_455CA6 = v13;
    }
    sub_404910(0, 16);
    sub_407E00((int)&unk_444764);
  }
  if ( v3 & 0x40 && !(v3 & 0x10) && !(v3 & 0x20) )
  {
    if ( (unsigned __int8)byte_455CA6 >= v13 )
    {
      byte_455CA6 = 0;
    }
    else
    {
      v5 = byte_455CA6++ + 1;
      if ( v12 && v5 == 1 )
        byte_455CA6 = 2;
    }
    sub_404910(0, 64);
    sub_407E00((int)&unk_444764);
  }
  sub_401580(1);
  byte_443AF2 = -26;
  byte_443AF1 = 0;
  byte_443AF0 = 0;
  sub_4015D0(
    0x10000000u,
    (*((_DWORD *)dword_443D44 + 3) - 130) / 2 + 5,
    (unsigned __int16)dword_443AE4,
    HIWORD(dword_443AE4),
    1,
    0x12u);
  sub_401D10();
  sub_4015B0(&v17, &v15);
  v6 = 0;
  v14 = 0;
  v7 = (*((_DWORD *)dword_443D44 + 3) - 130) / 2 + v15 + 30;
  if ( v13 != -1 )
  {
    do
    {
      if ( v6 == 1 && v12 )
      {
        v6 = 2;
        v14 = 2;
      }
      if ( v6 == byte_455CA6 )
      {
        byte_443AF0 = 0;
        byte_443AF2 = word_442380;
        byte_443AF1 = word_442380;
      }
      else
      {
        byte_443AF2 = 120;
        byte_443AF1 = 40;
        byte_443AF0 = 47;
      }
      if ( v6 == 1 && v12 )
      {
        byte_443AF2 = 20;
        byte_443AF1 = 20;
        byte_443AF0 = 20;
      }
      if ( a1 )
      {
        switch ( v14 )
        {
          case 0:
            sub_4015D0(0x10000000u, v7 + 10, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x13u);
            break;
          case 1:
            sub_4015D0(0x10000000u, v7 + 10, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0xC5u);
            break;
          case 2:
            sub_4015D0(0x10000000u, v7 + 10, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x15u);
            break;
          case 3:
            sub_4015D0(0x10000000u, v7 + 10, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x16u);
            break;
          default:
            break;
        }
        v7 += v15;
      }
      v14 = ++v6;
    }
    while ( v6 < (unsigned __int8)(v13 + 1) );
  }
  sub_401D10();
  sub_401580(0);
  byte_443AF2 = 10;
  byte_443AF1 = 10;
  byte_443AF0 = 10;
  byte_443C1D = 10;
  byte_443C1E = 10;
  byte_443C1C = 10;
  sub_401E50(0, 0, *((_DWORD *)dword_443D44 + 2), *((_DWORD *)dword_443D44 + 3), 1);
  sub_401D10();
  sub_401580(0);
  byte_443AF2 = 10;
  byte_443AF1 = 10;
  byte_443AF0 = 10;
  byte_443C1D = 10;
  byte_443C1E = 10;
  byte_443C1C = 10;
  sub_401E50(0, 0, *((_DWORD *)dword_443D44 + 2), *((_DWORD *)dword_443D44 + 3), 1);
  sub_401D10();
  sub_4345A0();
  v8 = v16 & 0x3000;
  if ( !(v16 & 0x3000) )
  {
    v10 = v16 & 0xC000;
    if ( v16 & 0xC000 )
    {
      sub_434530();
      dword_44C72C = 0;
      sub_407E00((int)&unk_444770);
      sub_404910(0, v10);
      switch ( byte_455CA6 )
      {
        case 0:
          if ( byte_44B812 )
          {
            sub_404930(0, 4096);
            v11 = dword_455BEC;
            BYTE1(v11) |= 0x10u;
            dword_455BEC = v11;
          }
          return 1;
        case 1:
          if ( !v12 )
            goto LABEL_61;
          return 0;
        case 2:
LABEL_61:
          byte_44C748 = 1;
          LOBYTE(dword_44C708) = 1;
          return 0;
        case 3:
          return 4;
        default:
          return 0;
      }
    }
    return 0;
  }
  sub_434530();
  dword_44C72C = 0;
  sub_407E00((int)&dword_444758);
  sub_404910(0, v8);
  if ( !byte_44B812 )
    return 1;
  sub_404930(0, 4096);
  v9 = dword_455BEC;
  BYTE1(v9) |= 0x10u;
  dword_455BEC = v9;
  return 1;
}
// 442380: using guessed type __int16 word_442380;
// 443AE4: using guessed type int dword_443AE4;
// 443AF0: using guessed type char byte_443AF0;
// 443AF1: using guessed type char byte_443AF1;
// 443AF2: using guessed type char byte_443AF2;
// 443C1C: using guessed type char byte_443C1C;
// 443C1D: using guessed type char byte_443C1D;
// 443C1E: using guessed type char byte_443C1E;
// 44B812: using guessed type char byte_44B812;
// 44C708: using guessed type int dword_44C708;
// 44C72C: using guessed type int dword_44C72C;
// 44C748: using guessed type char byte_44C748;
// 455BEC: using guessed type int dword_455BEC;
// 455BF8: using guessed type int dword_455BF8;
// 455C14: using guessed type char byte_455C14;
// 455CA2: using guessed type char byte_455CA2;
// 455CA6: using guessed type char byte_455CA6;
// 455CA7: using guessed type char byte_455CA7;
// 455CAB: using guessed type char byte_455CAB;

//----- (004263E0) --------------------------------------------------------
char sub_4263E0()
{
  __int16 v0; // bx
  bool v1; // zf
  int v2; // edi
  char result; // al
  unsigned __int8 v4; // bl
  int v5; // esi
  int v6; // esi
  int v7; // [esp+Ch] [ebp-Ch]
  int v8; // [esp+10h] [ebp-8h]
  char v9; // [esp+14h] [ebp-4h]

  v0 = dword_455BEC;
  v1 = (dword_455BEC & 0x10) == 0;
  v8 = dword_455BEC;
  dword_455BEC = 0;
  if ( !v1 )
  {
    if ( (_BYTE)dword_44C708 )
      LOBYTE(dword_44C708) = dword_44C708 - 1;
    else
      LOBYTE(dword_44C708) = 1;
    sub_404910(0, 16);
    sub_407E00((int)&unk_444764);
  }
  if ( v0 & 0x40 )
  {
    if ( (unsigned __int8)dword_44C708 >= 1u )
      LOBYTE(dword_44C708) = 0;
    else
      LOBYTE(dword_44C708) = dword_44C708 + 1;
    sub_404910(0, 64);
    sub_407E00((int)&unk_444764);
  }
  v2 = v0 & 0xC000;
  if ( v0 & 0xC000 && (unsigned __int8)dword_44C708 == 1 )
  {
    sub_407E00((int)&unk_444770);
    sub_404910(0, v0 & 0xC000);
    result = 1;
  }
  else
  {
    sub_401580(1);
    byte_443AF2 = 127;
    byte_443AF1 = 0;
    byte_443AF0 = 0;
    sub_4015D0(
      0x10000000u,
      (*((_DWORD *)dword_443D44 + 3) - 130) / 2 + 5,
      (unsigned __int16)dword_443AE4,
      HIWORD(dword_443AE4),
      1,
      0xFu);
    sub_401D10();
    sub_4015B0(&v9, &v7);
    v4 = 0;
    v5 = (*((_DWORD *)dword_443D44 + 3) - 130) / 2 + v7 + 30;
    do
    {
      if ( v4 == (_BYTE)dword_44C708 )
      {
        byte_443AF0 = 0;
        byte_443AF2 = word_442380;
        byte_443AF1 = word_442380;
      }
      else
      {
        byte_443AF2 = 120;
        byte_443AF1 = 40;
        byte_443AF0 = 47;
      }
      if ( v4 )
        sub_4015D0(0x10000000u, v5 + 10, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x11u);
      else
        sub_4015D0(0x10000000u, v5 + 10, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x10u);
      v5 += v7;
      ++v4;
    }
    while ( v4 < 2u );
    sub_401D10();
    sub_401580(0);
    byte_443AF2 = 10;
    byte_443AF1 = 10;
    byte_443AF0 = 10;
    byte_443C1D = 10;
    byte_443C1E = 10;
    byte_443C1C = 10;
    sub_401E50(0, 0, *((_DWORD *)dword_443D44 + 2), *((_DWORD *)dword_443D44 + 3), 1);
    sub_401D10();
    sub_401580(0);
    byte_443AF2 = 10;
    byte_443AF1 = 10;
    byte_443AF0 = 10;
    byte_443C1D = 10;
    byte_443C1E = 10;
    byte_443C1C = 10;
    sub_401E50(0, 0, *((_DWORD *)dword_443D44 + 2), *((_DWORD *)dword_443D44 + 3), 1);
    sub_401D10();
    sub_4345A0();
    v6 = v8 & 0x3000;
    if ( v8 & 0x3000 )
    {
      sub_407E00((int)&dword_444758);
      sub_404910(0, v6);
      result = 1;
    }
    else if ( !v2 || (_BYTE)dword_44C708 )
    {
      result = 0;
    }
    else
    {
      sub_407E00((int)&unk_444770);
      sub_404910(0, v2);
      result = 2;
    }
  }
  return result;
}
// 442380: using guessed type __int16 word_442380;
// 443AE4: using guessed type int dword_443AE4;
// 443AF0: using guessed type char byte_443AF0;
// 443AF1: using guessed type char byte_443AF1;
// 443AF2: using guessed type char byte_443AF2;
// 443C1C: using guessed type char byte_443C1C;
// 443C1D: using guessed type char byte_443C1D;
// 443C1E: using guessed type char byte_443C1E;
// 44C708: using guessed type int dword_44C708;
// 455BEC: using guessed type int dword_455BEC;

//----- (004266A0) --------------------------------------------------------
char sub_4266A0()
{
  int v0; // eax

  v0 = dword_455BEC;
  if ( byte_44B790 )
    LOBYTE(v0) = dword_455BEC & 0x5F;
  else
    LOBYTE(v0) = dword_455BEC & 0x7F | 0x20;
  dword_455BEC = v0;
  return v0;
}
// 44B790: using guessed type char byte_44B790;
// 455BEC: using guessed type int dword_455BEC;

//----- (004266C0) --------------------------------------------------------
char sub_4266C0()
{
  unsigned __int16 *v0; // eax
  unsigned __int16 v1; // dx
  int v2; // eax
  int v3; // eax
  bool v4; // zf

  LOBYTE(v0) = byte_455CA9;
  if ( (unsigned __int8)byte_455CA9 <= 0x28u )
  {
    if ( byte_455CA9 )
    {
      sub_4122C0(0xFFu, 1, byte_455CA9);
      v4 = byte_455CA9 == 4;
      LOBYTE(v0) = byte_455CA9 - 4;
      byte_455CA9 -= 4;
      if ( v4 )
      {
        LOBYTE(v0) = dword_44B814;
        byte_455CA9 = 0;
        HIBYTE(dword_455C98) = 0;
        if ( !(_BYTE)dword_44B814 )
        {
          word_44B7F0 = 0;
          word_44B7EE = 0;
          word_44B7EC = 0;
          LOBYTE(v0) = sub_434530();
        }
      }
    }
  }
  else
  {
    dword_4412A4 = 0;
    sub_4122C0(0xFFu, 1, byte_455CA9);
    LOBYTE(v0) = byte_455CA9;
    if ( byte_455CA9 == 42 )
    {
      if ( LODWORD(dword_44B700) )
      {
        v0 = *(unsigned __int16 **)(LODWORD(dword_44B700) + 184);
        if ( v0 )
        {
          v1 = *v0;
          LOWORD(v0) = *(_WORD *)(LODWORD(dword_44B700) + 174);
          if ( (unsigned __int16)v0 == v1 - 1 )
          {
            byte_455CA9 = 41;
            if ( (_BYTE)dword_44B814 )
            {
              sub_408670(dword_44B71C, 0, 0);
              word_44B7F6 = 0;
              LOBYTE(v0) = sub_408670(dword_44B700, 0, 0);
              word_44B7F4 = 0;
            }
            else
            {
              sub_408670(dword_44B71C, 60, 0);
              word_44B7F6 = 60;
              LOBYTE(v0) = sub_408670(dword_44B700, 60, 0);
              word_44B7F4 = 60;
            }
          }
        }
      }
      return (char)v0;
    }
    if ( byte_455CA9 != 41 )
      return (char)v0;
    LOBYTE(v0) = dword_455BF8;
    if ( dword_455BF8 == 11 )
    {
      v2 = (unsigned __int8)sub_41F530(0xAF0u) - 1;
      if ( v2 )
      {
        v0 = (unsigned __int16 *)(v2 - 1);
        if ( !v0 )
          byte_455CA9 = 40;
      }
      else
      {
        LOBYTE(v0) = sub_40F890();
      }
      return (char)v0;
    }
    if ( dword_455BF8 == 4 )
    {
      LOBYTE(v0) = sub_41F5D0();
      if ( !(_BYTE)v0 )
        return (char)v0;
LABEL_17:
      byte_455CA9 = 40;
      return (char)v0;
    }
    if ( dword_455BF8 != 8 )
      goto LABEL_17;
    v3 = (unsigned __int8)sub_41F530(0xED8u) - 1;
    if ( v3 )
    {
      v0 = (unsigned __int16 *)(v3 - 1);
      if ( !v0 )
        byte_455CA9 = 40;
    }
    else
    {
      LOBYTE(v0) = sub_413D10();
    }
  }
  return (char)v0;
}
// 4412A4: using guessed type int dword_4412A4;
// 44B7EC: using guessed type __int16 word_44B7EC;
// 44B7EE: using guessed type __int16 word_44B7EE;
// 44B7F0: using guessed type __int16 word_44B7F0;
// 44B7F4: using guessed type __int16 word_44B7F4;
// 44B7F6: using guessed type __int16 word_44B7F6;
// 44B814: using guessed type int dword_44B814;
// 455BF8: using guessed type int dword_455BF8;
// 455C98: using guessed type int dword_455C98;
// 455CA9: using guessed type char byte_455CA9;

//----- (00426880) --------------------------------------------------------
float __usercall sub_426880@<eax>(char a1)
{
  float result; // eax

  if ( !(_BYTE)dword_44B814 )
  {
    sub_408670(dword_44B71C, 93, 0);
    word_44B7F6 = 93;
    sub_408670(dword_44B700, 93, 0);
    word_44B7F4 = 93;
    goto LABEL_5;
  }
  if ( !a1 )
  {
    sub_408670(dword_44B71C, 0, 0);
    word_44B7F6 = 0;
    sub_408670(dword_44B700, 0, 0);
    word_44B7F4 = 0;
LABEL_5:
    byte_455CA9 = 41;
    goto LABEL_6;
  }
  sub_408670(dword_44B71C, 22, 0);
  word_44B7F6 = 22;
  sub_408670(dword_44B700, 22, 0);
  word_44B7F4 = 22;
  sub_407E00((int)&unk_4447C4);
  byte_455CA9 = 42;
LABEL_6:
  result = flt_44B770;
  BYTE2(dword_44B80C) = 0;
  byte_44B818 = 0;
  dword_44B764 = 0;
  dword_44B740 = flt_44B770;
  return result;
}
// 44B764: using guessed type int dword_44B764;
// 44B7F4: using guessed type __int16 word_44B7F4;
// 44B7F6: using guessed type __int16 word_44B7F6;
// 44B80C: using guessed type int dword_44B80C;
// 44B814: using guessed type int dword_44B814;
// 44B818: using guessed type char byte_44B818;
// 455CA9: using guessed type char byte_455CA9;

//----- (00426970) --------------------------------------------------------
unsigned int __cdecl sub_426970(char a1)
{
  _DWORD *v1; // eax
  int v2; // esi
  double v3; // st7
  double v4; // st7
  char v5; // cl
  signed int v6; // ebp
  _DWORD *v7; // eax
  int v8; // esi
  double v9; // st7
  float v10; // ST2C_4
  unsigned int result; // eax
  int v12; // edx
  unsigned int v13; // ebp
  signed int v14; // ebp
  _DWORD *v15; // eax
  int v16; // esi
  double v17; // st7
  float v18; // ST30_4
  _DWORD *v19; // eax
  int v20; // esi
  int v21; // ebp
  double v22; // st7
  double v23; // st6
  float v24; // ST30_4
  double v25; // st7
  double v26; // st7
  float v27; // [esp+10h] [ebp-30h]
  float v28; // [esp+10h] [ebp-30h]
  float v29; // [esp+14h] [ebp-2Ch]
  float v30; // [esp+14h] [ebp-2Ch]
  unsigned int v31; // [esp+18h] [ebp-28h]
  unsigned int v32; // [esp+18h] [ebp-28h]
  unsigned int v33; // [esp+1Ch] [ebp-24h]
  int v34; // [esp+28h] [ebp-18h]
  char v35; // [esp+44h] [ebp+4h]

  v1 = dword_443D2C;
  v2 = *((_DWORD *)dword_443D2C + 16032);
  *((_DWORD *)dword_443D2C + 16032) = v2 + 128;
  *(_DWORD *)(v2 + 4) = 0;
  *(_DWORD *)v2 = v1[30];
  v1[30] = v2;
  *(_DWORD *)(v2 + 16) = 1101004800;
  v3 = (double)(a1 - 5);
  *(_DWORD *)(v2 + 44) = 1121845248;
  *(_DWORD *)(v2 + 100) = 1121845248;
  *(_DWORD *)(v2 + 72) = 1101004800;
  *(float *)(v2 + 20) = v3;
  *(float *)(v2 + 48) = v3;
  *(_DWORD *)(v2 + 40) = 1048872069;
  *(_DWORD *)(v2 + 68) = 1048872069;
  v4 = v3 + 49.4;
  *(float *)(v2 + 76) = v4;
  *(float *)(v2 + 104) = v4;
  *(_BYTE *)(v2 + 34) = -1;
  *(_BYTE *)(v2 + 33) = -1;
  *(_BYTE *)(v2 + 32) = -1;
  *(_DWORD *)(v2 + 4) = 5;
  *(_DWORD *)(v2 + 24) = 0;
  *(_DWORD *)(v2 + 28) = 1065353216;
  *(_DWORD *)(v2 + 52) = 0;
  *(_DWORD *)(v2 + 56) = 1065353216;
  *(_DWORD *)(v2 + 80) = 0;
  *(_DWORD *)(v2 + 84) = 1065353216;
  *(_DWORD *)(v2 + 108) = 0;
  *(_DWORD *)(v2 + 112) = 1065353216;
  *(_DWORD *)(v2 + 36) = 1059629225;
  *(_DWORD *)(v2 + 64) = 1063708391;
  *(_DWORD *)(v2 + 92) = 1059629225;
  *(_DWORD *)(v2 + 96) = 1053740751;
  *(_DWORD *)(v2 + 120) = 1063708391;
  *(_DWORD *)(v2 + 124) = 1053740751;
  *(_DWORD *)(v2 + 8) = sub_401000(0, 0, 1194, 66);
  v5 = a1 + 10;
  v35 = a1 + 10;
  v31 = 0;
  if ( (unsigned __int8)dword_44B808 > 0u )
  {
    v6 = 159;
    v27 = (double)(v5 - 1);
    v29 = (double)(v5 + 32);
    do
    {
      v7 = dword_443D2C;
      v8 = *((_DWORD *)dword_443D2C + 16032);
      *((_DWORD *)dword_443D2C + 16032) = v8 + 128;
      *(_DWORD *)(v8 + 4) = 0;
      *(_DWORD *)v8 = v7[30];
      v7[30] = v8;
      *(_BYTE *)(v8 + 34) = -1;
      *(_BYTE *)(v8 + 33) = -1;
      *(_BYTE *)(v8 + 32) = -1;
      *(_DWORD *)(v8 + 4) = 5;
      v9 = (double)(unsigned int)(v6 - 33);
      *(_DWORD *)(v8 + 8) = sub_401000(0, 0, 1194, 33);
      *(float *)(v8 + 16) = v9;
      *(float *)(v8 + 20) = v27;
      *(float *)(v8 + 48) = v27;
      v10 = (double)(unsigned int)v6;
      *(float *)(v8 + 76) = v29;
      *(float *)(v8 + 44) = v10;
      *(float *)(v8 + 100) = v10;
      *(float *)(v8 + 72) = v9;
      *(float *)(v8 + 104) = v29;
      *(_DWORD *)(v8 + 36) = 1059629225;
      *(_DWORD *)(v8 + 92) = 1059629225;
      *(_DWORD *)(v8 + 24) = 0;
      *(_DWORD *)(v8 + 28) = 1065353216;
      *(_DWORD *)(v8 + 52) = 0;
      *(_DWORD *)(v8 + 56) = 1065353216;
      *(_DWORD *)(v8 + 80) = 0;
      *(_DWORD *)(v8 + 84) = 1065353216;
      *(_DWORD *)(v8 + 108) = 0;
      *(_DWORD *)(v8 + 112) = 1065353216;
      *(_DWORD *)(v8 + 40) = 1040483461;
      *(_DWORD *)(v8 + 64) = 1061734601;
      *(_DWORD *)(v8 + 68) = 1040483461;
      *(_DWORD *)(v8 + 96) = 1048740483;
      *(_DWORD *)(v8 + 120) = 1061734601;
      *(_DWORD *)(v8 + 124) = 1048740483;
      v6 += 38;
      ++v31;
    }
    while ( v31 < (unsigned __int8)dword_44B808 );
  }
  result = (unsigned int)HIBYTE(dword_44B804) >> 1;
  v12 = HIBYTE(dword_44B804) % 2;
  v13 = 0;
  v34 = HIBYTE(dword_44B804) % 2;
  if ( result > 0 )
  {
    v14 = 159;
    v32 = (unsigned int)HIBYTE(dword_44B804) >> 1;
    v28 = (double)(v35 - 1);
    v33 = (unsigned int)HIBYTE(dword_44B804) >> 1;
    v30 = (double)(v35 + 32);
    do
    {
      v15 = dword_443D2C;
      v16 = *((_DWORD *)dword_443D2C + 16032);
      *((_DWORD *)dword_443D2C + 16032) = v16 + 128;
      *(_DWORD *)(v16 + 4) = 0;
      *(_DWORD *)v16 = v15[30];
      v15[30] = v16;
      *(float *)(v16 + 20) = v28;
      v17 = (double)(unsigned int)(v14 - 33);
      *(float *)(v16 + 76) = v30;
      *(float *)(v16 + 48) = v28;
      *(float *)(v16 + 16) = v17;
      *(_BYTE *)(v16 + 34) = -1;
      *(_BYTE *)(v16 + 33) = -1;
      *(_BYTE *)(v16 + 32) = -1;
      v18 = (double)(unsigned int)v14;
      *(_DWORD *)(v16 + 4) = 5;
      *(float *)(v16 + 44) = v18;
      *(float *)(v16 + 100) = v18;
      *(float *)(v16 + 72) = v17;
      *(_DWORD *)(v16 + 36) = 1059629225;
      *(_DWORD *)(v16 + 92) = 1059629225;
      *(float *)(v16 + 104) = v30;
      *(_DWORD *)(v16 + 24) = 0;
      *(_DWORD *)(v16 + 28) = 1065353216;
      *(_DWORD *)(v16 + 52) = 0;
      *(_DWORD *)(v16 + 56) = 1065353216;
      *(_DWORD *)(v16 + 80) = 0;
      *(_DWORD *)(v16 + 84) = 1065353216;
      *(_DWORD *)(v16 + 108) = 0;
      *(_DWORD *)(v16 + 112) = 1065353216;
      *(_DWORD *)(v16 + 40) = 0;
      *(_DWORD *)(v16 + 64) = 1061734601;
      *(_DWORD *)(v16 + 68) = 0;
      *(_DWORD *)(v16 + 96) = 1040220289;
      *(_DWORD *)(v16 + 120) = 1061734601;
      *(_DWORD *)(v16 + 124) = 1040220289;
      *(_DWORD *)(v16 + 8) = sub_401000(0, 0, 1194, 0);
      v14 += 38;
      result = v33-- - 1;
    }
    while ( v33 );
    v12 = v34;
    v13 = v32;
  }
  if ( v12 )
  {
    v19 = dword_443D2C;
    v20 = *((_DWORD *)dword_443D2C + 16032);
    *((_DWORD *)dword_443D2C + 16032) = v20 + 128;
    *(_DWORD *)(v20 + 4) = 0;
    *(_DWORD *)v20 = v19[30];
    v19[30] = v20;
    *(_BYTE *)(v20 + 34) = -1;
    *(_BYTE *)(v20 + 33) = -1;
    *(_BYTE *)(v20 + 32) = -1;
    *(_DWORD *)(v20 + 4) = 5;
    v21 = 38 * v13;
    v22 = (double)(unsigned int)(v21 + 126);
    *(float *)(v20 + 16) = v22;
    v23 = (double)(v35 - 1);
    *(float *)(v20 + 20) = v23;
    *(_DWORD *)(v20 + 24) = 0;
    v24 = (double)(33 * ((unsigned int)(33 * v12) >> 1) / 0x21 + v21 + 126);
    *(float *)(v20 + 44) = v24;
    *(_DWORD *)(v20 + 28) = 1065353216;
    *(float *)(v20 + 48) = v23;
    *(float *)(v20 + 100) = v24;
    *(float *)(v20 + 72) = v22;
    v25 = (double)(v35 + 32);
    *(_DWORD *)(v20 + 36) = 1059629225;
    *(_DWORD *)(v20 + 92) = 1059629225;
    *(_DWORD *)(v20 + 52) = 0;
    *(float *)(v20 + 76) = v25;
    *(float *)(v20 + 104) = v25;
    *(_DWORD *)(v20 + 56) = 1065353216;
    *(_DWORD *)(v20 + 80) = 0;
    *(_DWORD *)(v20 + 84) = 1065353216;
    *(_DWORD *)(v20 + 108) = 0;
    *(_DWORD *)(v20 + 112) = 1065353216;
    *(_DWORD *)(v20 + 40) = 0;
    *(_DWORD *)(v20 + 68) = 0;
    *(_DWORD *)(v20 + 96) = 1040220289;
    v26 = (double)(((unsigned int)(33 * v12) >> 1) - 1) * 0.0039215689 + 0.65882355;
    *(_DWORD *)(v20 + 124) = 1040220289;
    *(float *)(v20 + 64) = v26;
    *(float *)(v20 + 120) = v26;
    result = sub_401000(0, 0, 1194, 0);
    *(_DWORD *)(v20 + 8) = result;
  }
  return result;
}
// 44B804: using guessed type int dword_44B804;
// 44B808: using guessed type int dword_44B808;

//----- (00426DF0) --------------------------------------------------------
char sub_426DF0()
{
  char result; // al

  result = byte_44C718;
  if ( byte_44D33D || byte_44C718 <= 18 && byte_44C718 > -20 )
    result = sub_426970(byte_44C718);
  return result;
}
// 44C718: using guessed type char byte_44C718;
// 44D33D: using guessed type char byte_44D33D;

//----- (00426E10) --------------------------------------------------------
char __fastcall sub_426E10(int a1)
{
  char result; // al
  __int64 v2; // rax
  int v3; // esi
  signed __int16 v4; // dx
  int v5; // ecx
  _DWORD *v6; // eax
  int v7; // esi
  double v8; // st7
  double v9; // st6
  float v10; // ST3C_4
  double v11; // st7
  unsigned __int16 v12; // ax
  unsigned __int16 v13; // ax

  result = byte_44C749;
  if ( byte_44C749 || byte_44C70E <= 18 && byte_44C70E > -20 )
  {
    if ( (_WORD)dword_455C98 )
    {
      LOWORD(a1) = byte_44C70E;
      v2 = (signed __int16)(((unsigned int)((unsigned __int64)(17179869190i64 * (unsigned __int16)dword_455C98) >> 32) >> 31)
                          + ((signed int)((unsigned __int64)(17179869190i64 * (unsigned __int16)dword_455C98) >> 32) >> 2));
      v3 = ((signed int)v2 - HIDWORD(v2)) >> 1;
      v4 = 480 - v3;
      v5 = a1 - v3 - 9;
      if ( byte_455C14 )
        LOWORD(dword_455C98) = dword_455C98 - 1;
    }
    else
    {
      v4 = 480;
      LOWORD(v5) = byte_44C70E - 9;
    }
    v6 = dword_443D2C;
    v7 = *((_DWORD *)dword_443D2C + 16032);
    v8 = (double)v4;
    *((_DWORD *)dword_443D2C + 16032) = v7 + 128;
    *(_DWORD *)(v7 + 4) = 0;
    *(_DWORD *)v7 = v6[30];
    v6[30] = v7;
    *(float *)(v7 + 16) = v8;
    *(_BYTE *)(v7 + 34) = -16;
    *(_BYTE *)(v7 + 33) = -16;
    *(_BYTE *)(v7 + 32) = -16;
    *(_DWORD *)(v7 + 4) = 5;
    v9 = (double)(signed __int16)v5;
    *(_DWORD *)(v7 + 28) = 1065353216;
    *(_DWORD *)(v7 + 56) = 1065353216;
    *(_DWORD *)(v7 + 84) = 1065353216;
    *(_DWORD *)(v7 + 112) = 1065353216;
    *(float *)(v7 + 20) = v9;
    *(_DWORD *)(v7 + 24) = 0;
    *(_DWORD *)(v7 + 36) = 1061997773;
    *(_DWORD *)(v7 + 92) = 1061997773;
    *(_DWORD *)(v7 + 52) = 0;
    *(_DWORD *)(v7 + 80) = 0;
    *(_DWORD *)(v7 + 108) = 0;
    v10 = v8 + 39.6;
    *(float *)(v7 + 44) = v10;
    *(_DWORD *)(v7 + 40) = 0;
    *(float *)(v7 + 48) = v9;
    *(float *)(v7 + 100) = v10;
    *(float *)(v7 + 72) = v8;
    *(_DWORD *)(v7 + 64) = 1064366321;
    *(_DWORD *)(v7 + 68) = 0;
    *(_DWORD *)(v7 + 96) = 1043115181;
    *(_DWORD *)(v7 + 120) = 1064366321;
    v11 = v9 + 47.3;
    *(float *)(v7 + 76) = v11;
    *(_DWORD *)(v7 + 124) = 1043115181;
    *(float *)(v7 + 104) = v11;
    *(_DWORD *)(v7 + 8) = sub_401000(0, 1, 1203, 0);
    sub_401580(0);
    byte_443AF2 = -116;
    byte_443AF1 = -116;
    byte_443AF0 = -116;
    sub_4015D0(0x218u, byte_44C70E + 4, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0xDFu);
    sub_401D10();
    sub_401580(1);
    byte_443AF2 = -1;
    byte_443AF1 = -1;
    byte_443AF0 = -1;
    v12 = word_44B7FE;
    if ( (unsigned __int16)word_44B7FE > 0x270Fu )
    {
      v12 = 9999;
      word_44B7FE = 9999;
    }
    sub_401870(558, byte_44C70E + 3, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, v12);
    sub_401D10();
    sub_401580(2);
    byte_443AF2 = 127;
    byte_443AF1 = 127;
    byte_443AF0 = 127;
    v13 = word_44B7FE;
    if ( (unsigned __int16)word_44B7FE > 0x270Fu )
    {
      v13 = 9999;
      word_44B7FE = 9999;
    }
    sub_401870(560, byte_44C70E + 5, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, v13);
    sub_401D10();
    result = sub_401580(1);
  }
  return result;
}
// 443AE4: using guessed type int dword_443AE4;
// 443AF0: using guessed type char byte_443AF0;
// 443AF1: using guessed type char byte_443AF1;
// 443AF2: using guessed type char byte_443AF2;
// 44B7FE: using guessed type __int16 word_44B7FE;
// 44C70E: using guessed type char byte_44C70E;
// 44C749: using guessed type char byte_44C749;
// 455C14: using guessed type char byte_455C14;
// 455C98: using guessed type int dword_455C98;

//----- (004270A0) --------------------------------------------------------
float __usercall sub_4270A0@<eax>()
{
  char v1; // [esp+0h] [ebp-B0h]
  int v2; // [esp+Ch] [ebp-A4h]
  float v3; // [esp+20h] [ebp-90h]
  int v4; // [esp+24h] [ebp-8Ch]
  int v5; // [esp+28h] [ebp-88h]

  v2 = *(_DWORD *)(dword_44EAA4 + 16);
  v3 = *(float *)(dword_44EAA4 + 36) - 256.0;
  v4 = *(_DWORD *)(dword_44EAA4 + 40);
  v5 = *(_DWORD *)(dword_44EAA4 + 44);
  sub_41F7E0((int)&v1);
  return sub_41F740((int)&v1);
}
// 44EAA4: using guessed type int dword_44EAA4;

//----- (004270F0) --------------------------------------------------------
char sub_4270F0()
{
  int v0; // ecx
  bool v1; // zf
  bool v2; // sf
  unsigned __int8 v3; // of
  char result; // al

  sub_401580(1);
  if ( byte_44D33D )
  {
    if ( byte_44C718 >= 18 )
    {
      sub_426DF0();
    }
    else
    {
      sub_426DF0();
      v3 = __OFSUB__(byte_44C718 + 8, 18);
      v1 = byte_44C718 == 10;
      v2 = (char)(byte_44C718 - 10) < 0;
      byte_44C718 += 8;
      if ( !((unsigned __int8)(v2 ^ v3) | v1) )
        byte_44C718 = 18;
    }
  }
  else if ( byte_44C718 <= 18 && byte_44C718 > -20 )
  {
    sub_426DF0();
    byte_44C718 -= 2;
  }
  if ( byte_44C749 )
  {
    if ( byte_44C70E >= 18 )
    {
      sub_426E10(v0);
    }
    else
    {
      sub_426E10(v0);
      v3 = __OFSUB__(byte_44C70E + 8, 18);
      v1 = byte_44C70E == 10;
      v2 = (char)(byte_44C70E - 10) < 0;
      byte_44C70E += 8;
      if ( !((unsigned __int8)(v2 ^ v3) | v1) )
        byte_44C70E = 18;
    }
  }
  else if ( byte_44C70E <= 18 && byte_44C70E > -20 )
  {
    sub_426E10(v0);
    byte_44C70E -= 2;
  }
  if ( byte_44C6F9 )
  {
    if ( (unsigned __int16)dword_44C720 <= 0x1C2u )
    {
      sub_424F80();
    }
    else
    {
      sub_424F80();
      LOWORD(dword_44C720) = dword_44C720 - 8;
      if ( (unsigned __int16)dword_44C720 < 0x1C2u )
        LOWORD(dword_44C720) = 450;
    }
  }
  else if ( (unsigned __int16)dword_44C720 >= 0x1C2u && (unsigned __int16)dword_44C720 < HIWORD(dword_443AE4) + 480 )
  {
    sub_424F80();
    LOWORD(dword_44C720) = dword_44C720 + 2;
  }
  sub_401580(1);
  result = 120;
  byte_443AF2 = 120;
  byte_443AF1 = 120;
  byte_443AF0 = 120;
  return result;
}
// 443AE4: using guessed type int dword_443AE4;
// 443AF0: using guessed type char byte_443AF0;
// 443AF1: using guessed type char byte_443AF1;
// 443AF2: using guessed type char byte_443AF2;
// 44C6F9: using guessed type char byte_44C6F9;
// 44C70E: using guessed type char byte_44C70E;
// 44C718: using guessed type char byte_44C718;
// 44C720: using guessed type int dword_44C720;
// 44C749: using guessed type char byte_44C749;
// 44D33D: using guessed type char byte_44D33D;

//----- (00428550) --------------------------------------------------------
int sub_428550()
{
  _DWORD *v0; // eax
  int v1; // esi
  _DWORD *v2; // ecx
  int result; // eax
  int v4; // ebp
  int v5; // [esp+10h] [ebp-4h]

  v0 = dword_443D2C;
  v1 = *((_DWORD *)dword_443D2C + 16032);
  *((_DWORD *)dword_443D2C + 16032) = v1 + 128;
  *(_DWORD *)(v1 + 4) = 0;
  *(_DWORD *)v1 = v0[30];
  v0[30] = v1;
  *(_DWORD *)(v1 + 20) = 1135345664;
  *(_DWORD *)(v1 + 48) = 1135345664;
  *(_DWORD *)(v1 + 76) = 1139749683;
  *(_DWORD *)(v1 + 104) = 1139749683;
  *(_DWORD *)(v1 + 28) = 1065353216;
  *(_DWORD *)(v1 + 56) = 1065353216;
  *(_DWORD *)(v1 + 84) = 1065353216;
  *(_DWORD *)(v1 + 112) = 1065353216;
  *(_BYTE *)(v1 + 34) = -1;
  *(_BYTE *)(v1 + 33) = -1;
  *(_BYTE *)(v1 + 32) = -1;
  *(_DWORD *)(v1 + 4) = 261;
  *(_DWORD *)(v1 + 16) = 1140129792;
  *(_DWORD *)(v1 + 44) = 1142849536;
  *(_DWORD *)(v1 + 72) = 1140129792;
  *(_DWORD *)(v1 + 100) = 1142849536;
  *(_DWORD *)(v1 + 24) = 0;
  *(_DWORD *)(v1 + 52) = 0;
  *(_DWORD *)(v1 + 80) = 0;
  *(_DWORD *)(v1 + 108) = 0;
  *(_DWORD *)(v1 + 36) = 0;
  *(_DWORD *)(v1 + 40) = 0;
  *(_DWORD *)(v1 + 64) = 1052688063;
  *(_DWORD *)(v1 + 68) = 0;
  *(_DWORD *)(v1 + 92) = 0;
  *(_DWORD *)(v1 + 96) = 1052688063;
  *(_DWORD *)(v1 + 120) = 1052688063;
  *(_DWORD *)(v1 + 124) = 1052688063;
  *(_DWORD *)(v1 + 8) = sub_401000(0, 2, 1216, 0);
  v5 = 0;
  do
  {
    v2 = dword_443D2C;
    result = *((_DWORD *)dword_443D2C + 16032);
    *((_DWORD *)dword_443D2C + 16032) = result + 88;
    *(_DWORD *)(result + 4) = 0;
    *(_DWORD *)result = v2[30];
    v4 = v5;
    v2[30] = result;
    *(_DWORD *)(result + 4) = 3;
    if ( *((_BYTE *)&dword_44B81A + v5) & 1 )
    {
      *(_BYTE *)(result + 26) = -1;
      *(_BYTE *)(result + 25) = 50;
    }
    else
    {
      *(_BYTE *)(result + 26) = 50;
      *(_BYTE *)(result + 25) = 0;
    }
    *(_BYTE *)(result + 24) = -1;
    *(_DWORD *)(result + 4) = 3;
    switch ( v5 )
    {
      case 0:
        *(_DWORD *)(result + 12) = 1138556928;
        *(_DWORD *)(result + 8) = 1141350400;
        *(_DWORD *)(result + 48) = 1141350400;
        *(_DWORD *)(result + 28) = 1141719040;
        *(_DWORD *)(result + 32) = 1138491392;
        *(_DWORD *)(result + 52) = 1139146752;
        *(_DWORD *)(result + 68) = 1141719040;
        *(_DWORD *)(result + 72) = 1139146752;
        break;
      case 1:
        *(_DWORD *)(result + 8) = 1141719040;
        *(_DWORD *)(result + 12) = 1138589696;
        *(_DWORD *)(result + 32) = 1138589696;
        *(_DWORD *)(result + 28) = 1142112256;
        *(_DWORD *)(result + 48) = 1141719040;
        *(_DWORD *)(result + 52) = 1139113984;
        *(_DWORD *)(result + 68) = 1142087680;
        *(_DWORD *)(result + 72) = 1139113984;
        break;
      case 2:
        *(_DWORD *)(result + 8) = 1141719040;
        *(_DWORD *)(result + 12) = 1139146752;
        *(_DWORD *)(result + 28) = 1142087680;
        *(_DWORD *)(result + 32) = 1139146752;
        *(_DWORD *)(result + 48) = 1141719040;
        *(_DWORD *)(result + 52) = 1139703808;
        *(_DWORD *)(result + 68) = 1142063104;
        *(_DWORD *)(result + 72) = 1139572736;
        break;
      case 3:
        *(_DWORD *)(result + 8) = 1141129216;
        *(_DWORD *)(result + 12) = 1139146752;
        *(_DWORD *)(result + 28) = 1141719040;
        *(_DWORD *)(result + 32) = 1139146752;
        *(_DWORD *)(result + 48) = 1141350400;
        *(_DWORD *)(result + 52) = 1139539968;
        *(_DWORD *)(result + 68) = 1141719040;
        *(_DWORD *)(result + 72) = 1139671040;
        break;
      case 4:
        *(_DWORD *)(result + 8) = 1142136832;
        *(_DWORD *)(result + 12) = 1138393088;
        *(_DWORD *)(result + 32) = 1138393088;
        *(_DWORD *)(result + 28) = 1142456320;
        *(_DWORD *)(result + 48) = 1142063104;
        *(_DWORD *)(result + 52) = 1139113984;
        *(_DWORD *)(result + 68) = 1142382592;
        *(_DWORD *)(result + 72) = 1139113984;
        break;
      case 5:
        *(_DWORD *)(result + 12) = 1137311744;
        *(_DWORD *)(result + 8) = 1141596160;
        *(_DWORD *)(result + 28) = 1142210560;
        *(_DWORD *)(result + 32) = 1137311744;
        *(_DWORD *)(result + 48) = 1141596160;
        *(_DWORD *)(result + 52) = 1137901568;
        *(_DWORD *)(result + 68) = 1142185984;
        *(_DWORD *)(result + 72) = 1137901568;
        break;
      case 6:
        *(_DWORD *)(result + 12) = 1137967104;
        *(_DWORD *)(result + 8) = 1141350400;
        *(_DWORD *)(result + 48) = 1141350400;
        *(_DWORD *)(result + 28) = 1141817344;
        *(_DWORD *)(result + 32) = 1137901568;
        *(_DWORD *)(result + 52) = 1138556928;
        *(_DWORD *)(result + 68) = 1141719040;
        *(_DWORD *)(result + 72) = 1138556928;
        break;
      case 7:
        *(_DWORD *)(result + 8) = 1141792768;
        *(_DWORD *)(result + 12) = 1137901568;
        *(_DWORD *)(result + 28) = 1142210560;
        *(_DWORD *)(result + 32) = 1137901568;
        *(_DWORD *)(result + 48) = 1141719040;
        *(_DWORD *)(result + 52) = 1138556928;
        *(_DWORD *)(result + 68) = 1142136832;
        *(_DWORD *)(result + 72) = 1138589696;
        break;
      case 8:
        *(_DWORD *)(result + 12) = 1136590848;
        *(_DWORD *)(result + 8) = 1141374976;
        *(_DWORD *)(result + 28) = 1141547008;
        *(_DWORD *)(result + 32) = 1136512205;
        *(_DWORD *)(result + 48) = 1141374976;
        *(_DWORD *)(result + 52) = 1137901568;
        *(_DWORD *)(result + 68) = 1141620736;
        *(_DWORD *)(result + 72) = 1137901568;
        break;
      case 9:
        *(_DWORD *)(result + 8) = 1141547008;
        *(_DWORD *)(result + 12) = 1136512205;
        *(_DWORD *)(result + 28) = 1141817344;
        *(_DWORD *)(result + 32) = 1136479437;
        *(_DWORD *)(result + 48) = 1141571584;
        *(_DWORD *)(result + 52) = 1137311744;
        *(_DWORD *)(result + 68) = 1141817344;
        *(_DWORD *)(result + 72) = 1137311744;
        break;
      case 10:
        *(_DWORD *)(result + 12) = 1136479437;
        *(_DWORD *)(result + 8) = 1141817344;
        *(_DWORD *)(result + 28) = 1142259712;
        *(_DWORD *)(result + 32) = 1136420454;
        *(_DWORD *)(result + 48) = 1141817344;
        *(_DWORD *)(result + 52) = 1137311744;
        *(_DWORD *)(result + 68) = 1142210560;
        *(_DWORD *)(result + 72) = 1137311744;
        break;
      case 11:
        *(_DWORD *)(result + 8) = 1141497856;
        *(_DWORD *)(result + 12) = 1135948595;
        *(_DWORD *)(result + 28) = 1142063104;
        *(_DWORD *)(result + 32) = 1135948595;
        *(_DWORD *)(result + 48) = 1141374976;
        *(_DWORD *)(result + 52) = 1136544973;
        *(_DWORD *)(result + 68) = 1142333440;
        *(_DWORD *)(result + 72) = 1136479437;
        break;
      default:
        *(_DWORD *)(result + 8) = 0;
        *(_DWORD *)(result + 12) = 0;
        *(_DWORD *)(result + 28) = 0;
        *(_DWORD *)(result + 32) = 0;
        *(_DWORD *)(result + 48) = 0;
        *(_DWORD *)(result + 52) = 0;
        *(_DWORD *)(result + 68) = 0;
        *(_DWORD *)(result + 72) = 0;
        break;
    }
    ++v5;
  }
  while ( (unsigned int)(v4 + 1) < 0xC );
  return result;
}
// 44B81A: using guessed type int dword_44B81A;

//----- (00428920) --------------------------------------------------------
int __usercall sub_428920@<eax>(int a1@<edi>, int a2, unsigned __int16 a3, unsigned __int16 a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8)
{
  int v8; // edi
  int v9; // ebp
  int v10; // esi
  int v11; // edi
  int result; // eax
  unsigned __int16 v13; // di
  int v14; // [esp+18h] [ebp+8h]

  LOWORD(a1) = a4 >> 3;
  v8 = a1 + 2;
  if ( a6 >= 0xAu )
  {
    if ( a6 >= 0x3Cu )
      goto LABEL_6;
    sub_401870((unsigned __int16)a2, a3, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 0, a6 / 10);
    sub_401D10();
    sub_401870(
      (unsigned __int16)a2 + (unsigned __int16)v8,
      a3,
      (unsigned __int16)dword_443AE4,
      HIWORD(dword_443AE4),
      0,
      a6 % 10);
  }
  else
  {
    sub_401870(
      (unsigned __int16)a2 + (unsigned __int16)v8,
      a3,
      (unsigned __int16)dword_443AE4,
      HIWORD(dword_443AE4),
      0,
      a6);
  }
  sub_401D10();
LABEL_6:
  v9 = (unsigned __int16)v8;
  v10 = a3;
  sub_4015D0(
    2 * (unsigned __int16)v8 + (unsigned __int16)a2,
    a3,
    (unsigned __int16)dword_443AE4,
    HIWORD(dword_443AE4),
    0,
    0x5Bu);
  sub_401D10();
  v14 = 3 * v8;
  v11 = a2 + 3 * v8;
  if ( a7 >= 0xAu )
  {
    if ( a7 >= 0x3Cu )
      goto LABEL_11;
    sub_401870((unsigned __int16)v11, v10, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 0, a7 / 10);
    sub_401D10();
    sub_401870((unsigned __int16)v11 + v9, v10, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 0, a7 % 10);
  }
  else
  {
    sub_401870((unsigned __int16)v11, v10, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 0, 0);
    sub_401D10();
    sub_401870((unsigned __int16)v11 + v9, v10, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 0, a7);
  }
  sub_401D10();
LABEL_11:
  sub_4015D0(2 * v9 + (unsigned __int16)v11, v10, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 0, 0x5Cu);
  result = sub_401D10();
  v13 = v14 + v11;
  if ( a8 >= 0xAu )
  {
    if ( a8 >= 0x64u )
      return result;
    sub_401870(v13, v10, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 0, a8 / 10);
    sub_401D10();
    sub_401870(v13 + v9, v10, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 0, a8 % 10);
  }
  else
  {
    sub_401870(v13, v10, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 0, 0);
    sub_401D10();
    sub_401870(v13 + v9, v10, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 0, a8);
  }
  return sub_401D10();
}
// 443AE4: using guessed type int dword_443AE4;

//----- (00428C70) --------------------------------------------------------
int __cdecl sub_428C70(__int16 a1, unsigned __int16 a2, unsigned __int8 a3, unsigned __int8 a4, __int16 a5, unsigned __int8 a6, char a7)
{
  int v7; // ebp
  int v8; // edi
  _DWORD *v9; // eax
  int v10; // esi
  unsigned int v11; // ebp
  double v12; // st7
  double v13; // st6
  double v14; // st7
  int v15; // eax
  _DWORD *v16; // eax
  int v17; // esi
  double v18; // st7
  double v19; // st6
  double v20; // st7
  unsigned __int16 v21; // cx
  unsigned __int8 v22; // ST14_1
  unsigned __int8 v23; // ST10_1
  int v25; // [esp-10h] [ebp-1Ch]
  int v26; // [esp+10h] [ebp+4h]
  float v27; // [esp+14h] [ebp+8h]
  float v28; // [esp+24h] [ebp+18h]

  v7 = (signed __int64)((double)a1 + dword_44B7E4);
  v26 = (signed __int64)((double)a1 + dword_44B7E4);
  v8 = (signed __int64)(flt_44B7E8 - (double)a2);
  if ( !a7 )
    goto LABEL_24;
  v9 = dword_443D2C;
  v10 = *((_DWORD *)dword_443D2C + 16032);
  *((_DWORD *)dword_443D2C + 16032) = v10 + 128;
  *(_DWORD *)(v10 + 4) = 0;
  v11 = ((unsigned int)a3 >> 1) + v7;
  *(_DWORD *)v10 = v9[30];
  v9[30] = v10;
  v12 = (double)(v11 - 20);
  *(_BYTE *)(v10 + 34) = -16;
  *(_BYTE *)(v10 + 33) = -16;
  *(float *)(v10 + 16) = v12;
  v13 = (double)(unsigned int)(v8 - 11);
  *(_BYTE *)(v10 + 32) = -16;
  *(_DWORD *)(v10 + 4) = 5;
  *(float *)(v10 + 20) = v13;
  *(_DWORD *)(v10 + 28) = 1065353216;
  v27 = (double)(v11 + 34);
  *(float *)(v10 + 44) = v27;
  *(_DWORD *)(v10 + 56) = 1065353216;
  *(float *)(v10 + 48) = v13;
  *(_DWORD *)(v10 + 84) = 1065353216;
  *(_DWORD *)(v10 + 112) = 1065353216;
  *(float *)(v10 + 72) = v12;
  v14 = (double)(unsigned int)(v8 + 13);
  *(float *)(v10 + 100) = v27;
  *(_DWORD *)(v10 + 24) = 0;
  *(float *)(v10 + 76) = v14;
  *(float *)(v10 + 104) = v14;
  *(_DWORD *)(v10 + 52) = 0;
  *(_DWORD *)(v10 + 80) = 0;
  *(_DWORD *)(v10 + 108) = 0;
  switch ( a5 )
  {
    case 0:
      *(_DWORD *)(v10 + 36) = 0;
      *(_DWORD *)(v10 + 40) = 1045746901;
      *(_DWORD *)(v10 + 64) = 1046273245;
      *(_DWORD *)(v10 + 68) = 1045746901;
      *(_DWORD *)(v10 + 92) = 0;
      *(_DWORD *)(v10 + 96) = 1050845859;
      *(_DWORD *)(v10 + 120) = 1046273245;
      *(_DWORD *)(v10 + 124) = 1050845859;
      v15 = sub_401000(0, 0, 1152, 53);
      goto LABEL_16;
    case 1:
      *(_DWORD *)(v10 + 40) = 1045746901;
      *(_DWORD *)(v10 + 68) = 1045746901;
      *(_DWORD *)(v10 + 36) = 1046536417;
      *(_DWORD *)(v10 + 64) = 1054793439;
      *(_DWORD *)(v10 + 92) = 1046536417;
      *(_DWORD *)(v10 + 96) = 1050845859;
      *(_DWORD *)(v10 + 120) = 1054793439;
      *(_DWORD *)(v10 + 124) = 1050845859;
      v15 = sub_401000(0, 0, 1166, 53);
      goto LABEL_16;
    case 2:
      *(_DWORD *)(v10 + 36) = 1054925025;
      *(_DWORD *)(v10 + 92) = 1054925025;
      *(_DWORD *)(v10 + 40) = 1045746901;
      *(_DWORD *)(v10 + 64) = 1059563432;
      *(_DWORD *)(v10 + 68) = 1045746901;
      *(_DWORD *)(v10 + 96) = 1050845859;
      *(_DWORD *)(v10 + 120) = 1059563432;
      *(_DWORD *)(v10 + 124) = 1050845859;
      v25 = 53;
      goto LABEL_15;
    case 3:
      *(_DWORD *)(v10 + 36) = 0;
      *(_DWORD *)(v10 + 40) = 1050977445;
      *(_DWORD *)(v10 + 64) = 1046273245;
      *(_DWORD *)(v10 + 68) = 1050977445;
      *(_DWORD *)(v10 + 92) = 0;
      *(_DWORD *)(v10 + 96) = 1054661853;
      *(_DWORD *)(v10 + 120) = 1046273245;
      *(_DWORD *)(v10 + 124) = 1054661853;
      v15 = sub_401000(0, 0, 1152, 82);
      goto LABEL_16;
    case 4:
      *(_DWORD *)(v10 + 40) = 1050977445;
      *(_DWORD *)(v10 + 68) = 1050977445;
      *(_DWORD *)(v10 + 36) = 1046536417;
      *(_DWORD *)(v10 + 64) = 1054793439;
      *(_DWORD *)(v10 + 92) = 1046536417;
      *(_DWORD *)(v10 + 96) = 1054661853;
      *(_DWORD *)(v10 + 120) = 1054793439;
      *(_DWORD *)(v10 + 124) = 1054661853;
      v15 = sub_401000(0, 0, 1166, 82);
      goto LABEL_16;
    case 5:
      *(_DWORD *)(v10 + 36) = 1054925025;
      *(_DWORD *)(v10 + 92) = 1054925025;
      *(_DWORD *)(v10 + 40) = 1050977445;
      *(_DWORD *)(v10 + 64) = 1059563432;
      *(_DWORD *)(v10 + 68) = 1050977445;
      *(_DWORD *)(v10 + 96) = 1054661853;
      *(_DWORD *)(v10 + 120) = 1059563432;
      *(_DWORD *)(v10 + 124) = 1054661853;
      v25 = 82;
      goto LABEL_15;
    case 6:
      *(_DWORD *)(v10 + 36) = 0;
      *(_DWORD *)(v10 + 40) = 1054793439;
      *(_DWORD *)(v10 + 64) = 1046273245;
      *(_DWORD *)(v10 + 68) = 1054793439;
      *(_DWORD *)(v10 + 92) = 0;
      *(_DWORD *)(v10 + 96) = 1057721228;
      *(_DWORD *)(v10 + 120) = 1046273245;
      *(_DWORD *)(v10 + 124) = 1057721228;
      v15 = sub_401000(0, 0, 1152, 111);
      goto LABEL_16;
    case 7:
      *(_DWORD *)(v10 + 36) = 1046536417;
      *(_DWORD *)(v10 + 40) = 1054793439;
      *(_DWORD *)(v10 + 64) = 1054793439;
      *(_DWORD *)(v10 + 68) = 1054793439;
      *(_DWORD *)(v10 + 92) = 1046536417;
      *(_DWORD *)(v10 + 96) = 1057721228;
      *(_DWORD *)(v10 + 120) = 1054793439;
      *(_DWORD *)(v10 + 124) = 1057721228;
      v15 = sub_401000(0, 0, 1166, 111);
      goto LABEL_16;
    case 8:
      *(_DWORD *)(v10 + 36) = 1054925025;
      *(_DWORD *)(v10 + 92) = 1054925025;
      *(_DWORD *)(v10 + 40) = 1054793439;
      *(_DWORD *)(v10 + 64) = 1059563432;
      *(_DWORD *)(v10 + 68) = 1054793439;
      *(_DWORD *)(v10 + 96) = 1057721228;
      *(_DWORD *)(v10 + 120) = 1059563432;
      *(_DWORD *)(v10 + 124) = 1057721228;
      v25 = 111;
      goto LABEL_15;
    case 9:
      *(_DWORD *)(v10 + 36) = 0;
      *(_DWORD *)(v10 + 40) = 1057787021;
      *(_DWORD *)(v10 + 64) = 1046273245;
      *(_DWORD *)(v10 + 68) = 1057787021;
      *(_DWORD *)(v10 + 92) = 0;
      *(_DWORD *)(v10 + 96) = 1059629225;
      *(_DWORD *)(v10 + 120) = 1046273245;
      *(_DWORD *)(v10 + 124) = 1059629225;
      v15 = sub_401000(0, 0, 1152, 140);
      goto LABEL_16;
    case 0xA:
      *(_DWORD *)(v10 + 40) = 1057787021;
      *(_DWORD *)(v10 + 68) = 1057787021;
      *(_DWORD *)(v10 + 36) = 1046536417;
      *(_DWORD *)(v10 + 64) = 1054793439;
      *(_DWORD *)(v10 + 92) = 1046536417;
      *(_DWORD *)(v10 + 96) = 1059629225;
      *(_DWORD *)(v10 + 120) = 1054793439;
      *(_DWORD *)(v10 + 124) = 1059629225;
      v15 = sub_401000(0, 0, 1166, 140);
      goto LABEL_16;
    case 0xB:
      *(_DWORD *)(v10 + 36) = 1054925025;
      *(_DWORD *)(v10 + 92) = 1054925025;
      *(_DWORD *)(v10 + 40) = 1057787021;
      *(_DWORD *)(v10 + 64) = 1059563432;
      *(_DWORD *)(v10 + 68) = 1057787021;
      *(_DWORD *)(v10 + 96) = 1059629225;
      *(_DWORD *)(v10 + 120) = 1059563432;
      *(_DWORD *)(v10 + 124) = 1059629225;
      v25 = 140;
LABEL_15:
      v15 = sub_401000(0, 0, 1180, v25);
LABEL_16:
      *(_DWORD *)(v10 + 8) = v15;
      break;
    default:
      break;
  }
  if ( a6 >= 0xAu )
  {
    if ( a6 >= 0x64u )
      goto LABEL_22;
    sub_401580(2);
    byte_443AF2 = 64;
    byte_443AF1 = 127;
    byte_443AF0 = 82;
    sub_401870(v11 - 48, v8 + 12, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, a6);
  }
  else
  {
    sub_401580(2);
    byte_443AF2 = 64;
    byte_443AF1 = 127;
    byte_443AF0 = 82;
    sub_401AB0(v11 - 40, v8 + 12, 1, aDD);
  }
  sub_401D10();
LABEL_22:
  v16 = dword_443D2C;
  v17 = *((_DWORD *)dword_443D2C + 16032);
  v18 = (double)v11;
  *((_DWORD *)dword_443D2C + 16032) = v17 + 128;
  *(_DWORD *)(v17 + 4) = 0;
  *(_DWORD *)v17 = v16[30];
  v16[30] = v17;
  *(float *)(v17 + 16) = v18;
  v19 = (double)(unsigned int)(v8 + 15);
  *(_DWORD *)(v17 + 28) = 1065353216;
  *(_DWORD *)(v17 + 56) = 1065353216;
  *(float *)(v17 + 20) = v19;
  *(_DWORD *)(v17 + 84) = 1065353216;
  *(_DWORD *)(v17 + 112) = 1065353216;
  v28 = (double)(v11 + 48);
  *(float *)(v17 + 44) = v28;
  *(float *)(v17 + 48) = v19;
  *(float *)(v17 + 100) = v28;
  *(_DWORD *)(v17 + 40) = 1062918875;
  *(float *)(v17 + 72) = v18;
  v20 = (double)(unsigned int)(v8 + 39);
  *(_DWORD *)(v17 + 68) = 1062918875;
  *(float *)(v17 + 76) = v20;
  *(float *)(v17 + 104) = v20;
  *(_BYTE *)(v17 + 34) = -16;
  *(_BYTE *)(v17 + 33) = -16;
  *(_BYTE *)(v17 + 32) = -16;
  *(_DWORD *)(v17 + 4) = 5;
  *(_DWORD *)(v17 + 24) = 0;
  *(_DWORD *)(v17 + 52) = 0;
  *(_DWORD *)(v17 + 80) = 0;
  *(_DWORD *)(v17 + 108) = 0;
  *(_DWORD *)(v17 + 36) = 1044431041;
  *(_DWORD *)(v17 + 64) = 1051109031;
  *(_DWORD *)(v17 + 92) = 1044431041;
  *(_DWORD *)(v17 + 96) = 1064037356;
  *(_DWORD *)(v17 + 120) = 1051109031;
  *(_DWORD *)(v17 + 124) = 1064037356;
  *(_DWORD *)(v17 + 8) = sub_401000(0, 0, 1164, 218);
  if ( dword_455BFC != 11 )
  {
    sub_401580(2);
    byte_443AF2 = 64;
    v21 = word_44B9DC[dword_455BFC];
    byte_443AF1 = 127;
    v22 = byte_44B9CC[dword_455BFC];
    v23 = byte_44B9BC[dword_455BFC];
    byte_443AF0 = 82;
    sub_428920(
      v8,
      v26 - 18,
      v8 + 40,
      0x60u,
      16,
      v23,
      v22,
      ((signed int)(1717986919 * (unsigned __int64)v21 >> 32) >> 2 < 0)
    + ((signed int)(1717986919 * (unsigned __int64)v21 >> 32) >> 2));
  }
LABEL_24:
  sub_401580(1);
  return sub_40CFF0(v26, v8, a3, a4, byte_44D376, a7, byte_44D3C0);
}
// 443AE4: using guessed type int dword_443AE4;
// 443AF0: using guessed type char byte_443AF0;
// 443AF1: using guessed type char byte_443AF1;
// 443AF2: using guessed type char byte_443AF2;
// 44B7E8: using guessed type float flt_44B7E8;
// 44D376: using guessed type char byte_44D376;
// 44D3C0: using guessed type char byte_44D3C0;
// 455BFC: using guessed type int dword_455BFC;

//----- (00429280) --------------------------------------------------------
int __cdecl sub_429280(__int16 a1, unsigned __int16 a2, unsigned __int8 a3, unsigned __int8 a4, char a5)
{
  int v5; // ebp
  unsigned int v6; // edi
  _DWORD *v7; // eax
  int v8; // esi
  double v9; // st7
  double v10; // st6
  double v11; // st7
  _DWORD *v12; // eax
  int v13; // esi
  double v14; // st7
  double v15; // st6
  double v16; // st7
  int v18; // [esp+10h] [ebp+4h]
  float v19; // [esp+14h] [ebp+8h]
  unsigned __int8 v20; // [esp+14h] [ebp+8h]
  float v21; // [esp+14h] [ebp+8h]

  v5 = (signed __int64)((double)a1 + dword_44B7E4);
  v6 = (signed __int64)(flt_44B7E8 - (double)a2);
  v18 = (signed __int64)(flt_44B7E8 - (double)a2);
  if ( a5 )
  {
    v7 = dword_443D2C;
    v8 = *((_DWORD *)dword_443D2C + 16032);
    *((_DWORD *)dword_443D2C + 16032) = v8 + 128;
    *(_DWORD *)(v8 + 4) = 0;
    *(_DWORD *)v8 = v7[30];
    v9 = (double)(unsigned int)(v5 - 25);
    v7[30] = v8;
    *(float *)(v8 + 16) = v9;
    v10 = (double)(v6 - 2);
    *(float *)(v8 + 20) = v10;
    *(_BYTE *)(v8 + 34) = -1;
    v19 = (double)(unsigned int)(v5 + 7);
    *(float *)(v8 + 44) = v19;
    *(_DWORD *)(v8 + 28) = 1065353216;
    *(float *)(v8 + 48) = v10;
    *(_DWORD *)(v8 + 56) = 1065353216;
    *(_DWORD *)(v8 + 84) = 1065353216;
    *(float *)(v8 + 72) = v9;
    *(_DWORD *)(v8 + 112) = 1065353216;
    *(_DWORD *)(v8 + 40) = 1060945085;
    *(_DWORD *)(v8 + 68) = 1060945085;
    v11 = v10 + 38.4;
    *(float *)(v8 + 76) = v11;
    *(_BYTE *)(v8 + 33) = -1;
    *(float *)(v8 + 104) = v11;
    *(_BYTE *)(v8 + 32) = -1;
    *(_DWORD *)(v8 + 4) = 5;
    *(float *)(v8 + 100) = v19;
    *(_DWORD *)(v8 + 24) = 0;
    *(_DWORD *)(v8 + 52) = 0;
    *(_DWORD *)(v8 + 80) = 0;
    *(_DWORD *)(v8 + 108) = 0;
    *(_DWORD *)(v8 + 36) = 0;
    *(_DWORD *)(v8 + 64) = 1040220289;
    *(_DWORD *)(v8 + 92) = 0;
    *(_DWORD *)(v8 + 96) = 1063050461;
    *(_DWORD *)(v8 + 120) = 1040220289;
    *(_DWORD *)(v8 + 124) = 1063050461;
    *(_DWORD *)(v8 + 8) = sub_401000(0, 0, 896, 444);
    if ( (unsigned __int16)word_44B7F8 >= 0x64u )
      v20 = (unsigned __int16)word_44B7F8 < 0x3E8u;
    else
      v20 = 2;
    sub_401580(2);
    v6 = (unsigned int)a3 >> 1;
    byte_443AF2 = 64;
    byte_443AF1 = 127;
    byte_443AF0 = 82;
    sub_401870(
      v6 + (unsigned __int16)dword_443AE4 * (v20 - 1) + v5 - 10,
      v18 + 2,
      (unsigned __int16)dword_443AE4,
      HIWORD(dword_443AE4),
      1,
      word_44B7F8);
    sub_401D10();
    v12 = dword_443D2C;
    v13 = *((_DWORD *)dword_443D2C + 16032);
    *((_DWORD *)dword_443D2C + 16032) = v13 + 128;
    *(_DWORD *)(v13 + 4) = 0;
    *(_DWORD *)v13 = v12[30];
    v12[30] = v13;
    v14 = (double)(v6 + v5 - 10);
    *(float *)(v13 + 16) = v14;
    v15 = (double)(unsigned int)(v18 + 35);
    *(_BYTE *)(v13 + 34) = -1;
    *(float *)(v13 + 20) = v15;
    *(_BYTE *)(v13 + 33) = -1;
    *(_BYTE *)(v13 + 32) = -1;
    v21 = (double)(v6 + v5 + 45);
    *(float *)(v13 + 44) = v21;
    *(_DWORD *)(v13 + 4) = 5;
    *(float *)(v13 + 48) = v15;
    *(float *)(v13 + 100) = v21;
    *(float *)(v13 + 72) = v14;
    v16 = (double)(unsigned int)(v18 + 87);
    *(_DWORD *)(v13 + 28) = 1065353216;
    *(_DWORD *)(v13 + 56) = 1065353216;
    *(_DWORD *)(v13 + 84) = 1065353216;
    *(_DWORD *)(v13 + 112) = 1065353216;
    *(float *)(v13 + 76) = v16;
    *(float *)(v13 + 104) = v16;
    *(_DWORD *)(v13 + 24) = 0;
    *(_DWORD *)(v13 + 52) = 0;
    *(_DWORD *)(v13 + 80) = 0;
    *(_DWORD *)(v13 + 108) = 0;
    *(_DWORD *)(v13 + 36) = 1046536417;
    *(_DWORD *)(v13 + 40) = 1052819649;
    *(_DWORD *)(v13 + 68) = 1052819649;
    *(_DWORD *)(v13 + 64) = 1054925025;
    *(_DWORD *)(v13 + 92) = 1046536417;
    *(_DWORD *)(v13 + 96) = 1058379158;
    *(_DWORD *)(v13 + 120) = 1054925025;
    *(_DWORD *)(v13 + 124) = 1058379158;
    LOWORD(v6) = v18;
    *(_DWORD *)(v13 + 8) = sub_401000(0, 0, 1230, 96);
  }
  sub_401580(1);
  return sub_40CFF0(v5, v6, a3, a4, byte_44D376, a5, byte_44D3C0);
}
// 443AE4: using guessed type int dword_443AE4;
// 443AF0: using guessed type char byte_443AF0;
// 443AF1: using guessed type char byte_443AF1;
// 443AF2: using guessed type char byte_443AF2;
// 44B7E8: using guessed type float flt_44B7E8;
// 44B7F8: using guessed type __int16 word_44B7F8;
// 44D376: using guessed type char byte_44D376;
// 44D3C0: using guessed type char byte_44D3C0;

//----- (00429580) --------------------------------------------------------
int __cdecl sub_429580(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3)
{
  _DWORD *v3; // eax
  int v4; // esi
  int v5; // ebp
  double v6; // st7
  double v7; // st6
  double v8; // st7
  float v10; // [esp+14h] [ebp+4h]

  v3 = dword_443D2C;
  v4 = *((_DWORD *)dword_443D2C + 16032);
  v5 = a1;
  *((_DWORD *)dword_443D2C + 16032) = v4 + 128;
  *(_DWORD *)(v4 + 4) = 0;
  v6 = (double)a1;
  *(_DWORD *)v4 = v3[30];
  v3[30] = v4;
  *(float *)(v4 + 16) = v6;
  v7 = (double)(a2 - 4);
  *(_DWORD *)(v4 + 28) = 1065353216;
  *(_DWORD *)(v4 + 56) = 1065353216;
  *(_DWORD *)(v4 + 84) = 1065353216;
  *(_DWORD *)(v4 + 112) = 1065353216;
  *(float *)(v4 + 20) = v7;
  *(_DWORD *)(v4 + 36) = 1061997773;
  *(_DWORD *)(v4 + 92) = 1061997773;
  v10 = v6 + 39.6;
  *(float *)(v4 + 44) = v10;
  *(_BYTE *)(v4 + 34) = -1;
  *(float *)(v4 + 48) = v7;
  *(float *)(v4 + 100) = v10;
  *(float *)(v4 + 72) = v6;
  *(_BYTE *)(v4 + 33) = -1;
  *(_BYTE *)(v4 + 32) = -1;
  *(_DWORD *)(v4 + 4) = 5;
  *(_DWORD *)(v4 + 24) = 0;
  v8 = v7 + 47.3;
  *(float *)(v4 + 76) = v8;
  *(_DWORD *)(v4 + 52) = 0;
  *(_DWORD *)(v4 + 80) = 0;
  *(float *)(v4 + 104) = v8;
  *(_DWORD *)(v4 + 108) = 0;
  *(_DWORD *)(v4 + 40) = 0;
  *(_DWORD *)(v4 + 64) = 1064366321;
  *(_DWORD *)(v4 + 68) = 0;
  *(_DWORD *)(v4 + 96) = 1043115181;
  *(_DWORD *)(v4 + 120) = 1064366321;
  *(_DWORD *)(v4 + 124) = 1043115181;
  *(_DWORD *)(v4 + 8) = sub_401000(0, 1, 1203, 0);
  sub_401580(0);
  byte_443AF2 = -1;
  byte_443AF1 = -1;
  byte_443AF0 = -1;
  sub_4015D0(v5 + 56, a2 + 9, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0xDFu);
  sub_401D10();
  sub_401580(1);
  byte_443AF2 = -1;
  byte_443AF1 = -1;
  byte_443AF0 = -1;
  if ( (unsigned __int16)word_44B7FE > 0x270Fu )
    word_44B7FE = 9999;
  sub_401870(v5 + 78, a2 + 8, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, a3);
  sub_401D10();
  sub_401580(2);
  byte_443AF2 = -106;
  byte_443AF1 = -106;
  byte_443AF0 = -106;
  sub_401870(v5 + 80, a2 + 10, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, a3);
  sub_401D10();
  return sub_401580(1);
}
// 443AE4: using guessed type int dword_443AE4;
// 443AF0: using guessed type char byte_443AF0;
// 443AF1: using guessed type char byte_443AF1;
// 443AF2: using guessed type char byte_443AF2;
// 44B7FE: using guessed type __int16 word_44B7FE;

//----- (00429770) --------------------------------------------------------
int sub_429770()
{
  double v0; // st7
  double v1; // st6
  double v3; // st5
  char v4; // c0
  double v5; // st6
  double v7; // st5
  char v8; // c0
  char v9; // al
  _DWORD *v10; // eax
  int v11; // esi
  float v12; // ST3C_4
  float v13; // ST38_4
  _DWORD *v14; // eax
  int v15; // esi
  unsigned __int16 v17; // [esp+0h] [ebp-10h]

  if ( byte_44B7FA )
  {
    if ( word_44B7FC )
    {
      dword_44D3B0 = 1139802112;
      dword_44D3B4 = 1095761920;
      word_44BAB0 = word_44B7FE;
      word_44BAB2 = word_44B7FC;
      word_44B7FC = 0;
      HIWORD(dword_44D384) = 0;
      flt_44D3A8 = (dword_44B7E4 - 60.0 - 480.0) * 0.050000001;
      flt_44D3AC = (flt_44B7E8 - 70.0 - 13.0) * 0.050000001;
      sub_41BB60(3);
      v17 = word_44BAB2;
    }
    else
    {
      v0 = dword_44B7E4 - 60.0;
      v1 = v0 - *(float *)&dword_44D3B0;
      if ( v1 < 0.0 )
        v1 = -v1;
      v3 = flt_44D3A8;
      if ( v4 )
        v3 = -v3;
      if ( v1 <= v3 )
        goto LABEL_38;
      v5 = flt_44B7E8 - 70.0 - *(float *)&dword_44D3B4;
      if ( v5 < 0.0 )
        v5 = -v5;
      v7 = flt_44D3AC;
      if ( v8 )
        v7 = -v7;
      if ( v5 <= v7 )
      {
LABEL_38:
        *(float *)&dword_44D3B0 = v0;
        byte_44B7FA = 0;
        *(float *)&dword_44D3B4 = flt_44B7E8 - 70.0;
        word_44B7FE = word_44BAB0 - word_44BAB2;
        sub_407E00((int)&unk_4448CC);
        v17 = word_44BAB2;
      }
      else
      {
        byte_44BAB4 = 25;
        *(float *)&dword_44D3B0 = flt_44D3A8 + *(float *)&dword_44D3B0;
        *(float *)&dword_44D3B4 = flt_44D3AC + *(float *)&dword_44D3B4;
        word_44B7FE += (unsigned __int16)word_44BAB2 / -20;
        switch ( HIWORD(dword_44D384) )
        {
          case 0u:
          case 0xCu:
            sub_407E00((int)&unk_444878);
            ++HIWORD(dword_44D384);
            v17 = word_44BAB2;
            break;
          case 2u:
          case 0xAu:
          case 0x13u:
            sub_407E00((int)&unk_444884);
            goto LABEL_18;
          case 6u:
          case 0xFu:
            sub_407E00((int)&unk_444890);
            ++HIWORD(dword_44D384);
            v17 = word_44BAB2;
            break;
          default:
LABEL_18:
            ++HIWORD(dword_44D384);
            v17 = word_44BAB2;
            break;
        }
      }
    }
  }
  else
  {
    if ( !byte_44BAB4 )
      goto LABEL_29;
    v9 = byte_44BAB4 - 1;
    byte_44BAB4 = v9;
    if ( v9 == 1 )
    {
      v10 = sub_40B8D0();
      v11 = (int)v10;
      if ( v10 )
      {
        sub_40CAD0((int)v10);
        v12 = dword_44B744 - 700.0;
        v13 = dword_44B740 - 400.0;
        sub_40B920(v11, dword_44B73C, v13, v12);
      }
      sub_407E00((int)&unk_4448FC);
    }
    else if ( !v9 )
    {
      sub_41BB60(0);
    }
    v17 = word_44BAB2;
  }
  sub_429580((signed __int64)*(float *)&dword_44D3B0, (signed __int64)*(float *)&dword_44D3B4, v17);
LABEL_29:
  sub_426970(18);
  sub_429580(0x1E0u, 0xDu, word_44B7FE);
  v14 = dword_443D2C;
  v15 = *((_DWORD *)dword_443D2C + 16032);
  *((_DWORD *)dword_443D2C + 16032) = v15 + 128;
  *(_DWORD *)(v15 + 4) = 0;
  *(_DWORD *)v15 = v14[30];
  v14[30] = v15;
  *(_DWORD *)(v15 + 44) = 1137704960;
  *(_DWORD *)(v15 + 20) = 1138819072;
  *(_DWORD *)(v15 + 48) = 1138819072;
  *(_DWORD *)(v15 + 100) = 1137704960;
  *(_DWORD *)(v15 + 76) = 1139605504;
  *(_DWORD *)(v15 + 104) = 1139605504;
  *(_DWORD *)(v15 + 28) = 1065353216;
  *(_DWORD *)(v15 + 56) = 1065353216;
  *(_DWORD *)(v15 + 84) = 1065353216;
  *(_DWORD *)(v15 + 112) = 1065353216;
  *(_DWORD *)(v15 + 40) = 1062918875;
  *(_DWORD *)(v15 + 68) = 1062918875;
  *(_BYTE *)(v15 + 34) = -1;
  *(_BYTE *)(v15 + 33) = -1;
  *(_BYTE *)(v15 + 32) = -1;
  *(_DWORD *)(v15 + 4) = 5;
  *(_DWORD *)(v15 + 16) = 1135869952;
  *(_DWORD *)(v15 + 72) = 1135869952;
  *(_DWORD *)(v15 + 24) = 0;
  *(_DWORD *)(v15 + 52) = 0;
  *(_DWORD *)(v15 + 80) = 0;
  *(_DWORD *)(v15 + 108) = 0;
  *(_DWORD *)(v15 + 36) = 0;
  *(_DWORD *)(v15 + 64) = 1044167869;
  *(_DWORD *)(v15 + 92) = 0;
  *(_DWORD *)(v15 + 96) = 1064037356;
  *(_DWORD *)(v15 + 120) = 1044167869;
  *(_DWORD *)(v15 + 124) = 1064037356;
  *(_DWORD *)(v15 + 8) = sub_401000(0, 0, 1152, 218);
  byte_443AF2 = 60;
  byte_443AF1 = 60;
  byte_443AF0 = 60;
  sub_4015D0(0x1A9u, 450, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0xDFu);
  sub_401580(1);
  byte_443AF2 = -1;
  byte_443AF1 = -1;
  byte_443AF0 = -1;
  if ( (unsigned __int8)dword_44B804 >= 0xAu )
    sub_401870(445, 448, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, (unsigned __int8)dword_44B804);
  else
    sub_401AB0(445, 448, 1, aDD);
  sub_401D10();
  sub_401580(2);
  byte_443AF2 = 120;
  byte_443AF1 = 120;
  byte_443AF0 = 120;
  if ( (unsigned __int8)dword_44B804 >= 0xAu )
    sub_401870(447, 450, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, (unsigned __int8)dword_44B804);
  else
    sub_401AB0(447, 450, 1, aDD);
  sub_401D10();
  sub_401580(1);
  return sub_428550();
}
// 443AE4: using guessed type int dword_443AE4;
// 443AF0: using guessed type char byte_443AF0;
// 443AF1: using guessed type char byte_443AF1;
// 443AF2: using guessed type char byte_443AF2;
// 44B7E8: using guessed type float flt_44B7E8;
// 44B7FA: using guessed type char byte_44B7FA;
// 44B7FC: using guessed type __int16 word_44B7FC;
// 44B7FE: using guessed type __int16 word_44B7FE;
// 44B804: using guessed type int dword_44B804;
// 44BAB0: using guessed type __int16 word_44BAB0;
// 44BAB2: using guessed type __int16 word_44BAB2;
// 44BAB4: using guessed type char byte_44BAB4;
// 44D384: using guessed type int dword_44D384;
// 44D3A8: using guessed type float flt_44D3A8;
// 44D3AC: using guessed type float flt_44D3AC;
// 44D3B0: using guessed type int dword_44D3B0;
// 44D3B4: using guessed type int dword_44D3B4;

//----- (00429CB0) --------------------------------------------------------
char sub_429CB0()
{
  char result; // al

  result = 1;
  if ( !(dword_44B81A & 1) && !(dword_44B81A & 0x100) )
    result = 0;
  return result;
}
// 44B81A: using guessed type int dword_44B81A;

//----- (00429CD0) --------------------------------------------------------
unsigned __int8 sub_429CD0()
{
  unsigned __int8 result; // al
  unsigned __int8 v1; // cl
  char v2; // bl
  int v3; // edx
  unsigned int v4; // edx
  __int16 v5; // si
  unsigned int v6; // edx
  int v7; // edx
  __int16 v8; // si
  char v9; // [esp+10h] [ebp-4h]

  result = BYTE1(dword_44B80C);
  v9 = 0;
  if ( BYTE1(dword_44B80C) == 3 || !BYTE2(dword_455CB0) && dword_455BFC == 255 || (result = dword_455004) != 0 )
  {
    if ( byte_44B813 != 1 || !word_44B7F8 )
    {
      LOBYTE(dword_44D38C) = 0;
      LOBYTE(dword_44D394) = 0;
      byte_44D402 = 0;
      byte_44D403 = 0;
      return result;
    }
  }
  result = byte_44D402;
  if ( BYTE2(dword_455CB0) && !byte_44D402 && !byte_455CA5 )
    ++byte_44D403;
  if ( (unsigned __int8)byte_44D403 < 0x32u )
  {
    if ( !byte_44D402 && BYTE2(dword_455CB0) )
    {
      LOBYTE(dword_44D38C) = byte_44D402;
      LOBYTE(dword_44D394) = byte_44D402;
      return result;
    }
  }
  else
  {
    byte_44D402 = 1;
  }
  v1 = 70;
  if ( (unsigned __int8)dword_44D38C >= 0x50u )
  {
    if ( (unsigned __int8)dword_44D394 >= 0x46u )
    {
      result = 80;
      v9 = 1;
      LOBYTE(dword_44D38C) = 80;
      LOBYTE(dword_44D394) = 70;
      v2 = byte_44B797;
      if ( byte_44B797 == byte_44D376 )
      {
        v5 = word_44D3BE;
        LOWORD(v7) = word_44D3BC;
      }
      else
      {
        v5 = word_44D3BE;
        LOWORD(v7) = word_44D3BC;
        byte_44D3C0 = 20 * byte_44B797;
        result = dword_44D38C;
        byte_44D376 = byte_44B797;
      }
      goto LABEL_28;
    }
    goto LABEL_20;
  }
  LOBYTE(dword_44D38C) = dword_44D38C + 6;
  if ( (unsigned __int8)dword_44D394 < 0x46u )
LABEL_20:
    LOBYTE(dword_44D394) = dword_44D394 + 5;
  v2 = byte_44B797;
  if ( byte_44B797 == 1 )
  {
    v3 = 80 * (unsigned __int8)dword_44D38C / 80;
  }
  else
  {
    v4 = (signed int)((unsigned __int64)(-274877907040i64 * (unsigned __int8)dword_44D38C) >> 32) >> 5;
    v3 = (v4 >> 31) + v4;
  }
  v5 = v3;
  v1 = dword_44D394;
  v6 = (signed int)(150 * (unsigned __int8)dword_44D394
                  + ((unsigned __int64)(-55221007950i64 * (unsigned __int8)dword_44D394) >> 32)) >> 6;
  v7 = (v6 >> 31) + v6;
  result = dword_44D38C;
  word_44D3BC = v7;
LABEL_28:
  if ( v2 == -1 )
  {
    if ( v5 > -160 )
      goto LABEL_34;
LABEL_33:
    byte_44D3C0 = 0;
    goto LABEL_34;
  }
  if ( v2 == 1 && v5 >= 80 )
    goto LABEL_33;
LABEL_34:
  v8 = byte_44D3C0 + v5;
  word_44D3BE = v8;
  if ( v8 >= -160 )
  {
    if ( v8 <= 80 )
      goto LABEL_39;
    v8 = 80;
  }
  else
  {
    v8 = -160;
  }
  word_44D3BE = v8;
LABEL_39:
  if ( byte_44B813 == 1 )
  {
    if ( word_44B7F8 )
      result = sub_429280(v8, v7, result, v1, v9);
  }
  else
  {
    if ( byte_44B812 )
    {
      if ( !BYTE2(dword_455CB0) )
        return result;
    }
    else if ( !BYTE2(dword_455CB0) )
    {
      return sub_428C70(v8, v7, result, v1, dword_455BFC, byte_4423AC[44 * dword_455BFC], v9);
    }
    result = sub_425A50(v8, v7, result, v1, byte_44D376, 1, v9, byte_44D3C0);
  }
  return result;
}
// 44B797: using guessed type char byte_44B797;
// 44B7F8: using guessed type __int16 word_44B7F8;
// 44B80C: using guessed type int dword_44B80C;
// 44B812: using guessed type char byte_44B812;
// 44B813: using guessed type char byte_44B813;
// 44D376: using guessed type char byte_44D376;
// 44D38C: using guessed type int dword_44D38C;
// 44D394: using guessed type int dword_44D394;
// 44D3BC: using guessed type __int16 word_44D3BC;
// 44D3BE: using guessed type __int16 word_44D3BE;
// 44D3C0: using guessed type char byte_44D3C0;
// 44D402: using guessed type char byte_44D402;
// 44D403: using guessed type char byte_44D403;
// 455004: using guessed type int dword_455004;
// 455BFC: using guessed type int dword_455BFC;
// 455CA5: using guessed type char byte_455CA5;
// 455CB0: using guessed type int dword_455CB0;

//----- (00429F80) --------------------------------------------------------
int sub_429F80()
{
  int v0; // eax
  int v2; // [esp+0h] [ebp-28h]
  __int16 v3; // [esp+10h] [ebp-18h]
  int v4; // [esp+14h] [ebp-14h]
  __int16 v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  __int16 v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h]

  sub_404910(0, 1);
  if ( byte_455CA5 )
  {
    v0 = dword_455BEC;
  }
  else
  {
    sub_41FCE0(0);
    v3 = 37;
    v4 = 0x10000000;
    v5 = 38;
    v6 = 0x10000000;
    v7 = 39;
    v8 = 0x10000000;
    v0 = sub_41FEF0((int)&v3, 0x5000u);
    for ( dword_455BEC = v0; !v0; dword_455BEC = v0 )
    {
      sub_435281((int)aRetry, v2);
      v3 = 37;
      v4 = 0x10000000;
      v5 = 38;
      v6 = 0x10000000;
      v7 = 39;
      v8 = 0x10000000;
      v0 = sub_41FEF0((int)&v3, 0x5000u);
    }
    if ( v0 & 0x4000 )
    {
      if ( sub_41FEC0() )
        goto LABEL_14;
      v3 = 199;
      v4 = 0x10000000;
      v5 = 71;
      v6 = 0x10000000;
      v7 = 39;
      v8 = 0x10000000;
      v0 = sub_41FEF0((int)&v3, 0x5000u);
      for ( dword_455BEC = v0; !v0; dword_455BEC = v0 )
      {
        v3 = 199;
        v4 = 0x10000000;
        v5 = 71;
        v6 = 0x10000000;
        v7 = 39;
        v8 = 0x10000000;
        v0 = sub_41FEF0((int)&v3, 0x5000u);
      }
      if ( v0 & 0x4000 )
      {
LABEL_14:
        sub_41FCE0(0);
        sub_41FDB0();
        v0 = dword_455BEC;
        BYTE1(v0) &= 0xBFu;
      }
    }
  }
  BYTE1(v0) &= 0xEFu;
  dword_455BEC = v0;
  return sub_404910(0, 4096);
}
// 455BEC: using guessed type int dword_455BEC;
// 455CA5: using guessed type char byte_455CA5;

//----- (0042A870) --------------------------------------------------------
int __cdecl sub_42A870(unsigned __int16 a1, unsigned __int16 a2)
{
  _DWORD *v2; // eax
  int v3; // ecx
  double v4; // st7
  int v5; // eax
  _DWORD *v6; // eax
  int v7; // ecx
  int v8; // kr0C_4
  int v9; // ebp
  _DWORD *v10; // eax
  int v11; // ecx
  int v12; // eax
  int v13; // eax
  _DWORD *v14; // eax
  int v15; // ecx
  int v16; // eax
  _DWORD *v17; // eax
  int v18; // esi
  double v19; // ST30_8
  int v20; // eax
  _DWORD *v21; // eax
  int v22; // esi
  int v23; // eax
  int result; // eax

  if ( (signed int)a2 < *((_DWORD *)dword_443D44 + 3) )
  {
    v2 = dword_443D2C;
    v3 = *((_DWORD *)dword_443D2C + 16032);
    *((_DWORD *)dword_443D2C + 16032) = v3 + 88;
    *(_DWORD *)(v3 + 4) = 0;
    *(_DWORD *)v3 = v2[30];
    v2[30] = v3;
    *(_DWORD *)(v3 + 4) = 3;
    *(_BYTE *)(v3 + 26) = 0;
    *(_BYTE *)(v3 + 25) = 0;
    *(_BYTE *)(v3 + 24) = 0;
    *(_DWORD *)(v3 + 8) = -1063256064;
    *(_DWORD *)(v3 + 12) = -1063256064;
    v4 = (double)*((signed int *)dword_443D44 + 2);
    *(_DWORD *)(v3 + 32) = -1063256064;
    *(_DWORD *)(v3 + 48) = -1063256064;
    *(float *)(v3 + 28) = v4;
    *(float *)(v3 + 52) = (double)((*((_DWORD *)dword_443D44 + 3) - a2) / 2 + 2);
    *(float *)(v3 + 68) = (double)*((signed int *)dword_443D44 + 2);
    v5 = *((_DWORD *)dword_443D44 + 3);
    *(_DWORD *)(v3 + 16) = 0;
    *(_DWORD *)(v3 + 20) = 1065353216;
    *(_DWORD *)(v3 + 36) = 0;
    *(_DWORD *)(v3 + 40) = 1065353216;
    *(_DWORD *)(v3 + 56) = 0;
    *(_DWORD *)(v3 + 60) = 1065353216;
    *(_DWORD *)(v3 + 76) = 0;
    *(_DWORD *)(v3 + 80) = 1065353216;
    *(float *)(v3 + 72) = (double)((v5 - a2) / 2 + 2);
    v6 = dword_443D2C;
    v7 = *((_DWORD *)dword_443D2C + 16032);
    *((_DWORD *)dword_443D2C + 16032) = v7 + 88;
    *(_DWORD *)(v7 + 4) = 0;
    *(_DWORD *)v7 = v6[30];
    v6[30] = v7;
    *(_DWORD *)(v7 + 4) = 3;
    *(_BYTE *)(v7 + 26) = 0;
    *(_BYTE *)(v7 + 25) = 0;
    *(_BYTE *)(v7 + 24) = 0;
    *(_DWORD *)(v7 + 8) = -1063256064;
    *(float *)(v7 + 12) = (double)((a2 + *((_DWORD *)dword_443D44 + 3)) / 2);
    *(float *)(v7 + 28) = (double)*((signed int *)dword_443D44 + 2);
    v8 = a2 + *((_DWORD *)dword_443D44 + 3);
    *(_DWORD *)(v7 + 48) = -1063256064;
    *(float *)(v7 + 32) = (double)(v8 / 2);
    *(float *)(v7 + 52) = (double)((*((_DWORD *)dword_443D44 + 3) - a2) / 2
                                 + (a2 + *((_DWORD *)dword_443D44 + 3)) / 2
                                 + 2);
    *(float *)(v7 + 68) = (double)*((signed int *)dword_443D44 + 2);
    v9 = *((_DWORD *)dword_443D44 + 3);
    *(_DWORD *)(v7 + 16) = 0;
    *(_DWORD *)(v7 + 20) = 1065353216;
    *(_DWORD *)(v7 + 36) = 0;
    *(_DWORD *)(v7 + 40) = 1065353216;
    *(_DWORD *)(v7 + 56) = 0;
    *(_DWORD *)(v7 + 60) = 1065353216;
    *(_DWORD *)(v7 + 76) = 0;
    *(_DWORD *)(v7 + 80) = 1065353216;
    *(float *)(v7 + 72) = (double)((v9 - a2) / 2 + (a2 + v9) / 2 + 2);
  }
  if ( (signed int)a1 < *((_DWORD *)dword_443D44 + 2) )
  {
    v10 = dword_443D2C;
    v11 = *((_DWORD *)dword_443D2C + 16032);
    *((_DWORD *)dword_443D2C + 16032) = v11 + 88;
    *(_DWORD *)(v11 + 4) = 0;
    *(_DWORD *)v11 = v10[30];
    v10[30] = v11;
    *(_DWORD *)(v11 + 4) = 3;
    *(_BYTE *)(v11 + 26) = 0;
    *(_BYTE *)(v11 + 25) = 0;
    *(_BYTE *)(v11 + 24) = 0;
    *(_DWORD *)(v11 + 8) = -1063256064;
    *(float *)(v11 + 12) = (double)((*((_DWORD *)dword_443D44 + 3) - a2) / 2);
    *(float *)(v11 + 28) = (double)((*((_DWORD *)dword_443D44 + 2) - a1) / 2 + 2);
    v12 = *((_DWORD *)dword_443D44 + 3);
    *(_DWORD *)(v11 + 48) = -1063256064;
    *(float *)(v11 + 32) = (double)((v12 - a2) / 2);
    *(float *)(v11 + 52) = (double)(a2 + (*((_DWORD *)dword_443D44 + 3) - a2) / 2);
    *(float *)(v11 + 68) = (double)((*((_DWORD *)dword_443D44 + 2) - a1) / 2 + 2);
    v13 = *((_DWORD *)dword_443D44 + 3);
    *(_DWORD *)(v11 + 16) = 0;
    *(_DWORD *)(v11 + 20) = 1065353216;
    *(_DWORD *)(v11 + 36) = 0;
    *(_DWORD *)(v11 + 40) = 1065353216;
    *(_DWORD *)(v11 + 56) = 0;
    *(_DWORD *)(v11 + 60) = 1065353216;
    *(_DWORD *)(v11 + 76) = 0;
    *(_DWORD *)(v11 + 80) = 1065353216;
    *(float *)(v11 + 72) = (double)(a2 + (v13 - a2) / 2);
    v14 = dword_443D2C;
    v15 = *((_DWORD *)dword_443D2C + 16032);
    *((_DWORD *)dword_443D2C + 16032) = v15 + 88;
    *(_DWORD *)(v15 + 4) = 0;
    *(_DWORD *)v15 = v14[30];
    v14[30] = v15;
    *(_DWORD *)(v15 + 4) = 3;
    *(_BYTE *)(v15 + 26) = 0;
    *(_BYTE *)(v15 + 25) = 0;
    *(_BYTE *)(v15 + 24) = 0;
    *(float *)(v15 + 8) = (double)((a1 + *((_DWORD *)dword_443D44 + 2)) / 2 - 2);
    *(float *)(v15 + 12) = (double)((*((_DWORD *)dword_443D44 + 3) - a2) / 2);
    *(float *)(v15 + 28) = (double)((*((_DWORD *)dword_443D44 + 2) + a1) / 2 + (*((_DWORD *)dword_443D44 + 2) - a1) / 2);
    *(float *)(v15 + 32) = (double)((*((_DWORD *)dword_443D44 + 3) - a2) / 2);
    *(float *)(v15 + 48) = (double)((a1 + *((_DWORD *)dword_443D44 + 2)) / 2 - 2);
    *(float *)(v15 + 52) = (double)(a2 + (*((_DWORD *)dword_443D44 + 3) - a2) / 2);
    *(float *)(v15 + 68) = (double)((*((_DWORD *)dword_443D44 + 2) + a1) / 2 + (*((_DWORD *)dword_443D44 + 2) - a1) / 2);
    v16 = *((_DWORD *)dword_443D44 + 3);
    *(_DWORD *)(v15 + 16) = 0;
    *(_DWORD *)(v15 + 36) = 0;
    *(_DWORD *)(v15 + 56) = 0;
    *(_DWORD *)(v15 + 76) = 0;
    *(_DWORD *)(v15 + 20) = 1065353216;
    *(_DWORD *)(v15 + 40) = 1065353216;
    *(_DWORD *)(v15 + 60) = 1065353216;
    *(_DWORD *)(v15 + 80) = 1065353216;
    *(float *)(v15 + 72) = (double)(a2 + (v16 - a2) / 2);
  }
  v17 = dword_443D2C;
  v18 = *((_DWORD *)dword_443D2C + 16032);
  *((_DWORD *)dword_443D2C + 16032) = v18 + 128;
  *(_DWORD *)(v18 + 4) = 0;
  *(_DWORD *)v18 = v17[30];
  v17[30] = v18;
  *(_DWORD *)(v18 + 4) = 261;
  *(_BYTE *)(v18 + 34) = -1;
  *(_BYTE *)(v18 + 33) = -1;
  *(_BYTE *)(v18 + 32) = -1;
  *(float *)(v18 + 16) = (double)((*((_DWORD *)dword_443D44 + 2) - a1) / 2 - 2);
  *(float *)(v18 + 20) = (double)((*((_DWORD *)dword_443D44 + 3) - a2) / 2);
  *(float *)(v18 + 44) = (double)(signed int)((*((_DWORD *)dword_443D44 + 2) - a1) / 2 + ((unsigned int)a1 >> 1) - 1);
  *(float *)(v18 + 48) = (double)((*((_DWORD *)dword_443D44 + 3) - a2) / 2);
  *(float *)(v18 + 72) = (double)((*((_DWORD *)dword_443D44 + 2) - a1) / 2 - 2);
  v19 = (double)a2 * 1.2;
  *(float *)(v18 + 76) = (double)((*((_DWORD *)dword_443D44 + 3) - a2) / 2) + v19;
  *(float *)(v18 + 100) = (double)(signed int)((*((_DWORD *)dword_443D44 + 2) - a1) / 2 + ((unsigned int)a1 >> 1) - 1);
  v20 = *((_DWORD *)dword_443D44 + 3);
  *(_DWORD *)(v18 + 24) = 0;
  *(_DWORD *)(v18 + 28) = 1065353216;
  *(_DWORD *)(v18 + 52) = 0;
  *(_DWORD *)(v18 + 36) = 1044431041;
  *(_DWORD *)(v18 + 92) = 1044431041;
  *(_DWORD *)(v18 + 56) = 1065353216;
  *(float *)(v18 + 104) = (double)((v20 - a2) / 2) + v19;
  *(_DWORD *)(v18 + 80) = 0;
  *(_DWORD *)(v18 + 84) = 1065353216;
  *(_DWORD *)(v18 + 108) = 0;
  *(_DWORD *)(v18 + 112) = 1065353216;
  *(_DWORD *)(v18 + 40) = 0;
  *(_DWORD *)(v18 + 64) = 0;
  *(_DWORD *)(v18 + 68) = 0;
  *(_DWORD *)(v18 + 96) = 1056898815;
  *(_DWORD *)(v18 + 120) = 0;
  *(_DWORD *)(v18 + 124) = 1056898815;
  *(_DWORD *)(v18 + 8) = sub_401000(0, 2, 1088, 256);
  v21 = dword_443D2C;
  v22 = *((_DWORD *)dword_443D2C + 16032);
  *((_DWORD *)dword_443D2C + 16032) = v22 + 128;
  *(_DWORD *)(v22 + 4) = 0;
  *(_DWORD *)v22 = v21[30];
  v21[30] = v22;
  *(_DWORD *)(v22 + 4) = 261;
  *(_BYTE *)(v22 + 34) = -1;
  *(_BYTE *)(v22 + 33) = -1;
  *(_BYTE *)(v22 + 32) = -1;
  *(float *)(v22 + 16) = (double)(*((_DWORD *)dword_443D44 + 2) / 2 - 1);
  *(float *)(v22 + 20) = (double)((*((_DWORD *)dword_443D44 + 3) - a2) / 2);
  *(float *)(v22 + 44) = (double)(signed int)(*((_DWORD *)dword_443D44 + 2) / 2 + ((unsigned int)a1 >> 1) + 1);
  *(float *)(v22 + 48) = (double)((*((_DWORD *)dword_443D44 + 3) - a2) / 2);
  *(float *)(v22 + 72) = (double)(*((_DWORD *)dword_443D44 + 2) / 2 - 1);
  *(float *)(v22 + 76) = (double)((*((_DWORD *)dword_443D44 + 3) - a2) / 2) + v19;
  *(float *)(v22 + 100) = (double)(signed int)(*((_DWORD *)dword_443D44 + 2) / 2 + ((unsigned int)a1 >> 1) + 1);
  v23 = *((_DWORD *)dword_443D44 + 3);
  *(_DWORD *)(v22 + 24) = 0;
  *(_DWORD *)(v22 + 28) = 1065353216;
  *(_DWORD *)(v22 + 52) = 0;
  *(_DWORD *)(v22 + 56) = 1065353216;
  *(_DWORD *)(v22 + 80) = 0;
  *(_DWORD *)(v22 + 84) = 1065353216;
  *(_DWORD *)(v22 + 108) = 0;
  *(float *)(v22 + 104) = (double)((v23 - a2) / 2) + v19;
  *(_DWORD *)(v22 + 112) = 1065353216;
  *(_DWORD *)(v22 + 36) = 0;
  *(_DWORD *)(v22 + 40) = 0;
  *(_DWORD *)(v22 + 64) = 1044431041;
  *(_DWORD *)(v22 + 68) = 0;
  *(_DWORD *)(v22 + 92) = 0;
  *(_DWORD *)(v22 + 96) = 1056898815;
  *(_DWORD *)(v22 + 120) = 1044431041;
  *(_DWORD *)(v22 + 124) = 1056898815;
  result = sub_401000(0, 2, 1088, 256);
  *(_DWORD *)(v22 + 8) = result;
  return result;
}

//----- (0042AFC0) --------------------------------------------------------
char sub_42AFC0()
{
  char result; // al
  bool v1; // zf
  _DWORD *v2; // eax
  int v3; // esi
  _DWORD *v4; // eax
  int v5; // esi
  _DWORD *v6; // eax
  int v7; // esi
  int v8; // [esp-30h] [ebp-40h]
  int v9; // [esp-2Ch] [ebp-3Ch]
  unsigned int v10; // [esp-24h] [ebp-34h]

  result = BYTE1(dword_44B80C);
  if ( BYTE1(dword_44B80C) != 3 )
  {
    result = dword_455BFC;
    if ( dword_455BFC != 255 && !(_BYTE)dword_455004 )
    {
      if ( (unsigned __int8)dword_44B804 < (signed int)byte_4423AC[44 * dword_455BFC] )
      {
LABEL_17:
        sub_4345A0();
        result = sub_401580(1);
        goto LABEL_18;
      }
      sub_401580(1);
      byte_443AF2 = -66;
      byte_443AF1 = 0;
      byte_443AF0 = 0;
      v1 = sub_429CB0() == 0;
      v2 = dword_443D2C;
      v3 = *((_DWORD *)dword_443D2C + 16032);
      *((_DWORD *)dword_443D2C + 16032) = v3 + 128;
      *(_DWORD *)(v3 + 4) = 0;
      *(_DWORD *)v3 = v2[30];
      v2[30] = v3;
      *(_BYTE *)(v3 + 34) = -16;
      *(_BYTE *)(v3 + 33) = -16;
      *(_BYTE *)(v3 + 32) = -16;
      *(_DWORD *)(v3 + 4) = 5;
      *(_DWORD *)(v3 + 16) = 1092616192;
      if ( v1 )
      {
        *(_DWORD *)(v3 + 20) = 1138819072;
        *(_DWORD *)(v3 + 48) = 1138819072;
        *(_DWORD *)(v3 + 44) = 1109655552;
        *(_DWORD *)(v3 + 76) = 1139671040;
        *(_DWORD *)(v3 + 104) = 1139671040;
        *(_DWORD *)(v3 + 100) = 1109655552;
      }
      else
      {
        *(_DWORD *)(v3 + 20) = 1137803264;
        *(_DWORD *)(v3 + 44) = 1109655552;
        *(_DWORD *)(v3 + 48) = 1137803264;
        *(_DWORD *)(v3 + 100) = 1109655552;
        *(_DWORD *)(v3 + 76) = 1138655232;
        *(_DWORD *)(v3 + 104) = 1138655232;
      }
      *(_DWORD *)(v3 + 36) = 1058839709;
      *(_DWORD *)(v3 + 92) = 1058839709;
      *(_DWORD *)(v3 + 72) = 1092616192;
      *(_DWORD *)(v3 + 24) = 0;
      *(_DWORD *)(v3 + 28) = 1065353216;
      *(_DWORD *)(v3 + 52) = 0;
      *(_DWORD *)(v3 + 56) = 1065353216;
      *(_DWORD *)(v3 + 80) = 0;
      *(_DWORD *)(v3 + 84) = 1065353216;
      *(_DWORD *)(v3 + 108) = 0;
      *(_DWORD *)(v3 + 112) = 1065353216;
      *(_DWORD *)(v3 + 40) = 1039726841;
      *(_DWORD *)(v3 + 64) = 1060945085;
      *(_DWORD *)(v3 + 68) = 1039726841;
      *(_DWORD *)(v3 + 96) = 1048115449;
      *(_DWORD *)(v3 + 120) = 1060945085;
      *(_DWORD *)(v3 + 124) = 1048115449;
      *(_DWORD *)(v3 + 8) = sub_401000(0, 0, 1255, 31);
      if ( *((_BYTE *)&dword_44B81A + dword_455BFC) & 1 )
      {
        if ( sub_429CB0() )
        {
          sub_401580(1);
          byte_443AF2 = -1 - word_442380;
          byte_443AF1 = -1 - word_442380;
          byte_443AF0 = -1 - word_442380;
          sub_4015D0(0x37u, 419, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x1Du);
          sub_401D10();
          sub_401580(2);
          byte_443AF2 = 127;
          byte_443AF1 = 127;
          byte_443AF0 = 127;
          sub_4015D0(0x39u, 421, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x1Du);
LABEL_16:
          sub_401D10();
          goto LABEL_17;
        }
        sub_401580(1);
        byte_443AF2 = -1 - word_442380;
        byte_443AF1 = -1 - word_442380;
        byte_443AF0 = -1 - word_442380;
        sub_4015D0(0x37u, 450, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x1Du);
        sub_401D10();
        sub_401580(2);
        byte_443AF2 = 127;
        byte_443AF1 = 127;
        byte_443AF0 = 127;
        v10 = 29;
        v9 = HIWORD(dword_443AE4);
        v8 = (unsigned __int16)dword_443AE4;
      }
      else
      {
        if ( sub_429CB0() )
        {
          sub_401580(1);
          byte_443AF2 = -1 - word_442380;
          byte_443AF1 = -1 - word_442380;
          byte_443AF0 = -1 - word_442380;
          sub_4015D0(0x37u, 419, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x1Cu);
          sub_401D10();
          sub_401580(2);
          byte_443AF2 = 127;
          byte_443AF1 = 127;
          byte_443AF0 = 127;
          sub_4015D0(0x39u, 421, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x1Cu);
          goto LABEL_16;
        }
        sub_401580(1);
        byte_443AF2 = -1 - word_442380;
        byte_443AF1 = -1 - word_442380;
        byte_443AF0 = -1 - word_442380;
        sub_4015D0(0x37u, 450, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x1Cu);
        sub_401D10();
        sub_401580(2);
        byte_443AF2 = 127;
        byte_443AF1 = 127;
        byte_443AF0 = 127;
        v10 = 28;
        v9 = HIWORD(dword_443AE4);
        v8 = (unsigned __int16)dword_443AE4;
      }
      sub_4015D0(0x39u, 452, v8, v9, 1, v10);
      goto LABEL_16;
    }
  }
LABEL_18:
  if ( byte_44B813 && !word_44B7F8 )
  {
    v4 = dword_443D2C;
    v5 = *((_DWORD *)dword_443D2C + 16032);
    *((_DWORD *)dword_443D2C + 16032) = v5 + 128;
    *(_DWORD *)(v5 + 4) = 0;
    *(_DWORD *)v5 = v4[30];
    v4[30] = v5;
    *(_DWORD *)(v5 + 44) = 1109655552;
    *(_DWORD *)(v5 + 20) = 1137803264;
    *(_DWORD *)(v5 + 48) = 1137803264;
    *(_DWORD *)(v5 + 100) = 1109655552;
    *(_DWORD *)(v5 + 76) = 1138753536;
    *(_DWORD *)(v5 + 104) = 1138753536;
    *(_DWORD *)(v5 + 40) = 1039726841;
    *(_DWORD *)(v5 + 68) = 1039726841;
    *(_BYTE *)(v5 + 34) = -16;
    *(_BYTE *)(v5 + 33) = -16;
    *(_BYTE *)(v5 + 32) = -16;
    *(_DWORD *)(v5 + 4) = 5;
    *(_DWORD *)(v5 + 16) = 1092616192;
    *(_DWORD *)(v5 + 72) = 1092616192;
    *(_DWORD *)(v5 + 24) = 0;
    *(_DWORD *)(v5 + 28) = 1065353216;
    *(_DWORD *)(v5 + 52) = 0;
    *(_DWORD *)(v5 + 56) = 1065353216;
    *(_DWORD *)(v5 + 80) = 0;
    *(_DWORD *)(v5 + 84) = 1065353216;
    *(_DWORD *)(v5 + 108) = 0;
    *(_DWORD *)(v5 + 112) = 1065353216;
    *(_DWORD *)(v5 + 36) = 1058839709;
    *(_DWORD *)(v5 + 64) = 1060945085;
    *(_DWORD *)(v5 + 92) = 1058839709;
    *(_DWORD *)(v5 + 96) = 1048115449;
    *(_DWORD *)(v5 + 120) = 1060945085;
    *(_DWORD *)(v5 + 124) = 1048115449;
    *(_DWORD *)(v5 + 8) = sub_401000(0, 0, 1255, 31);
    sub_401580(1);
    byte_443AF2 = -76;
    byte_443AF1 = -76;
    byte_443AF0 = -76;
    sub_4015D0(0x37u, 419, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x1Bu);
    sub_401D10();
    sub_401580(2);
    byte_443AF2 = -69;
    byte_443AF1 = -69;
    byte_443AF0 = -69;
    sub_4015D0(0x39u, 421, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x1Bu);
    result = sub_401D10();
  }
  if ( BYTE1(dword_44B80C) != 3 )
  {
    result = sub_429CB0();
    if ( result )
    {
      v6 = dword_443D2C;
      v7 = *((_DWORD *)dword_443D2C + 16032);
      *((_DWORD *)dword_443D2C + 16032) = v7 + 128;
      *(_DWORD *)(v7 + 4) = 0;
      *(_DWORD *)v7 = v6[30];
      v6[30] = v7;
      *(_DWORD *)(v7 + 44) = 1111805133;
      *(_DWORD *)(v7 + 20) = 1138655232;
      *(_DWORD *)(v7 + 48) = 1138655232;
      *(_DWORD *)(v7 + 100) = 1111805133;
      *(_DWORD *)(v7 + 76) = 1139870925;
      *(_DWORD *)(v7 + 104) = 1139870925;
      *(_BYTE *)(v7 + 34) = -1;
      *(_BYTE *)(v7 + 33) = -1;
      *(_BYTE *)(v7 + 32) = -1;
      *(_DWORD *)(v7 + 4) = 261;
      *(_DWORD *)(v7 + 16) = 1092616192;
      *(_DWORD *)(v7 + 72) = 1092616192;
      *(_DWORD *)(v7 + 24) = 0;
      *(_DWORD *)(v7 + 28) = 1065353216;
      *(_DWORD *)(v7 + 52) = 0;
      *(_DWORD *)(v7 + 56) = 1065353216;
      *(_DWORD *)(v7 + 80) = 0;
      *(_DWORD *)(v7 + 84) = 1065353216;
      *(_DWORD *)(v7 + 108) = 0;
      *(_DWORD *)(v7 + 112) = 1065353216;
      *(_DWORD *)(v7 + 36) = 0;
      *(_DWORD *)(v7 + 40) = 0;
      *(_DWORD *)(v7 + 64) = 1046536417;
      *(_DWORD *)(v7 + 68) = 0;
      *(_DWORD *)(v7 + 92) = 0;
      *(_DWORD *)(v7 + 96) = 1045746901;
      *(_DWORD *)(v7 + 120) = 1046536417;
      *(_DWORD *)(v7 + 124) = 1045746901;
      *(_DWORD *)(v7 + 8) = sub_401000(0, 1, 1152, 0);
      sub_401580(1);
      byte_443AF2 = -76;
      byte_443AF1 = -76;
      byte_443AF0 = -76;
      sub_4015D0(0x37u, 450, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x1Eu);
      sub_401D10();
      sub_401580(2);
      byte_443AF2 = -69;
      byte_443AF1 = -69;
      byte_443AF0 = -69;
      sub_4015D0(0x39u, 452, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x1Eu);
      result = sub_401D10();
    }
  }
  return result;
}
// 442380: using guessed type __int16 word_442380;
// 443AE4: using guessed type int dword_443AE4;
// 443AF0: using guessed type char byte_443AF0;
// 443AF1: using guessed type char byte_443AF1;
// 443AF2: using guessed type char byte_443AF2;
// 44B7F8: using guessed type __int16 word_44B7F8;
// 44B804: using guessed type int dword_44B804;
// 44B80C: using guessed type int dword_44B80C;
// 44B813: using guessed type char byte_44B813;
// 44B81A: using guessed type int dword_44B81A;
// 455004: using guessed type int dword_455004;
// 455BFC: using guessed type int dword_455BFC;

//----- (0042B670) --------------------------------------------------------
int sub_42B670()
{
  _DWORD *v0; // ecx
  int v1; // esi
  double v2; // st7
  double v3; // st7
  int result; // eax

  v0 = dword_443D2C;
  v1 = *((_DWORD *)dword_443D2C + 16032);
  *((_DWORD *)dword_443D2C + 16032) = v1 + 128;
  *(_DWORD *)(v1 + 4) = 0;
  *(_DWORD *)v1 = v0[30];
  v0[30] = v1;
  *(_DWORD *)(v1 + 4) = 5;
  *(_BYTE *)(v1 + 34) = -1;
  *(_BYTE *)(v1 + 33) = -1;
  *(_BYTE *)(v1 + 32) = -1;
  *(_DWORD *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 20) = 0;
  v2 = (double)*((signed int *)dword_443D44 + 2);
  *(_DWORD *)(v1 + 48) = 0;
  *(_DWORD *)(v1 + 72) = 0;
  *(_DWORD *)(v1 + 76) = 1139802112;
  *(float *)(v1 + 44) = v2;
  v3 = (double)*((signed int *)dword_443D44 + 2);
  *(_DWORD *)(v1 + 104) = 1139802112;
  *(_DWORD *)(v1 + 24) = 0;
  *(_DWORD *)(v1 + 28) = 1065353216;
  *(float *)(v1 + 100) = v3;
  *(_DWORD *)(v1 + 52) = 0;
  *(_DWORD *)(v1 + 56) = 1065353216;
  *(_DWORD *)(v1 + 80) = 0;
  *(_DWORD *)(v1 + 84) = 1065353216;
  *(_DWORD *)(v1 + 108) = 0;
  *(_DWORD *)(v1 + 112) = 1065353216;
  *(_DWORD *)(v1 + 36) = 0;
  *(_DWORD *)(v1 + 40) = 0;
  *(_DWORD *)(v1 + 64) = 1065353216;
  *(_DWORD *)(v1 + 68) = 0;
  *(_DWORD *)(v1 + 92) = 0;
  *(_DWORD *)(v1 + 96) = 1065353216;
  *(_DWORD *)(v1 + 120) = 1065353216;
  *(_DWORD *)(v1 + 124) = 1065353216;
  result = sub_401000(1, 0, 640, 256);
  *(_DWORD *)(v1 + 8) = result;
  return result;
}

//----- (0042B730) --------------------------------------------------------
#error "42B85F: call analysis failed (funcsize=74)"

//----- (0042C0B0) --------------------------------------------------------
char __cdecl sub_42C0B0(int a1)
{
  AGLFILE *v1; // eax
  unsigned int v2; // edi
  signed int v3; // esi
  char v5; // [esp+0h] [ebp-100h]

  if ( sub_407E30((AGLSOUNDBUFFER **)&unk_444818) )
    sub_407E50((AGLSOUNDBUFFER **)&unk_444818);
  sub_407C30();
  sub_4345F0();
  sub_402A90();
  sub_4345F0();
  sub_402A90();
  sub_402A90();
  sprintf(&v5, aDataGraphGaler, a1);
  v1 = sub_401D60((int)&v5);
  v2 = (unsigned int)v1;
  if ( v1 )
  {
    sub_402A90();
    v3 = 12;
    do
    {
      sub_401DB0((unsigned __int8 *)v2, 0, 0, v3, 0, *(_WORD *)(v2 + 4) - 12);
      v3 += 256;
    }
    while ( v3 < 524 );
    sub_401E40(v2);
    sub_402A90();
    while ( !(dword_455BEC & 0x1000) )
    {
      sub_404530();
      sub_434560();
      sub_434690(6u, 0);
    }
    while ( (_BYTE)dword_455004 )
    {
      sub_4345F0();
      sub_4346F0();
      sub_402A90();
    }
    sub_434690(1u, 0);
    dword_455BEC = 0;
    LOBYTE(v1) = sub_407BB0(16);
  }
  return (char)v1;
}
// 455004: using guessed type int dword_455004;
// 455BEC: using guessed type int dword_455BEC;

//----- (0042C1E0) --------------------------------------------------------
char __cdecl sub_42C1E0(int a1)
{
  char result; // al
  int v2; // eax
  int v3; // eax
  unsigned __int8 v4; // cl
  char v5; // al
  int v6; // edx
  char v7; // al
  double v8; // st7
  double v9; // st6
  bool v10; // c0
  int v11; // eax
  char v12; // al
  int v13; // eax
  char v14; // al
  int v15; // eax
  unsigned __int16 *v16; // ecx
  int v17; // edx
  float v18; // ST00_4

  if ( *(float *)&a1 == 0.0 )
    return 1;
  v2 = *(_DWORD *)(a1 + 20);
  if ( v2 )
  {
    *(_DWORD *)(v2 + 92) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 96) = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 100) = *(_DWORD *)(a1 + 40);
    if ( byte_455C14 )
      sub_4083F0(*(int **)(a1 + 20));
  }
  v3 = *(_DWORD *)(a1 + 12);
  if ( v3 & 0x400 )
  {
    BYTE1(v3) = BYTE1(v3) & 0xFB | 0x80;
    *(_DWORD *)(a1 + 12) = v3;
    if ( *(_BYTE *)(a1 + 4) == 50 )
      sub_40AC20(*(unsigned __int16 *)(a1 + 62), 0);
    *(_DWORD *)(a1 + 16) = 0;
    return 0;
  }
  if ( (v3 & 0x8000) == 0 )
  {
    if ( v3 & 0x20000 )
    {
      if ( !*(_DWORD *)(a1 + 16) )
      {
        v14 = *(_BYTE *)(a1 + 4);
        *(_DWORD *)(a1 + 16) = dword_455BE0;
        if ( v14 == 50 )
          sub_40AC20(*(unsigned __int16 *)(a1 + 62), 1);
        sub_408670(*(float *)(a1 + 20), 3, 0);
      }
      v15 = *(_DWORD *)(a1 + 20);
      if ( v15 )
      {
        v16 = *(unsigned __int16 **)(v15 + 184);
        if ( v16 )
        {
          if ( *(unsigned __int16 *)(v15 + 174) == *v16 - 1 )
          {
            v17 = *(_DWORD *)(a1 + 12);
            *(_DWORD *)(a1 + 16) = 0;
            result = 0;
            *(_DWORD *)(a1 + 12) = v17 & 0xFC047FFF | 0x40000;
            return result;
          }
        }
      }
    }
    else if ( v3 & 0x40000 && !*(_DWORD *)(a1 + 16) )
    {
      v18 = *(float *)(a1 + 20);
      *(_DWORD *)(a1 + 16) = dword_455BE0;
      sub_408670(v18, 2, 0);
    }
    return 0;
  }
  if ( !*(_DWORD *)(a1 + 16) )
  {
    v4 = *(_BYTE *)(a1 + 8);
    *(_DWORD *)(a1 + 16) = dword_455BE0;
    if ( (unsigned __int8)dword_44B804 >= v4 )
    {
      v5 = *(_BYTE *)(a1 + 4);
      if ( v5 == 50 || v5 == 68 )
        sub_40AC20(*(unsigned __int16 *)(a1 + 62), 1);
      v6 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 12) = v6 & 0xFC047FFF | 0x40000;
    }
    sub_408670(*(float *)(a1 + 20), 0, 0);
  }
  v7 = *(_BYTE *)(a1 + 4);
  if ( v7 == 51 || v7 == 52 || v7 == 53 )
  {
    v8 = sub_41F420((float *)(a1 + 32), &dword_44B73C);
    switch ( *(_BYTE *)(a1 + 4) )
    {
      case 0x33:
        v9 = 2000.0;
        break;
      case 0x34:
        if ( (_BYTE)dword_44B804 == 12 )
          v9 = 0.0;
        else
          v9 = 750.0;
        break;
      case 0x35:
        v9 = 150.0;
        break;
      default:
        v9 = *(float *)&a1;
        break;
    }
    if ( v8 >= v9 )
    {
      if ( v8 >= 4000.0 )
        goto LABEL_38;
    }
    else if ( sub_4168A0(a1, 0) )
    {
      v10 = dword_44B73C < (double)*(float *)(a1 + 32);
      BYTE2(dword_44B80C) = 2;
      if ( !v10 )
        BYTE2(dword_44B80C) = 1;
      if ( !byte_455CA5 )
      {
        v11 = dword_455BEC;
        BYTE1(v11) &= 0xBFu;
        dword_455BEC = v11;
      }
      goto LABEL_38;
    }
    BYTE2(dword_44B80C) = 0;
  }
LABEL_38:
  if ( (_BYTE)dword_44B804 != *(_BYTE *)(a1 + 8) )
  {
    v12 = *(_BYTE *)(a1 + 4);
    if ( (v12 != 52 || !(dword_44B81E & 1))
      && (v12 != 68 || !(dword_44B81E & 0x100))
      && (v12 != 53 || !(dword_44B822 & 1))
      && (v12 != 51 || !(dword_44B822 & 1)) )
    {
      return 0;
    }
  }
  v13 = *(unsigned __int8 *)(a1 + 4) - 50;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 12) & 0xFC027FFF | 0x20000;
  *(_DWORD *)(a1 + 16) = 0;
  switch ( v13 )
  {
    case 0:
    case 18:
      sub_407E00((int)&dword_444920);
      BYTE2(dword_44B80C) = 0;
      result = 0;
      break;
    case 1:
      sub_407E00((int)&dword_444908);
      BYTE2(dword_44B80C) = 0;
      result = 0;
      break;
    case 2:
    case 3:
      sub_407E00((int)&dword_444914);
      goto LABEL_51;
    default:
LABEL_51:
      BYTE2(dword_44B80C) = 0;
      result = 0;
      break;
  }
  return result;
}
// 444908: using guessed type int dword_444908;
// 444914: using guessed type int dword_444914;
// 444920: using guessed type int dword_444920;
// 44B804: using guessed type int dword_44B804;
// 44B80C: using guessed type int dword_44B80C;
// 44B81E: using guessed type int dword_44B81E;
// 44B822: using guessed type int dword_44B822;
// 455BE0: using guessed type int dword_455BE0;
// 455BEC: using guessed type int dword_455BEC;
// 455C14: using guessed type char byte_455C14;
// 455CA5: using guessed type char byte_455CA5;

//----- (0042C510) --------------------------------------------------------
char __cdecl sub_42C510(int a1)
{
  char result; // al
  int v2; // ecx
  int v3; // ecx

  if ( !a1 )
    return 1;
  v2 = *(_DWORD *)(a1 + 20);
  if ( v2 )
  {
    *(_DWORD *)(v2 + 92) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 96) = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 100) = *(_DWORD *)(a1 + 40);
  }
  v3 = *(_DWORD *)(a1 + 12);
  if ( v3 & 0x400 )
  {
    BYTE1(v3) &= 0xBBu;
    *(_DWORD *)(a1 + 12) = v3;
    result = 0;
  }
  else
  {
    if ( !(v3 & 0x4000) && *((_BYTE *)&dword_44B7CC + *(unsigned __int8 *)(a1 + 4)) < 0 )
    {
      BYTE1(v3) |= 0x40u;
      *(_DWORD *)(a1 + 12) = v3;
    }
    result = 0;
  }
  return result;
}
// 44B7CC: using guessed type int dword_44B7CC;

//----- (0042C570) --------------------------------------------------------
char __cdecl sub_42C570(int a1)
{
  int v1; // eax
  char result; // al
  int v3; // ecx
  int v4; // ecx
  unsigned __int8 v5; // [esp+4h] [ebp+4h]

  v1 = a1;
  if ( !a1 )
    return 1;
  v3 = *(_DWORD *)(a1 + 20);
  v5 = *(_BYTE *)(a1 + 4) > 0x31u ? 67 : 41;
  if ( v3 )
  {
    *(_DWORD *)(v3 + 92) = *(_DWORD *)(v1 + 32);
    *(_DWORD *)(*(_DWORD *)(v1 + 20) + 96) = *(_DWORD *)(v1 + 36);
    *(_DWORD *)(*(_DWORD *)(v1 + 20) + 100) = *(_DWORD *)(v1 + 40);
  }
  v4 = *(_DWORD *)(v1 + 12);
  if ( v4 & 0x400 )
  {
    BYTE1(v4) = BYTE1(v4) & 0xFB | 0x40;
    *(_DWORD *)(v1 + 12) = v4;
    result = 0;
  }
  else
  {
    if ( v4 & 0x4000 )
    {
      if ( *((_BYTE *)&dword_44B81A + *(unsigned __int8 *)(v1 + 4) - v5) & 0x10 )
      {
        BYTE1(v4) &= 0x9Fu;
        *(_DWORD *)(v1 + 12) = v4;
      }
    }
    result = 0;
  }
  return result;
}
// 44B81A: using guessed type int dword_44B81A;

//----- (0042C5F0) --------------------------------------------------------
char __cdecl sub_42C5F0(char a1)
{
  if ( !dword_44D424 )
    return 0;
  (*(void (__stdcall **)(int, signed int))(*(_DWORD *)dword_44D418 + 148))(dword_44D418, -1);
  (*(void (__stdcall **)(int, signed int))(*(_DWORD *)dword_44D418 + 76))(dword_44D418, -1);
  if ( a1 )
  {
    sub_404530();
    if ( sub_404900() & 0xF008 )
      sub_42C8C0();
  }
  return dword_44D424;
}
// 44D418: using guessed type int dword_44D418;
// 44D424: using guessed type int dword_44D424;

//----- (0042C650) --------------------------------------------------------
int __usercall sub_42C650@<eax>(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, HWND hWnd, int a5)
{
  int result; // eax
  double v6; // st7
  int v7; // ebx
  int v8; // ebp
  double v9; // st6
  float v10; // [esp+64h] [ebp-320h]
  struct tagRECT Rect; // [esp+68h] [ebp-31Ch]
  CHAR MultiByteStr[4]; // [esp+78h] [ebp-30Ch]
  int v13; // [esp+7Ch] [ebp-308h]
  int v14; // [esp+80h] [ebp-304h]
  WCHAR WideCharStr; // [esp+17Ch] [ebp-208h]

  if ( dword_44D424 )
    sub_42C8C0();
  sprintf(MultiByteStr, aSS, &unk_443E5C, a5);
  MultiByteToWideChar(0, 1u, MultiByteStr, -1, &WideCharStr, 520);
  CoInitialize(0);
  dword_44D414 = (int)hWnd;
  GetClientRect(hWnd, &Rect);
  ppv = 0;
  dword_44D40C = 0;
  dword_44D410 = 0;
  dword_44D418 = 0;
  dword_44D41C = 0;
  dword_44D420 = 0;
  CoCreateInstance(&rclsid, 0, 1u, &riid, &ppv);
  (**(void (__stdcall ***)(LPVOID, void *, int *))ppv)(ppv, &unk_43E3F8, &dword_44D40C);
  (**(void (__stdcall ***)(LPVOID, void *, int *))ppv)(ppv, &unk_43E3E8, &dword_44D410);
  if ( (*(int (__stdcall **)(LPVOID, WCHAR *, _DWORD))(*(_DWORD *)ppv + 52))(ppv, &WideCharStr, 0) )
    return 0;
  (**(void (__stdcall ***)(LPVOID, void *, int *, int, int, int))ppv)(ppv, &unk_43E3D8, &dword_44D418, a3, a2, a1);
  (**(void (__stdcall ***)(LPVOID, void *, int *))ppv)(ppv, &unk_43E3C8, &dword_44D41C);
  (*(void (__stdcall **)(int, LONG *, LONG *))(*(_DWORD *)dword_44D41C + 136))(dword_44D41C, &Rect.right, &Rect.top);
  v6 = (double)Rect.right;
  v7 = v13 - Rect.bottom;
  v8 = v14 - *(_DWORD *)MultiByteStr;
  v9 = (double)(v13 - Rect.bottom) / v6;
  v10 = (double)Rect.top;
  *(float *)&Rect.left = (double)(v14 - *(_DWORD *)MultiByteStr) / v10;
  if ( v9 >= *(float *)&Rect.left )
    v9 = *(float *)&Rect.left;
  (*(void (__stdcall **)(int))(*(_DWORD *)dword_44D418 + 116))(dword_44D418);
  (*(void (__cdecl **)(int, signed int))(*(_DWORD *)dword_44D418 + 36))(dword_44D418, 1409286144);
  (*(void (__stdcall **)(int, int, int, _DWORD, _DWORD))(*(_DWORD *)dword_44D418 + 156))(
    dword_44D418,
    (signed int)(v7 - (unsigned __int64)(signed __int64)(v6 * v9)) / 2,
    (signed int)(v8 - (unsigned __int64)(signed __int64)(v10 * v9)) / 2,
    (signed __int64)(v6 * v9),
    (signed __int64)(v10 * v9));
  (*(void (__stdcall **)(int, signed int))(*(_DWORD *)dword_44D418 + 76))(dword_44D418, -1);
  (*(void (__stdcall **)(int, signed int))(*(_DWORD *)dword_44D418 + 52))(dword_44D418, -1);
  (*(void (__stdcall **)(int, signed int))(*(_DWORD *)dword_44D418 + 148))(dword_44D418, -1);
  (**(void (__stdcall ***)(LPVOID, void *, int *))ppv)(ppv, &unk_43E3B8, &dword_44D420);
  (*(void (__stdcall **)(int, int))(*(_DWORD *)dword_44D420 + 28))(
    dword_44D420,
    500 * ((unsigned __int8)word_455CB7 - 10));
  result = 1;
  dword_44D424 = 1;
  return result;
}
// 44D40C: using guessed type int dword_44D40C;
// 44D410: using guessed type int dword_44D410;
// 44D414: using guessed type int dword_44D414;
// 44D418: using guessed type int dword_44D418;
// 44D41C: using guessed type int dword_44D41C;
// 44D420: using guessed type int dword_44D420;
// 44D424: using guessed type int dword_44D424;
// 455CB7: using guessed type __int16 word_455CB7;

//----- (0042C8C0) --------------------------------------------------------
void sub_42C8C0()
{
  if ( dword_44D424 )
  {
    (*(void (__stdcall **)(int))(*(_DWORD *)dword_44D41C + 8))(dword_44D41C);
    (*(void (__stdcall **)(int))(*(_DWORD *)dword_44D418 + 8))(dword_44D418);
    (*(void (__stdcall **)(int))(*(_DWORD *)dword_44D410 + 8))(dword_44D410);
    (*(void (__stdcall **)(int))(*(_DWORD *)dword_44D40C + 8))(dword_44D40C);
    (*(void (__stdcall **)(LPVOID))(*(_DWORD *)ppv + 8))(ppv);
    (*(void (__stdcall **)(int))(*(_DWORD *)dword_44D420 + 8))(dword_44D420);
    CoUninitialize();
    dword_44D424 = 0;
  }
}
// 44D40C: using guessed type int dword_44D40C;
// 44D410: using guessed type int dword_44D410;
// 44D418: using guessed type int dword_44D418;
// 44D41C: using guessed type int dword_44D41C;
// 44D420: using guessed type int dword_44D420;
// 44D424: using guessed type int dword_44D424;

//----- (0042C920) --------------------------------------------------------
void sub_42C920()
{
  int v0; // [esp+2Ch] [ebp-Ch]
  int v1; // [esp+30h] [ebp-8h]
  int v2; // [esp+34h] [ebp-4h]

  if ( !(*(int (__stdcall **)(int, int *, int *, int *, signed int))(*(_DWORD *)dword_44D410 + 32))(
          dword_44D410,
          &v0,
          &v2,
          &v1,
          200) )
  {
    while ( 1 )
    {
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)dword_44D410 + 48))(dword_44D410, v0, v2, v1);
      if ( v0 > 36 )
      {
        switch ( v0 )
        {
          case 80:
            nullsub_1(aDebugVideoEcGr);
            break;
          case 512:
            nullsub_1(aDebugVideoEcSn_0);
            break;
          case 513:
            nullsub_1(aDebugVideoEcSn);
            break;
          default:
LABEL_37:
            nullsub_1(aDebugVideoUnko);
            break;
        }
      }
      else if ( v0 == 36 )
      {
        nullsub_1(aDebugVideoEcSt_4);
      }
      else
      {
        switch ( v0 )
        {
          case 1:
            nullsub_1(aDebugVideoEcCo);
            break;
          case 2:
            nullsub_1(aDebugVideoEcUs);
            break;
          case 3:
            nullsub_1(aDebugVideoEcEr_0);
            break;
          case 5:
            nullsub_1(aDebugVideoEcRe);
            break;
          case 6:
            nullsub_1(aDebugVideoEcSt_3);
            break;
          case 7:
            nullsub_1(aDebugVideoEcSt_2);
            break;
          case 8:
            nullsub_1(aDebugVideoEcEr);
            break;
          case 9:
            nullsub_1(aDebugVideoEcPa);
            break;
          case 10:
            nullsub_1(aDebugVideoEcVi);
            break;
          case 11:
            nullsub_1(aDebugVideoEcQu);
            break;
          case 12:
            nullsub_1(aDebugVideoEcSh);
            break;
          case 13:
            nullsub_1(aDebugVideoEcCl);
            break;
          case 14:
            nullsub_1(aDebugVideoEcPa_0);
            break;
          case 16:
            nullsub_1(aDebugVideoEcOp);
            break;
          case 17:
            nullsub_1(aDebugVideoEcBu);
            break;
          case 18:
            nullsub_1(aDebugVideoEcFu);
            break;
          case 19:
            nullsub_1(aDebugVideoEcAc);
            break;
          case 20:
            nullsub_1(aDebugVideoEcNe);
            break;
          case 21:
            nullsub_1(aDebugVideoEcWi);
            break;
          case 22:
            nullsub_1(aDebugVideoEcDi);
            break;
          case 23:
            nullsub_1(aDebugVideoEcSt);
            break;
          case 24:
            nullsub_1(aDebugVideoEcOl);
            break;
          case 25:
            nullsub_1(aDebugVideoEcNo);
            break;
          case 26:
            nullsub_1(aDebugVideoEcSt_1);
            break;
          case 27:
            nullsub_1(aDebugVideoEcSt_0);
            break;
          case 28:
            nullsub_1(aDebugVideoEcEn);
            break;
          case 29:
            nullsub_1(aDebugVideoEcSe);
            break;
          case 31:
            nullsub_1(aDebugVideoEcDe);
            break;
          default:
            goto LABEL_37;
        }
      }
      (*(void (__stdcall **)(int, signed int))(*(_DWORD *)dword_44D418 + 76))(dword_44D418, -1);
      if ( v0 == 1 || v0 == 2 || v0 == 3 )
        break;
      if ( (*(int (__stdcall **)(int, int *, int *, int *, signed int))(*(_DWORD *)dword_44D410 + 32))(
             dword_44D410,
             &v0,
             &v2,
             &v1,
             200) )
      {
        return;
      }
    }
    sub_42C8C0();
  }
}
// 434B40: using guessed type int __cdecl nullsub_1(_DWORD);
// 44D410: using guessed type int dword_44D410;
// 44D418: using guessed type int dword_44D418;

//----- (0042CBA0) --------------------------------------------------------
int sub_42CBA0()
{
  int result; // eax

  result = dword_44D424;
  if ( dword_44D424 )
  {
    sub_402B00();
    (*(void (__stdcall **)(int))(*(_DWORD *)dword_44D40C + 28))(dword_44D40C);
    result = (*(int (__stdcall **)(int, int, signed int, _DWORD))(*(_DWORD *)dword_44D410 + 52))(
               dword_44D410,
               dword_44D414,
               32769,
               0);
  }
  return result;
}
// 44D40C: using guessed type int dword_44D40C;
// 44D410: using guessed type int dword_44D410;
// 44D414: using guessed type int dword_44D414;
// 44D424: using guessed type int dword_44D424;

//----- (0042CBE0) --------------------------------------------------------
int __cdecl sub_42CBE0(int a1, char a2)
{
  sub_42CC70(a1);
  *(_BYTE *)(a1 + 116) = a2;
  return sub_407E00((int)&unk_4447D0);
}

//----- (0042CC10) --------------------------------------------------------
int __cdecl sub_42CC10(int a1)
{
  int result; // eax
  int v2; // ecx
  char v3; // al

  result = a1;
  if ( !*(_BYTE *)(a1 + 115) )
  {
    *(_BYTE *)(a1 + 115) = 1;
    *(_BYTE *)(a1 + 113) = 0;
    if ( dword_44B7C0 )
    {
      v2 = *(_DWORD *)(dword_44B7C0 + 12);
      BYTE1(v2) |= 0x40u;
      *(_DWORD *)(dword_44B7C0 + 12) = v2;
    }
    v3 = rand();
    result = sub_407E00(12 * (unsigned __int8)(-3 * v3) + 4474844);
  }
  return result;
}
// 44B7C0: using guessed type int dword_44B7C0;

//----- (0042CC70) --------------------------------------------------------
int __cdecl sub_42CC70(int a1)
{
  int result; // eax
  int v2; // ecx

  result = a1;
  *(_BYTE *)(a1 + 115) = 0;
  if ( (float *)a1 == &dword_44B71C )
  {
    byte_44B803 = 0;
    LOBYTE(dword_44B80C) = 0;
    if ( dword_44B7C0 )
    {
      v2 = *(_DWORD *)(dword_44B7C0 + 12);
      BYTE1(v2) &= 0xBFu;
      *(_DWORD *)(dword_44B7C0 + 12) = v2;
    }
    byte_44B78D = 1;
    sub_407E50((AGLSOUNDBUFFER **)&unk_4447DC);
    sub_407E50((AGLSOUNDBUFFER **)&unk_4447E8);
    result = sub_407E50((AGLSOUNDBUFFER **)&unk_4447F4);
  }
  return result;
}
// 44B78D: using guessed type char byte_44B78D;
// 44B7C0: using guessed type int dword_44B7C0;
// 44B803: using guessed type char byte_44B803;
// 44B80C: using guessed type int dword_44B80C;

//----- (0042CCD0) --------------------------------------------------------
int __cdecl sub_42CCD0(int a1)
{
  int result; // eax

  result = a1;
  if ( !*(_BYTE *)(a1 + 112) )
    result = sub_42CCF0(a1, 0.0);
  return result;
}

//----- (0042CCF0) --------------------------------------------------------
int __cdecl sub_42CCF0(int a1, float a2)
{
  int result; // eax
  int v3; // edx
  int v4; // ecx

  result = a1;
  *(float *)(a1 + 80) = a2;
  v3 = *(_DWORD *)(a1 + 140);
  *(_BYTE *)(a1 + 112) = 1;
  v4 = dword_455BE0;
  *(_DWORD *)(a1 + 68) = v3;
  *(_DWORD *)(a1 + 100) = v4;
  LOBYTE(v4) = *(_BYTE *)(a1 + 115);
  *(_BYTE *)(a1 + 114) = 0;
  if ( (_BYTE)v4 )
    result = sub_42CC70(a1);
  return result;
}
// 455BE0: using guessed type int dword_455BE0;

//----- (0042CD30) --------------------------------------------------------
int __cdecl sub_42CD30(int a1, float a2)
{
  int result; // eax

  result = a1;
  *(float *)(a1 + 80) = a2;
  return result;
}

//----- (0042CD40) --------------------------------------------------------
char __cdecl sub_42CD40(int a1, float a2)
{
  char result; // al
  float *v3; // eax
  double v4; // st7

  result = *(_BYTE *)(a1 + 112);
  if ( !result )
  {
    v3 = *(float **)(a1 + 28);
    if ( v3
      && (v4 = (*(float *)&dword_44B764 * 5.1199999 * 0.00390625 + *(float *)(a1 + 92)) * v3[9] / v3[8] * v3[4]
             + *(float *)(*(_DWORD *)(a1 + 12) + 64)
             + v3[1],
          v4 < *(float *)(a1 + 36)) )
    {
      *(float *)(a1 + 72) = *(float *)(a1 + 72) * 0.5;
      *(float *)(a1 + 36) = v4;
      result = sub_42CCF0(a1, a2);
      *(_BYTE *)(a1 + 113) = 0;
    }
    else
    {
      result = sub_42CCF0(a1, a2);
      *(_BYTE *)(a1 + 113) = 0;
    }
  }
  return result;
}
// 44B764: using guessed type int dword_44B764;

//----- (0042CDC0) --------------------------------------------------------
int __cdecl sub_42CDC0(int a1, float a2)
{
  int result; // eax

  result = sub_42CCF0(a1, a2);
  *(_BYTE *)(a1 + 120) = 1;
  return result;
}

//----- (0042CDE0) --------------------------------------------------------
char __cdecl sub_42CDE0(int a1)
{
  int v1; // eax
  int v2; // ecx
  double v3; // st7
  float *v4; // edx
  int v5; // ecx
  double v6; // st7
  int v7; // edx
  double v8; // st7
  int v9; // eax

  v1 = *(_DWORD *)(a1 + 28);
  if ( v1 )
  {
    v2 = 4 * (*(_WORD *)(v1 + 24) & 0xFFF);
    v3 = *(float *)((char *)dword_4449D4 + v2);
    v4 = *(float **)(a1 + 12);
    *(float *)(a1 + 32) = -*(float *)((char *)dword_4449D8 + v2) * *(float *)(a1 + 92) + v4[15] + *(float *)v1;
    v5 = *(_DWORD *)(a1 + 32);
    *(float *)(a1 + 40) = v3 * *(float *)(a1 + 92) + v4[17] + *(float *)(v1 + 8);
    v6 = *(float *)(v1 + 36) * *(float *)(a1 + 92) / *(float *)(v1 + 32) * *(float *)(v1 + 16) + v4[16];
    v7 = *(_DWORD *)(a1 + 40);
    v8 = v6 + *(float *)(v1 + 4);
    *(_DWORD *)(a1 + 56) = v5;
    *(_DWORD *)(a1 + 64) = v7;
    *(_BYTE *)(a1 + 112) = 0;
    *(_BYTE *)(a1 + 113) = 1;
    *(_BYTE *)(a1 + 117) = 0;
    *(float *)(a1 + 84) = v8;
    v9 = *(_DWORD *)(a1 + 84);
    *(float *)(a1 + 36) = v8;
    *(_DWORD *)(a1 + 60) = v9;
    *(_DWORD *)(a1 + 68) = *(_DWORD *)(a1 + 140);
    if ( (float *)a1 != &dword_44B71C || !(dword_455BEC & 0x4000) )
      *(_BYTE *)(a1 + 120) = 0;
    LOBYTE(v1) = sub_407E30((AGLSOUNDBUFFER **)&unk_444818);
    if ( (_BYTE)v1 )
    {
      if ( (float *)a1 != &dword_44B71C )
        goto LABEL_11;
      LOBYTE(v1) = sub_407E50((AGLSOUNDBUFFER **)&unk_444818);
    }
    if ( (float *)a1 == &dword_44B71C )
    {
      if ( *(_BYTE *)(a1 + 115) )
        goto LABEL_12;
      LOBYTE(v1) = sub_407E00((int)&unk_44483C);
      byte_44B819 = 0;
    }
LABEL_11:
    if ( !*(_BYTE *)(a1 + 115) )
    {
LABEL_14:
      *(_BYTE *)(a1 + 121) = 1;
      return v1;
    }
LABEL_12:
    if ( (float *)a1 != &dword_44B71C )
      LOBYTE(v1) = sub_42CC70(a1);
    goto LABEL_14;
  }
  return v1;
}
// 44B819: using guessed type char byte_44B819;
// 455BEC: using guessed type int dword_455BEC;

//----- (0042CEF0) --------------------------------------------------------
int __cdecl sub_42CEF0(int a1, __int16 a2)
{
  int result; // eax

  result = a1;
  *(_WORD *)(a1 + 110) = a2 & 0xFFF;
  *(_BYTE *)(a1 + 122) = 1;
  return result;
}

//----- (0042CF10) --------------------------------------------------------
void __cdecl sub_42CF10(int a1)
{
  double v1; // st7
  int v2; // eax
  double v3; // st7
  double v4; // st6
  float *v5; // eax
  double v6; // st7
  float *v7; // eax
  float *v8; // eax
  double v9; // st7

  if ( *(_DWORD *)(a1 + 28) && byte_455C14 )
  {
    if ( *(_BYTE *)(a1 + 122) )
    {
      v1 = (double)(signed __int16)sub_434580(*(_WORD *)(a1 + 108), *(_WORD *)(a1 + 110));
      sub_42D090(0, a1, (signed __int64)v1);
      *(_BYTE *)(a1 + 122) = 0;
    }
    *(_WORD *)(a1 + 108) = (*(_WORD *)(a1 + 108)
                          + (unsigned __int64)(signed __int64)(double)(signed __int16)sub_42D0F0(a1)) & 0xFFF;
  }
  if ( *(_DWORD *)a1 )
  {
    v2 = 4 * (*(_WORD *)(a1 + 108) & 0xFFF);
    v3 = *(float *)((char *)dword_4449D8 + v2);
    v4 = *(float *)((char *)dword_4449D4 + v2);
    *(float *)(*(_DWORD *)a1 + 56) = *(float *)((char *)dword_4449D4 + v2);
    *(_DWORD *)(*(_DWORD *)a1 + 68) = 0;
    *(float *)(*(_DWORD *)a1 + 80) = v3;
    *(_DWORD *)(*(_DWORD *)a1 + 60) = 0;
    *(_DWORD *)(*(_DWORD *)a1 + 72) = 1065353216;
    *(_DWORD *)(*(_DWORD *)a1 + 84) = 0;
    *(float *)(*(_DWORD *)a1 + 64) = -v3;
    *(_DWORD *)(*(_DWORD *)a1 + 76) = 0;
    *(float *)(*(_DWORD *)a1 + 88) = v4;
    *(_DWORD *)(*(_DWORD *)a1 + 92) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(*(_DWORD *)a1 + 96) = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(*(_DWORD *)a1 + 100) = *(_DWORD *)(a1 + 40);
    *(_DWORD *)(dword_44B720 + 92) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(dword_44B720 + 96) = *(_DWORD *)(a1 + 84);
    *(_DWORD *)(dword_44B720 + 100) = *(_DWORD *)(a1 + 40);
    if ( *(float *)(a1 + 36) < (double)*(float *)(a1 + 84) )
    {
      v6 = *(float *)(a1 + 84) - *(float *)(a1 + 36);
      if ( v6 < 700.0 )
      {
        v8 = (float *)(dword_44B720 + 56);
        v9 = 1.2 - v6 * 1.2 * 0.0014285714;
        *v8 = v9;
        v8[8] = v9;
      }
      else
      {
        v7 = (float *)(dword_44B720 + 56);
        *v7 = 0.015;
        v7[8] = 0.015;
      }
    }
    else
    {
      v5 = (float *)(dword_44B720 + 56);
      *v5 = 1.2;
      v5[8] = 1.2;
    }
  }
}
// 44B720: using guessed type int dword_44B720;
// 455C14: using guessed type char byte_455C14;

//----- (0042D090) --------------------------------------------------------
int __usercall sub_42D090@<eax>(int a1@<ebx>, int a2, __int16 a3)
{
  int *v3; // ecx
  int v4; // ebx
  int result; // eax

  v3 = *(int **)(a2 + 156);
  *(_DWORD *)(a2 + 152) = 0;
  LOWORD(a1) = a3 / 6;
  v4 = a1 << 16;
  LOWORD(v4) = a3 / 6;
  *v3 = v4;
  v3[1] = v4;
  v3[2] = v4;
  result = 6 * (a3 / 6);
  **(_WORD **)(a2 + 156) += a3 % 6;
  return result;
}

//----- (0042D0F0) --------------------------------------------------------
int __cdecl sub_42D0F0(int a1)
{
  _WORD *v1; // edx
  int result; // eax
  unsigned int v3; // edx

  result = *(_DWORD *)(a1 + 152);
  v1 = (_WORD *)(*(_DWORD *)(a1 + 156) + 2 * result);
  LOWORD(result) = *v1;
  *v1 = 0;
  v3 = *(_DWORD *)(a1 + 152) + 1;
  *(_DWORD *)(a1 + 152) = v3;
  if ( v3 >= 6 )
    *(_DWORD *)(a1 + 152) = 0;
  return result;
}

//----- (0042D130) --------------------------------------------------------
int __cdecl sub_42D130(int a1, int a2)
{
  int result; // eax
  __int16 v3; // cx
  int v4; // ecx

  result = a2;
  v3 = *(_WORD *)(a2 + 60);
  if ( v3 != -1 )
  {
    result = a1;
    *(_WORD *)(a1 + 104) = v3;
    *(_WORD *)(a1 + 106) = 1;
    *(_BYTE *)(a1 + 112) = 0;
    *(_BYTE *)(a1 + 113) = 0;
    *(_BYTE *)(a1 + 115) = 0;
    *(_BYTE *)(a1 + 114) = 0;
    *(_BYTE *)(a1 + 118) = 0;
    *(_BYTE *)(a1 + 120) = 0;
    *(_BYTE *)(a1 + 122) = 0;
    *(_BYTE *)(a1 + 121) = 0;
    *(_DWORD *)(a1 + 80) = 0;
    if ( (float *)a1 == &dword_44B71C )
    {
      sub_407E50((AGLSOUNDBUFFER **)&unk_444818);
      result = dword_44B7C0;
      word_44B7F2 = 0;
      if ( dword_44B7C0 )
      {
        v4 = *(_DWORD *)(dword_44B7C0 + 12);
        BYTE1(v4) |= 0x40u;
        *(_DWORD *)(dword_44B7C0 + 12) = v4;
      }
    }
  }
  return result;
}
// 44B7C0: using guessed type int dword_44B7C0;
// 44B7F2: using guessed type __int16 word_44B7F2;

//----- (0042D1A0) --------------------------------------------------------
char __cdecl sub_42D1A0(float a1)
{
  float v1; // esi
  float *v2; // ebx
  int v3; // ecx
  int v4; // edx
  unsigned __int16 v5; // ax
  int v6; // ebp
  int v7; // eax
  float *v8; // edi
  double v9; // st7
  int v10; // ecx
  char v11; // al
  double v12; // st7
  int v13; // ecx
  int v15; // [esp+0h] [ebp-10h]
  float v16; // [esp+14h] [ebp+4h]

  v1 = a1;
  v2 = (float *)(LODWORD(a1) + 32);
  v3 = *(_DWORD *)(LODWORD(a1) + 36);
  v4 = *(_DWORD *)(LODWORD(a1) + 40);
  *(_DWORD *)(LODWORD(a1) + 44) = *(_DWORD *)(LODWORD(a1) + 32);
  v5 = *(_WORD *)(LODWORD(a1) + 104);
  *(_DWORD *)(LODWORD(a1) + 48) = v3;
  *(_DWORD *)(LODWORD(a1) + 52) = v4;
  v6 = dword_455C84 + 12 * v5;
  v7 = *(_DWORD *)(v6 + 4);
  v8 = (float *)(v7 + 12 * *(unsigned __int16 *)(LODWORD(a1) + 106));
  v16 = sub_41F420((float *)(LODWORD(a1) + 32), (float *)(v7 + 12 * *(unsigned __int16 *)(LODWORD(a1) + 106))) * 256.0;
  v9 = AGLSqrt(v16);
  if ( v9 >= 92.160004 )
  {
    *v2 = (*v8 - *v2) * 92.160004 / v9 + *v2;
    *(float *)(LODWORD(v1) + 36) = (v8[1] - *(float *)(LODWORD(v1) + 36)) * 92.160004 / v9
                                 + *(float *)(LODWORD(v1) + 36);
    *(float *)(LODWORD(v1) + 40) = (v8[2] - *(float *)(LODWORD(v1) + 40)) * 92.160004 / v9
                                 + *(float *)(LODWORD(v1) + 40);
    return 1;
  }
  *v2 = *v8;
  *(float *)(LODWORD(v1) + 36) = v8[1];
  v10 = *((_DWORD *)v8 + 2);
  ++*(_WORD *)(LODWORD(v1) + 106);
  *(_DWORD *)(LODWORD(v1) + 40) = v10;
  if ( (float *)LODWORD(v1) == &dword_44B71C )
  {
    if ( HIBYTE(dword_44B808) )
    {
      if ( !sub_407E30((AGLSOUNDBUFFER **)&dword_444944) )
        sub_407E00((int)&dword_444944);
    }
    else if ( ++byte_44D428 == 3 )
    {
      v11 = rand();
      sub_407E00(12 * (unsigned __int8)(-3 * v11) + 4475048);
      byte_44D428 = 0;
    }
  }
  if ( *(_WORD *)(LODWORD(v1) + 106) != *(_WORD *)(v6 + 2) )
    return 1;
  if ( (float *)LODWORD(v1) == &dword_44B71C )
  {
    v12 = 3840.0;
    *(_DWORD *)(LODWORD(v1) + 76) = 1164967936;
  }
  else
  {
    v12 = *(float *)(LODWORD(v1) + 76);
  }
  *(_DWORD *)(LODWORD(v1) + 12) = 0;
  *(_DWORD *)(LODWORD(v1) + 20) = 0;
  *(_DWORD *)(LODWORD(v1) + 28) = 0;
  *(_DWORD *)(LODWORD(v1) + 8) = -1;
  *(_DWORD *)(LODWORD(v1) + 16) = -1;
  *(_DWORD *)(LODWORD(v1) + 24) = -1;
  if ( *v8 <= (double)*(v8 - 3) )
  {
    if ( *v8 < (double)*(v8 - 3) )
    {
      *(float *)(LODWORD(v1) + 72) = -v12;
      *(_BYTE *)(LODWORD(v1) + 123) = -1;
    }
  }
  else
  {
    *(float *)(LODWORD(v1) + 72) = v12;
    *(_BYTE *)(LODWORD(v1) + 123) = 1;
  }
  if ( (float *)LODWORD(v1) == &dword_44B71C )
  {
    if ( dword_44B7C0 )
    {
      v13 = *(_DWORD *)(dword_44B7C0 + 12);
      BYTE1(v13) &= 0xBFu;
      *(_DWORD *)(dword_44B7C0 + 12) = v13;
    }
    HIBYTE(dword_44B80C) = 1;
  }
  if ( dword_455BF8 == 10 && dword_455C80 && (_WORD)dword_44B784 == *(_WORD *)(dword_455C80 + 60) )
  {
    sub_435281((int)aTuyau11, v15);
    sub_41E7B0(&flt_44B7D8, 0, 0);
    HIBYTE(dword_44B814) = 1;
    sub_434690(4u, 1);
  }
  byte_44D428 = 0;
  *(_WORD *)(LODWORD(v1) + 104) = -1;
  dword_455BEC = 0;
  return 0;
}
// 444944: using guessed type int dword_444944;
// 44B784: using guessed type int dword_44B784;
// 44B7C0: using guessed type int dword_44B7C0;
// 44B7D8: using guessed type float flt_44B7D8;
// 44B808: using guessed type int dword_44B808;
// 44B80C: using guessed type int dword_44B80C;
// 44B814: using guessed type int dword_44B814;
// 44D428: using guessed type char byte_44D428;
// 455BEC: using guessed type int dword_455BEC;
// 455BF8: using guessed type int dword_455BF8;
// 455C80: using guessed type int dword_455C80;
// 455C84: using guessed type int dword_455C84;

//----- (0042D3D0) --------------------------------------------------------
void __cdecl sub_42D3D0(int a1)
{
  int v1; // ecx
  int v2; // edx
  int v3; // ebx
  float v4; // [esp+8h] [ebp+4h]

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 24);
  if ( v2 == -1 )
  {
    sub_42D4A0(a1, 1, 1.0);
  }
  else
  {
    v4 = *(float *)(a1 + 92);
    if ( v4 < 0.0 || v4 > (double)*(float *)(*(_DWORD *)(v1 + 28) + 32) )
    {
      v3 = *(_DWORD *)(*(_DWORD *)(v1 + 12) + 4);
      if ( v3 & 0x100 && v2 == *(unsigned __int8 *)(*(_DWORD *)(v1 + 20) + 2) - 1 )
      {
        if ( !byte_455C12 && !*(_BYTE *)(v1 + 119) )
        {
          byte_455C12 = 1;
          sub_434690(5u, 0);
        }
      }
      else
      {
        sub_42D4A0(v1, 1, v4);
      }
    }
    else if ( *(_BYTE *)(v1 + 112) )
    {
      sub_42D4A0(v1, 0, v4);
    }
    else if ( *(_BYTE *)(v1 + 118) )
    {
      sub_42D4A0(v1, 2, v4);
    }
  }
}
// 455C12: using guessed type char byte_455C12;

//----- (0042D4A0) --------------------------------------------------------
void __cdecl sub_42D4A0(int a1, int a2, float a3)
{
  int v3; // esi
  int v4; // eax
  int v5; // eax
  int v6; // eax
  float v7; // ST20_4
  float v8; // ecx
  int v9; // edx
  int v10; // eax
  float *v11; // ecx
  double v12; // st7
  double v13; // st7
  int v14; // eax
  float *v15; // eax
  float *v16; // ecx
  int v17; // eax
  float *v18; // ecx
  double v19; // st7
  int v20; // edx
  double v21; // st7
  float *v22; // eax
  float *v23; // ecx
  char v24; // al
  int v25; // ecx
  int v26; // eax
  double v27; // st7
  float *v28; // ecx
  double v29; // st7
  _BYTE *v30; // eax
  int v31; // edi
  int v32; // ecx
  unsigned __int16 v33; // ax
  double v34; // st7
  float v35; // ST20_4
  float v36; // ecx
  int v37; // edx
  int v38; // ecx
  float *v39; // eax
  double v40; // st7
  double v41; // st7
  float *v42; // eax
  double v43; // st7
  float *v44; // eax
  float *v45; // ecx
  double v46; // st7
  int v47; // [esp+Ch] [ebp-14h]
  int v48; // [esp+10h] [ebp-10h]
  char v49; // [esp+14h] [ebp-Ch]
  float v50; // [esp+18h] [ebp-8h]

  dword_44D430 = a2;
  dword_44D42C = LODWORD(a3);
  v3 = a1;
  v4 = *(_DWORD *)(a1 + 16);
  if ( v4 == -1 )
  {
    sub_42DD10(a1, &v47, &a1, &a2, (int *)&v49);
    sub_42DB20(v3, v47, a1, a2);
    return;
  }
  if ( a2 == 2 )
  {
    sub_42DB20(a1, *(_DWORD *)(a1 + 8), v4, *(_DWORD *)(a1 + 24));
    return;
  }
  if ( *(_BYTE *)(a1 + 112) )
  {
    if ( **(_BYTE **)(a1 + 20) & 0x10 )
    {
      if ( a2 != 1 )
        return;
      v24 = a3 <= 0.0 ? sub_42E490((_DWORD *)a1, &v47, &a1, &a2) : sub_42E3E0((_DWORD *)a1, &v47, &a1, &a2);
      if ( !v24 )
      {
        v25 = dword_455C38 + 12 * (a1 + *(unsigned __int16 *)(dword_455C20 + 120 * v47 + 32));
        if ( *(_BYTE *)v25 & 0x10 )
        {
          if ( sub_42DAD0(*(_DWORD *)(v25 + 8) + 44 * a2, *(float *)(v3 + 36), *(float *)(v3 + 84), *(float *)(v3 + 68)) )
            goto LABEL_13;
          if ( a3 > 0.0 )
          {
            v26 = *(_DWORD *)(v3 + 28);
            *(_DWORD *)(v3 + 92) = *(_DWORD *)(v26 + 32);
LABEL_35:
            v27 = *(float *)(v26 + 36);
            v28 = *(float **)(v3 + 12);
            *(float *)(v3 + 32) = v27 * *(float *)(v26 + 12) + v28[15] + *(float *)v26;
            *(float *)(v3 + 84) = v27 * *(float *)(v26 + 16) + v28[16] + *(float *)(v26 + 4);
            v29 = v27 * *(float *)(v26 + 20) + v28[17] + *(float *)(v26 + 8);
            *(_DWORD *)(v3 + 72) = 0;
            *(float *)(v3 + 40) = v29;
            return;
          }
          goto LABEL_53;
        }
      }
    }
    if ( a3 < (double)*(float *)(*(_DWORD *)(v3 + 28) + 32)
      || (v30 = *(_BYTE **)(v3 + 20), *(_DWORD *)(v3 + 24) != (unsigned __int8)v30[2] - 1) )
    {
      if ( a3 > 0.0 || *(_DWORD *)(v3 + 24) )
        goto LABEL_43;
      v31 = **(_BYTE **)(v3 + 20) & 1;
    }
    else
    {
      v31 = *v30 & 2;
    }
    if ( v31 )
    {
      if ( sub_42DD10(v3, &v47, &a1, &a2, (int *)&v49)
        && *(float *)(v3 + 84) - *(float *)(dword_455C20 + 120 * v47 + 64) >= v50 )
      {
        sub_42DB20(v3, v47, a1, a2);
        return;
      }
      if ( v31 != 1 )
      {
        v26 = *(_DWORD *)(v3 + 28);
        *(_DWORD *)(v3 + 92) = *(_DWORD *)(v26 + 32);
        goto LABEL_35;
      }
LABEL_53:
      v44 = *(float **)(v3 + 12);
      v45 = *(float **)(v3 + 28);
      *(_DWORD *)(v3 + 92) = 0;
      *(float *)(v3 + 32) = v44[15] + *v45;
      *(float *)(v3 + 84) = v44[16] + v45[1];
      v46 = v44[17] + v45[2];
      *(_DWORD *)(v3 + 72) = 0;
      *(float *)(v3 + 40) = v46;
      return;
    }
LABEL_43:
    if ( sub_42DD10(v3, &v47, &a1, &a2, (int *)&v49) )
    {
      v32 = dword_455C20 + 120 * v47;
      v33 = *(_WORD *)(v32 + 32);
      v34 = v50 + *(float *)(v32 + 64);
      v35 = *(float *)(v3 + 68);
      v36 = *(float *)(v3 + 36);
      v37 = *(_DWORD *)(dword_455C38 + 12 * (a1 + v33) + 8);
      v50 = v34;
      if ( !sub_42DAD0(v37 + 44 * a2, v36, v50, v35) )
      {
        v38 = *(_DWORD *)(v3 + 28);
        if ( a3 < (double)*(float *)(v38 + 32) )
        {
          if ( a3 <= 0.0 )
          {
            v42 = *(float **)(v3 + 12);
            *(_DWORD *)(v3 + 92) = 0;
            *(float *)(v3 + 32) = v42[15] + *(float *)v38;
            *(float *)(v3 + 84) = v42[16] + *(float *)(v38 + 4);
            v43 = v42[17] + *(float *)(v38 + 8);
            *(_DWORD *)(v3 + 72) = 0;
            *(float *)(v3 + 40) = v43;
          }
        }
        else
        {
          v39 = *(float **)(v3 + 12);
          *(_DWORD *)(v3 + 92) = *(_DWORD *)(v38 + 32);
          v40 = *(float *)(v38 + 36);
          *(float *)(v3 + 32) = v40 * *(float *)(v38 + 12) + v39[15] + *(float *)v38;
          *(float *)(v3 + 84) = v40 * *(float *)(v38 + 16) + v39[16] + *(float *)(v38 + 4);
          v41 = v40 * *(float *)(v38 + 20) + v39[17] + *(float *)(v38 + 8);
          *(_DWORD *)(v3 + 72) = 0;
          *(float *)(v3 + 40) = v41;
        }
        return;
      }
    }
    goto LABEL_20;
  }
  if ( a3 <= 0.0 )
    LOBYTE(v5) = sub_42E490((_DWORD *)a1, &v47, &a1, &a2);
  else
    LOBYTE(v5) = sub_42E3E0((_DWORD *)a1, &v47, &a1, &a2);
  LOBYTE(v48) = v5;
  v5 = (unsigned __int8)v5;
  if ( !(_BYTE)v5 )
  {
    if ( !sub_42DAD0(
            *(_DWORD *)(dword_455C38 + 12 * (a1 + *(unsigned __int16 *)(dword_455C20 + 120 * v47 + 32)) + 8) + 44 * a2,
            *(float *)(v3 + 36),
            *(float *)(v3 + 84),
            *(float *)(v3 + 68)) )
      goto LABEL_21;
LABEL_20:
    sub_42DB20(v3, v47, a1, a2);
    return;
  }
  v6 = v5 - 1;
  if ( !v6 )
  {
LABEL_21:
    if ( a3 <= 0.0 )
    {
      v22 = *(float **)(v3 + 12);
      v23 = *(float **)(v3 + 28);
      *(_DWORD *)(v3 + 92) = 0;
      *(float *)(v3 + 32) = v22[15] + *v23;
      *(float *)(v3 + 84) = v22[16] + v23[1];
      v21 = v22[17] + v23[2];
      v20 = *(_DWORD *)(v3 + 84);
    }
    else
    {
      v17 = *(_DWORD *)(v3 + 28);
      *(_DWORD *)(v3 + 92) = *(_DWORD *)(v17 + 32);
      v18 = *(float **)(v3 + 12);
      v19 = *(float *)(v17 + 36);
      *(float *)(v3 + 32) = v19 * *(float *)(v17 + 12) + v18[15] + *(float *)v17;
      *(float *)(v3 + 84) = v19 * *(float *)(v17 + 16) + v18[16] + *(float *)(v17 + 4);
      v20 = *(_DWORD *)(v3 + 84);
      v21 = v19 * *(float *)(v17 + 20) + v18[17] + *(float *)(v17 + 8);
    }
    *(_DWORD *)(v3 + 72) = 0;
    *(_DWORD *)(v3 + 36) = v20;
    *(float *)(v3 + 40) = v21;
    return;
  }
  if ( v6 != 1 )
    return;
  if ( sub_42DD10(v3, &v47, &a1, &a2, (int *)&v49) )
  {
    v7 = *(float *)(v3 + 68);
    v8 = *(float *)(v3 + 36);
    v9 = *(_DWORD *)(dword_455C38 + 12 * (a1 + *(unsigned __int16 *)(dword_455C20 + 120 * v47 + 32)) + 8);
    v50 = v50 + *(float *)(dword_455C20 + 120 * v47 + 64);
    if ( sub_42DAD0(v9 + 44 * a2, v8, v50, v7) )
    {
LABEL_13:
      sub_42DB20(v3, v47, a1, a2);
      return;
    }
    if ( a3 <= 0.0 )
    {
      v15 = *(float **)(v3 + 12);
      v16 = *(float **)(v3 + 28);
      *(_DWORD *)(v3 + 92) = 0;
      *(float *)(v3 + 32) = v15[15] + *v16;
      *(float *)(v3 + 84) = v15[16] + v16[1];
      v13 = v15[17] + v16[2];
    }
    else
    {
      v10 = *(_DWORD *)(v3 + 28);
      v11 = *(float **)(v3 + 12);
      *(_DWORD *)(v3 + 92) = *(_DWORD *)(v10 + 32);
      v12 = *(float *)(v10 + 36);
      *(float *)(v3 + 32) = v12 * *(float *)(v10 + 12) + v11[15] + *(float *)v10;
      *(float *)(v3 + 84) = v12 * *(float *)(v10 + 16) + v11[16] + *(float *)(v10 + 4);
      v13 = v12 * *(float *)(v10 + 20) + v11[17] + *(float *)(v10 + 8);
    }
    v14 = *(_DWORD *)(v3 + 84);
    *(_DWORD *)(v3 + 72) = 0;
    *(_DWORD *)(v3 + 36) = v14;
    *(float *)(v3 + 40) = v13;
  }
  else
  {
    sub_42DB20(v3, v47, a1, a2);
  }
}
// 44D42C: using guessed type int dword_44D42C;
// 44D430: using guessed type int dword_44D430;
// 455C20: using guessed type int dword_455C20;
// 455C38: using guessed type int dword_455C38;

//----- (0042DAD0) --------------------------------------------------------
char __cdecl sub_42DAD0(int a1, float a2, float a3, float a4)
{
  double v4; // st7

  if ( *(float *)(a1 + 40) != 0.0 )
  {
    v4 = a3 - *(float *)(a1 + 40);
    if ( a2 < v4 )
      return 0;
    if ( a2 - a4 < v4 )
      return 0;
  }
  return 1;
}

//----- (0042DB20) --------------------------------------------------------
int __cdecl sub_42DB20(int a1, int a2, int a3, int a4)
{
  int result; // eax
  int v5; // edi
  int v6; // edx
  int v7; // ecx
  double v8; // st7
  int v9; // eax
  int v10; // ecx
  int v11; // edi
  int v12; // ecx
  int v13; // edx
  double v14; // st7
  float *v15; // eax
  int v16; // edx
  _WORD *v17; // ecx
  double v18; // st7
  int v19; // esi
  float v20; // [esp+8h] [ebp-Ch]
  float v21; // [esp+Ch] [ebp-8h]
  float v22; // [esp+10h] [ebp-4h]
  float v23; // [esp+1Ch] [ebp+8h]

  result = a2;
  if ( a2 == -1 )
  {
    result = *(_DWORD *)(a1 + 8);
    if ( result == -1 )
      return result;
    if ( *(_BYTE *)(*(_DWORD *)(a1 + 12) + 4) < 0 || *(_BYTE *)(a1 + 119) )
    {
      *(_DWORD *)(a1 + 8) = -1;
      *(_DWORD *)(a1 + 16) = -1;
      *(_DWORD *)(a1 + 24) = -1;
      return sub_42CCD0(a1);
    }
    v5 = *(_DWORD *)(a1 + 16);
    v6 = *(_DWORD *)(a1 + 24);
    *(_BYTE *)(a1 + 118) = 1;
  }
  else
  {
    v6 = a4;
    v5 = a3;
  }
  if ( result != *(_DWORD *)(a1 + 8) || v5 != *(_DWORD *)(a1 + 16) || v6 != *(_DWORD *)(a1 + 24) || byte_44B792 )
  {
    *(_DWORD *)(a1 + 8) = result;
    v7 = dword_455C20;
    *(_DWORD *)(a1 + 16) = v5;
    v8 = *(float *)(a1 + 32);
    v9 = v7 + 120 * result;
    *(_DWORD *)(a1 + 12) = v9;
    v10 = v5 + *(unsigned __int16 *)(v9 + 32);
    v11 = dword_455C38;
    *(_DWORD *)(a1 + 24) = v6;
    v12 = v11 + 12 * v10;
    *(_DWORD *)(a1 + 20) = v12;
    v13 = *(_DWORD *)(v12 + 8) + 44 * v6;
    *(_DWORD *)(a1 + 28) = v13;
    v20 = v8 - *(float *)(v9 + 60);
    v21 = *(float *)(a1 + 36) - *(float *)(v9 + 64);
    v22 = *(float *)(a1 + 40) - *(float *)(v9 + 68);
    v14 = sub_42DCD0(v13, &v20);
    v15 = *(float **)(a1 + 28);
    v16 = *(_DWORD *)(a1 + 12);
    *(float *)(a1 + 92) = v14;
    v17 = *(_WORD **)(a1 + 20);
    v23 = v14 * v15[9] / v15[8] * v15[4] + v15[1] + *(float *)(v16 + 64);
    *(float *)(a1 + 84) = v23;
    if ( *v17 & 0x120 )
      goto LABEL_27;
    v18 = *(float *)(a1 + 36) - v23;
    if ( v18 >= 0.0 )
    {
      if ( *(_BYTE *)(a1 + 112) )
      {
        if ( *(float *)(a1 + 80) >= 0.0 )
          sub_42CDE0(a1);
      }
      else
      {
        *(float *)(a1 + 36) = v23;
      }
      goto LABEL_16;
    }
    if ( v18 < -64.0 )
LABEL_27:
      sub_42CCD0(a1);
LABEL_16:
    if ( *(_BYTE *)(a1 + 123) < 0 )
      sub_42CEF0(a1, *(_WORD *)(*(_DWORD *)(a1 + 28) + 24) - 2048);
    else
      sub_42CEF0(a1, *(_WORD *)(*(_DWORD *)(a1 + 28) + 24));
    v19 = *(_DWORD *)(a1 + 12);
    result = *(_DWORD *)(v19 + 4);
    if ( result & 0x200 )
    {
      BYTE1(result) &= 0xFDu;
      *(_DWORD *)(v19 + 4) = result;
    }
  }
  return result;
}
// 44B792: using guessed type char byte_44B792;
// 455C20: using guessed type int dword_455C20;
// 455C38: using guessed type int dword_455C38;

//----- (0042DCD0) --------------------------------------------------------
double __cdecl sub_42DCD0(int a1, float *a2)
{
  int v2; // eax

  v2 = 4 * (*(_WORD *)(a1 + 24) & 0xFFF);
  return (*a2 - *(float *)a1) * -*(float *)((char *)dword_4449D8 + v2)
       + *(float *)((char *)dword_4449D4 + v2) * (a2[2] - *(float *)(a1 + 8));
}

//----- (0042DD10) --------------------------------------------------------
bool __cdecl sub_42DD10(int a1, _DWORD *a2, int *a3, int *a4, int *a5)
{
  int *v5; // ebx
  float *v6; // esi
  double v7; // st7
  _DWORD *v8; // edi
  int i; // edi
  unsigned int v10; // ebp
  unsigned __int16 v11; // ax
  double v12; // st7
  int v13; // ecx
  int v14; // eax
  int v15; // ecx
  int v16; // edx
  float *v18; // edi
  unsigned int v19; // eax
  _BYTE *v20; // ebp
  double v21; // st7
  int v22; // edx
  int v23; // ecx
  int v24; // edx
  int v25; // eax
  float v26; // [esp+10h] [ebp-30h]
  signed int v27; // [esp+14h] [ebp-2Ch]
  int v28; // [esp+14h] [ebp-2Ch]
  int v29; // [esp+18h] [ebp-28h]
  float v30; // [esp+1Ch] [ebp-24h]
  float v31; // [esp+20h] [ebp-20h]
  float v32; // [esp+24h] [ebp-1Ch]
  float v33; // [esp+28h] [ebp-18h]
  float v34; // [esp+2Ch] [ebp-14h]
  float v35; // [esp+30h] [ebp-10h]
  int v36; // [esp+34h] [ebp-Ch]
  int v37; // [esp+38h] [ebp-8h]
  int v38; // [esp+3Ch] [ebp-4h]
  unsigned int v39; // [esp+44h] [ebp+4h]
  unsigned int v40; // [esp+44h] [ebp+4h]
  int v41; // [esp+54h] [ebp+14h]
  unsigned int v42; // [esp+54h] [ebp+14h]

  v5 = a5;
  v6 = (float *)a1;
  *a2 = -1;
  *a3 = -1;
  *a4 = -1;
  a5[1] = 2139081118;
  v26 = 3.4e38;
  v27 = 1;
  if ( *(_DWORD *)(a1 + 24) != -1 )
  {
    if ( *(_BYTE *)(a1 + 112) )
    {
      v7 = sub_42DFF0((float *)a1, a2, a3, a4, (float *)a5);
      v8 = (_DWORD *)dword_455C28;
      v26 = v7;
      if ( !dword_455C28 )
        goto LABEL_8;
      while ( !sub_40B140((int)v8, a1 + 32, 0.0) )
      {
        v8 = (_DWORD *)*v8;
        if ( !v8 )
          goto LABEL_8;
      }
    }
    v27 = 0;
  }
LABEL_8:
  for ( i = dword_455C28; i; i = *(_DWORD *)i )
  {
    if ( v27 || sub_40B140(i, (int)(v6 + 8), 256.0) )
    {
      v10 = 0;
      v33 = v6[11] - *(float *)(i + 60);
      v34 = v6[12] - *(float *)(i + 64);
      v35 = v6[13] - *(float *)(i + 68);
      v30 = v6[8] - *(float *)(i + 60);
      v31 = v6[9] - *(float *)(i + 64);
      v32 = v6[10] - *(float *)(i + 68);
      v41 = dword_455C38 + 12 * *(unsigned __int16 *)(i + 32);
      v11 = *(_WORD *)(i + 34);
      v39 = v11;
      if ( v11 )
      {
        do
        {
          v12 = sub_42E530(v41, (int)&v33, &v30, (unsigned int *)&v29, (float *)&v36);
          if ( v12 < v26 )
          {
            v13 = v29;
            v26 = v12;
            *a2 = *(unsigned __int8 *)(v41 + 3);
            *a3 = v10;
            v14 = v36;
            *a4 = v13;
            v15 = v37;
            v16 = v38;
            *v5 = v14;
            v5[1] = v15;
            v5[2] = v16;
          }
          ++v10;
          v41 += 12;
        }
        while ( v10 < v39 );
      }
    }
  }
  if ( *a2 != -1 )
    return 1;
  if ( dword_455C24 )
  {
    v18 = (float *)(dword_455C20 + 64);
    v28 = dword_455C24;
    do
    {
      v42 = 0;
      v33 = v6[11] - *(v18 - 1);
      v34 = v6[12] - *v18;
      v35 = v6[13] - v18[1];
      v30 = v6[8] - *(v18 - 1);
      v31 = v6[9] - *v18;
      v32 = v6[10] - v18[1];
      v19 = *((unsigned __int16 *)v18 - 15);
      v20 = (_BYTE *)(dword_455C38 + 12 * *((unsigned __int16 *)v18 - 16));
      v40 = (unsigned __int16)v19;
      if ( (_WORD)v19 )
      {
        do
        {
          if ( !(*v20 & 0x20) )
          {
            v21 = sub_42E530((int)v20, (int)&v33, &v30, (unsigned int *)&v29, (float *)&v36);
            if ( v21 < v26 )
            {
              *a2 = (unsigned __int8)v20[3];
              v22 = v29;
              v26 = v21;
              *a3 = v42;
              v23 = v36;
              *a4 = v22;
              v24 = v37;
              v25 = v38;
              *v5 = v23;
              v5[1] = v24;
              v5[2] = v25;
            }
            v19 = v40;
          }
          v20 += 12;
          ++v42;
        }
        while ( v42 < v19 );
      }
      v18 += 30;
      --v28;
    }
    while ( v28 );
  }
  return *a2 != -1;
}
// 455C20: using guessed type int dword_455C20;
// 455C24: using guessed type int dword_455C24;
// 455C38: using guessed type int dword_455C38;

//----- (0042DFF0) --------------------------------------------------------
double __cdecl sub_42DFF0(float *a1, _DWORD *a2, int *a3, int *a4, float *a5)
{
  float *v5; // ebx
  int v6; // ebp
  int v7; // ecx
  int v8; // edx
  double result; // st7
  int v10; // edi
  int v11; // esi
  int v12; // eax
  int v13; // ebp
  int v14; // esi
  int v15; // edx
  int v16; // edi
  int v17; // esi
  float v18; // [esp+10h] [ebp-18h]
  float v19; // [esp+14h] [ebp-14h]
  float v20; // [esp+18h] [ebp-10h]
  float v21; // [esp+1Ch] [ebp-Ch]
  float v22; // [esp+20h] [ebp-8h]
  float v23; // [esp+24h] [ebp-4h]
  int v24; // [esp+2Ch] [ebp+4h]

  v5 = a1;
  v6 = *((_DWORD *)a1 + 5);
  v7 = *((_DWORD *)a1 + 3);
  v8 = *((_DWORD *)a1 + 7);
  v24 = *((_DWORD *)a1 + 5);
  if ( dword_44D430 != 1 )
  {
    v21 = v5[11] - *(float *)(v7 + 60);
    v22 = v5[12] - *(float *)(v7 + 64);
    v23 = v5[13] - *(float *)(v7 + 68);
    v18 = v5[8] - *(float *)(v7 + 60);
    v19 = v5[9] - *(float *)(v7 + 64);
    v20 = v5[10] - *(float *)(v7 + 68);
    result = sub_42E1F0(v8, (int)&v21, &v18, a5);
    *a2 = *((_DWORD *)v5 + 2);
    *a3 = *((_DWORD *)v5 + 4);
    *a4 = *((_DWORD *)v5 + 6);
    return result;
  }
  v10 = *((_DWORD *)v5 + 6);
  if ( *(float *)&dword_44D42C <= 0.0 )
  {
    if ( v10 )
    {
      v13 = *((_DWORD *)v5 + 2);
      v14 = *((_DWORD *)v5 + 4);
      v16 = v10 - 1;
      v15 = v8 - 44;
    }
    else
    {
      v17 = *(unsigned __int16 *)(v6 + 4);
      if ( (unsigned __int16)v17 == 0xFFFF )
        return 3.4e38;
      v13 = *(unsigned __int8 *)(dword_455C38 + 12 * v17 + 3);
      v24 = dword_455C38 + 12 * v17;
      v7 = dword_455C20 + 120 * v13;
      v14 = v17 - *(unsigned __int16 *)(v7 + 32);
      v16 = *(unsigned __int8 *)(v24 + 2) - 1;
      v15 = *(_DWORD *)(v24 + 8) + 44 * v16;
    }
  }
  else
  {
    if ( v10 == *(unsigned __int8 *)(v24 + 2) - 1 )
    {
      v11 = *(unsigned __int16 *)(v24 + 6);
      if ( (unsigned __int16)v11 == 0xFFFF )
        return 3.4e38;
      v12 = dword_455C38 + 12 * v11;
      v13 = *(unsigned __int8 *)(dword_455C38 + 12 * v11 + 3);
      v7 = dword_455C20 + 120 * v13;
      v14 = v11 - *(unsigned __int16 *)(v7 + 32);
      v15 = *(_DWORD *)(v12 + 8);
      v16 = 0;
      goto LABEL_15;
    }
    v13 = *((_DWORD *)v5 + 2);
    v14 = *((_DWORD *)v5 + 4);
    v16 = v10 + 1;
    v15 = v8 + 44;
  }
  v12 = v24;
LABEL_15:
  if ( *(_BYTE *)v12 & 0x20 )
    return 3.4e38;
  v18 = v5[8] - *(float *)(v7 + 60);
  v19 = v5[9] - *(float *)(v7 + 64);
  v20 = v5[10] - *(float *)(v7 + 68);
  result = sub_42E1F0(v15, 0, &v18, a5);
  *a2 = v13;
  *a3 = v14;
  *a4 = v16;
  return result;
}
// 44D42C: using guessed type int dword_44D42C;
// 44D430: using guessed type int dword_44D430;
// 455C20: using guessed type int dword_455C20;
// 455C38: using guessed type int dword_455C38;

//----- (0042E1F0) --------------------------------------------------------
double __cdecl sub_42E1F0(int a1, int a2, float *a3, float *a4)
{
  int v4; // ecx
  float *v5; // edx
  int v6; // esi
  double result; // st7
  int v8; // eax
  long double v9; // st7
  long double v10; // st7
  __int16 v11; // fps
  double v12; // st7
  bool v13; // c0
  char v14; // c2
  bool v15; // c3
  char v16; // ah
  __int16 v17; // fps
  double v18; // st7
  bool v19; // c0
  char v20; // c2
  bool v21; // c3
  double v22; // st6
  double v23; // st6
  double v24; // st5
  float v25; // [esp+8h] [ebp-14h]
  float v26; // [esp+Ch] [ebp-10h]
  float v27; // [esp+14h] [ebp-8h]
  float v28; // [esp+18h] [ebp-4h]
  float v29; // [esp+20h] [ebp+4h]
  float v30; // [esp+20h] [ebp+4h]
  float v31; // [esp+20h] [ebp+4h]
  float v32; // [esp+20h] [ebp+4h]
  float v33; // [esp+24h] [ebp+8h]
  float v34; // [esp+28h] [ebp+Ch]

  v4 = a1;
  v5 = a3;
  v6 = a2;
  v29 = *(float *)(a1 + 28) + 32.0;
  if ( a2 && a3[1] > (double)v29 && *(float *)(a2 + 4) > (double)v29 )
    return 3.4e38;
  v25 = *(float *)(v4 + 4);
  v26 = *(float *)(v4 + 8);
  v30 = *(float *)(v4 + 32);
  v27 = *(float *)(v4 + 16);
  v28 = *(float *)(v4 + 20);
  v8 = 4 * (*(_WORD *)(v4 + 24) & 0xFFF);
  v9 = (*a3 - *(float *)v4) * -*(float *)((char *)dword_4449D8 + v8)
     + *(float *)((char *)dword_4449D4 + v8) * (a3[2] - v26);
  if ( a2 )
  {
    if ( fabs(v9) < 0.01999999955296516 )
      v9 = 0.0;
    if ( fabs(v9 - v30) < 0.01999999955296516 )
      v9 = v30;
    if ( v9 < 0.0 || v9 > v30 )
      return 3.4e38;
  }
  v10 = v9 * *(float *)(v4 + 36) / v30;
  v33 = v10 * *(float *)(v4 + 12) + *(float *)v4;
  *a4 = v33;
  v31 = v10 * v27 + v25;
  a4[1] = v31;
  v34 = v10 * v28 + v26;
  a4[2] = v34;
  v12 = v5[1];
  v13 = v12 < v31;
  v14 = 0;
  v15 = v12 == v31;
  v16 = HIBYTE(v11);
  if ( v6 )
  {
    if ( v13 || v15 )
      goto LABEL_18;
    v18 = *(float *)(v6 + 4);
    v19 = v18 < v31;
    v20 = 0;
    v21 = v18 == v31;
    v16 = HIBYTE(v17);
  }
  if ( !(v16 & 0x41) )
    return 3.4e38;
LABEL_18:
  v22 = v5[1] - v31;
  v32 = v22 * v22 * 0.00390625;
  v23 = v5[2] - v34;
  v24 = v23 * v23 * 0.00390625 + (*v5 - v33) * (*v5 - v33) * 0.00390625;
  if ( v6 && v24 > 256.0 )
    result = 3.4e38;
  else
    result = v24 + v32;
  return result;
}

//----- (0042E3E0) --------------------------------------------------------
char __cdecl sub_42E3E0(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  int v4; // eax
  char result; // al
  unsigned __int16 v6; // ax
  _BYTE *v7; // eax
  int v8; // eax
  int v9; // ecx

  v4 = a1[5];
  if ( a1[6] + 1 >= (unsigned int)*(unsigned __int8 *)(v4 + 2) )
  {
    if ( *(_BYTE *)v4 & 2 )
    {
      result = 1;
    }
    else
    {
      v6 = *(_WORD *)(v4 + 6);
      if ( v6 == -1 || (v7 = (_BYTE *)(dword_455C38 + 12 * v6), *v7 & 0x20) )
      {
        result = 2;
      }
      else
      {
        v8 = (unsigned __int8)v7[3];
        v9 = dword_455C20 + 120 * v8;
        *a2 = v8;
        *a3 = *(unsigned __int16 *)(a1[5] + 6) - *(unsigned __int16 *)(v9 + 32);
        *a4 = 0;
        result = 0;
      }
    }
  }
  else
  {
    *a2 = a1[2];
    *a3 = a1[4];
    *a4 = a1[6] + 1;
    result = 0;
  }
  return result;
}
// 455C20: using guessed type int dword_455C20;
// 455C38: using guessed type int dword_455C38;

//----- (0042E490) --------------------------------------------------------
char __cdecl sub_42E490(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  char result; // al
  int v5; // eax
  unsigned __int16 v6; // ax
  _BYTE *v7; // ecx
  int v8; // eax
  int v9; // edx

  if ( a1[6] )
  {
    *a2 = a1[2];
    *a3 = a1[4];
    result = 0;
    *a4 = a1[6] - 1;
  }
  else
  {
    v5 = a1[5];
    if ( *(_BYTE *)v5 & 1 )
    {
      result = 1;
    }
    else
    {
      v6 = *(_WORD *)(v5 + 4);
      if ( v6 == -1 || (v7 = (_BYTE *)(dword_455C38 + 12 * v6), *v7 & 0x20) )
      {
        result = 2;
      }
      else
      {
        v8 = (unsigned __int8)v7[3];
        v9 = dword_455C20 + 120 * v8;
        *a2 = v8;
        *a3 = *(unsigned __int16 *)(a1[5] + 4) - *(unsigned __int16 *)(v9 + 32);
        *a4 = (unsigned __int8)v7[2] - 1;
        result = 0;
      }
    }
  }
  return result;
}
// 455C20: using guessed type int dword_455C20;
// 455C38: using guessed type int dword_455C38;

//----- (0042E530) --------------------------------------------------------
double __cdecl sub_42E530(int a1, int a2, float *a3, unsigned int *a4, float *a5)
{
  unsigned int v5; // ebx
  unsigned int v6; // esi
  int v7; // edi
  double v8; // st7
  float v10; // [esp+Ch] [ebp-4h]

  v5 = *(unsigned __int8 *)(a1 + 2);
  v6 = 0;
  v7 = *(_DWORD *)(a1 + 8);
  v10 = 3.4e38;
  if ( !*(_BYTE *)(a1 + 2) )
    return 3.4e38;
  do
  {
    v8 = sub_42E1F0(v7, a2, a3, a5);
    if ( v8 < v10 )
    {
      v10 = v8;
      *a4 = v6;
    }
    v7 += 44;
    ++v6;
  }
  while ( v6 < v5 );
  return v10;
}

//----- (0042E5A0) --------------------------------------------------------
char sub_42E5A0()
{
  unsigned __int16 v0; // di
  int v1; // eax
  int v2; // ebx
  unsigned __int16 v3; // si
  int v4; // ecx
  int v5; // edx
  char result; // al
  int v7; // [esp+0h] [ebp-4h]
  int v8; // [esp+0h] [ebp-4h]

  sub_435281((int)aStartingFindal, v7);
  v0 = dword_455C44;
  LOWORD(dword_44DB98) = dword_455C3C;
  if ( !(_WORD)dword_455C3C )
    goto LABEL_18;
  if ( !(_WORD)dword_455C44 )
    goto LABEL_18;
  v1 = sub_401250(8 * (unsigned __int16)dword_455C3C);
  dword_44DB88 = v1;
  if ( !v1 )
    goto LABEL_18;
  v2 = dword_455C40;
  v3 = 0;
  if ( (_WORD)dword_44DB98 )
  {
    do
    {
      v4 = v2;
      *(_DWORD *)v1 = 0;
      *(_WORD *)(v1 + 4) = 0;
      if ( v0 )
      {
        v5 = v0;
        do
        {
          if ( *(_WORD *)(v4 + 24) == v3 )
          {
            if ( !*(_WORD *)(v1 + 4) )
              *(_DWORD *)v1 = v4;
            ++*(_WORD *)(v1 + 4);
          }
          v4 += 32;
          --v5;
        }
        while ( v5 );
      }
      v1 += 8;
      ++v3;
    }
    while ( v3 < (unsigned __int16)dword_44DB98 );
  }
  dword_44DB94 = sub_401250(2 * (unsigned __int16)dword_44DB98);
  if ( dword_44DB94 )
  {
    sub_42E690();
    sub_435281((int)aFindalgoInitia, v8);
    result = 1;
  }
  else
  {
LABEL_18:
    sub_435281((int)aFindalgoInitia_0, v8);
    result = 0;
  }
  return result;
}
// 44DB88: using guessed type int dword_44DB88;
// 44DB94: using guessed type int dword_44DB94;
// 44DB98: using guessed type int dword_44DB98;
// 455C3C: using guessed type int dword_455C3C;
// 455C40: using guessed type int dword_455C40;
// 455C44: using guessed type int dword_455C44;

//----- (0042E690) --------------------------------------------------------
_WORD *sub_42E690()
{
  _WORD *result; // eax
  int v1; // ecx

  result = (_WORD *)dword_44DB94;
  v1 = 0;
  if ( (_WORD)dword_44DB98 )
  {
    do
    {
      *result = 0;
      ++result;
      ++v1;
    }
    while ( (unsigned __int16)v1 < (unsigned __int16)dword_44DB98 );
  }
  word_44DB8C = 0;
  return result;
}
// 44DB8C: using guessed type __int16 word_44DB8C;
// 44DB94: using guessed type int dword_44DB94;
// 44DB98: using guessed type int dword_44DB98;

//----- (0042E6C0) --------------------------------------------------------
char __cdecl sub_42E6C0(unsigned __int16 a1, unsigned __int16 a2, int a3, _BYTE *a4)
{
  int v4; // ecx
  unsigned __int16 v5; // dx
  unsigned __int16 v6; // si
  int v7; // eax
  int v8; // edi
  int v10; // [esp+10h] [ebp-Ch]
  int v11; // [esp+14h] [ebp-8h]
  unsigned __int16 v12; // [esp+18h] [ebp-4h]
  char v13; // [esp+20h] [ebp+4h]

  if ( a1 < (unsigned __int16)dword_44DB98 && a2 < (unsigned __int16)dword_44DB98 && a1 != a2 )
  {
    if ( ++word_44DB8C == 0x7FFF )
      sub_42E690();
    word_44DBB0 = a1;
    dword_44DBB4 = 0;
    dword_44DBB8 = 0;
    LOWORD(dword_44DBAC) = 1;
    dword_44D440[0] = (int)&word_44DBB0;
    word_44D444 = 1;
    dword_44D448 = 0;
    dword_44D44C = 0;
    dword_44DB84 = (int)dword_44D440;
    dword_44DBA0 = (int)dword_44D440;
    LOWORD(dword_44DB9C) = 1;
    LOWORD(dword_44D438) = 1;
    v11 = 0;
    do
    {
      v4 = dword_44DB84;
      dword_44DBA8 = dword_44DB84;
      v12 = dword_44D438;
      v10 = 0;
      if ( (unsigned __int16)dword_44D438 > 0u )
      {
        do
        {
          v5 = **(_WORD **)v4;
          v6 = *(_WORD *)(dword_44DB88 + 8 * v5 + 4);
          if ( v6 )
          {
            v7 = *(_DWORD *)(dword_44DB88 + 8 * v5);
            v8 = 0;
            dword_44DBA4 = *(_DWORD *)(dword_44DB88 + 8 * v5);
            v13 = 0;
            if ( v6 > 0u )
            {
              do
              {
                if ( *(_WORD *)(dword_44DB94 + 2 * *(unsigned __int16 *)(v7 + 26)) != word_44DB8C )
                {
                  if ( v13 )
                  {
                    if ( !sub_42E960() )
                      return 0;
                    dword_44DB90 = dword_44DBA0;
                    if ( !sub_42E8E0() )
                      return 0;
                  }
                  else
                  {
                    dword_44DB80 = *(_DWORD *)v4;
                    HIWORD(dword_44DB98) = *(_WORD *)(v4 + 4);
                    dword_44DB90 = v4;
                    if ( !sub_42E8E0() )
                      return 0;
                    v13 = 1;
                  }
                  v7 = dword_44DBA4;
                  if ( *(_WORD *)(dword_44DBA4 + 26) == a2 )
                  {
                    sub_42EA40(a3, a4);
                    return 1;
                  }
                  v4 = dword_44DBA8;
                }
                v7 += 32;
                ++v8;
                dword_44DBA4 = v7;
              }
              while ( (unsigned __int16)v8 < v6 );
              if ( v13 )
                goto LABEL_24;
            }
            if ( !sub_42E9D0() )
              return 0;
          }
          else if ( !sub_42E9D0() )
          {
            return 0;
          }
          v4 = dword_44DBA8;
LABEL_24:
          v4 = *(_DWORD *)(v4 + 12);
          dword_44DBA8 = v4;
          ++v10;
        }
        while ( (unsigned __int16)v10 < v12 );
      }
      ++v11;
    }
    while ( (_WORD)v11 != 80 );
  }
  return 0;
}
// 44D438: using guessed type int dword_44D438;
// 44D440: using guessed type int dword_44D440[];
// 44D444: using guessed type __int16 word_44D444;
// 44D448: using guessed type int dword_44D448;
// 44D44C: using guessed type int dword_44D44C;
// 44DB80: using guessed type int dword_44DB80;
// 44DB84: using guessed type int dword_44DB84;
// 44DB88: using guessed type int dword_44DB88;
// 44DB8C: using guessed type __int16 word_44DB8C;
// 44DB90: using guessed type int dword_44DB90;
// 44DB94: using guessed type int dword_44DB94;
// 44DB98: using guessed type int dword_44DB98;
// 44DB9C: using guessed type int dword_44DB9C;
// 44DBA0: using guessed type int dword_44DBA0;
// 44DBA4: using guessed type int dword_44DBA4;
// 44DBA8: using guessed type int dword_44DBA8;
// 44DBAC: using guessed type int dword_44DBAC;
// 44DBB0: using guessed type __int16 word_44DBB0;
// 44DBB4: using guessed type int dword_44DBB4;
// 44DBB8: using guessed type int dword_44DBB8;

//----- (0042E8E0) --------------------------------------------------------
char sub_42E8E0()
{
  int v1; // eax

  if ( (_WORD)dword_44DBAC == 300 )
    return 0;
  v1 = 12 * (unsigned __int16)dword_44DBAC + 4512688;
  *(_WORD *)v1 = *(_WORD *)(dword_44DBA4 + 26);
  *(_DWORD *)(v1 + 4) = dword_44DBA4;
  *(_DWORD *)(v1 + 8) = dword_44DB80;
  ++*(_WORD *)(dword_44DB90 + 4);
  *(_DWORD *)dword_44DB90 = v1;
  *(_WORD *)(dword_44DB94 + 2 * *(unsigned __int16 *)(dword_44DBA4 + 26)) = word_44DB8C;
  LOWORD(dword_44DBAC) = dword_44DBAC + 1;
  return 1;
}
// 44DB80: using guessed type int dword_44DB80;
// 44DB8C: using guessed type __int16 word_44DB8C;
// 44DB90: using guessed type int dword_44DB90;
// 44DB94: using guessed type int dword_44DB94;
// 44DBA4: using guessed type int dword_44DBA4;
// 44DBAC: using guessed type int dword_44DBAC;

//----- (0042E960) --------------------------------------------------------
char sub_42E960()
{
  int *v1; // eax

  if ( (_WORD)dword_44DB9C == 115 )
    return 0;
  v1 = &dword_44D440[4 * (unsigned __int16)dword_44DB9C];
  v1[2] = dword_44DBA0;
  v1[3] = 0;
  *(_DWORD *)(dword_44DBA0 + 12) = v1;
  dword_44DBA0 = (int)v1;
  *v1 = dword_44DB80;
  *((_WORD *)v1 + 2) = HIWORD(dword_44DB98);
  LOWORD(dword_44DB9C) = dword_44DB9C + 1;
  LOWORD(dword_44D438) = dword_44D438 + 1;
  return 1;
}
// 44D438: using guessed type int dword_44D438;
// 44D440: using guessed type int dword_44D440[];
// 44DB80: using guessed type int dword_44DB80;
// 44DB98: using guessed type int dword_44DB98;
// 44DB9C: using guessed type int dword_44DB9C;
// 44DBA0: using guessed type int dword_44DBA0;

//----- (0042E9D0) --------------------------------------------------------
char sub_42E9D0()
{
  char result; // al
  int v1; // eax
  int v2; // eax

  LOWORD(dword_44D438) = dword_44D438 - 1;
  if ( !(_WORD)dword_44D438 )
    return 0;
  if ( dword_44DBA8 == dword_44DB84 )
  {
    v1 = *(_DWORD *)(dword_44DBA8 + 12);
    dword_44DB84 = v1;
    *(_DWORD *)(v1 + 8) = 0;
    result = 1;
  }
  else if ( dword_44DBA8 == dword_44DBA0 )
  {
    v2 = *(_DWORD *)(dword_44DBA8 + 8);
    dword_44DBA0 = v2;
    *(_DWORD *)(v2 + 12) = 0;
    result = 1;
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)(dword_44DBA8 + 8) + 12) = *(_DWORD *)(dword_44DBA8 + 12);
    result = 1;
    *(_DWORD *)(*(_DWORD *)(dword_44DBA8 + 12) + 8) = *(_DWORD *)(dword_44DBA8 + 8);
  }
  return result;
}
// 44D438: using guessed type int dword_44D438;
// 44DB84: using guessed type int dword_44DB84;
// 44DBA0: using guessed type int dword_44DBA0;
// 44DBA8: using guessed type int dword_44DBA8;

//----- (0042EA40) --------------------------------------------------------
int __cdecl sub_42EA40(int a1, _BYTE *a2)
{
  unsigned __int16 v2; // ax
  _DWORD *v3; // ecx
  __int64 v4; // rax

  v2 = *(_WORD *)(dword_44DB90 + 4) - 1;
  *a2 = v2;
  v3 = (_DWORD *)(a1 + 4 * v2);
  v4 = *(unsigned int *)dword_44DB90;
  if ( *(unsigned __int16 *)(dword_44DB90 + 4) - 1 > 0 )
  {
    do
    {
      --v3;
      ++HIDWORD(v4);
      *v3 = *(_DWORD *)(v4 + 4);
      LODWORD(v4) = *(_DWORD *)(v4 + 8);
    }
    while ( WORD2(v4) < *(unsigned __int16 *)(dword_44DB90 + 4) - 1 );
  }
  return v4;
}
// 44DB90: using guessed type int dword_44DB90;

//----- (0042EC80) --------------------------------------------------------
void sub_42EC80()
{
  char *v0; // eax
  char v1; // cl
  int v2; // esi
  char v3; // cl
  int v4; // edx
  int v5; // ecx
  int v6; // eax
  float v7; // ST08_4
  int v8; // eax
  char v9; // al
  int v10; // edx
  float v11; // ST0C_4
  unsigned __int8 v12; // al
  long double v13; // st7
  int v14; // eax
  int v15; // eax
  float v16; // ST08_4
  int v17; // edx
  int v18; // [esp+10h] [ebp-8h]
  float v19; // [esp+14h] [ebp-4h]

  word_44EA94 = *(_WORD *)(LODWORD(dword_44EAB0) + 16) + *(_WORD *)(*(_DWORD *)(LODWORD(dword_44EAB0) + 12) + 32);
  if ( *(_BYTE *)(dword_44EAAC + 506) )
    dword_44EAB8 = *(_DWORD *)(dword_44EAAC + 4 * *(unsigned __int8 *)(dword_44EAAC + 508) + 184);
  else
    dword_44EAB8 = 0;
  sub_417400(*(unsigned __int8 *)(*(unsigned __int8 *)(dword_44EAAC + 180) + dword_44EB0C), &v18, 1);
  v0 = (char *)dword_44EAAC;
  v1 = *(_BYTE *)(dword_44EAAC + 182);
  if ( v1 == 1 )
  {
    if ( !dword_44B7C0
      || *(_BYTE *)(dword_44B7C0 + 4) != *(_BYTE *)(*(unsigned __int8 *)(dword_44EAAC + 180) + dword_44EB0C) )
    {
      *(_BYTE *)(dword_44EAAC + 182) = 2;
      *(_BYTE *)(dword_44EAAC + 506) = 0;
LABEL_22:
      v0 = (char *)dword_44EAAC;
      goto LABEL_23;
    }
  }
  else
  {
    if ( v1 != 5 )
    {
      if ( dword_44B7C0 )
      {
        v2 = *(unsigned __int8 *)(dword_44EAAC + 180);
        if ( *(_BYTE *)(dword_44B7C0 + 4) == *(_BYTE *)(v2 + dword_44EB0C) && *(_DWORD *)(dword_44EAB4 + 12) < 0 )
        {
          if ( v1 && v1 != 4 || !*(_BYTE *)(v2 + dword_44EB20) || sub_415990(SLODWORD(dword_44EAB0), &dword_44B73C) )
            sub_42FEC0();
          else
            *(_BYTE *)(dword_44EAAC + 548) = 1;
          v0 = (char *)dword_44EAAC;
        }
      }
    }
    if ( v0[548] )
    {
      if ( sub_415990(SLODWORD(dword_44EAB0), (float *)(v18 + 32)) )
        sub_42FEC0();
      goto LABEL_22;
    }
  }
LABEL_23:
  v3 = v0[182];
  if ( *(_DWORD *)(LODWORD(dword_44EAB0) + 164) )
  {
    if ( v3 != 3 )
    {
      sub_431CC0(v0[180], 3);
      v0 = (char *)dword_44EAAC;
    }
    v0[182] = 3;
  }
  else
  {
    if ( v3 != 3 )
      goto LABEL_30;
    v0[182] = 4;
    sub_407E80(0);
  }
  v0 = (char *)dword_44EAAC;
LABEL_30:
  if ( *(_DWORD *)(dword_44EAB4 + 12) & 0x22000000 )
    return;
  sub_431E70(v0[180], v0[182]);
  sub_430DD0();
  v5 = dword_44EAAC;
  switch ( *(unsigned __int8 *)(dword_44EAAC + 182) )
  {
    case 0u:
      byte_44EAA1 = 1;
      v6 = *(unsigned __int8 *)(dword_44EAAC + 180);
      if ( *(_BYTE *)(v6 + dword_44EB20) )
      {
        LODWORD(v19) = *(unsigned __int16 *)(dword_44EB24 + 2 * v6);
        v7 = (double)SLODWORD(v19);
        sub_430230(dword_44EAB4 + 44, v7, 0);
      }
      else
      {
        v19 = *(float *)(dword_44EAB4 + 44);
        if ( fabs(*(float *)(LODWORD(dword_44EAB0) + 32) - v19) <= 5.0 )
          *(_DWORD *)(LODWORD(dword_44EAB0) + 72) = 0;
        else
          sub_430050(v19);
      }
      return;
    case 1u:
      v8 = *(_DWORD *)(dword_44EAB4 + 12);
      if ( !(v8 & 0x40) )
      {
        if ( v8 & 1 )
        {
          if ( !sub_415990(SLODWORD(dword_44EAB0), &dword_44B73C) )
            sub_42FFA0(dword_44B73C);
        }
        else if ( fabs(*(float *)(LODWORD(dword_44EAB0) + 32) - dword_44B73C) >= 200.0
               || fabs(*(float *)(LODWORD(dword_44EAB0) + 36) - dword_44B740) >= 50.0 )
        {
          sub_42FC40();
          LOBYTE(v10) = *(_BYTE *)(dword_44EAAC + 513) == 0;
          v11 = *(float *)&v10;
          LOWORD(v10) = *(_WORD *)(dword_44EAAC + 514);
          sub_42F360(v10, dword_44EAAC + 516, 200.0, v11);
        }
        else if ( byte_44B812 )
        {
          *(_BYTE *)(dword_44EAAC + 506) = 0;
          *(_BYTE *)(dword_44EAAC + 182) = 5;
          *(_BYTE *)(dword_44EAAC + 549) = 0;
          dword_44EA88 = LODWORD(dword_44B73C);
          dword_44EA8C = LODWORD(dword_44B740);
          dword_44EA90 = LODWORD(dword_44B744);
          sub_430210();
        }
        else
        {
          v9 = *(_BYTE *)(LODWORD(dword_44EAB0) + 123);
          if ( *(float *)(LODWORD(dword_44EAB0) + 32) > (double)dword_44B73C )
          {
            if ( v9 == -1 )
              byte_44EA9C = 1;
            else
              byte_44EA98 = 1;
          }
          else if ( v9 == 1 )
          {
            byte_44EA9C = 1;
          }
          else
          {
            byte_44EA99 = 1;
          }
        }
      }
      return;
    case 2u:
      if ( *(_BYTE *)(dword_44EAB4 + 12) & 1 )
        return;
      v12 = *(_BYTE *)(dword_44EAAC + 513);
      if ( !v12 )
        goto LABEL_61;
      if ( v12 <= 2u )
      {
        *(_BYTE *)(dword_44EAAC + 513) = 0;
      }
      else if ( v12 == 3 )
      {
        return;
      }
LABEL_61:
      LOWORD(v4) = *(_WORD *)(v18 + 96);
      sub_42F360(v4, v18 + 32, 200.0, 0.0);
      if ( !*(_BYTE *)(LODWORD(dword_44EAB0) + 112)
        && !*(_DWORD *)(LODWORD(dword_44EAB0) + 164)
        && word_44EA94 == *(_WORD *)(v18 + 96) )
      {
        v13 = *(float *)(LODWORD(dword_44EAB0) + 32) - *(float *)(v18 + 32);
        goto LABEL_68;
      }
      return;
    case 3u:
      LOWORD(v4) = *(_WORD *)(v18 + 60);
      sub_42F360(v4, v18 + 44, 200.0, 0.0);
      if ( !*(_BYTE *)(LODWORD(dword_44EAB0) + 112) && word_44EA94 == *(_WORD *)(v18 + 60) )
      {
        v13 = *(float *)(LODWORD(dword_44EAB0) + 32) - *(float *)(v18 + 44);
LABEL_68:
        if ( fabs(v13) < 200.0 )
          byte_44EA9C = 1;
      }
      return;
    case 4u:
      LOWORD(v4) = *(_WORD *)(dword_44EAB4 + 60);
      sub_42F360(v4, dword_44EAB4 + 44, 200.0, 0.0);
      if ( word_44EA94 == *(_WORD *)(dword_44EAB4 + 60)
        && fabs(*(float *)(LODWORD(dword_44EAB0) + 32) - *(float *)(dword_44EAB4 + 44)) < 200.0 )
      {
        *(_BYTE *)(dword_44EAAC + 506) = 0;
        *(_BYTE *)(dword_44EAAC + 182) = 0;
        sub_430210();
        sub_42FF60();
        sub_431920();
      }
      return;
    case 5u:
      if ( !byte_44B812 )
      {
        if ( sub_415990(SLODWORD(dword_44EAB0), &dword_44B73C)
          || (v5 = dword_44EAAC,
              *(unsigned __int8 *)(dword_44EAAC + 549) == *(unsigned __int8 *)(*(unsigned __int8 *)(dword_44EAAC + 180)
                                                                             + dword_44EB34)
                                                        + 2) )
        {
          sub_4315A0();
          v14 = dword_44EAAC;
          if ( dword_44B7C0
            && *(_BYTE *)(dword_44B7C0 + 4) == *(_BYTE *)(*(unsigned __int8 *)(dword_44EAAC + 180) + dword_44EB0C) )
          {
            *(_BYTE *)(dword_44EAAC + 182) = 1;
            byte_44EA9F = 1;
            sub_431CC0(*(_BYTE *)(dword_44EAAC + 180), 2);
            return;
          }
          goto LABEL_82;
        }
      }
      if ( !dword_44B7C0 )
      {
        if ( sub_415990(SLODWORD(dword_44EAB0), (float *)(v18 + 32)) )
        {
          sub_4315A0();
          v14 = dword_44EAAC;
LABEL_82:
          *(_BYTE *)(v14 + 182) = 2;
          return;
        }
        v5 = dword_44EAAC;
      }
      v15 = *(unsigned __int8 *)(v5 + 180);
      if ( *(unsigned __int8 *)(v5 + 549) >= *(unsigned __int8 *)(v15 + dword_44EB34) + 2 )
      {
        if ( !sub_431BB0() )
        {
          LOWORD(v17) = *(_WORD *)(dword_44EAB4 + 60);
          sub_42F360(v17, dword_44EAB4 + 44, 200.0, 0.0);
        }
      }
      else
      {
        LODWORD(v19) = *(unsigned __int16 *)(dword_44EB30 + 2 * v15);
        v16 = (double)SLODWORD(v19);
        sub_430230((int)&dword_44EA88, v16, 1);
      }
      return;
    default:
      return;
  }
}
// 44B7C0: using guessed type int dword_44B7C0;
// 44B812: using guessed type char byte_44B812;
// 44EA88: using guessed type int dword_44EA88;
// 44EA8C: using guessed type int dword_44EA8C;
// 44EA90: using guessed type int dword_44EA90;
// 44EA94: using guessed type __int16 word_44EA94;
// 44EA98: using guessed type char byte_44EA98;
// 44EA99: using guessed type char byte_44EA99;
// 44EA9C: using guessed type char byte_44EA9C;
// 44EA9F: using guessed type char byte_44EA9F;
// 44EAA1: using guessed type char byte_44EAA1;
// 44EAB4: using guessed type int dword_44EAB4;
// 44EAB8: using guessed type int dword_44EAB8;
// 44EB0C: using guessed type int dword_44EB0C;
// 44EB20: using guessed type int dword_44EB20;
// 44EB24: using guessed type int dword_44EB24;
// 44EB30: using guessed type int dword_44EB30;
// 44EB34: using guessed type int dword_44EB34;

//----- (0042F360) --------------------------------------------------------
char __cdecl sub_42F360(int a1, int a2, float a3, float a4)
{
  int v4; // edi
  long double v5; // st7
  _BYTE *v6; // eax
  unsigned __int16 v7; // cx
  char result; // al
  unsigned __int8 v9; // cl
  int v10; // ecx
  int v11; // edx
  float v12; // ecx
  int v13; // ecx
  unsigned __int8 v14; // al
  float v15; // edi
  int v16; // eax
  __int16 v17; // dx
  unsigned __int8 v18; // al
  float v19; // [esp+Ch] [ebp-4h]
  float v20; // [esp+20h] [ebp+10h]
  float v21; // [esp+20h] [ebp+10h]
  float v22; // [esp+20h] [ebp+10h]

  v4 = LODWORD(dword_44EAB0);
  v5 = fabs(*(float *)(LODWORD(dword_44EAB0) + 72)) * 0.02;
  v19 = v5;
  if ( v5 < 50.0 )
    v19 = 50.0;
  v6 = (_BYTE *)dword_44EAAC;
  if ( !*(_BYTE *)(dword_44EAAC + 506) || !dword_44EAB8 )
    goto LABEL_13;
  v7 = word_44EA94;
  if ( !*(_BYTE *)(LODWORD(dword_44EAB0) + 112)
    && word_44EA94 != *(_WORD *)(dword_44EAB8 + 24)
    && word_44EA94 != *(_WORD *)(dword_44EAB8 + 26)
    || word_44EA94 == (_WORD)a1
    || LOBYTE(a4)
    && (_WORD)a1 != *(_WORD *)(*(_DWORD *)(dword_44EAAC + 4 * *(unsigned __int8 *)(dword_44EAAC + 507) + 180) + 26)
    && *(_BYTE *)(dword_44EAAC + 509) != 5 )
  {
    *(_BYTE *)(dword_44EAAC + 506) = 0;
    *(_BYTE *)(dword_44EAAC + 509) = 0;
    v4 = LODWORD(dword_44EAB0);
    v6 = (_BYTE *)dword_44EAAC;
LABEL_13:
    v7 = word_44EA94;
  }
  if ( !v6[506] )
  {
    if ( v7 == (_WORD)a1 )
      goto LABEL_24;
    *(_BYTE *)(dword_44EAAC + 506) = sub_42E6C0(v7, a1, (int)(v6 + 184), v6 + 507);
    if ( *(_BYTE *)(dword_44EAAC + 506) )
    {
      *(_BYTE *)(dword_44EAAC + 508) = 0;
      dword_44EAB8 = *(_DWORD *)(dword_44EAAC + 184);
      *(_BYTE *)(dword_44EAAC + 509) = 4;
      *(_BYTE *)(dword_44EAAC + 546) = 1;
      *(_BYTE *)(dword_44EAAC + 547) = 0;
    }
    else
    {
      *(_BYTE *)(dword_44EAAC + 546) = 0;
    }
    v6 = (_BYTE *)dword_44EAAC;
    if ( *(_BYTE *)(dword_44EAAC + 513) )
    {
      v4 = LODWORD(dword_44EAB0);
    }
    else
    {
      *(_WORD *)(dword_44EAAC + 544) = a1;
      v4 = LODWORD(dword_44EAB0);
      v6 = (_BYTE *)dword_44EAAC;
    }
    v7 = word_44EA94;
  }
  if ( v7 == (_WORD)a1 )
  {
LABEL_24:
    if ( !v6[506] )
    {
      if ( LOBYTE(a4) )
      {
        if ( fabs(*(float *)(v4 + 32) - *(float *)a2) > a3 || fabs(*(float *)(v4 + 36) - *(float *)(a2 + 4)) > 50.0 )
        {
          sub_42FFA0(*(float *)a2);
          if ( byte_44B78C )
          {
            if ( byte_44B797 != *(_BYTE *)(LODWORD(dword_44EAB0) + 123)
              && *(float *)&dword_44B76C < 0.0
              && !*(_BYTE *)(LODWORD(dword_44EAB0) + 112) )
            {
              byte_44EA9A = 1;
              return 1;
            }
          }
        }
        return 1;
      }
      if ( !v6[513] )
      {
        if ( *(_BYTE *)(v4 + 112) )
        {
          if ( fabs(*(float *)(v4 + 32) - *(float *)a2) > a3 || !sub_415990(v4, (float *)a2) )
          {
            sub_42FFA0(*(float *)a2);
            return 1;
          }
        }
        else if ( sub_430D30(v4 + 32, a2, a3) == a3
               || fabs(*(float *)(LODWORD(dword_44EAB0) + 36) - *(float *)(a2 + 4)) > 50.0 )
        {
          sub_42FFA0(*(float *)a2);
          return 1;
        }
        return 1;
      }
      if ( sub_415990(v4, (float *)a2) && fabs(*(float *)(LODWORD(dword_44EAB0) + 32) - *(float *)a2) <= v19 )
      {
        *(_DWORD *)(LODWORD(dword_44EAB0) + 72) = 0;
        result = 1;
      }
      else
      {
        sub_42FFA0(*(float *)a2);
        result = 1;
      }
      return result;
    }
    goto LABEL_47;
  }
  if ( !v6[506] )
    return 0;
LABEL_47:
  if ( !*(_BYTE *)(v4 + 112) && v6[547] )
  {
    byte_44EA9A = 1;
    v6[547] = 0;
    v6 = (_BYTE *)dword_44EAAC;
  }
  switch ( v6[509] )
  {
    case 0:
      v6[510] = 0;
      *(_BYTE *)(dword_44EAAC + 512) = 0;
      return 1;
    case 1:
    case 2:
    case 3:
      v6[512] = 0;
      v9 = *(_BYTE *)(dword_44EAAC + 510);
      if ( v9 < *(_BYTE *)(dword_44EAAC + 511) )
      {
        *(_BYTE *)(dword_44EAAC + 510) = v9 + 1;
        return 1;
      }
      *(_BYTE *)(dword_44EAAC + 510) = 0;
      *(_BYTE *)(dword_44EAAC + 511) = 0;
      v10 = dword_44EAAC;
      switch ( *(_BYTE *)(dword_44EAAC + 509) )
      {
        case 1:
          *(_BYTE *)(dword_44EAAC + 509) = 4;
          result = 1;
          break;
        case 2:
LABEL_68:
          *(_BYTE *)(v10 + 509) = 5;
          result = 1;
          break;
        case 3:
          *(_BYTE *)(dword_44EAAC + 506) = 0;
          result = 1;
          break;
        default:
          return 1;
      }
      return result;
    case 4:
      v6[510] = 0;
      *(_BYTE *)(dword_44EAAC + 512) = 0;
      v11 = dword_44EAB8;
      if ( word_44EA94 == *(_WORD *)(dword_44EAB8 + 26) )
      {
        sub_42FFD0(0, 4);
        v11 = dword_44EAB8;
      }
      v12 = dword_44EAB0;
      if ( *(_WORD *)(LODWORD(dword_44EAB0) + 104) != -1 && *(_BYTE *)(v11 + 28) == 40 )
      {
        *(_BYTE *)(dword_44EAAC + 509) = 5;
        v12 = dword_44EAB0;
        v11 = dword_44EAB8;
      }
      v20 = (double)*(signed int *)v11;
      if ( fabs(*(float *)(LODWORD(v12) + 32) - v20) <= v19 )
      {
        switch ( *(unsigned __int8 *)(v11 + 28) )
        {
          case 0u:
            v10 = dword_44EAAC;
            byte_44EA98 = 1;
            goto LABEL_68;
          case 1u:
            goto LABEL_73;
          case 0xAu:
          case 0xBu:
          case 0xCu:
            if ( !*(_BYTE *)(LODWORD(v12) + 112) )
            {
              sub_430050(v20);
              *(_BYTE *)(dword_44EAAC + 547) = 1;
              v13 = dword_44EAAC;
              goto LABEL_114;
            }
            sub_430050(v20);
            return 1;
          case 0x14u:
            if ( *(_BYTE *)(LODWORD(v12) + 123) == -1 )
              goto LABEL_75;
            if ( *(_BYTE *)(LODWORD(v12) + 112) )
              return 1;
            byte_44EA99 = 1;
            *(_BYTE *)(dword_44EAAC + 509) = 5;
            return 1;
          case 0x15u:
            if ( *(_BYTE *)(LODWORD(v12) + 123) == 1 )
            {
LABEL_73:
              byte_44EA99 = 1;
              *(_BYTE *)(dword_44EAAC + 509) = 5;
              return 1;
            }
            if ( *(_BYTE *)(LODWORD(v12) + 112) )
              return 1;
LABEL_75:
            byte_44EA98 = 1;
            *(_BYTE *)(dword_44EAAC + 509) = 5;
            result = 1;
            break;
          case 0x16u:
          case 0x17u:
            if ( *(_BYTE *)(LODWORD(v12) + 112) )
            {
              sub_430050(v20);
            }
            else
            {
              byte_44EA9A = 1;
              *(_BYTE *)(dword_44EAAC + 509) = 5;
            }
            return 1;
          case 0x1Eu:
            if ( fabs((double)*(signed int *)(v11 + 4) - *(float *)(LODWORD(v12) + 36)) >= 50.0 )
              return 1;
            byte_44EA9D = 1;
            return 1;
          case 0x1Fu:
            sub_42FFA0(v20);
            return 1;
          default:
            return 1;
        }
      }
      else
      {
        sub_42FFA0(v20);
        result = 1;
      }
      return result;
    case 5:
      v6[510] = 0;
      v13 = dword_44EAAC;
      v14 = *(_BYTE *)(dword_44EAAC + 512);
      if ( v14 < 0x14u )
      {
        *(_BYTE *)(dword_44EAAC + 512) = v14 + 1;
        v15 = dword_44EAB0;
        v13 = dword_44EAAC;
LABEL_88:
        v16 = dword_44EAB8;
        goto LABEL_89;
      }
      v15 = dword_44EAB0;
      if ( fabs(*(float *)(LODWORD(dword_44EAB0) + 32) - *(float *)(LODWORD(dword_44EAB0) + 44)) >= 16.0
        || fabs(*(float *)(LODWORD(dword_44EAB0) + 36) - *(float *)(LODWORD(dword_44EAB0) + 48)) >= 16.0 )
      {
        goto LABEL_88;
      }
      v16 = dword_44EAB8;
      if ( *(_BYTE *)(dword_44EAB8 + 28) != 40 )
      {
        *(_BYTE *)(dword_44EAAC + 506) = 0;
        *(_BYTE *)(dword_44EAAC + 512) = 0;
        return 1;
      }
LABEL_89:
      if ( word_44EA94 == *(_WORD *)(v16 + 26) )
      {
        switch ( *(unsigned __int8 *)(v16 + 28) )
        {
          case 0u:
          case 1u:
          case 0x1Eu:
          case 0x1Fu:
          case 0x28u:
            sub_42FFD0(0, 4);
            return 1;
          case 0xAu:
          case 0xBu:
          case 0xCu:
            v21 = (double)*(signed int *)(v16 + 12);
            if ( fabs(*(float *)(LODWORD(v15) + 32) - v21) <= v19 )
            {
              sub_430050(v21);
              sub_42FFD0(0, 1);
            }
            else
            {
              sub_42FFA0(v21);
            }
            return 1;
          case 0x14u:
            if ( *(float *)(LODWORD(v15) + 72) <= 0.0 )
              goto LABEL_110;
            byte_44EA98 = 1;
            return 1;
          case 0x15u:
            if ( *(float *)(LODWORD(v15) + 72) < 0.0 )
              goto LABEL_103;
            goto LABEL_110;
          case 0x16u:
          case 0x17u:
            goto LABEL_110;
          default:
            return 1;
        }
        return 1;
      }
      v17 = *(_WORD *)(v16 + 24);
      if ( word_44EA94 != v17 )
      {
        if ( *(_WORD *)(v13 + 504) == v17 )
        {
          v18 = *(_BYTE *)(v16 + 28);
          if ( v18 >= 0x14u && v18 <= 0x15u )
          {
LABEL_114:
            *(_BYTE *)(v13 + 509) = 2;
            *(_BYTE *)(dword_44EAAC + 511) = 2;
            return 1;
          }
        }
        else
        {
          v22 = (double)*(signed int *)(v16 + 12);
          if ( fabs(*(float *)(LODWORD(v15) + 32) - v22) > v19 )
          {
            sub_42FFA0(v22);
            return 1;
          }
LABEL_117:
          sub_430050(v22);
        }
        return 1;
      }
      switch ( *(unsigned __int8 *)(v16 + 28) )
      {
        case 0u:
        case 0x14u:
        case 0x16u:
          byte_44EA98 = 1;
          result = 1;
          break;
        case 1u:
        case 0x15u:
        case 0x17u:
LABEL_103:
          byte_44EA99 = 1;
          result = 1;
          break;
        case 0xBu:
        case 0xCu:
          v22 = (double)*(signed int *)(v16 + 12);
          if ( fabs(*(float *)(LODWORD(v15) + 32) - v22) <= v19 )
            goto LABEL_117;
          sub_42FFA0(v22);
          result = 1;
          break;
        case 0x28u:
          if ( *(_WORD *)(LODWORD(v15) + 104) != -1 )
            return 1;
LABEL_110:
          sub_42FFD0(1, 1);
          result = 1;
          break;
        default:
          return 1;
      }
      return result;
    default:
      return 1;
  }
}
// 44B76C: using guessed type int dword_44B76C;
// 44B78C: using guessed type char byte_44B78C;
// 44B797: using guessed type char byte_44B797;
// 44EA94: using guessed type __int16 word_44EA94;
// 44EA98: using guessed type char byte_44EA98;
// 44EA99: using guessed type char byte_44EA99;
// 44EA9A: using guessed type char byte_44EA9A;
// 44EA9D: using guessed type char byte_44EA9D;
// 44EAB8: using guessed type int dword_44EAB8;

//----- (0042FC40) --------------------------------------------------------
char sub_42FC40()
{
  __int16 v0; // si
  __int16 v1; // dx
  int v2; // ecx
  char result; // al
  char *v4; // [esp+0h] [ebp-8h]

  if ( (_WORD)dword_44B784 == -1 )
  {
    v0 = dword_44B838;
    v1 = dword_44B72C + *(_WORD *)(dword_44B728 + 32);
    word_44E9D2 = dword_44B72C + *(_WORD *)(dword_44B728 + 32);
  }
  else
  {
    v1 = sub_431960(
           (float *)(*(_DWORD *)(dword_455C84 + 12 * (unsigned __int16)dword_44B784 + 4)
                   + 12 * *(unsigned __int16 *)(dword_455C84 + 12 * (unsigned __int16)dword_44B784 + 2)
                   - 12),
           0,
           v4);
    word_44E9D2 = v1;
    v0 = v1;
  }
  v2 = dword_44EAAC;
  if ( *(_BYTE *)(dword_44EAAC + 513) == 1 )
  {
    if ( word_44EA94 != *(_WORD *)(dword_44EAAC + 514)
      || fabs(*(float *)(LODWORD(dword_44EAB0) + 32) - *(float *)(dword_44EAAC + 516)) >= 200.0 )
    {
      goto LABEL_16;
    }
LABEL_14:
    *(_BYTE *)(dword_44EAAC + 513) = 0;
    goto LABEL_15;
  }
  if ( *(_BYTE *)(dword_44EAAC + 513) == 2 )
  {
    if ( v1 != v0 )
      goto LABEL_16;
    goto LABEL_14;
  }
  if ( *(_BYTE *)(dword_44EAAC + 513) == 3 && v1 == v0 && *(_WORD *)(dword_44EAAC + 544) != v1 )
  {
    *(_BYTE *)(dword_44EAAC + 513) = 0;
    *(_BYTE *)(dword_44EAAC + 546) = 1;
LABEL_15:
    v1 = word_44E9D2;
    v2 = dword_44EAAC;
  }
LABEL_16:
  if ( !*(_BYTE *)(v2 + 513) )
  {
    if ( v1 == v0 )
    {
      if ( *(_BYTE *)(v2 + 546) )
      {
        if ( !*(_BYTE *)(v2 + 506)
          || !dword_44EAB8
          || v1 != *(_WORD *)(*(_DWORD *)(v2 + 4 * *(unsigned __int8 *)(v2 + 507) + 180) + 26) )
        {
          goto LABEL_26;
        }
        *(_WORD *)(v2 + 528) = v1;
        *(float *)(dword_44EAAC + 532) = dword_44B73C;
        *(float *)(dword_44EAAC + 536) = dword_44B740;
        *(float *)(dword_44EAAC + 540) = dword_44B744;
      }
      else
      {
        *(_BYTE *)(v2 + 513) = 3;
        *(_WORD *)(dword_44EAAC + 514) = *(_WORD *)(dword_44EAAC + 528);
        *(_DWORD *)(dword_44EAAC + 516) = *(_DWORD *)(dword_44EAAC + 532);
        *(_DWORD *)(dword_44EAAC + 520) = *(_DWORD *)(dword_44EAAC + 536);
        *(_DWORD *)(dword_44EAAC + 524) = *(_DWORD *)(dword_44EAAC + 540);
      }
    }
    else
    {
      *(_BYTE *)(v2 + 513) = 2;
      *(_WORD *)(dword_44EAAC + 514) = v0;
      *(float *)(dword_44EAAC + 516) = *(float *)&dword_44B83C;
      *(float *)(dword_44EAAC + 520) = *(float *)&dword_44B840;
      *(float *)(dword_44EAAC + 524) = *(float *)&dword_44B844;
    }
    v1 = word_44E9D2;
    v2 = dword_44EAAC;
  }
LABEL_26:
  result = *(_BYTE *)(v2 + 513);
  if ( !result )
  {
    *(_WORD *)(v2 + 514) = v1;
    *(float *)(dword_44EAAC + 516) = dword_44B73C;
    result = dword_44EAAC;
    *(float *)(dword_44EAAC + 520) = dword_44B740;
    *(float *)(dword_44EAAC + 524) = dword_44B744;
  }
  return result;
}
// 44B728: using guessed type int dword_44B728;
// 44B72C: using guessed type int dword_44B72C;
// 44B784: using guessed type int dword_44B784;
// 44B838: using guessed type int dword_44B838;
// 44B83C: using guessed type int dword_44B83C;
// 44B840: using guessed type int dword_44B840;
// 44B844: using guessed type int dword_44B844;
// 44E9D2: using guessed type __int16 word_44E9D2;
// 44EA94: using guessed type __int16 word_44EA94;
// 44EAB8: using guessed type int dword_44EAB8;
// 455C84: using guessed type int dword_455C84;

//----- (0042FEC0) --------------------------------------------------------
char sub_42FEC0()
{
  char result; // al
  int v1; // ecx

  result = byte_44B812;
  if ( !byte_44B812 )
  {
    v1 = dword_44EAAC;
    result = *(_BYTE *)(dword_44EAAC + 182);
    if ( result != 5 || !(*(_BYTE *)(dword_44EAB4 + 12) & 9) )
    {
      if ( result != 2 )
      {
        byte_44EA9F = 1;
        sub_431CC0(*(_BYTE *)(dword_44EAAC + 180), 2);
        v1 = dword_44EAAC;
      }
      *(_BYTE *)(v1 + 182) = 1;
      *(_BYTE *)(dword_44EAAC + 546) = 1;
      *(_BYTE *)(dword_44EAAC + 513) = 0;
      *(_BYTE *)(dword_44EAAC + 506) = 0;
      *(_BYTE *)(dword_44EAAC + 547) = 0;
      *(_BYTE *)(dword_44EAAC + 548) = 0;
      result = LOBYTE(dword_44EAB0);
      *(_BYTE *)(LODWORD(dword_44EAB0) + 160) = 0;
    }
  }
  return result;
}
// 44B812: using guessed type char byte_44B812;
// 44EA9F: using guessed type char byte_44EA9F;
// 44EAB4: using guessed type int dword_44EAB4;

//----- (0042FF60) --------------------------------------------------------
char sub_42FF60()
{
  char result; // al

  result = 0;
  byte_44EA98 = 0;
  byte_44EA99 = 0;
  byte_44EA9A = 0;
  byte_44EA9B = 0;
  byte_44EA9C = 0;
  byte_44EA9D = 0;
  byte_44EA9E = 0;
  byte_44EA9F = 0;
  byte_44EAA0 = 0;
  byte_44EAA1 = 0;
  byte_44EAA2 = 0;
  return result;
}
// 44EA98: using guessed type char byte_44EA98;
// 44EA99: using guessed type char byte_44EA99;
// 44EA9A: using guessed type char byte_44EA9A;
// 44EA9B: using guessed type char byte_44EA9B;
// 44EA9C: using guessed type char byte_44EA9C;
// 44EA9D: using guessed type char byte_44EA9D;
// 44EA9E: using guessed type char byte_44EA9E;
// 44EA9F: using guessed type char byte_44EA9F;
// 44EAA0: using guessed type char byte_44EAA0;
// 44EAA1: using guessed type char byte_44EAA1;
// 44EAA2: using guessed type char byte_44EAA2;

//----- (0042FFA0) --------------------------------------------------------
void __cdecl sub_42FFA0(float a1)
{
  if ( *(float *)(LODWORD(dword_44EAB0) + 32) <= (double)a1 )
    byte_44EA99 = 1;
  else
    byte_44EA98 = 1;
}
// 44EA98: using guessed type char byte_44EA98;
// 44EA99: using guessed type char byte_44EA99;

//----- (0042FFD0) --------------------------------------------------------
char __cdecl sub_42FFD0(char a1, char a2)
{
  char result; // al

  if ( *(unsigned __int8 *)(dword_44EAAC + 508) == *(unsigned __int8 *)(dword_44EAAC + 507) - 1 )
  {
    result = a1;
    if ( a1 )
      *(_BYTE *)(dword_44EAAC + 509) = 3;
    else
      *(_BYTE *)(dword_44EAAC + 506) = 0;
  }
  else
  {
    ++*(_BYTE *)(dword_44EAAC + 508);
    *(_BYTE *)(dword_44EAAC + 509) = a2;
    if ( a2 == 1 )
    {
      result = dword_44EAAC;
      *(_BYTE *)(dword_44EAAC + 511) = 1;
    }
    else
    {
      result = a2 - 2;
      if ( a2 == 2 )
        *(_BYTE *)(dword_44EAAC + 511) = 2;
    }
  }
  return result;
}

//----- (00430050) --------------------------------------------------------
int __cdecl sub_430050(float a1)
{
  int result; // eax

  result = *(_DWORD *)(LODWORD(dword_44EAB0) + 12);
  *(float *)(LODWORD(dword_44EAB0) + 72) = ((a1
                                           - (double)(signed int)(signed __int64)**(float **)(LODWORD(dword_44EAB0) + 28)
                                           - *(float *)(result + 60))
                                          / -*((float *)dword_4449D8
                                             + (*(_WORD *)(*(_DWORD *)(LODWORD(dword_44EAB0) + 28) + 24) & 0xFFF))
                                          - *(float *)(LODWORD(dword_44EAB0) + 92))
                                         * 256.0
                                         * 0.1953125;
  byte_44EAA2 = 1;
  return result;
}
// 44EAA2: using guessed type char byte_44EAA2;

//----- (004300B0) --------------------------------------------------------
int sub_4300B0()
{
  double v0; // st7
  float v1; // eax

  v0 = *(float *)&dword_4412A4 + *(float *)(LODWORD(dword_44EAB0) + 32);
  flt_44E9E4 = v0;
  flt_44E9E8 = *(float *)&dword_4412A8 + *(float *)(LODWORD(dword_44EAB0) + 36);
  v1 = *(float *)(LODWORD(dword_44EAB0) + 40);
  dword_44E9F4 = 0;
  flt_44E9D8 = v0;
  dword_44E9EC = LODWORD(v1);
  flt_44E9DC = flt_44E9E8 - 400.0;
  flt_44E9E0 = v1 - 1600.0;
  sub_40A9F0(&flt_44E9D8);
  return sub_40AD00((int)&flt_44E9D8, 5120.0);
}
// 4412A4: using guessed type int dword_4412A4;
// 4412A8: using guessed type int dword_4412A8;
// 44E9D8: using guessed type float flt_44E9D8;
// 44E9DC: using guessed type float flt_44E9DC;
// 44E9E0: using guessed type float flt_44E9E0;
// 44E9E4: using guessed type float flt_44E9E4;
// 44E9E8: using guessed type float flt_44E9E8;
// 44E9EC: using guessed type int dword_44E9EC;
// 44E9F4: using guessed type int dword_44E9F4;

//----- (00430130) --------------------------------------------------------
void __cdecl sub_430130(_DWORD *a1)
{
  *(_DWORD *)(LODWORD(dword_44EAB0) + 72) = 0;
  *(_DWORD *)(LODWORD(dword_44EAB0) + 92) = 0;
  *(_DWORD *)(LODWORD(dword_44EAB0) + 32) = *a1;
  *(_DWORD *)(LODWORD(dword_44EAB0) + 36) = a1[1];
  *(_DWORD *)(LODWORD(dword_44EAB0) + 40) = a1[2];
  *(_DWORD *)(LODWORD(dword_44EAB0) + 44) = *a1;
  *(_DWORD *)(LODWORD(dword_44EAB0) + 48) = a1[1];
  *(_DWORD *)(LODWORD(dword_44EAB0) + 52) = a1[2];
  *(_DWORD *)(LODWORD(dword_44EAB0) + 84) = a1[1];
  *(_DWORD *)(LODWORD(dword_44EAB0) + 8) = -1;
  *(_DWORD *)(LODWORD(dword_44EAB0) + 16) = -1;
  *(_DWORD *)(LODWORD(dword_44EAB0) + 24) = -1;
  *(_DWORD *)(LODWORD(dword_44EAB0) + 12) = 0;
  *(_DWORD *)(LODWORD(dword_44EAB0) + 20) = 0;
  *(_DWORD *)(LODWORD(dword_44EAB0) + 28) = 0;
  *(_WORD *)(LODWORD(dword_44EAB0) + 104) = -1;
  sub_4300B0();
  sub_42D4A0(SLODWORD(dword_44EAB0), 1, 1.0);
  *(_BYTE *)(LODWORD(dword_44EAB0) + 113) = 0;
}

//----- (00430210) --------------------------------------------------------
int sub_430210()
{
  int result; // eax

  LOBYTE(result) = 0;
  *(_BYTE *)(dword_44EAAC + 510) = 0;
  *(_BYTE *)(dword_44EAAC + 509) = 0;
  return result;
}

//----- (00430230) --------------------------------------------------------
unsigned __int8 __cdecl sub_430230(int a1, float a2, char a3)
{
  unsigned __int8 *v3; // ecx
  unsigned __int8 v4; // bl
  int v5; // ecx
  unsigned __int8 result; // al
  int v7; // edx

  v3 = (unsigned __int8 *)dword_44EAAC;
  if ( fabs(*(float *)a1 - *(float *)(LODWORD(dword_44EAB0) + 32)) < a2
    || !*(_BYTE *)(dword_44EAAC + 509) && *(_BYTE *)(dword_44EAAC + 510) < 5u )
  {
    if ( *(_BYTE *)(LODWORD(dword_44EAB0) + 123) == -1 )
      byte_44EA98 = 1;
    else
      byte_44EA99 = 1;
    *(_BYTE *)(dword_44EAAC + 509) = 0;
    goto LABEL_32;
  }
  if ( !a3
    && !dword_455BF8
    && !*(_BYTE *)(dword_44EAAC + 180)
    && *(_DWORD *)(dword_44EAB4 + 20)
    && *(_BYTE *)(LODWORD(dword_44EAB0) + 123) == 1 )
  {
    if ( !sub_407E30((AGLSOUNDBUFFER **)&unk_44495C) )
      sub_407E00((int)&unk_44495C);
    v3 = (unsigned __int8 *)dword_44EAAC;
  }
  v4 = v3[509];
  if ( v4 == 1 && v3[510] == (unsigned __int16)(50 * *(unsigned __int8 *)(v3[180] + dword_44EB2C) / 60) )
    goto LABEL_16;
  if ( v4 )
  {
    if ( v3[510] != 10 )
    {
LABEL_33:
      result = v3[510] + 1;
      v3[510] = result;
      return result;
    }
    v7 = rand() / 10923;
    if ( v7 )
    {
      if ( v7 == 1 )
        byte_44EAA0 = 1;
    }
    else
    {
      byte_44EA9F = 1;
    }
LABEL_32:
    v3 = (unsigned __int8 *)dword_44EAAC;
    goto LABEL_33;
  }
  if ( a3 )
  {
    v3[509] = 1;
    *(_BYTE *)(dword_44EAAC + 510) = 0;
    goto LABEL_32;
  }
LABEL_16:
  v3[509] = 0;
  *(_BYTE *)(dword_44EAAC + 510) = 0;
  v5 = dword_44EAAC;
  if ( *(_BYTE *)(dword_44EAAC + 182) == 5 )
  {
    ++*(_BYTE *)(dword_44EAAC + 549);
    v5 = dword_44EAAC;
  }
  if ( *(float *)(LODWORD(dword_44EAB0) + 32) >= (double)*(float *)a1 )
    byte_44EA98 = 1;
  else
    byte_44EA99 = 1;
  result = *(_BYTE *)(v5 + 510) + 1;
  *(_BYTE *)(v5 + 510) = result;
  return result;
}
// 44EA98: using guessed type char byte_44EA98;
// 44EA99: using guessed type char byte_44EA99;
// 44EA9F: using guessed type char byte_44EA9F;
// 44EAA0: using guessed type char byte_44EAA0;
// 44EAB4: using guessed type int dword_44EAB4;
// 44EB2C: using guessed type int dword_44EB2C;
// 455BF8: using guessed type int dword_455BF8;

//----- (00430420) --------------------------------------------------------
void __cdecl sub_430420(float a1)
{
  int v1; // esi
  int v2; // eax
  double v3; // st7
  double v4; // st7
  double v5; // st7
  int v6; // eax
  double v7; // st7
  int v8; // eax
  int v9; // et1
  double v11; // st7
  unsigned __int8 v12; // c0
  unsigned __int8 v13; // c3
  double v14; // st7
  double v15; // st7

  v1 = LODWORD(a1);
  if ( *(_WORD *)(LODWORD(a1) + 104) != -1 )
  {
    if ( sub_42D1A0(a1) )
      return;
    *(_DWORD *)(dword_44EAB4 + 12) &= 0xFFFFBFFF;
    v2 = *(_DWORD *)(LODWORD(dword_44EAB0) + 164);
    if ( v2 )
      *(_DWORD *)(v2 + 12) &= 0xFFFFBFFF;
  }
  if ( byte_44EA9C )
  {
    if ( !(*(_BYTE *)(dword_44EAB4 + 12) & 0x40) )
    {
      sub_4151B0(SLODWORD(dword_44EAB0), 200.0, 0, (int)&a1, dword_44EAAC);
      if ( *(_BYTE *)(v1 + 161) )
        *(_BYTE *)(v1 + 160) = 1;
    }
  }
  if ( byte_44EA98 && !byte_44EAA2 && !*(_BYTE *)(v1 + 160) )
  {
    v3 = *(float *)(v1 + 72);
    if ( *(_BYTE *)(v1 + 112) )
      v4 = v3 - *(float *)(v1 + 132);
    else
      v4 = v3 - *(float *)(v1 + 128);
    *(float *)(v1 + 72) = v4;
    v5 = -*(float *)(v1 + 76);
    if ( v5 > *(float *)(v1 + 72) )
      *(float *)(v1 + 72) = v5;
    if ( *(_BYTE *)(v1 + 123) == 1 )
    {
      v6 = *(_DWORD *)(v1 + 28);
      if ( v6 )
        sub_42CEF0(v1, *(_WORD *)(v6 + 24) - 2048);
    }
    *(_BYTE *)(v1 + 123) = -1;
    *(_BYTE *)(v1 + 113) = 0;
  }
  if ( byte_44EA99 && !byte_44EAA2 && !*(_BYTE *)(v1 + 160) )
  {
    if ( *(_BYTE *)(v1 + 112) )
      v7 = *(float *)(v1 + 132);
    else
      v7 = *(float *)(v1 + 128);
    *(float *)(v1 + 72) = v7 + *(float *)(v1 + 72);
    if ( *(float *)(v1 + 72) > (double)*(float *)(v1 + 76) )
      *(_DWORD *)(v1 + 72) = *(_DWORD *)(v1 + 76);
    if ( *(_BYTE *)(v1 + 123) == -1 )
    {
      v8 = *(_DWORD *)(v1 + 28);
      if ( v8 )
        sub_42CEF0(v1, *(_WORD *)(v8 + 24));
    }
    *(_BYTE *)(v1 + 123) = 1;
    *(_BYTE *)(v1 + 113) = 0;
  }
  if ( !byte_44EA98 && !byte_44EA99 && !byte_44EAA2 )
  {
    v9 = *(_DWORD *)(v1 + 72);
    v11 = *(float *)(v1 + 72);
    if ( !(v12 | v13) )
    {
      v14 = v11 - *(float *)(v1 + 128);
      *(float *)(v1 + 72) = v14;
      if ( v14 >= 0.0 )
        goto LABEL_42;
      goto LABEL_41;
    }
    if ( v11 < 0.0 )
    {
      v15 = *(float *)(v1 + 128) + *(float *)(v1 + 72);
      *(float *)(v1 + 72) = v15;
      if ( v15 > 0.0 )
      {
LABEL_41:
        *(_DWORD *)(v1 + 72) = 0;
        goto LABEL_42;
      }
    }
  }
LABEL_42:
  if ( byte_44EA9A )
  {
    if ( *(_BYTE *)(*(_DWORD *)(LODWORD(dword_44EAB0) + 20) + 1) & 8 )
      sub_42CD40(SLODWORD(dword_44EAB0), -10000.0);
    else
      sub_42CD40(SLODWORD(dword_44EAB0), *(float *)(LODWORD(dword_44EAB0) + 136));
  }
}
// 44EA98: using guessed type char byte_44EA98;
// 44EA99: using guessed type char byte_44EA99;
// 44EA9A: using guessed type char byte_44EA9A;
// 44EA9C: using guessed type char byte_44EA9C;
// 44EAA2: using guessed type char byte_44EAA2;
// 44EAB4: using guessed type int dword_44EAB4;

//----- (00430630) --------------------------------------------------------
void __cdecl sub_430630(float a1, float a2)
{
  int v2; // esi
  int v3; // ecx
  int v4; // edx
  int v5; // eax
  int v6; // edx
  int v7; // eax
  double v8; // st7
  float v9; // ST14_4
  float *v10; // eax
  double v11; // st7
  bool v12; // zf
  int v13; // eax
  int v14; // ecx
  double v15; // st7
  int v16; // edx
  double v17; // st7
  int v18; // eax
  int v19; // ecx
  double v20; // st7
  float v21; // [esp+Ch] [ebp+4h]
  float v22; // [esp+Ch] [ebp+4h]
  float v23; // [esp+10h] [ebp+8h]

  v2 = LODWORD(a1);
  v3 = *(_DWORD *)(LODWORD(a1) + 28);
  if ( v3 )
  {
    v4 = *(_DWORD *)(LODWORD(a1) + 36);
    *(_DWORD *)(LODWORD(a1) + 44) = *(_DWORD *)(LODWORD(a1) + 32);
    *(_DWORD *)(LODWORD(a1) + 52) = *(_DWORD *)(LODWORD(a1) + 40);
    v5 = *(_DWORD *)(LODWORD(a1) + 92);
    *(_DWORD *)(LODWORD(a1) + 48) = v4;
    v6 = *(_DWORD *)(LODWORD(a1) + 84);
    *(_DWORD *)(LODWORD(a1) + 96) = v5;
    *(_DWORD *)(LODWORD(a1) + 88) = v6;
    v7 = 4 * (*(_WORD *)(v3 + 24) & 0xFFF);
    v8 = -*(float *)((char *)dword_4449D8 + v7);
    v9 = *(float *)((char *)dword_4449D4 + v7);
    v21 = *(float *)(LODWORD(a1) + 72) * 0.02 + *(float *)(LODWORD(a1) + 92);
    *(float *)(v2 + 92) = v21;
    v10 = *(float **)(v2 + 12);
    *(float *)(v2 + 32) = v21 * v8 + v10[15] + *(float *)v3;
    *(float *)(v2 + 40) = v21 * v9 + v10[17] + *(float *)(v3 + 8);
    if ( LOBYTE(a2) )
      *(float *)(v2 + 84) = v21 * *(float *)(v3 + 36) / *(float *)(v3 + 32) * *(float *)(v3 + 16)
                          + v10[16]
                          + *(float *)(v3 + 4);
    if ( *(_BYTE *)(v2 + 112) )
    {
      v11 = *(float *)(v2 + 80) + 614.40002;
      *(float *)(v2 + 80) = v11;
      if ( v11 > 30720.0 )
        *(_DWORD *)(v2 + 80) = 1190133760;
      v12 = *(_DWORD *)(v2 + 24) == -1;
      v23 = *(float *)(v2 + 80) * 5.1199999 * 0.00390625 + *(float *)(v2 + 36);
      *(float *)(v2 + 36) = v23;
      if ( !v12 )
      {
        v22 = *(float *)(v2 + 84);
        if ( v23 < (double)v22 )
        {
          if ( !sub_42DAD0(v3, v23, v22, *(float *)(v2 + 68)) )
          {
            if ( *(float *)(v2 + 80) < 0.0 )
              *(_DWORD *)(v2 + 80) = 0;
            v13 = *(_DWORD *)(v2 + 28);
            v14 = *(_DWORD *)(v2 + 44);
            v15 = *(float *)(v2 + 84);
            *(_DWORD *)(v2 + 72) = 0;
            v16 = *(_DWORD *)(v2 + 52);
            v17 = v15 - *(float *)(v13 + 40);
            v18 = *(_DWORD *)(v2 + 88);
            *(_DWORD *)(v2 + 32) = v14;
            v19 = *(_DWORD *)(v2 + 92);
            *(_DWORD *)(v2 + 40) = v16;
            v20 = v17 + *(float *)(v2 + 68);
            *(_DWORD *)(v2 + 84) = v18;
            *(_DWORD *)(v2 + 96) = v19;
            *(float *)(v2 + 36) = v20;
          }
        }
        else if ( !(**(_WORD **)(v2 + 20) & 0x120) )
        {
          sub_42CDE0(v2);
          *(_DWORD *)(v2 + 100) = dword_455BE0;
          return;
        }
      }
      *(_DWORD *)(v2 + 100) = dword_455BE0;
    }
    else
    {
      *(_DWORD *)(v2 + 36) = *(_DWORD *)(v2 + 84);
    }
  }
}
// 455BE0: using guessed type int dword_455BE0;

//----- (004307E0) --------------------------------------------------------
void sub_4307E0()
{
  float v0; // ecx
  int v1; // edi
  int v2; // edx
  int v3; // edx
  unsigned __int16 v4; // bx
  int v5; // ebp
  int v6; // esi
  unsigned __int16 v7; // bx
  int v8; // ebp
  int v9; // esi
  int v10; // esi
  int v11; // edi
  int v12; // ebp
  int v13; // eax
  int v14; // eax
  char *v15; // [esp+0h] [ebp-7Ch]
  float v16; // [esp+10h] [ebp-6Ch]
  float v17; // [esp+14h] [ebp-68h]
  float v18; // [esp+18h] [ebp-64h]
  float v19; // [esp+1Ch] [ebp-60h]
  float v20; // [esp+20h] [ebp-5Ch]
  float v21; // [esp+24h] [ebp-58h]
  float v22; // [esp+28h] [ebp-54h]
  int v23; // [esp+2Ch] [ebp-50h]
  float v24; // [esp+30h] [ebp-4Ch]
  int v25; // [esp+34h] [ebp-48h]
  float v26; // [esp+38h] [ebp-44h]
  int v27; // [esp+3Ch] [ebp-40h]
  float v28; // [esp+40h] [ebp-3Ch]
  float v29; // [esp+44h] [ebp-38h]
  float v30; // [esp+48h] [ebp-34h]
  float v31; // [esp+4Ch] [ebp-30h]
  float v32; // [esp+50h] [ebp-2Ch]
  float v33; // [esp+54h] [ebp-28h]
  float v34; // [esp+58h] [ebp-24h]
  float v35; // [esp+5Ch] [ebp-20h]
  __int16 v36; // [esp+60h] [ebp-1Ch]
  int v37; // [esp+64h] [ebp-18h]
  float v38; // [esp+68h] [ebp-14h]
  int v39; // [esp+6Ch] [ebp-10h]
  int v40; // [esp+70h] [ebp-Ch]
  int v41; // [esp+74h] [ebp-8h]
  int i; // [esp+78h] [ebp-4h]

  v0 = dword_44EAB0;
  v1 = dword_455C28;
  v20 = *(float *)(LODWORD(dword_44EAB0) + 32) - *(float *)(LODWORD(dword_44EAB0) + 44);
  v21 = *(float *)(LODWORD(dword_44EAB0) + 36) - *(float *)(LODWORD(dword_44EAB0) + 48);
  v22 = *(float *)(LODWORD(dword_44EAB0) + 40) - *(float *)(LODWORD(dword_44EAB0) + 52);
  v23 = *(_DWORD *)(LODWORD(dword_44EAB0) + 32);
  v24 = *(float *)(LODWORD(dword_44EAB0) + 36) - 100.0;
  v2 = *(_DWORD *)(LODWORD(dword_44EAB0) + 40);
  v26 = 100.0;
  v25 = v2;
  v37 = *(_DWORD *)(LODWORD(dword_44EAB0) + 44);
  v38 = *(float *)(LODWORD(dword_44EAB0) + 48) - 112.0;
  v3 = *(_DWORD *)(LODWORD(dword_44EAB0) + 52);
  v40 = 1103101952;
  v39 = v3;
  v41 = 1121976320;
  for ( i = 1103101952; v1; v1 = *(_DWORD *)v1 )
  {
    if ( byte_44EA9D )
    {
      v4 = *(_WORD *)(v1 + 54);
      v5 = 0;
      v6 = dword_455C60 + 24 * *(unsigned __int16 *)(v1 + 52);
      if ( v4 )
      {
        do
        {
          if ( *(_BYTE *)(v6 + 12) == 3 )
          {
            *(float *)&v27 = (double)(signed int)(signed __int64)*(float *)v6 + *(float *)(v1 + 60);
            v28 = (double)(signed int)(signed __int64)*(float *)(v6 + 4) + *(float *)(v1 + 64);
            v29 = (double)(signed int)(signed __int64)*(float *)(v6 + 8) + *(float *)(v1 + 68);
            v30 = *(float *)(v6 + 16);
            if ( sub_430C80((int)&v27, v30, (int)&v23, v26)
              && sub_424E30(*(_WORD *)(v6 + 22), *(_WORD *)(v6 + 20), &v17) )
            {
              *(_BYTE *)(LODWORD(dword_44EAB0) + 118) = 1;
              goto LABEL_34;
            }
            v0 = dword_44EAB0;
          }
          v6 += 24;
          ++v5;
        }
        while ( (unsigned __int16)v5 < v4 );
      }
    }
    v7 = *(_WORD *)(v1 + 50);
    v8 = 0;
    v9 = dword_455C58 + 28 * *(unsigned __int16 *)(v1 + 48);
    if ( v7 )
    {
      do
      {
        if ( *(_BYTE *)(v9 + 12) == 3 )
        {
          v31 = (double)(signed int)(signed __int64)*(float *)v9 + *(float *)(v1 + 60);
          v32 = (double)(signed int)(signed __int64)*(float *)(v9 + 4) + *(float *)(v1 + 64);
          v33 = (double)(signed int)(signed __int64)*(float *)(v9 + 8) + *(float *)(v1 + 68);
          v34 = (double)*(unsigned __int16 *)(v9 + 18);
          v35 = (double)*(unsigned __int16 *)(v9 + 20);
          v36 = *(_WORD *)(v9 + 16);
          if ( sub_423300((float *)&v37, (int)&v31, &v20) && sub_424E30(*(_WORD *)(v9 + 24), *(_WORD *)(v9 + 22), &v17) )
          {
            *(_BYTE *)(LODWORD(dword_44EAB0) + 118) = 1;
            sub_430130(&v17);
            return;
          }
          v0 = dword_44EAB0;
        }
        v9 += 28;
        ++v8;
      }
      while ( (unsigned __int16)v8 < v7 );
    }
  }
  if ( dword_44EAB8 )
  {
    if ( *(_BYTE *)(dword_44EAB8 + 28) == 40 && *(_WORD *)(LODWORD(v0) + 104) == -1 )
    {
      v10 = dword_455C74;
      v11 = 0;
      if ( dword_455C78 )
      {
        v12 = dword_455C74 + 32;
        do
        {
          if ( *(_BYTE *)(v12 - 28) == 73 )
          {
            v16 = *(float *)(*(_DWORD *)(48 * sub_40A5E0(73) + dword_448AC4 + 40) + 4);
            if ( v16 != 0.0 && sub_430C80((int)&v23, v26, v12, v16) )
            {
              sub_42D130(SLODWORD(dword_44EAB0), v10);
              *(_DWORD *)(dword_44EAB4 + 12) |= 0x4000u;
              v13 = *(_DWORD *)(LODWORD(dword_44EAB0) + 164);
              if ( v13 )
                *(_DWORD *)(v13 + 12) |= 0x4000u;
            }
          }
          v10 += 104;
          v12 += 104;
          ++v11;
        }
        while ( (unsigned __int16)v11 < (unsigned int)dword_455C78 );
      }
    }
  }
  if ( dword_44B828 || dword_44B82C )
  {
    v14 = dword_44EAAC;
    if ( *(_BYTE *)(*(unsigned __int8 *)(dword_44EAAC + 180) + dword_44EB4C) && *(_BYTE *)(dword_44EAAC + 182) == 1 )
    {
      if ( !sub_431B70() && sub_430F60(7, 8, &v17) )
      {
        *(_BYTE *)(LODWORD(dword_44EAB0) + 118) = 1;
LABEL_34:
        sub_430130(&v17);
        return;
      }
      v14 = dword_44EAAC;
    }
    if ( *(_BYTE *)(*(unsigned __int8 *)(v14 + 180) + dword_44EB50)
      && *(_BYTE *)(v14 + 182) == 1
      && sub_431B70()
      && !*(_BYTE *)(dword_44EAAC + 513) )
    {
      if ( sub_430F60(9, 10, &v17) )
      {
        *(_BYTE *)(dword_44EAAC + 513) = 1;
        *(float *)(dword_44EAAC + 516) = v17;
        *(float *)(dword_44EAAC + 520) = v18;
        *(float *)(dword_44EAAC + 524) = v19;
        *(_WORD *)(dword_44EAAC + 514) = sub_431960((float *)(dword_44EAAC + 516), 0, v15);
      }
    }
  }
}
// 448AC4: using guessed type int dword_448AC4;
// 44B828: using guessed type int dword_44B828;
// 44B82C: using guessed type int dword_44B82C;
// 44EA9D: using guessed type char byte_44EA9D;
// 44EAB4: using guessed type int dword_44EAB4;
// 44EAB8: using guessed type int dword_44EAB8;
// 44EB4C: using guessed type int dword_44EB4C;
// 44EB50: using guessed type int dword_44EB50;
// 455C58: using guessed type int dword_455C58;
// 455C60: using guessed type int dword_455C60;
// 455C74: using guessed type int dword_455C74;
// 455C78: using guessed type int dword_455C78;

//----- (00430C80) --------------------------------------------------------
bool __cdecl sub_430C80(int a1, float a2, int a3, float a4)
{
  int v4; // eax
  int v5; // ecx
  int v7; // [esp+4h] [ebp+4h]
  float v8; // [esp+8h] [ebp+8h]
  int v9; // [esp+Ch] [ebp+Ch]
  float v10; // [esp+10h] [ebp+10h]

  v4 = a1;
  v5 = a3;
  v8 = a2 + a4;
  *(float *)&v9 = fabs(*(float *)a1 - *(float *)a3);
  *(float *)&v7 = fabs(*(float *)(a1 + 4) - *(float *)(v5 + 4));
  v10 = fabs(*(float *)(v4 + 8) - *(float *)(v5 + 8));
  return *(float *)&v9 < (double)v8
      && *(float *)&v7 < (double)v8
      && v10 < (double)v8
      && v10 * v10 * 0.00390625
       + *(float *)&v7 * *(float *)&v7 * 0.00390625
       + *(float *)&v9 * *(float *)&v9 * 0.00390625 < v8 * v8 * 0.00390625;
}

//----- (00430D30) --------------------------------------------------------
double __cdecl sub_430D30(int a1, int a2, float a3)
{
  int v3; // ecx
  float v4; // ST00_4
  double result; // st7
  float v6; // [esp+4h] [ebp-4h]
  int v7; // [esp+Ch] [ebp+4h]
  int v8; // [esp+10h] [ebp+8h]

  v3 = a2;
  v6 = fabs(*(float *)a1 - *(float *)a2);
  *(float *)&v8 = fabs(*(float *)(a1 + 4) - *(float *)(a2 + 4));
  *(float *)&v7 = fabs(*(float *)(a1 + 8) - *(float *)(v3 + 8));
  if ( v6 >= (double)a3
    || *(float *)&v8 >= (double)a3
    || *(float *)&v7 >= (double)a3
    || (v4 = *(float *)&v7 * *(float *)&v7 + *(float *)&v8 * *(float *)&v8 + v6 * v6, result = AGLSqrt(v4), result >= a3) )
  {
    result = a3;
  }
  return result;
}

//----- (00430DD0) --------------------------------------------------------
void sub_430DD0()
{
  int v0; // edx
  int v1; // eax
  float v2; // edi
  int v3; // ebp
  signed int v4; // esi
  double v5; // st7
  float v6; // ST1C_4
  double v7; // st6
  double v8; // st7

  v0 = dword_44EAAC;
  if ( *(_BYTE *)(dword_44EAAC + 182) == 1 )
  {
    v1 = *(unsigned __int8 *)(dword_44EAAC + 180);
    if ( *(_BYTE *)(v1 + dword_44EB54) )
    {
      v2 = dword_44EAB0;
      LOWORD(v3) = *(_WORD *)(dword_44EB58 + 2 * v1);
      v4 = *(unsigned __int16 *)(dword_44EB60 + 2 * v1);
      v5 = (double)v4;
      if ( fabs(*(float *)(LODWORD(dword_44EAB0) + 32) - dword_44B73C) <= v5
        && fabs(*(float *)(LODWORD(dword_44EAB0) + 36) - dword_44B740) <= v5
        && fabs(*(float *)(LODWORD(dword_44EAB0) + 40) - dword_44B744) <= v5 )
      {
        v6 = sub_41F420((float *)(LODWORD(dword_44EAB0) + 32), &dword_44B73C);
        v5 = AGLSqrt(v6);
        v0 = dword_44EAAC;
        v2 = dword_44EAB0;
      }
      v3 = (unsigned __int16)v3;
      v7 = (double)(unsigned __int16)v3;
      if ( v5 >= v7 )
      {
        v8 = (double)(*(unsigned __int8 *)(*(unsigned __int8 *)(v0 + 180) + dword_44EB64)
                    - *(unsigned __int8 *)(*(unsigned __int8 *)(v0 + 180) + dword_44EB5C))
           * (v5 - v7)
           / (double)(v4 - v3)
           + (double)(*(unsigned __int8 *)(*(unsigned __int8 *)(v0 + 180) + dword_44EB5C) + 100);
        *(float *)(LODWORD(v2) + 124) = v8 * *(float *)(LODWORD(v2) + 124) * 0.0099999998;
        *(float *)(LODWORD(dword_44EAB0) + 132) = v8 * *(float *)(LODWORD(dword_44EAB0) + 132) * 0.0099999998;
        *(float *)(LODWORD(dword_44EAB0) + 128) = v8 * *(float *)(LODWORD(dword_44EAB0) + 128) * 0.0099999998;
        *(_DWORD *)(LODWORD(dword_44EAB0) + 76) = *(_DWORD *)(LODWORD(dword_44EAB0) + 124);
      }
    }
  }
}
// 44EB54: using guessed type int dword_44EB54;
// 44EB58: using guessed type int dword_44EB58;
// 44EB5C: using guessed type int dword_44EB5C;
// 44EB60: using guessed type int dword_44EB60;
// 44EB64: using guessed type int dword_44EB64;

//----- (00430F60) --------------------------------------------------------
char __cdecl sub_430F60(char a1, char a2, float *a3)
{
  char v3; // al
  int v4; // eax
  char v5; // al

  if ( dword_44B828 && ((v3 = *(_BYTE *)(dword_44B828 + 12), v3 == a1) || v3 == a2) )
  {
    v4 = dword_44B828 + 20;
  }
  else
  {
    if ( !dword_44B82C )
      return 0;
    v5 = *(_BYTE *)(dword_44B82C + 12);
    if ( v5 != a1 && v5 != a2 )
      return 0;
    v4 = dword_44B82C + 22;
  }
  if ( v4 && sub_424E30(*(_WORD *)(v4 + 2), *(_WORD *)v4, a3) )
    return 1;
  return 0;
}
// 44B828: using guessed type int dword_44B828;
// 44B82C: using guessed type int dword_44B82C;

//----- (00430FD0) --------------------------------------------------------
void sub_430FD0()
{
  int v0; // eax
  float v1; // ecx
  unsigned __int16 *v2; // edx
  char v3; // bl
  int v4; // ecx
  int v5; // edx
  int v6; // edx
  int v7; // edx
  char v8; // dl
  int v9; // ecx
  signed int v10; // ecx
  int v11; // ecx
  int v12; // edx
  char v13; // [esp+Bh] [ebp-5h]
  int v14; // [esp+Ch] [ebp-4h]

  *(_DWORD *)LODWORD(dword_44EAB0) = *(_DWORD *)(dword_44EAB4 + 20);
  if ( !*(_DWORD *)LODWORD(dword_44EAB0) )
    return;
  *(_DWORD *)(LODWORD(dword_44EAB0) + 168) = *(_DWORD *)(*(_DWORD *)LODWORD(dword_44EAB0) + 180)
                                           + 236
                                           * *(signed __int16 *)(dword_44EB48
                                                               + 2 * *(unsigned __int8 *)(dword_44EAAC + 181));
  v0 = LODWORD(dword_44EAB0);
  if ( *(_DWORD *)LODWORD(dword_44EAB0) && byte_455C14 )
  {
    sub_4083F0(*(int **)LODWORD(dword_44EAB0));
    v0 = LODWORD(dword_44EAB0);
  }
  v1 = *(float *)v0;
  if ( *(_DWORD *)v0
    && (v2 = *(unsigned __int16 **)(LODWORD(v1) + 184)) != 0
    && *(unsigned __int16 *)(LODWORD(v1) + 174) == *v2 - 1 )
  {
    v3 = 1;
    v13 = 1;
  }
  else
  {
    v13 = 0;
    v3 = 0;
  }
  v4 = dword_44EAB4;
  v5 = *(_DWORD *)(dword_44EAB4 + 12);
  if ( v5 & 0x2000000 )
  {
    if ( !v3 )
      return;
    *(_DWORD *)(dword_44EAB4 + 12) = v5 & 0xFDFFFFFF;
    v0 = LODWORD(dword_44EAB0);
    v4 = dword_44EAB4;
  }
  else if ( byte_44EAA3 )
  {
    sub_4315A0();
    sub_408670(*(float *)LODWORD(dword_44EAB0), 19, 0);
    *(_DWORD *)(dword_44EAB4 + 12) |= 0x2000000u;
    byte_44EAA3 = 0;
    sub_417400(*(unsigned __int8 *)(dword_44EB0C + 2), &v14, 1);
    sub_415890(SLODWORD(dword_44EAB0), v14);
    sub_4314E0();
    return;
  }
  if ( byte_44EAA1 )
  {
    sub_4315A0();
    sub_408670(*(float *)LODWORD(dword_44EAB0), 1, 3);
    return;
  }
  if ( byte_44EAA0 )
  {
    sub_4315A0();
    *(_DWORD *)(dword_44EAB4 + 12) |= 8u;
    sub_408670(*(float *)LODWORD(dword_44EAB0), 8, 3);
    return;
  }
  v6 = *(_DWORD *)(v4 + 12);
  if ( v6 & 8 )
  {
    if ( !v3 )
      return;
    *(_DWORD *)(v4 + 12) = v6 & 0xFFFFFFF7;
    v0 = LODWORD(dword_44EAB0);
    v4 = dword_44EAB4;
  }
  if ( byte_44EA9F )
  {
    sub_4315A0();
    *(_DWORD *)(dword_44EAB4 + 12) |= 1u;
    sub_408670(*(float *)LODWORD(dword_44EAB0), 7, 3);
    return;
  }
  v7 = *(_DWORD *)(v4 + 12);
  if ( v7 & 1 )
  {
    if ( !v3 )
      return;
    *(_DWORD *)(v4 + 12) = v7 & 0xFFFFFFFE;
    v0 = LODWORD(dword_44EAB0);
    v4 = dword_44EAB4;
  }
  v8 = *(_BYTE *)(v0 + 160);
  if ( !v8 )
    goto LABEL_45;
  v9 = *(_DWORD *)(v4 + 12);
  if ( v9 & 0x40 )
  {
    if ( !v3 )
      return;
    if ( v8 == 1 )
    {
      if ( v9 < 0 )
      {
        sub_415360(v0, 256.0, 0, dword_44EAAC);
        v0 = LODWORD(dword_44EAB0);
      }
      v10 = *(unsigned __int8 *)(v0 + 161);
      if ( v10 > 4 )
      {
        if ( v10 != 6 && v10 != 0xFFFF )
          goto LABEL_43;
        sub_408670(*(float *)v0, 14, 0);
      }
      else if ( v10 != 4 && (v11 = v10 - 1) != 0 )
      {
        if ( v11 != 2 )
        {
LABEL_43:
          ++*(_BYTE *)(v0 + 160);
          return;
        }
        sub_408670(*(float *)v0, 16, 0);
      }
      else
      {
        sub_408670(*(float *)v0, 18, 0);
      }
      v0 = LODWORD(dword_44EAB0);
      goto LABEL_43;
    }
    *(_BYTE *)(v0 + 160) = 0;
    *(_DWORD *)(dword_44EAB4 + 12) &= 0xFFFFFFBF;
    v0 = LODWORD(dword_44EAB0);
    v4 = dword_44EAB4;
LABEL_45:
    if ( *(_BYTE *)(v0 + 112) )
    {
      if ( byte_44EA9A )
      {
        sub_4315A0();
        v12 = *(_DWORD *)(dword_44EAB4 + 12);
        LOBYTE(v12) = v12 | 0x80;
        *(_DWORD *)(dword_44EAB4 + 12) = v12;
        if ( *(_DWORD *)(LODWORD(dword_44EAB0) + 164) )
          sub_408670(*(float *)LODWORD(dword_44EAB0), 10, 0);
        else
          sub_408670(*(float *)LODWORD(dword_44EAB0), 3, 0);
      }
      else if ( *(_BYTE *)(v4 + 12) >= 0 )
      {
        sub_4315A0();
        *(_DWORD *)(dword_44EAB4 + 12) |= 0x80u;
        if ( *(_DWORD *)(LODWORD(dword_44EAB0) + 164) )
          sub_408670(*(float *)LODWORD(dword_44EAB0), 11, 3);
        else
          sub_408670(*(float *)LODWORD(dword_44EAB0), 4, 3);
      }
      else if ( v13 )
      {
        if ( *(_DWORD *)(v0 + 164) )
          sub_408670(*(float *)v0, 11, 3);
        else
          sub_408670(*(float *)v0, 4, 3);
      }
    }
    else if ( byte_44EA98 || byte_44EA99 )
    {
      sub_4315A0();
      if ( *(_DWORD *)(LODWORD(dword_44EAB0) + 164) )
        sub_408670(*(float *)LODWORD(dword_44EAB0), 9, 3);
      else
        sub_408670(*(float *)LODWORD(dword_44EAB0), 2, 3);
    }
    else if ( *(float *)(v0 + 72) == 0.0 )
    {
      sub_4315A0();
      sub_408670(*(float *)LODWORD(dword_44EAB0), 0, 3);
    }
    return;
  }
  sub_4315A0();
  *(_DWORD *)(dword_44EAB4 + 12) |= 0x40u;
  *(_DWORD *)(LODWORD(dword_44EAB0) + 72) = 0;
  switch ( *(unsigned __int8 *)(LODWORD(dword_44EAB0) + 161) )
  {
    case 1u:
      sub_408670(*(float *)LODWORD(dword_44EAB0), 17, 2);
      break;
    case 3u:
    case 4u:
      sub_408670(*(float *)LODWORD(dword_44EAB0), 15, 2);
      break;
    case 6u:
      sub_408670(*(float *)LODWORD(dword_44EAB0), 13, 2);
      break;
    default:
      return;
  }
}
// 44EA98: using guessed type char byte_44EA98;
// 44EA99: using guessed type char byte_44EA99;
// 44EA9A: using guessed type char byte_44EA9A;
// 44EA9F: using guessed type char byte_44EA9F;
// 44EAA0: using guessed type char byte_44EAA0;
// 44EAA1: using guessed type char byte_44EAA1;
// 44EAA3: using guessed type char byte_44EAA3;
// 44EAB4: using guessed type int dword_44EAB4;
// 44EB0C: using guessed type int dword_44EB0C;
// 44EB48: using guessed type int dword_44EB48;
// 455C14: using guessed type char byte_455C14;

//----- (004314E0) --------------------------------------------------------
_DWORD *sub_4314E0()
{
  _DWORD *result; // eax

  *(_DWORD *)(*(_DWORD *)LODWORD(dword_44EAB0) + 56) = 1166016512;
  *(_DWORD *)(*(_DWORD *)LODWORD(dword_44EAB0) + 68) = 0;
  *(_DWORD *)(*(_DWORD *)LODWORD(dword_44EAB0) + 80) = 0;
  *(_DWORD *)(*(_DWORD *)LODWORD(dword_44EAB0) + 60) = 0;
  *(_DWORD *)(*(_DWORD *)LODWORD(dword_44EAB0) + 72) = 1166016512;
  *(_DWORD *)(*(_DWORD *)LODWORD(dword_44EAB0) + 84) = 0;
  *(_DWORD *)(*(_DWORD *)LODWORD(dword_44EAB0) + 64) = 0;
  *(_DWORD *)(*(_DWORD *)LODWORD(dword_44EAB0) + 76) = 0;
  *(_DWORD *)(*(_DWORD *)LODWORD(dword_44EAB0) + 88) = 1166016512;
  *(_BYTE *)(LODWORD(dword_44EAB0) + 123) = 1;
  *(_BYTE *)(LODWORD(dword_44EAB0) + 122) = 0;
  *(_WORD *)(LODWORD(dword_44EAB0) + 108) = 3072;
  *(_WORD *)(LODWORD(dword_44EAB0) + 110) = 3072;
  *(_DWORD *)(LODWORD(dword_44EAB0) + 152) = 0;
  result = *(_DWORD **)(LODWORD(dword_44EAB0) + 156);
  *result = 0;
  result[1] = 0;
  result[2] = 0;
  return result;
}

//----- (004315A0) --------------------------------------------------------
int sub_4315A0()
{
  int v0; // ecx
  int result; // eax

  *(_DWORD *)(dword_44EAB4 + 12) &= 0xDFFFFFFF;
  *(_DWORD *)(dword_44EAB4 + 12) &= 0xFFFFFFBF;
  v0 = *(_DWORD *)(dword_44EAB4 + 12);
  LOBYTE(v0) = v0 & 0x7F;
  *(_DWORD *)(dword_44EAB4 + 12) = v0;
  *(_DWORD *)(dword_44EAB4 + 12) &= 0xFFFFFFFB;
  *(_DWORD *)(dword_44EAB4 + 12) &= 0xFFFFFFFE;
  *(_DWORD *)(dword_44EAB4 + 12) &= 0xFFFFFFF7;
  result = dword_44EAB4;
  *(_DWORD *)(result + 12) &= 0xFDFFFFFF;
  return result;
}
// 44EAB4: using guessed type int dword_44EAB4;

//----- (00431610) --------------------------------------------------------
int __cdecl sub_431610(int a1)
{
  dword_44EAB4 = a1;
  dword_44EAAC = *(_DWORD *)(a1 + 100);
  LODWORD(dword_44EAB0) = dword_44EAAC + 4;
  if ( *(int (**)())(a1 + 28) == sub_41A010 )
    *(_DWORD *)(a1 + 12) = -796868480;
  else
    *(_DWORD *)(a1 + 12) = -1073709056;
  *(_DWORD *)(dword_44EAB4 + 32) = *(_DWORD *)(dword_44EAB4 + 44);
  *(_DWORD *)(dword_44EAB4 + 36) = *(_DWORD *)(dword_44EAB4 + 48);
  *(_DWORD *)(dword_44EAB4 + 40) = *(_DWORD *)(dword_44EAB4 + 52);
  *(_DWORD *)(LODWORD(dword_44EAB0) + 140) = *(_DWORD *)(dword_44EB3C + 4 * *(unsigned __int8 *)(dword_44EAAC + 181));
  *(_DWORD *)(LODWORD(dword_44EAB0) + 144) = *(_DWORD *)(dword_44EB40 + 4 * *(unsigned __int8 *)(dword_44EAAC + 181));
  *(_DWORD *)(LODWORD(dword_44EAB0) + 148) = *(_DWORD *)(dword_44EB44 + 4 * *(unsigned __int8 *)(dword_44EAAC + 181));
  *(_BYTE *)(LODWORD(dword_44EAB0) + 116) = 0;
  *(_BYTE *)(LODWORD(dword_44EAB0) + 112) = 0;
  *(_BYTE *)(LODWORD(dword_44EAB0) + 113) = 0;
  *(_BYTE *)(LODWORD(dword_44EAB0) + 115) = 0;
  *(_BYTE *)(LODWORD(dword_44EAB0) + 118) = 0;
  *(_BYTE *)(LODWORD(dword_44EAB0) + 120) = 0;
  *(_BYTE *)(LODWORD(dword_44EAB0) + 122) = 0;
  *(_BYTE *)(LODWORD(dword_44EAB0) + 121) = 0;
  *(_BYTE *)(LODWORD(dword_44EAB0) + 117) = 0;
  *(_BYTE *)(LODWORD(dword_44EAB0) + 160) = 0;
  *(_DWORD *)(LODWORD(dword_44EAB0) + 164) = 0;
  sub_431E70(*(_BYTE *)(dword_44EAAC + 180), 0);
  *(_DWORD *)(LODWORD(dword_44EAB0) + 80) = 0;
  *(_DWORD *)(LODWORD(dword_44EAB0) + 68) = *(_DWORD *)(LODWORD(dword_44EAB0) + 140);
  *(_DWORD *)(LODWORD(dword_44EAB0) + 72) = 0;
  *(_BYTE *)(LODWORD(dword_44EAB0) + 123) = 1 - 2 * *(_BYTE *)(*(unsigned __int8 *)(dword_44EAAC + 180) + dword_44EB28);
  *(_DWORD *)(LODWORD(dword_44EAB0) + 32) = *(_DWORD *)(dword_44EAB4 + 44);
  *(_DWORD *)(LODWORD(dword_44EAB0) + 36) = *(_DWORD *)(dword_44EAB4 + 48);
  *(_DWORD *)(LODWORD(dword_44EAB0) + 40) = *(_DWORD *)(dword_44EAB4 + 52);
  *(_DWORD *)(LODWORD(dword_44EAB0) + 44) = *(_DWORD *)(dword_44EAB4 + 44);
  *(_DWORD *)(LODWORD(dword_44EAB0) + 48) = *(_DWORD *)(dword_44EAB4 + 48);
  *(_DWORD *)(LODWORD(dword_44EAB0) + 52) = *(_DWORD *)(dword_44EAB4 + 52);
  *(_DWORD *)(LODWORD(dword_44EAB0) + 84) = *(_DWORD *)(dword_44EAB4 + 48);
  *(_DWORD *)(LODWORD(dword_44EAB0) + 88) = *(_DWORD *)(dword_44EAB4 + 48);
  *(_DWORD *)(LODWORD(dword_44EAB0) + 92) = 0;
  *(_DWORD *)(LODWORD(dword_44EAB0) + 96) = 0;
  *(_WORD *)(LODWORD(dword_44EAB0) + 104) = -1;
  *(_DWORD *)(LODWORD(dword_44EAB0) + 100) = 0;
  *(_DWORD *)(LODWORD(dword_44EAB0) + 8) = -1;
  *(_DWORD *)(LODWORD(dword_44EAB0) + 12) = 0;
  *(_DWORD *)(LODWORD(dword_44EAB0) + 16) = -1;
  *(_DWORD *)(LODWORD(dword_44EAB0) + 20) = 0;
  *(_DWORD *)(LODWORD(dword_44EAB0) + 24) = -1;
  *(_DWORD *)(LODWORD(dword_44EAB0) + 28) = 0;
  *(_BYTE *)(dword_44EAAC + 182) = 0;
  *(_BYTE *)(dword_44EAAC + 506) = 0;
  *(_BYTE *)(dword_44EAAC + 509) = 0;
  *(_BYTE *)(dword_44EAAC + 510) = 0;
  *(_BYTE *)(dword_44EAAC + 513) = 0;
  if ( *(_BYTE *)(*(unsigned __int8 *)(dword_44EAAC + 180) + dword_44EB20) )
    sub_430210();
  byte_44EAA3 = 0;
  *(_BYTE *)(dword_44EAAC + 548) = 0;
  sub_4300B0();
  sub_42D4A0(SLODWORD(dword_44EAB0), 1, 1.0);
  return sub_435281((int)aTrackerDReady, *(unsigned __int8 *)(dword_44EAAC + 180));
}
// 41A010: using guessed type int sub_41A010();
// 44EAA3: using guessed type char byte_44EAA3;
// 44EAB4: using guessed type int dword_44EAB4;
// 44EB20: using guessed type int dword_44EB20;
// 44EB28: using guessed type int dword_44EB28;
// 44EB3C: using guessed type int dword_44EB3C;
// 44EB40: using guessed type int dword_44EB40;
// 44EB44: using guessed type int dword_44EB44;

//----- (00431920) --------------------------------------------------------
int sub_431920()
{
  int result; // eax

  result = *(unsigned __int8 *)(dword_44EAAC + 180);
  if ( !*(_BYTE *)(result + dword_44EB20) )
  {
    if ( *(_BYTE *)(result + dword_44EB28) )
      byte_44EA98 = 1;
    else
      byte_44EA99 = 1;
  }
  return result;
}
// 44EA98: using guessed type char byte_44EA98;
// 44EA99: using guessed type char byte_44EA99;
// 44EB20: using guessed type int dword_44EB20;
// 44EB28: using guessed type int dword_44EB28;

//----- (00431960) --------------------------------------------------------
__int16 __cdecl sub_431960(float *a1, char a2, char *a3)
{
  char *v3; // ecx
  int v4; // esi
  double v5; // st7
  unsigned __int16 v6; // bp
  int v7; // edi
  float *v8; // edx
  unsigned __int16 v9; // bx
  double v10; // st6
  double v11; // st6
  double v12; // st6
  double v13; // st6
  int v14; // eax
  int v15; // eax
  float v17; // [esp+0h] [ebp-D4h]
  int v18; // [esp+4h] [ebp-D0h]
  float v19; // [esp+8h] [ebp-CCh]
  float v20; // [esp+Ch] [ebp-C8h]
  float v21; // [esp+10h] [ebp-C4h]
  float v22; // [esp+14h] [ebp-C0h]
  float v23; // [esp+18h] [ebp-BCh]
  char v24; // [esp+24h] [ebp-B0h]

  v3 = a3;
  if ( !a2 )
    v3 = &v24;
  v4 = dword_455C20;
  v18 = 0;
  v22 = a1[2];
  v20 = *a1;
  v21 = a1[1] - 10.0;
  v5 = 3.4e38;
  if ( dword_455C24 )
  {
    do
    {
      v6 = 0;
      v7 = dword_455C38 + 12 * *(unsigned __int16 *)(v4 + 32);
      if ( *(_WORD *)(v4 + 34) )
      {
        do
        {
          v8 = *(float **)(v7 + 8);
          v9 = 0;
          if ( *(_BYTE *)(v7 + 2) )
          {
            do
            {
              v10 = *(float *)(v4 + 60) + *v8;
              v23 = v10;
              if ( v10 <= v20 )
              {
                v11 = v8[3] * v8[9] + v23;
                if ( v11 >= v20 )
                {
                  v19 = (v20 - v23) / (v11 - v23);
                  v12 = v8[1] + *(float *)(v4 + 64);
                  v17 = (v8[4] * v8[9] + v12 - v12) * v19 * 0.00390625 + v12;
                  if ( v17 >= (double)v21 && v17 < v5 )
                  {
                    v13 = v8[2] + *(float *)(v4 + 68);
                    if ( fabs(v13 + (v8[5] * v8[9] + v13 - v13) * v19 * 0.00390625 - v22) < 70.0 )
                    {
                      *((_DWORD *)v3 + 3) = v4;
                      *((_DWORD *)v3 + 5) = v7;
                      *((_DWORD *)v3 + 2) = (unsigned __int16)v18;
                      *((_DWORD *)v3 + 7) = v8;
                      *((_DWORD *)v3 + 4) = v6;
                      v5 = v17;
                      *((_DWORD *)v3 + 6) = v9;
                    }
                  }
                }
              }
              v8 += 11;
              ++v9;
            }
            while ( v9 < *(unsigned __int8 *)(v7 + 2) );
          }
          v7 += 12;
          ++v6;
        }
        while ( v6 < *(_WORD *)(v4 + 34) );
      }
      v4 += 120;
      v14 = v18 + 1;
      v18 = v14;
      v14 = (unsigned __int16)v14;
    }
    while ( (unsigned __int16)v14 < (unsigned int)dword_455C24 );
    if ( v5 == 3.4e38 )
    {
      LOWORD(v15) = -1;
    }
    else
    {
      LOWORD(v14) = *(_WORD *)(*((_DWORD *)v3 + 3) + 32);
      v15 = *((_DWORD *)v3 + 4) + v14;
    }
  }
  else
  {
    LOWORD(v15) = -1;
  }
  return v15;
}
// 455C20: using guessed type int dword_455C20;
// 455C24: using guessed type int dword_455C24;
// 455C38: using guessed type int dword_455C38;

//----- (00431B50) --------------------------------------------------------
char sub_431B50()
{
  _DWORD *v0; // eax

  v0 = (_DWORD *)dword_455C7C;
  if ( !dword_455C7C )
    return 0;
  while ( (_DWORD *)dword_44EAB4 != v0 )
  {
    v0 = (_DWORD *)*v0;
    if ( !v0 )
      return 0;
  }
  return 1;
}
// 44EAB4: using guessed type int dword_44EAB4;
// 455C7C: using guessed type int dword_455C7C;

//----- (00431B70) --------------------------------------------------------
bool sub_431B70()
{
  return fabs(*(float *)(dword_44EAB4 + 32) - *(float *)&dword_448A08) < 2048.0
      && fabs(*(float *)(dword_44EAB4 + 36) - *(float *)&dword_448A0C) < 1536.0;
}
// 448A08: using guessed type int dword_448A08;
// 448A0C: using guessed type int dword_448A0C;
// 44EAB4: using guessed type int dword_44EAB4;

//----- (00431BB0) --------------------------------------------------------
bool sub_431BB0()
{
  float v0; // ST08_4
  int v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  v2 = dword_448A08;
  v3 = dword_448A0C;
  v4 = *(_DWORD *)(dword_44EAB4 + 40);
  v0 = (double)*(unsigned __int16 *)(dword_44EB38 + 2 * *(unsigned __int8 *)(dword_44EAAC + 180));
  return (double)*(unsigned __int16 *)(dword_44EB38 + 2 * *(unsigned __int8 *)(dword_44EAAC + 180)) == sub_430D30(dword_44EAB4 + 32, (int)&v2, v0);
}
// 448A08: using guessed type int dword_448A08;
// 448A0C: using guessed type int dword_448A0C;
// 44EAB4: using guessed type int dword_44EAB4;
// 44EB38: using guessed type int dword_44EB38;

//----- (00431C40) --------------------------------------------------------
char sub_431C40()
{
  _BYTE *v0; // eax
  char v1; // dl
  char v2; // cl

  v0 = (_BYTE *)dword_44EAA4;
  v1 = 0;
  if ( !(_BYTE)dword_44EAA8 )
    return 0;
  while ( 1 )
  {
    if ( *(_DWORD *)(*(_DWORD *)v0 + 12) < 0 )
    {
      v2 = v0[182];
      if ( v2 )
      {
        if ( v2 != 4 )
          break;
      }
    }
    v0 += 552;
    if ( (unsigned __int8)++v1 >= (unsigned __int8)dword_44EAA8 )
      return 0;
  }
  return 1;
}
// 44EAA4: using guessed type int dword_44EAA4;
// 44EAA8: using guessed type int dword_44EAA8;

//----- (00431C80) --------------------------------------------------------
char __cdecl sub_431C80(int a1)
{
  char v1; // al
  _DWORD *v2; // ecx

  v1 = 0;
  if ( !(_BYTE)dword_44EAA8 )
    return 0;
  v2 = (_DWORD *)(dword_44EAA4 + 168);
  while ( a1 != *v2 )
  {
    v2 += 138;
    if ( (unsigned __int8)++v1 >= (unsigned __int8)dword_44EAA8 )
      return 0;
  }
  return 1;
}
// 44EAA4: using guessed type int dword_44EAA4;
// 44EAA8: using guessed type int dword_44EAA8;

//----- (00431CC0) --------------------------------------------------------
char __cdecl sub_431CC0(char a1, char a2)
{
  char result; // al
  unsigned __int8 v3; // [esp+Ch] [ebp+8h]

  if ( a1 )
  {
    if ( a1 != 1 )
    {
      result = a1 - 2;
      if ( a1 == 2 )
      {
        result = a2 - 2;
        if ( a2 == 2 )
        {
          result = dword_455BF8;
          switch ( dword_455BF8 )
          {
            case 2:
              goto LABEL_20;
            case 3:
              goto LABEL_6;
            case 7:
              goto LABEL_24;
            case 10:
              goto LABEL_25;
            default:
              return result;
          }
        }
      }
      return result;
    }
    if ( a2 != 2 )
    {
      result = a2 - 3;
      if ( a2 == 3 )
      {
        if ( dword_455BF8 != 5 )
          return result;
        v3 = 44;
      }
      else
      {
        result = a2 - 4;
        if ( a2 != 4 || dword_455BF8 != 11 )
          return result;
        v3 = 39;
      }
      goto LABEL_26;
    }
    result = dword_455BF8;
    switch ( dword_455BF8 )
    {
      case 0:
        goto LABEL_22;
      case 2:
        goto LABEL_20;
      case 5:
        goto LABEL_6;
      case 7:
        v3 = 42;
        goto LABEL_26;
      case 10:
        v3 = 46;
        goto LABEL_26;
      default:
        return result;
    }
  }
  else
  {
    if ( a2 != 2 )
    {
      result = a2 - 4;
      if ( a2 != 4 || dword_455BF8 != 11 )
        return result;
LABEL_20:
      v3 = 36;
LABEL_26:
      result = sub_407E30((AGLSOUNDBUFFER **)(12 * v3 + 4474712));
      if ( !result )
        result = sub_407E00(12 * v3 + 4474712);
      return result;
    }
    result = dword_455BF8;
    switch ( dword_455BF8 )
    {
      case 0:
LABEL_22:
        v3 = 44;
        goto LABEL_26;
      case 2:
        v3 = 37;
        goto LABEL_26;
      case 3:
LABEL_6:
        v3 = 43;
        goto LABEL_26;
      case 5:
      case 7:
LABEL_24:
        v3 = 41;
        goto LABEL_26;
      case 10:
LABEL_25:
        v3 = 47;
        goto LABEL_26;
      default:
        return result;
    }
  }
  return result;
}
// 455BF8: using guessed type int dword_455BF8;

//----- (00431E70) --------------------------------------------------------
float __usercall sub_431E70@<eax>(char a1, char a2)
{
  char v2; // cl
  int v3; // eax
  float result; // eax

  if ( *(_BYTE *)(LODWORD(dword_44EAB0) + 112) )
  {
LABEL_2:
    v2 = 1;
  }
  else
  {
    switch ( a2 )
    {
      case 0:
        v2 = 0;
        break;
      case 1:
      case 2:
        goto LABEL_2;
      case 3:
      case 4:
      case 5:
        v2 = 2;
        break;
      default:
        v2 = a1;
        break;
    }
  }
  v3 = 2 * (unsigned __int8)(v2 + 3 * a1);
  *(float *)(LODWORD(dword_44EAB0) + 124) = (double)*(signed __int16 *)(v3 + dword_44EB10);
  *(float *)(LODWORD(dword_44EAB0) + 132) = (double)*(signed __int16 *)(v3 + dword_44EB1C);
  *(float *)(LODWORD(dword_44EAB0) + 128) = (double)*(signed __int16 *)(v3 + dword_44EB14);
  *(float *)(LODWORD(dword_44EAB0) + 136) = (double)*(signed __int16 *)(v3 + dword_44EB18);
  result = dword_44EAB0;
  *(_DWORD *)(LODWORD(dword_44EAB0) + 76) = *(_DWORD *)(LODWORD(dword_44EAB0) + 124);
  return result;
}
// 44EB10: using guessed type int dword_44EB10;
// 44EB14: using guessed type int dword_44EB14;
// 44EB18: using guessed type int dword_44EB18;
// 44EB1C: using guessed type int dword_44EB1C;

//----- (00431F50) --------------------------------------------------------
char __cdecl sub_431F50(int a1)
{
  unsigned __int8 *v1; // eax
  int v2; // ecx

  v1 = (unsigned __int8 *)dword_44EAA4;
  v2 = 0;
  if ( (_BYTE)dword_44EAA8 )
  {
    while ( *(_BYTE *)(a1 + 4) != *(_BYTE *)(v1[180] + dword_44EB0C) )
    {
      v1 += 552;
      if ( (unsigned __int16)++v2 >= (unsigned __int8)dword_44EAA8 )
        return (char)v1;
    }
    v1[182] = 4;
    *(_DWORD *)(*(_DWORD *)v1 + 12) &= 0x7FFFFFFFu;
    LOBYTE(v1) = *(_BYTE *)(a1 + 4);
    if ( (_BYTE)v1 != 19 )
      LOBYTE(v1) = sub_407E80(0);
  }
  return (char)v1;
}
// 44EAA4: using guessed type int dword_44EAA4;
// 44EAA8: using guessed type int dword_44EAA8;
// 44EB0C: using guessed type int dword_44EB0C;

//----- (00431FC0) --------------------------------------------------------
int sub_431FC0()
{
  int v0; // esi
  int result; // eax
  int v2; // ecx
  int v3; // [esp+4h] [ebp-4h]

  v0 = *(_DWORD *)(dword_44EAA4 + 1104);
  sub_417400(*(unsigned __int8 *)(dword_44EB0C + 2), &v3, 1);
  *(_DWORD *)(v0 + 12) = *(_DWORD *)(v0 + 12) & 0xFF7FBFFF | 0x80000000;
  result = v3;
  byte_44EAA3 = 1;
  v2 = *(_DWORD *)(v3 + 12);
  BYTE1(v2) &= 0xBFu;
  *(_DWORD *)(v3 + 12) = v2;
  return result;
}
// 44EAA3: using guessed type char byte_44EAA3;
// 44EAA4: using guessed type int dword_44EAA4;
// 44EB0C: using guessed type int dword_44EB0C;

//----- (00432020) --------------------------------------------------------
char sub_432020()
{
  char v0; // bl
  int v1; // eax
  _BYTE *v2; // edx
  int v4; // eax
  int v5; // edi
  int *v6; // esi
  int v7; // eax
  int v8; // [esp+0h] [ebp-Ch]
  int v9; // [esp+0h] [ebp-Ch]

  sub_435281((int)aStartingTracke, v8);
  v0 = 0;
  v1 = 0;
  LOBYTE(dword_44EAA8) = 0;
  if ( !dword_455C78 )
    goto LABEL_18;
  v2 = (_BYTE *)(dword_455C74 + 4);
  do
  {
    if ( *v2 == 9 || *v2 == 10 )
      LOBYTE(dword_44EAA8) = ++v0;
    v2 += 104;
    ++v1;
  }
  while ( (unsigned __int16)v1 < (unsigned int)dword_455C78 );
  if ( !v0 )
  {
LABEL_18:
    dword_44EAA4 = 0;
    dword_44DB88 = 0;
    sub_435281((int)aNoTrackerIniti, v9);
    return 0;
  }
  v4 = sub_401250(552 * (unsigned __int8)dword_44EAA8);
  dword_44EAA4 = v4;
  if ( !v4 )
    goto LABEL_10;
  v5 = 0;
  if ( (_BYTE)dword_44EAA8 )
  {
    v6 = (int *)(v4 + 160);
    while ( 1 )
    {
      v7 = sub_401250(12);
      *v6 = v7;
      if ( !v7 )
        break;
      v6 += 138;
      if ( (unsigned __int16)++v5 >= (unsigned __int8)dword_44EAA8 )
        goto LABEL_15;
    }
LABEL_10:
    sub_435281((int)aNotEnouthMemor, v9);
    return 0;
  }
LABEL_15:
  sub_432250();
  sub_432130();
  sub_435281((int)aTrackersInitia, v9);
  return 1;
}
// 44DB88: using guessed type int dword_44DB88;
// 44EAA4: using guessed type int dword_44EAA4;
// 44EAA8: using guessed type int dword_44EAA8;
// 455C74: using guessed type int dword_455C74;
// 455C78: using guessed type int dword_455C78;

//----- (00432130) --------------------------------------------------------
int sub_432130()
{
  int result; // eax
  char v1; // bl
  int v2; // esi
  char v3; // cl
  char *v4; // ST08_4

  result = dword_455C74;
  dword_44EAAC = dword_44EAA4;
  v1 = 0;
  v2 = 0;
  dword_44EAB4 = dword_455C74;
  if ( dword_455C78 )
  {
    while ( 1 )
    {
      v3 = 1;
      if ( *(_BYTE *)(result + 4) == 9 )
        break;
      if ( *(_BYTE *)(result + 4) == 10 )
        goto LABEL_6;
      *(_DWORD *)(result + 100) = 0;
LABEL_10:
      result = dword_44EAB4 + 104;
      ++v2;
      dword_44EAB4 += 104;
      if ( (unsigned __int16)v2 >= (unsigned int)dword_455C78 )
        return result;
    }
    v3 = 0;
LABEL_6:
    *(_DWORD *)(result + 100) = dword_44EAAC;
    *(_DWORD *)dword_44EAAC = dword_44EAB4;
    *(_BYTE *)(dword_44EAAC + 181) = v3;
    *(_BYTE *)(dword_44EAAC + 180) = v1;
    sub_431610(dword_44EAB4);
    *(_DWORD *)(*(_DWORD *)(dword_44EAB4 + 100) + 8) = sub_4089F0(dword_455C8C);
    *(_WORD *)(dword_44EAB4 + 60) = sub_431960((float *)(dword_44EAB4 + 44), 0, v4);
    if ( dword_455BF8 == 3 && *(_BYTE *)(dword_44EAAC + 180) == 2 )
      *(_DWORD *)(dword_44EAB4 + 12) |= 0x804000u;
    ++v1;
    dword_44EAAC += 552;
    goto LABEL_10;
  }
  return result;
}
// 44EAA4: using guessed type int dword_44EAA4;
// 44EAB4: using guessed type int dword_44EAB4;
// 455BF8: using guessed type int dword_455BF8;
// 455C74: using guessed type int dword_455C74;
// 455C78: using guessed type int dword_455C78;
// 455C8C: using guessed type int dword_455C8C;

//----- (00432250) --------------------------------------------------------
char sub_432250()
{
  char result; // al

  switch ( dword_455BF8 )
  {
    case 0:
      dword_44EB0C = (int)&unk_441CA0;
      dword_44EB10 = (int)&unk_441CA4;
      dword_44EB14 = (int)&unk_441CB8;
      dword_44EB18 = (int)&unk_441CCC;
      dword_44EB1C = (int)&unk_441CE0;
      dword_44EB20 = (int)&unk_441D18;
      dword_44EB24 = (int)&unk_441D1C;
      dword_44EB28 = (int)&unk_44EABC;
      dword_44EB2C = (int)&off_441D24;
      dword_44EB30 = (int)&unk_441D28;
      dword_44EB34 = (int)&unk_44EAC0;
      dword_44EB38 = (int)&unk_441D30;
      dword_44EB3C = (int)&unk_441D38;
      dword_44EB40 = (int)&unk_441D40;
      dword_44EB44 = (int)&unk_441D48;
      dword_44EB48 = (int)&unk_441D50;
      dword_44EB4C = (int)&unk_441CF4;
      dword_44EB50 = (int)&unk_441CF8;
      dword_44EB54 = (int)&unk_441CFC;
      dword_44EB58 = (int)&unk_441D00;
      dword_44EB5C = (int)&unk_441D08;
      dword_44EB60 = (int)&unk_441D0C;
      dword_44EB64 = (int)&unk_441D14;
      result = 1;
      break;
    case 2:
    case 12:
      dword_44EB0C = (int)&unk_441D54;
      dword_44EB10 = (int)&unk_441D58;
      dword_44EB14 = (int)&unk_441D6C;
      dword_44EB18 = (int)&unk_441D80;
      dword_44EB1C = (int)&unk_441D94;
      dword_44EB20 = (int)&unk_441DCC;
      dword_44EB24 = (int)&unk_441DD0;
      dword_44EB28 = (int)&unk_44EAC4;
      dword_44EB2C = (int)&off_441DD8;
      dword_44EB30 = (int)&unk_441DDC;
      dword_44EB34 = (int)&unk_44EAC8;
      dword_44EB38 = (int)&unk_441DE4;
      dword_44EB3C = (int)&unk_441DEC;
      dword_44EB40 = (int)&unk_441DF4;
      dword_44EB44 = (int)&unk_441DFC;
      dword_44EB48 = (int)&unk_441E04;
      dword_44EB4C = (int)&unk_441DA8;
      dword_44EB50 = (int)&unk_441DAC;
      dword_44EB54 = (int)&unk_441DB0;
      dword_44EB58 = (int)&unk_441DB4;
      dword_44EB5C = (int)&unk_441DBC;
      dword_44EB60 = (int)&unk_441DC0;
      dword_44EB64 = (int)&unk_441DC8;
      result = 1;
      break;
    case 3:
      dword_44EB0C = (int)&unk_441E08;
      dword_44EB10 = (int)&unk_441E0C;
      dword_44EB14 = (int)&unk_441E20;
      dword_44EB18 = (int)&unk_441E34;
      dword_44EB1C = (int)&unk_441E48;
      dword_44EB20 = (int)&unk_441E80;
      dword_44EB24 = (int)&unk_441E84;
      dword_44EB28 = (int)&unk_44EACC;
      dword_44EB2C = (int)&off_441E8C;
      dword_44EB30 = (int)&unk_441E90;
      dword_44EB34 = (int)&unk_44EAD0;
      dword_44EB38 = (int)&unk_441E98;
      dword_44EB3C = (int)&unk_441EA0;
      dword_44EB40 = (int)&unk_441EA8;
      dword_44EB44 = (int)&unk_441EB0;
      dword_44EB48 = (int)&unk_441EB8;
      dword_44EB4C = (int)&unk_441E5C;
      dword_44EB50 = (int)&unk_441E60;
      dword_44EB54 = (int)&unk_441E64;
      dword_44EB58 = (int)&unk_441E68;
      dword_44EB5C = (int)&unk_441E70;
      dword_44EB60 = (int)&unk_441E74;
      dword_44EB64 = (int)&unk_441E7C;
      result = 1;
      break;
    case 5:
    case 15:
      dword_44EB0C = (int)&unk_441EBC;
      dword_44EB10 = (int)&unk_441EC0;
      dword_44EB14 = (int)&unk_441ED4;
      dword_44EB18 = (int)&unk_441EE8;
      dword_44EB1C = (int)&unk_441EFC;
      dword_44EB20 = (int)&unk_44EAD4;
      dword_44EB24 = (int)&unk_44EAD8;
      dword_44EB28 = (int)&unk_441F34;
      dword_44EB2C = (int)&off_441F38;
      dword_44EB30 = (int)&unk_441F3C;
      dword_44EB34 = (int)&unk_44EAE0;
      dword_44EB38 = (int)&unk_441F44;
      dword_44EB3C = (int)&unk_441F4C;
      dword_44EB40 = (int)&unk_441F54;
      dword_44EB44 = (int)&unk_441F5C;
      dword_44EB48 = (int)&unk_441F64;
      dword_44EB4C = (int)&unk_441F10;
      dword_44EB50 = (int)&unk_441F14;
      dword_44EB54 = (int)&unk_441F18;
      dword_44EB58 = (int)&unk_441F1C;
      dword_44EB5C = (int)&unk_441F24;
      dword_44EB60 = (int)&unk_441F28;
      dword_44EB64 = (int)&unk_441F30;
      result = 1;
      break;
    case 7:
      dword_44EB0C = (int)&unk_441F68;
      dword_44EB10 = (int)&unk_441F6C;
      dword_44EB14 = (int)&unk_441F80;
      dword_44EB18 = (int)&unk_441F94;
      dword_44EB1C = (int)&unk_441FA8;
      dword_44EB20 = (int)&unk_44EAE4;
      dword_44EB24 = (int)&unk_441FE0;
      dword_44EB28 = (int)&unk_44EAE8;
      dword_44EB2C = (int)&off_441FE8;
      dword_44EB30 = (int)&unk_441FEC;
      dword_44EB34 = (int)&unk_44EAEC;
      dword_44EB38 = (int)&unk_441FF4;
      dword_44EB3C = (int)&unk_441FFC;
      dword_44EB40 = (int)&unk_442004;
      dword_44EB44 = (int)&unk_44200C;
      dword_44EB48 = (int)&unk_442014;
      dword_44EB4C = (int)&unk_441FBC;
      dword_44EB50 = (int)&unk_441FC0;
      dword_44EB54 = (int)&unk_441FC4;
      dword_44EB58 = (int)&unk_441FC8;
      dword_44EB5C = (int)&unk_441FD0;
      dword_44EB60 = (int)&unk_441FD4;
      dword_44EB64 = (int)&unk_441FDC;
      result = 1;
      break;
    case 10:
      dword_44EB0C = (int)&unk_442018;
      dword_44EB10 = (int)&unk_44201C;
      dword_44EB14 = (int)&unk_442030;
      dword_44EB18 = (int)&unk_442044;
      dword_44EB1C = (int)&unk_442058;
      dword_44EB20 = (int)&unk_442090;
      dword_44EB24 = (int)&unk_442094;
      dword_44EB28 = (int)&unk_44209C;
      dword_44EB2C = (int)&off_4420A0;
      dword_44EB30 = (int)&unk_4420A4;
      dword_44EB34 = (int)&unk_44EAF0;
      dword_44EB38 = (int)&unk_4420AC;
      dword_44EB3C = (int)&unk_4420B4;
      dword_44EB40 = (int)&unk_4420BC;
      dword_44EB44 = (int)&unk_4420C4;
      dword_44EB48 = (int)&unk_4420CC;
      dword_44EB4C = (int)&unk_44206C;
      dword_44EB50 = (int)&unk_442070;
      dword_44EB54 = (int)&unk_442074;
      dword_44EB58 = (int)&unk_442078;
      dword_44EB5C = (int)&unk_442080;
      dword_44EB60 = (int)&unk_442084;
      dword_44EB64 = (int)&unk_44208C;
      result = 1;
      break;
    case 11:
      dword_44EB0C = (int)&unk_4420D0;
      dword_44EB10 = (int)&unk_4420D4;
      dword_44EB14 = (int)&unk_4420E8;
      dword_44EB18 = (int)aEcec;
      dword_44EB1C = (int)&unk_442110;
      dword_44EB20 = (int)&unk_44EAFC;
      dword_44EB24 = (int)&unk_44EB00;
      dword_44EB28 = (int)&unk_442140;
      dword_44EB2C = (int)&unk_442144;
      dword_44EB30 = (int)&unk_442148;
      dword_44EB34 = (int)&unk_44EB08;
      dword_44EB38 = (int)&unk_442150;
      dword_44EB3C = (int)&unk_442158;
      dword_44EB40 = (int)&unk_442160;
      dword_44EB44 = (int)&unk_442168;
      dword_44EB48 = (int)&unk_442170;
      dword_44EB4C = (int)&unk_44EAF4;
      dword_44EB50 = (int)&unk_442124;
      dword_44EB54 = (int)&unk_44EAF8;
      dword_44EB58 = (int)&unk_442128;
      dword_44EB5C = (int)&unk_442130;
      dword_44EB60 = (int)&unk_442134;
      dword_44EB64 = (int)&unk_44213C;
      result = 1;
      break;
    default:
      result = 0;
      dword_44EB0C = 0;
      dword_44EB10 = 0;
      dword_44EB14 = 0;
      dword_44EB18 = 0;
      dword_44EB1C = 0;
      dword_44EB20 = 0;
      dword_44EB24 = 0;
      dword_44EB28 = 0;
      dword_44EB2C = 0;
      dword_44EB30 = 0;
      dword_44EB34 = 0;
      dword_44EB38 = 0;
      dword_44EB3C = 0;
      dword_44EB40 = 0;
      dword_44EB44 = 0;
      dword_44EB48 = 0;
      dword_44EB4C = 0;
      dword_44EB50 = 0;
      dword_44EB54 = 0;
      dword_44EB58 = 0;
      dword_44EB5C = 0;
      dword_44EB60 = 0;
      dword_44EB64 = 0;
      break;
  }
  return result;
}
// 441D24: using guessed type void *off_441D24;
// 441DD8: using guessed type void *off_441DD8;
// 441E8C: using guessed type void *off_441E8C;
// 441F38: using guessed type void *off_441F38;
// 441FE8: using guessed type void *off_441FE8;
// 4420A0: using guessed type void *off_4420A0;
// 44EB0C: using guessed type int dword_44EB0C;
// 44EB10: using guessed type int dword_44EB10;
// 44EB14: using guessed type int dword_44EB14;
// 44EB18: using guessed type int dword_44EB18;
// 44EB1C: using guessed type int dword_44EB1C;
// 44EB20: using guessed type int dword_44EB20;
// 44EB24: using guessed type int dword_44EB24;
// 44EB28: using guessed type int dword_44EB28;
// 44EB2C: using guessed type int dword_44EB2C;
// 44EB30: using guessed type int dword_44EB30;
// 44EB34: using guessed type int dword_44EB34;
// 44EB38: using guessed type int dword_44EB38;
// 44EB3C: using guessed type int dword_44EB3C;
// 44EB40: using guessed type int dword_44EB40;
// 44EB44: using guessed type int dword_44EB44;
// 44EB48: using guessed type int dword_44EB48;
// 44EB4C: using guessed type int dword_44EB4C;
// 44EB50: using guessed type int dword_44EB50;
// 44EB54: using guessed type int dword_44EB54;
// 44EB58: using guessed type int dword_44EB58;
// 44EB5C: using guessed type int dword_44EB5C;
// 44EB60: using guessed type int dword_44EB60;
// 44EB64: using guessed type int dword_44EB64;
// 455BF8: using guessed type int dword_455BF8;

//----- (00432980) --------------------------------------------------------
int __cdecl sub_432980(__int16 a1)
{
  int result; // eax

  result = 0;
  while ( a1 < (unsigned __int8)byte_442200[result] || a1 >= (unsigned __int8)byte_442201[result] )
  {
    if ( ++result >= 20 )
      return 0;
  }
  return result;
}

//----- (004329B0) --------------------------------------------------------
int sub_4329B0()
{
  int v0; // eax

  v0 = 0;
  while ( BYTE1(dword_455CB0) < (unsigned __int8)byte_442200[v0]
       || BYTE1(dword_455CB0) >= (unsigned __int8)byte_442201[v0] )
  {
    if ( ++v0 >= 20 )
      return 0;
  }
  return (unsigned __int8)byte_442201[v0] - 1;
}
// 455CB0: using guessed type int dword_455CB0;

//----- (004329E0) --------------------------------------------------------
char sub_4329E0()
{
  AGLFILE *v0; // eax
  AGLFILE *v1; // edi
  unsigned int v2; // esi
  _BYTE *v3; // ebp
  bool v4; // zf
  int v5; // edx
  _BYTE *v6; // esi
  unsigned int v7; // edi
  int v8; // ecx
  int v9; // eax
  char v10; // bl

  v0 = sub_403630((int)aDataLocalParam, 2);
  v1 = v0;
  if ( v0 )
  {
    v2 = sub_403700(v0);
    v3 = (_BYTE *)sub_401250(v2);
    sub_4036A0(v1, v3, v2);
    sub_403690(v1);
    v4 = *v3 == 48;
    v5 = (int)&v3[v2 - 1];
    LOBYTE(dword_44EB68[0]) = *v3 - 48;
    v6 = v3 + 2;
    v7 = 0;
    if ( !v4 )
    {
      v8 = 0;
      do
      {
        v9 = 0;
        do
        {
          v10 = (v6++)[1];
          *((_BYTE *)&dword_44EB68[v8] + v9++ + 1) = v10;
        }
        while ( *v6 != 13 && v6 != (_BYTE *)v5 );
        *((_BYTE *)&dword_44EB68[v8] + v9) = 10;
        ++v6;
        ++v7;
        v8 += 4;
      }
      while ( v7 < LOBYTE(dword_44EB68[0]) );
    }
    sub_401380((unsigned int)v3);
    LOBYTE(v0) = sub_401380((unsigned int)v6);
  }
  return (char)v0;
}
// 44EB68: using guessed type int dword_44EB68[];

//----- (00432A80) --------------------------------------------------------
char __cdecl sub_432A80(unsigned __int8 a1)
{
  AGLFILE *v1; // eax
  AGLFILE *v2; // ebx
  unsigned __int16 *v3; // edi
  unsigned int v4; // ebp
  unsigned __int16 *v5; // esi
  unsigned __int16 v6; // ax
  unsigned __int16 v7; // cx
  unsigned __int16 v8; // dx
  int v9; // ecx
  unsigned __int16 *v10; // esi
  unsigned int v11; // edx
  __int16 *v12; // ecx
  unsigned __int16 v13; // ax
  int v14; // eax
  unsigned __int16 v15; // bx
  char v17; // [esp+4h] [ebp-14h]
  unsigned int v18; // [esp+1Ch] [ebp+4h]

  sprintf(&v17, aDataLocalDElb, a1);
  v1 = sub_403630((int)&v17, 2);
  v2 = v1;
  if ( v1 )
  {
    v3 = (unsigned __int16 *)&unk_44F3B4;
    v4 = sub_403700(v1);
    v5 = (unsigned __int16 *)sub_401250(v4);
    v18 = (unsigned int)v5;
    sub_4036A0(v2, v5, v4);
    sub_403690(v2);
    v6 = *v5;
    ++v5;
    LOWORD(dword_443AE0) = v6;
    v7 = *v5;
    ++v5;
    HIWORD(dword_443AE0) = v7;
    v8 = *v5;
    ++v5;
    LOWORD(dword_443AE4) = v8;
    HIWORD(dword_443AE4) = *v5;
    v9 = v8;
    v10 = v5 + 2;
    v11 = 0;
    LOWORD(dword_443AE8) = v6 / v9;
    LOWORD(dword_44EBC0) = *(v10 - 1);
    if ( (_WORD)dword_44EBC0 )
    {
      v12 = word_44EBC4;
      do
      {
        v13 = *v10;
        ++v10;
        *v12 = v13;
        v14 = v13;
        *((_DWORD *)v12 + 1) = v3;
        LOWORD(v14) = *v12;
        if ( *v12 )
        {
          do
          {
            v15 = *v10;
            ++v10;
            *v3 = v15;
            ++v3;
            --v14;
          }
          while ( v14 );
        }
        ++v11;
        v12 += 4;
      }
      while ( v11 < (unsigned __int16)dword_44EBC0 );
    }
    LOBYTE(v1) = sub_401380(v18);
  }
  return (char)v1;
}
// 443AE0: using guessed type int dword_443AE0;
// 443AE4: using guessed type int dword_443AE4;
// 443AE8: using guessed type int dword_443AE8;
// 44EBC0: using guessed type int dword_44EBC0;

//----- (00432BA0) --------------------------------------------------------
int __cdecl sub_432BA0(int a1, int a2)
{
  *(_DWORD *)(a1 + 2532) = a2;
  *(_DWORD *)(a1 + 2512) = sub_432BF0;
  *(_BYTE *)a1 = 5;
  *(_BYTE *)(a1 + 2530) = 1;
  *(_BYTE *)(a1 + 2531) = 8;
  *(_WORD *)(a1 + 2528) = 1;
  return sub_40B9B0(a1, 0x10u, 8u, 0x24u, 0, 0x2Eu, 0xAu);
}

//----- (00432BF0) --------------------------------------------------------
__int16 __cdecl sub_432BF0(int a1, int a2)
{
  char v2; // al
  unsigned __int8 v3; // bl

  v2 = rand();
  v3 = -10 * v2;
  *(_BYTE *)(a2 + 87) = -10 * v2;
  sub_40CD90(a1, a2);
  return sub_40BF30((_WORD *)a2, 32640, 16256, 1024, v3);
}

//----- (00432C50) --------------------------------------------------------
int __cdecl sub_432C50(int a1, int a2)
{
  *(_DWORD *)(a1 + 2532) = a2;
  *(_DWORD *)(a1 + 2512) = sub_432CA0;
  *(_BYTE *)a1 = 7;
  *(_BYTE *)(a1 + 2530) = 1;
  *(_BYTE *)(a1 + 2531) = 1;
  *(_WORD *)(a1 + 2528) = 1;
  return sub_40B9B0(a1, 0x20u, 0x10u, 0x10u, 0, 0x1Au, 0xAu);
}

//----- (00432CA0) --------------------------------------------------------
__int16 __cdecl sub_432CA0(int a1, int a2)
{
  unsigned __int8 v2; // bl

  v2 = 4 * rand() / 0x7FFF + 4;
  *(_BYTE *)(a2 + 87) = v2;
  sub_40CD90(a1, a2);
  return sub_40BF30((_WORD *)a2, 16256, 16256, 16256, v2);
}

//----- (00432D00) --------------------------------------------------------
int __cdecl sub_432D00(int a1)
{
  int v1; // edx
  float v2; // ST24_4

  v1 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 2512) = sub_432D70;
  *(_BYTE *)a1 = 8;
  *(_DWORD *)(a1 + 4) = v1 | 3;
  v2 = dword_44B740 - 1000.0;
  sub_40B920(a1, dword_44B73C, v2, dword_44B744);
  *(_BYTE *)(a1 + 2530) = 1;
  *(_BYTE *)(a1 + 2531) = 32;
  *(_WORD *)(a1 + 2528) = 1;
  return sub_40B9B0(a1, 0x34u, 0x1Au, 0x10u, 0, 0x1Au, 0xAu);
}

//----- (00432D70) --------------------------------------------------------
__int16 __cdecl sub_432D70(int a1, int a2)
{
  _WORD *v2; // esi
  unsigned __int8 v3; // bl
  int v4; // eax
  unsigned int v5; // edx
  int v6; // edi
  int v7; // ebp
  int v8; // ST40_4
  int v9; // ST3C_4
  float v10; // ST38_4
  int v11; // ST3C_4
  float v12; // ST38_4
  int v14; // [esp+24h] [ebp+8h]

  v2 = (_WORD *)a2;
  v3 = 25 * rand() / 0x7FFF + 60;
  *(_BYTE *)(a2 + 87) = v3;
  v4 = rand();
  v5 = (signed int)(4000 * v4 + ((unsigned __int64)(-8589672436000i64 * v4) >> 32)) >> 14;
  v6 = (v5 >> 31) + v5;
  v7 = 800 * rand() / 0x7FFF - 400;
  *(float *)&v8 = (double)(signed __int16)((signed __int16)(900 * rand()) / 0x7FFF - 450);
  *(float *)&v9 = (double)(signed __int16)v7;
  v10 = (double)(signed __int16)v6;
  sub_40BE40(a2, v10, v9, v8);
  sub_40BE80(a2, 10000.0, 1176256512, 1176256512);
  sub_40BE60(a2, -10000.0, -971227136, -971227136);
  v14 = (signed __int16)(-20 * rand() / 0x7FFF);
  *(float *)&v11 = (double)(signed __int16)((signed __int16)(30 * rand()) / 0x7FFF + 15);
  v12 = (double)v14;
  sub_40BEA0((int)v2, v12, v11, 0);
  sub_40BEE0((int)v2, 0.0, 1106247680, 0);
  sub_40BEC0((int)v2, -20.0, 0, 0);
  sub_40BF00((int)v2, 0.0, 0, 0, 1);
  return sub_40BF30(v2, 32640, 32640, 32640, v3);
}

//----- (00432F40) --------------------------------------------------------
int __cdecl sub_432F40(int a1, float *a2, char a3)
{
  int result; // eax
  float v4; // ST24_4
  float v5; // [esp+4h] [ebp-8h]

  byte_4541D8 = a3;
  *(_DWORD *)(a1 + 2512) = sub_432FF0;
  *(_BYTE *)a1 = 9;
  *(_BYTE *)(a1 + 2530) = 1;
  v5 = a2[2];
  if ( byte_4541D8 )
  {
    sub_40B920(a1, *a2, a2[1], v5);
    *(_BYTE *)(a1 + 2531) = 16;
    result = sub_40B9B0(a1, 0xA4u, 0x64u, 0, 0, 0xFu, 0xFu);
  }
  else
  {
    v4 = a2[1] + 40.0;
    sub_40B920(a1, *a2, v4, v5);
    *(_BYTE *)(a1 + 2531) = 6;
    result = sub_40B9B0(a1, 0x60u, 0x40u, 0, 0, 0xFu, 0xFu);
  }
  *(_WORD *)(a1 + 2528) = 1;
  return result;
}
// 4541D8: using guessed type char byte_4541D8;

//----- (00432FF0) --------------------------------------------------------
int __cdecl sub_432FF0(int a1, float a2)
{
  int v2; // esi
  unsigned __int8 v3; // bl
  int v4; // edi
  int v5; // ST3C_4
  float v6; // ST38_4
  float v8; // [esp+20h] [ebp+8h]

  v2 = LODWORD(a2);
  v3 = 8 * rand() / 0x7FFF + 7;
  *(_BYTE *)(LODWORD(a2) + 87) = v3;
  v8 = (double)(signed __int16)(100 * rand() / 0x7FFF - 50);
  sub_40BE40(v2, v8, 0, SLODWORD(v8));
  if ( byte_4541D8 )
  {
    sub_40BE80(v2, -1000.0, 1148846080, 1148846080);
    sub_40BE60(v2, -1000.0, -998637568, -998637568);
  }
  else
  {
    sub_40BE80(v2, -1000.0, 1148846080, 1148846080);
    sub_40BE60(v2, -1000.0, -1054867456, -998637568);
  }
  v4 = 30 * rand() / 0x7FFF - 15;
  *(float *)&v5 = (double)((signed __int16)(-60 * rand()) / 0x7FFF);
  v6 = (double)(signed __int16)v4;
  sub_40BEA0(v2, v6, v5, 0);
  sub_40BEE0(v2, 10.0, 0, 0);
  sub_40BEC0(v2, -10.0, -1054867456, 0);
  sub_40BF00(v2, 0.0, -1063256064, 0, 1);
  sub_40BF30((_WORD *)v2, 16256, 2032, 0, v3);
  return sub_40BF90((_WORD *)v2, 0, -14224, 0, v3);
}
// 4541D8: using guessed type char byte_4541D8;

//----- (00433180) --------------------------------------------------------
unsigned int __cdecl sub_433180(_DWORD *a1, char a2)
{
  char *v2; // esi
  unsigned int result; // eax
  int v4; // eax
  signed int v5; // eax
  int v6; // ecx

  v2 = (char *)&unk_4541E0;
  result = 0;
  while ( v2[12] )
  {
    v2 += 16;
    if ( ++result >= 0x1E )
      return result;
  }
  v2[12] = 1;
  v4 = rand();
  v2[15] = a2;
  v5 = (signed int)(8 * v4 + ((unsigned __int64)(-17179344872i64 * v4) >> 32)) >> 14;
  LOBYTE(v5) = (v5 < 0) + v5 + 2;
  v2[14] = v5;
  *(_DWORD *)v2 = *a1;
  *((_DWORD *)v2 + 1) = a1[1];
  *((_DWORD *)v2 + 2) = a1[2];
  v2[14] = v5 + 4;
  v6 = 8 * rand();
  result = (unsigned int)(v6 + ((unsigned __int64)(-2147418109i64 * v6) >> 32)) >> 31;
  v2[13] = v6 / 0x7FFF + 4;
  return result;
}

//----- (00433210) --------------------------------------------------------
int __cdecl sub_433210(char a1)
{
  int v1; // ebp
  int v2; // edi
  unsigned __int8 *v3; // esi
  int v4; // ecx
  unsigned __int8 v5; // ST2C_1
  unsigned __int8 v6; // ST23_1
  __int16 v7; // dx
  unsigned __int8 v8; // cl
  unsigned __int8 v9; // dl
  double v10; // st7
  bool v11; // zf
  int result; // eax
  signed int v13; // [esp+14h] [ebp-10h]
  signed int v14; // [esp+18h] [ebp-Ch]

  sub_409D20(-180);
  v1 = dword_448ACC;
  v2 = 8;
  v3 = (unsigned __int8 *)&unk_4541EC;
  v13 = 1024;
  v14 = 30;
  do
  {
    if ( *v3 )
    {
      if ( v2 >= *(unsigned __int16 *)(v1 + 10) )
        v4 = 0;
      else
        v4 = v13 + *(_DWORD *)(v1 + 4);
      v5 = -106 - (char)(-106 * (*v3 - 1)) / 12;
      v6 = v3[3];
      *(_BYTE *)(v4 + 33) = v5;
      v7 = v5 / 3;
      *(_WORD *)(v4 + 12) = v6;
      *(_WORD *)(v4 + 14) = v6;
      *(_BYTE *)(v4 + 34) = v7;
      *(_BYTE *)(v4 + 32) = v7;
      if ( a1 )
        sub_40A060((_DWORD *)v1, (_DWORD *)v3 - 3, v2, 1);
      if ( byte_455C14 )
      {
        v8 = v3[1];
        v9 = *v3 + 1;
        v10 = *((float *)v3 - 2) - (double)(char)v3[2];
        *v3 = v9;
        *((float *)v3 - 2) = v10;
        if ( v9 > v8 )
          *v3 = 0;
      }
    }
    v3 += 16;
    ++v2;
    result = v14 - 1;
    v11 = v14 == 1;
    v13 += 128;
    --v14;
  }
  while ( !v11 );
  return result;
}
// 448ACC: using guessed type int dword_448ACC;
// 455C14: using guessed type char byte_455C14;

//----- (00433340) --------------------------------------------------------
void __cdecl sub_433340(unsigned __int8 a1, char a2)
{
  int v2; // ecx
  int v3; // eax
  int v4; // eax
  int v5; // eax
  bool v6; // zf
  int v7; // eax
  unsigned __int8 v8; // [esp+4h] [ebp+4h]

  LOBYTE(v2) = a1;
  if ( a1 < 4u )
  {
    v3 = 0;
    v8 = 0;
    if ( dword_455C54 )
    {
      v2 = (unsigned __int8)v2;
      do
      {
        v4 = *(_DWORD *)(dword_455C50 + 4 * (v2 + 4 * v3));
        if ( HIWORD(v4) == 2 )
        {
          v5 = 3 * (unsigned __int16)v4;
          v6 = *(_BYTE *)(dword_455C60 + 8 * v5 + 12) == 6;
          v7 = dword_455C60 + 8 * v5;
          if ( v6 )
          {
            if ( a2 )
              *(_BYTE *)(v7 + 13) |= 0x80u;
            else
              *(_BYTE *)(v7 + 13) &= 0x7Fu;
          }
        }
        v3 = ++v8;
      }
      while ( v8 < (unsigned int)dword_455C54 );
    }
  }
}
// 455C50: using guessed type int dword_455C50;
// 455C54: using guessed type int dword_455C54;
// 455C60: using guessed type int dword_455C60;

//----- (004333D0) --------------------------------------------------------
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  int result; // eax
  struct tagMSG Msg; // [esp+0h] [ebp-1Ch]

  CreateMutexA(0, 0, Name);
  if ( GetLastError() == 183 )
    return 0;
  if ( (unsigned __int8)sub_433490(hInstance) )
  {
    BYTE2(dword_455CBC) = 1;
    while ( 1 )
    {
      while ( !PeekMessageA(&Msg, 0, 0, 0, 1u) )
      {
        if ( byte_44416E )
        {
          if ( dword_443D2C )
          {
            if ( dword_455CD8 )
              (*(void (**)(void))dword_455CD8)();
          }
        }
        else
        {
          WaitMessage();
        }
      }
      if ( Msg.message == 18 )
        break;
      DispatchMessageA(&Msg);
    }
    sub_403E00();
    sub_433620();
    result = 0;
  }
  else
  {
    sub_433620();
    result = 0;
  }
  return result;
}
// 433490: using guessed type _DWORD __cdecl sub_433490(_DWORD);
// 433620: using guessed type int sub_433620(void);
// 44416E: using guessed type char byte_44416E;
// 455CBC: using guessed type int dword_455CBC;
// 455CD8: using guessed type int dword_455CD8;

//----- (00433490) --------------------------------------------------------
#error "4334E8: call analysis failed (funcsize=97)"

//----- (00433620) --------------------------------------------------------
#error "433634: call analysis failed (funcsize=23)"

//----- (00433640) --------------------------------------------------------
__int16 sub_433640()
{
  byte_44B797 = 1;
  return sub_41E7B0((float *)&dword_4543D8, 1, 1);
}
// 44B797: using guessed type char byte_44B797;
// 4543D8: using guessed type int dword_4543D8;

//----- (00433660) --------------------------------------------------------
float __usercall sub_433660@<eax>()
{
  float result; // eax

  result = dword_44B73C;
  dword_4543D8 = LODWORD(dword_44B73C);
  dword_4543E0 = LODWORD(dword_44B744);
  flt_4543DC = dword_44B740 - 30.0;
  return result;
}
// 4543D8: using guessed type int dword_4543D8;
// 4543DC: using guessed type float flt_4543DC;
// 4543E0: using guessed type int dword_4543E0;

//----- (004336A0) --------------------------------------------------------
int sub_4336A0()
{
  if ( dword_455CD0 < (unsigned int)dword_455BE0 )
  {
    dword_455CC4 += 40;
    if ( (unsigned int)dword_455CC4 > 0x3E8 )
    {
      dword_455CC4 = 0;
      ++dword_454FE4;
    }
    dword_455CD0 = dword_455BE0;
  }
  return dword_454FE4;
}
// 454FE4: using guessed type int dword_454FE4;
// 455BE0: using guessed type int dword_455BE0;
// 455CC4: using guessed type int dword_455CC4;
// 455CD0: using guessed type int dword_455CD0;

//----- (004336F0) --------------------------------------------------------
int __cdecl sub_4336F0(__int16 a1)
{
  int result; // eax

  result = 0;
  if ( (_WORD)dword_455BDC )
    return sub_433720();
  LOWORD(dword_454FF8) = 0;
  LOWORD(dword_455BDC) = a1;
  word_454FEC = 0;
  return result;
}
// 454FEC: using guessed type __int16 word_454FEC;
// 454FF8: using guessed type int dword_454FF8;
// 455BDC: using guessed type int dword_455BDC;

//----- (00433720) --------------------------------------------------------
int sub_433720()
{
  int result; // eax

  LOWORD(dword_454FF8) = 395 / (unsigned __int16)dword_455BDC + dword_454FF8;
  result = 256 / (unsigned __int16)dword_455BDC;
  word_454FEC += result;
  return result;
}
// 454FEC: using guessed type __int16 word_454FEC;
// 454FF8: using guessed type int dword_454FF8;
// 455BDC: using guessed type int dword_455BDC;

//----- (00433750) --------------------------------------------------------
void sub_433750()
{
  LOWORD(dword_455BDC) = 0;
}
// 455BDC: using guessed type int dword_455BDC;

//----- (00433760) --------------------------------------------------------
void *__cdecl sub_433760(int a1, unsigned int a2)
{
  _DWORD *v2; // eax
  int v3; // ecx
  unsigned int v4; // eax
  _DWORD *v5; // ecx
  int v6; // eax
  float v8; // [esp+14h] [ebp+4h]

  v2 = dword_443D2C;
  v3 = *((_DWORD *)dword_443D2C + 16032);
  *((_DWORD *)dword_443D2C + 16032) = v3 + 88;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)v3 = v2[30];
  v2[30] = v3;
  *(_DWORD *)(v3 + 4) = 3;
  *(_BYTE *)(v3 + 26) = -2;
  *(_BYTE *)(v3 + 25) = -20;
  *(_BYTE *)(v3 + 24) = 68;
  v4 = dword_454FF8 + a1 * (0x18Bu / (unsigned __int16)dword_455BDC) / a2;
  if ( (signed __int16)v4 > 380 )
    LOWORD(v4) = 395;
  *(_DWORD *)(v3 + 8) = 1123811328;
  *(_DWORD *)(v3 + 12) = 1137934336;
  v8 = (double)((signed __int16)v4 + 126);
  *(float *)(v3 + 28) = v8;
  *(float *)(v3 + 68) = v8;
  *(_DWORD *)(v3 + 32) = 1137934336;
  *(_DWORD *)(v3 + 48) = 1123811328;
  *(_DWORD *)(v3 + 52) = 1138130944;
  *(_DWORD *)(v3 + 72) = 1138130944;
  *(_DWORD *)(v3 + 16) = 0;
  *(_DWORD *)(v3 + 20) = 1065353216;
  *(_DWORD *)(v3 + 36) = 0;
  *(_DWORD *)(v3 + 40) = 1065353216;
  *(_DWORD *)(v3 + 56) = 0;
  *(_DWORD *)(v3 + 60) = 1065353216;
  *(_DWORD *)(v3 + 76) = 0;
  *(_DWORD *)(v3 + 80) = 1065353216;
  sub_402A90();
  v5 = dword_443D2C;
  v6 = *((_DWORD *)dword_443D2C + 16032);
  *((_DWORD *)dword_443D2C + 16032) = v6 + 88;
  *(_DWORD *)(v6 + 4) = 0;
  *(_DWORD *)v6 = v5[30];
  v5[30] = v6;
  *(_DWORD *)(v6 + 8) = 1123811328;
  *(_DWORD *)(v6 + 48) = 1123811328;
  *(_DWORD *)(v6 + 4) = 3;
  *(_BYTE *)(v6 + 26) = -2;
  *(_BYTE *)(v6 + 25) = -20;
  *(_BYTE *)(v6 + 24) = 68;
  *(_DWORD *)(v6 + 12) = 1137934336;
  *(float *)(v6 + 28) = v8;
  *(_DWORD *)(v6 + 32) = 1137934336;
  *(_DWORD *)(v6 + 52) = 1138130944;
  *(float *)(v6 + 68) = v8;
  *(_DWORD *)(v6 + 72) = 1138130944;
  *(_DWORD *)(v6 + 16) = 0;
  *(_DWORD *)(v6 + 20) = 1065353216;
  *(_DWORD *)(v6 + 36) = 0;
  *(_DWORD *)(v6 + 40) = 1065353216;
  *(_DWORD *)(v6 + 56) = 0;
  *(_DWORD *)(v6 + 60) = 1065353216;
  *(_DWORD *)(v6 + 76) = 0;
  *(_DWORD *)(v6 + 80) = 1065353216;
  return sub_402A90();
}
// 454FF8: using guessed type int dword_454FF8;
// 455BDC: using guessed type int dword_455BDC;

//----- (004338A0) --------------------------------------------------------
char __cdecl sub_4338A0(int a1)
{
  unsigned __int8 *v1; // eax
  unsigned __int8 *v2; // esi

  v1 = (unsigned __int8 *)sub_401D60(a1);
  v2 = v1;
  if ( v1 )
  {
    if ( *v1 == 2 )
    {
      sub_401DB0(v1, 0, 0, 0, 0, 0);
      sub_402A90();
      sub_401DB0(v2, 0, 0, 0, 0, 0);
      sub_402A90();
    }
    LOBYTE(v1) = sub_401E40((unsigned int)v2);
  }
  return (char)v1;
}

//----- (00433900) --------------------------------------------------------
int __cdecl sub_433900(unsigned int a1, char a2, char a3)
{
  unsigned int v3; // ecx
  int v4; // eax
  unsigned __int8 *v5; // ebp
  unsigned __int16 v6; // dx
  int v7; // ebp
  AGLFILE *v8; // esi
  int v9; // eax
  int v10; // esi
  _BYTE *v11; // eax
  int v12; // ecx
  _DWORD *v13; // ecx
  int v14; // eax
  int v15; // ecx
  _DWORD *v16; // eax
  int v17; // esi
  int v18; // ecx
  const char *v20; // [esp+8h] [ebp-4Ch]
  unsigned __int8 v21; // [esp+Ch] [ebp-48h]
  unsigned int i; // [esp+10h] [ebp-44h]
  int v23; // [esp+14h] [ebp-40h]
  char v24; // [esp+18h] [ebp-3Ch]
  char v25; // [esp+34h] [ebp-20h]
  unsigned __int8 *v26; // [esp+60h] [ebp+Ch]

  dword_455BF8 = a1;
  if ( a1 == 9 || a1 == 6 || a1 == 1 || a1 == 14 )
  {
    LOBYTE(dword_44B814) = 0;
  }
  else if ( a1 == 4 || a1 == 8 || a1 == 11 || a1 == 13 )
  {
    LOBYTE(dword_44B814) = 2;
  }
  else
  {
    LOBYTE(dword_44B814) = 1;
  }
  sub_401580(1);
  byte_443AF2 = 110;
  byte_443AF1 = 110;
  byte_443AF0 = 110;
  byte_455C14 = 0;
  byte_455C34 = 0;
  byte_455C35 = 0;
  dword_455C18 = 0;
  dword_455C1C = 0;
  byte_455CA7 = 0;
  dword_455C8C = 0;
  byte_455CAA = 0;
  if ( a1 == 16 )
  {
    v3 = 16;
  }
  else
  {
    v3 = a1;
    flt_455C08 = 3.4e38;
    flt_455C0C = -3.4e38;
    word_455C10 = 0;
    LOWORD(dword_455C98) = 0;
    byte_455C12 = 0;
    HIBYTE(dword_455CB0) = 0;
    if ( a1 < 0xC )
    {
      dword_455BF8 = a1;
      byte_455CA7 = 1;
    }
    word_44B800 = 0;
  }
  if ( a2 )
  {
    switch ( a2 )
    {
      case 1:
        v4 = 44 * v3;
        byte_442391[v4] = 109;
        byte_44239C[v4] = 116;
        byte_44239D[v4] = 101;
        byte_44239E[v4] = 120;
        v20 = &byte_442388[44 * v3];
        if ( v3 < 0xC )
          v21 = v3 - 72;
        break;
      case 2:
        v20 = aDataGraphNextl;
        goto LABEL_26;
      case 3:
        v20 = aDataGraphGameo;
        goto LABEL_26;
      case 4:
        v20 = aDataGraphTitle;
        goto LABEL_26;
      case 5:
        v20 = aDataGraphDemol;
        goto LABEL_26;
      case 6:
        v20 = aDataGraphQuitt;
LABEL_26:
        v21 = -1;
        break;
      default:
        break;
    }
    byte_443AF2 = 0;
    byte_443AF1 = 0;
    byte_443AF0 = -1;
    v5 = (unsigned __int8 *)sub_401D60((int)v20);
    if ( v5 )
    {
      i = 0;
      do
      {
        sub_401DB0(v5, 0, 0, 0, 0, 0);
        if ( v21 != -1 )
        {
          sub_401580(1);
          byte_443AF2 = -2;
          byte_443AF1 = -20;
          byte_443AF0 = 68;
          sub_4015D0(0x10000000u, 35, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, v21);
          sub_401D10();
          sub_401580(2);
          v6 = word_44EBC4[4 * v21];
          byte_443AF2 = -106;
          byte_443AF1 = -106;
          byte_443AF0 = -106;
          sub_4015D0(
            (*((_DWORD *)dword_443D44 + 2) - (unsigned __int16)dword_443AE4 * v6 + 3) / 2,
            38,
            (unsigned __int16)dword_443AE4,
            HIWORD(dword_443AE4),
            1,
            v21);
          sub_401D10();
        }
        sub_402A90();
        ++i;
      }
      while ( i < 2 );
      sub_401E40((unsigned int)v5);
    }
    strcpy(&v25, v20);
    v3 = a1;
  }
  if ( v3 < 0xC )
    byte_442391[44 * v3] = 108;
  v7 = 44 * a1;
  v23 = v7;
  byte_44239C[v7] = 112;
  byte_44239D[v7] = 105;
  byte_44239E[v7] = 110;
  sub_408C80(15);
  sub_41F870();
  dword_455BE8 = 0;
  dword_455BEC = 0;
  byte_455CA5 = 0;
  if ( a3 & 2 )
    sub_4206D0((int)sub_433760);
  else
    sub_4206D0(0);
  sub_4336F0(2);
  sub_420750((int)&byte_442388[v7]);
  if ( a2 == 1 && a1 < 0x10 && (_BYTE)dword_44B814 == 1 )
  {
    switch ( a1 )
    {
      case 0u:
        v20 = aDataGraphPlanN;
        break;
      case 2u:
        v20 = aDataGraphPlanN_0;
        break;
      case 3u:
        v20 = aDataGraphPlanN_1;
        break;
      case 5u:
        v20 = aDataGraphPlanN_2;
        break;
      case 7u:
        v20 = aDataGraphPlanN_3;
        break;
      case 0xAu:
        v20 = aDataGraphPlanN_4;
        break;
      default:
        break;
    }
    v8 = sub_401D60((int)v20);
    if ( v8 )
    {
      if ( *((_DWORD *)dword_443D44 + 1) < 200 )
        sub_402A90();
      v9 = 0;
      i = 0;
      do
      {
        sub_401DB0((unsigned __int8 *)v8, 0, 0, v9 << 8, 0, *((_WORD *)v8 + 2));
        sub_402A90();
        v9 = i++ + 1;
      }
      while ( i < 2 );
      sub_401E40((unsigned int)v8);
    }
    v21 = -1;
    strcpy(&v25, v20);
  }
  sub_433720();
  if ( a1 == 16 )
  {
    sub_420750((int)aDataLevelItems);
  }
  else
  {
    if ( a1 >= 0xC )
      sprintf(&v24, aDataDemosItem0, dword_455BF8 + 1);
    else
      sprintf(&v24, aDataLevelItem0, dword_455BF8 + 1);
    sub_420750((int)&v24);
  }
  sub_420710();
  sub_433750();
  v10 = dword_455C74;
  for ( i = 0; i < dword_455C78; ++i )
  {
    *(_BYTE *)(v10 + 6) = sub_40A5E0(*(unsigned __int8 *)(v10 + 6));
    *(_BYTE *)(v10 + 7) = sub_40A5E0(*(unsigned __int8 *)(v10 + 7));
    if ( *(_BYTE *)(v10 + 4) == 90 )
    {
      LODWORD(dword_44B71C) = sub_4089F0(dword_448AC4 + 48 * *(unsigned __int8 *)(v10 + 6));
      sub_408670(dword_44B71C, 9, 0);
      flt_44B7D8 = *(float *)(v10 + 32);
      dword_44B7DC = *(_DWORD *)(v10 + 36);
      flt_44B7E0 = *(float *)(v10 + 40);
    }
    else if ( *(_BYTE *)(v10 + 4) == 91 )
    {
      v11 = sub_4089F0(dword_448AC4 + 48 * *(unsigned __int8 *)(v10 + 6));
      LODWORD(dword_44B700) = v11;
      if ( a1 == 9 || a1 == 6 || a1 == 1 || a1 == 14 )
        v12 = *(_DWORD *)(LODWORD(dword_44B71C) + 180) + 472;
      else
        v12 = *(_DWORD *)(LODWORD(dword_44B71C) + 180) + 236;
      *((_DWORD *)v11 + 1) = v12;
      sub_408670(dword_44B700, 9, 0);
    }
    else if ( *(_BYTE *)(v10 + 4) < 0x5Au )
    {
      sub_416160(v10);
    }
    v10 += 104;
  }
  if ( dword_455BF8 != 16 )
  {
    v26 = (unsigned __int8 *)sub_401D60((int)&v25);
    word_442382 = 16;
    word_442380 = 0;
    if ( !(dword_455BEC & 0xF008) )
    {
      do
      {
        sub_401DB0(v26, 0, 0, 0, 0, 0);
        sub_401580(1);
        byte_443AF2 = -1 - word_442380;
        byte_443AF1 = -1 - word_442380;
        byte_443AF0 = -1 - word_442380;
        sub_4015D0(0x131u, 448, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, 0x1Cu);
        sub_401D10();
        v13 = dword_443D2C;
        v14 = *((_DWORD *)dword_443D2C + 16032);
        *((_DWORD *)dword_443D2C + 16032) = v14 + 88;
        *(_DWORD *)(v14 + 4) = 0;
        *(_DWORD *)v14 = v13[30];
        v13[30] = v14;
        *(_DWORD *)(v14 + 4) = 3;
        *(_BYTE *)(v14 + 26) = -2;
        *(_BYTE *)(v14 + 25) = -20;
        *(_BYTE *)(v14 + 24) = 68;
        *(_DWORD *)(v14 + 8) = 1123811328;
        *(_DWORD *)(v14 + 12) = 1137934336;
        *(_DWORD *)(v14 + 28) = 1140998144;
        *(_DWORD *)(v14 + 32) = 1137934336;
        *(_DWORD *)(v14 + 48) = 1123811328;
        *(_DWORD *)(v14 + 52) = 1138130944;
        *(_DWORD *)(v14 + 68) = 1140998144;
        *(_DWORD *)(v14 + 72) = 1138130944;
        *(_DWORD *)(v14 + 16) = 0;
        *(_DWORD *)(v14 + 20) = 1065353216;
        *(_DWORD *)(v14 + 36) = 0;
        *(_DWORD *)(v14 + 40) = 1065353216;
        *(_DWORD *)(v14 + 56) = 0;
        *(_DWORD *)(v14 + 60) = 1065353216;
        *(_DWORD *)(v14 + 76) = 0;
        *(_DWORD *)(v14 + 80) = 1065353216;
        if ( v21 != -1 )
        {
          sub_401580(1);
          byte_443AF2 = -2;
          byte_443AF1 = -20;
          byte_443AF0 = 68;
          sub_4015D0(0x10000000u, 35, (unsigned __int16)dword_443AE4, HIWORD(dword_443AE4), 1, v21);
          sub_401D10();
          sub_401580(2);
          v15 = (unsigned __int16)dword_443AE4 * (unsigned __int16)word_44EBC4[4 * v21];
          byte_443AF2 = -106;
          byte_443AF1 = -106;
          byte_443AF0 = -106;
          sub_4015D0(
            (*((_DWORD *)dword_443D44 + 2) - v15 + 3) / 2,
            38,
            (unsigned __int16)dword_443AE4,
            HIWORD(dword_443AE4),
            1,
            v21);
          sub_401D10();
        }
        v16 = dword_443D2C;
        v17 = *((_DWORD *)dword_443D2C + 16032);
        *((_DWORD *)dword_443D2C + 16032) = v17 + 128;
        *(_DWORD *)(v17 + 4) = 0;
        *(_DWORD *)v17 = v16[30];
        v16[30] = v17;
        *(_DWORD *)(v17 + 20) = 1138753536;
        *(_DWORD *)(v17 + 48) = 1138753536;
        *(_DWORD *)(v17 + 16) = 1132593152;
        *(_DWORD *)(v17 + 76) = 1139769344;
        *(_DWORD *)(v17 + 104) = 1139769344;
        *(_DWORD *)(v17 + 44) = 1133641728;
        *(_DWORD *)(v17 + 72) = 1132593152;
        *(_DWORD *)(v17 + 100) = 1133641728;
        *(_DWORD *)(v17 + 40) = 1039726841;
        *(_DWORD *)(v17 + 68) = 1039726841;
        *(_BYTE *)(v17 + 34) = -1;
        *(_BYTE *)(v17 + 33) = -1;
        *(_BYTE *)(v17 + 32) = -1;
        *(_DWORD *)(v17 + 4) = 5;
        *(_DWORD *)(v17 + 24) = 0;
        *(_DWORD *)(v17 + 28) = 1065353216;
        *(_DWORD *)(v17 + 52) = 0;
        *(_DWORD *)(v17 + 56) = 1065353216;
        *(_DWORD *)(v17 + 80) = 0;
        *(_DWORD *)(v17 + 84) = 1065353216;
        *(_DWORD *)(v17 + 108) = 0;
        *(_DWORD *)(v17 + 112) = 1065353216;
        *(_DWORD *)(v17 + 36) = 1060945085;
        *(_DWORD *)(v17 + 64) = 1062918875;
        *(_DWORD *)(v17 + 92) = 1060945085;
        *(_DWORD *)(v17 + 96) = 1047589105;
        *(_DWORD *)(v17 + 120) = 1062918875;
        *(_DWORD *)(v17 + 124) = 1047589105;
        *(_DWORD *)(v17 + 8) = sub_401000(0, 0, 1263, 31);
        sub_404530();
        sub_434560();
        sub_4345A0();
        sub_402A90();
      }
      while ( !(dword_455BEC & 0xF008) );
      v7 = v23;
    }
    word_442382 = 8;
    sub_401E40((unsigned int)v26);
  }
  sub_4345F0();
  sub_402A90();
  sub_403730(0x32u);
  dword_4441C8 = (int (*)(void))__inc_tmpoff;
  sub_40BFD0();
  sub_41E960();
  sub_4171C0();
  sub_419450();
  sub_423580();
  if ( sub_432020() )
    sub_42E5A0();
  if ( dword_455BF8 != 16 && (_BYTE)dword_455CBC && BYTE1(dword_455CBC) )
    (*(void (__stdcall **)(_DWORD, signed int, _DWORD))(**((_DWORD **)dword_443D24 + 88) + 80))(
      *((_DWORD *)dword_443D24 + 88),
      2,
      (unsigned __int8)dword_455CBC);
  byte_455CB4 = 0;
  sub_404530();
  sub_402EB0(2);
  nullsub_1(256);
  sub_407AE0((int)(&off_4423A8)[11 * dword_455BF8], 0, (int)&dword_444908);
  if ( dword_4449D0 )
  {
    switch ( dword_455BF8 )
    {
      case 0:
        *(_BYTE *)(dword_444908 + 46) = 1;
        *(_BYTE *)(dword_444920 + 46) = 1;
        break;
      case 1:
        *(_BYTE *)(dword_444938 + 46) = 1;
        *(_BYTE *)(dword_444920 + 46) = 1;
        break;
      case 3:
        *(_BYTE *)(dword_444944 + 46) = 1;
        break;
      case 4:
        v18 = dword_444944;
        goto LABEL_99;
      case 5:
        *(_BYTE *)(dword_444908 + 46) = 1;
        *(_BYTE *)(dword_444914 + 46) = 1;
        break;
      case 6:
        *(_BYTE *)(dword_444908 + 46) = 1;
        *(_BYTE *)(dword_444914 + 46) = 1;
        break;
      case 7:
        *(_BYTE *)(dword_444908 + 46) = 1;
        v18 = dword_444914;
        goto LABEL_99;
      case 9:
        *(_BYTE *)(dword_444908 + 46) = 1;
        *(_BYTE *)(dword_444914 + 46) = 1;
        v18 = dword_444920;
LABEL_99:
        *(_BYTE *)(v18 + 46) = 1;
        break;
      default:
        break;
    }
    if ( *(int *)((char *)dword_4423A0 + v7) && a2 != 5 )
      sub_407BB0(a1);
  }
  sub_434690(1u, 0);
  sub_4011E0((int *)&i);
  return nullsub_1(aTotalMemD);
}
// 433690: using guessed type int __inc_tmpoff();
// 434B40: using guessed type int __cdecl nullsub_1(_DWORD);
// 442380: using guessed type __int16 word_442380;
// 442382: using guessed type __int16 word_442382;
// 4423A0: using guessed type int dword_4423A0[];
// 4423A8: using guessed type char *off_4423A8;
// 443AE4: using guessed type int dword_443AE4;
// 443AF0: using guessed type char byte_443AF0;
// 443AF1: using guessed type char byte_443AF1;
// 443AF2: using guessed type char byte_443AF2;
// 4441C8: using guessed type int (*dword_4441C8)(void);
// 444908: using guessed type int dword_444908;
// 444914: using guessed type int dword_444914;
// 444920: using guessed type int dword_444920;
// 444938: using guessed type int dword_444938;
// 444944: using guessed type int dword_444944;
// 4449D0: using guessed type int dword_4449D0;
// 448AC4: using guessed type int dword_448AC4;
// 44B7D8: using guessed type float flt_44B7D8;
// 44B7DC: using guessed type int dword_44B7DC;
// 44B7E0: using guessed type float flt_44B7E0;
// 44B800: using guessed type __int16 word_44B800;
// 44B814: using guessed type int dword_44B814;
// 455BE8: using guessed type int dword_455BE8;
// 455BEC: using guessed type int dword_455BEC;
// 455BF8: using guessed type int dword_455BF8;
// 455C08: using guessed type float flt_455C08;
// 455C0C: using guessed type float flt_455C0C;
// 455C10: using guessed type __int16 word_455C10;
// 455C12: using guessed type char byte_455C12;
// 455C14: using guessed type char byte_455C14;
// 455C18: using guessed type int dword_455C18;
// 455C1C: using guessed type int dword_455C1C;
// 455C34: using guessed type char byte_455C34;
// 455C35: using guessed type char byte_455C35;
// 455C74: using guessed type int dword_455C74;
// 455C78: using guessed type int dword_455C78;
// 455C8C: using guessed type int dword_455C8C;
// 455C98: using guessed type int dword_455C98;
// 455CA5: using guessed type char byte_455CA5;
// 455CA7: using guessed type char byte_455CA7;
// 455CAA: using guessed type char byte_455CAA;
// 455CB0: using guessed type int dword_455CB0;
// 455CB4: using guessed type char byte_455CB4;
// 455CBC: using guessed type int dword_455CBC;

//----- (00434400) --------------------------------------------------------
int sub_434400()
{
  if ( (_BYTE)dword_455CBC )
    (*(void (__stdcall **)(_DWORD, signed int, _DWORD))(**((_DWORD **)dword_443D24 + 88) + 80))(
      *((_DWORD *)dword_443D24 + 88),
      2,
      0);
  sub_402A40(dword_443D2C);
  sub_4345F0();
  sub_402A90();
  sub_4345F0();
  sub_402A90();
  sub_434530();
  sub_40ABD0();
  sub_41F920();
  sub_40AC80();
  sub_416FB0();
  sub_4170A0();
  sub_4171A0();
  sub_4228E0();
  sub_422950();
  sub_4229D0();
  sub_40B560();
  sub_408D30();
  sub_407E60();
  sub_407C30();
  return sub_401500();
}
// 455CBC: using guessed type int dword_455CBC;

//----- (00434490) --------------------------------------------------------
char *sub_434490()
{
  dword_44B81A = 0;
  byte_455CA4 = 0;
  dword_44B81E = 0;
  byte_455CA3 = 0;
  dword_44B822 = 0;
  dword_455BF8 = 0;
  dword_455C00 = 255;
  LOBYTE(dword_44B808) = 4;
  HIBYTE(dword_44B804) = 8;
  BYTE2(dword_44B808) = 6;
  word_44B7FE = 0;
  if ( !byte_455CAB || (LOBYTE(dword_44B804) = 13, !(dword_455CAC & 2)) )
    LOBYTE(dword_44B804) = 1;
  return sub_41FC40();
}
// 44B7FE: using guessed type __int16 word_44B7FE;
// 44B804: using guessed type int dword_44B804;
// 44B808: using guessed type int dword_44B808;
// 44B81A: using guessed type int dword_44B81A;
// 44B81E: using guessed type int dword_44B81E;
// 44B822: using guessed type int dword_44B822;
// 455BF8: using guessed type int dword_455BF8;
// 455C00: using guessed type int dword_455C00;
// 455CA3: using guessed type char byte_455CA3;
// 455CA4: using guessed type char byte_455CA4;
// 455CAB: using guessed type char byte_455CAB;
// 455CAC: using guessed type int dword_455CAC;

//----- (00434500) --------------------------------------------------------
char __cdecl sub_434500(unsigned __int8 a1)
{
  char result; // al

  result = unk_455CBA;
  if ( unk_455CBA )
  {
    result = BYTE2(dword_454FF4);
    if ( !BYTE2(dword_454FF4) )
    {
      BYTE2(dword_454FF4) = 1;
      result = sub_404250(1u, a1);
    }
  }
  return result;
}
// 454FF4: using guessed type int dword_454FF4;

//----- (00434530) --------------------------------------------------------
char sub_434530()
{
  char result; // al

  result = BYTE2(dword_454FF4);
  if ( BYTE2(dword_454FF4) )
  {
    BYTE2(dword_454FF4) = 0;
    result = sub_404340(1u);
  }
  return result;
}
// 454FF4: using guessed type int dword_454FF4;

//----- (00434550) --------------------------------------------------------
char sub_434550()
{
  return BYTE2(dword_454FF4);
}
// 454FF4: using guessed type int dword_454FF4;

//----- (00434560) --------------------------------------------------------
int sub_434560()
{
  int result; // eax

  dword_455BE8 = dword_455BEC;
  result = sub_404900();
  dword_455BEC = result;
  return result;
}
// 455BE8: using guessed type int dword_455BE8;
// 455BEC: using guessed type int dword_455BEC;

//----- (00434580) --------------------------------------------------------
int __cdecl sub_434580(__int16 a1, __int16 a2)
{
  int result; // eax

  result = (a2 - a1) & 0xFFF;
  if ( (signed __int16)result > 2048 )
    result -= 4096;
  return result;
}

//----- (004345A0) --------------------------------------------------------
__int16 sub_4345A0()
{
  __int16 result; // ax
  __int16 v1; // cx

  result = word_442382;
  v1 = word_442382 + word_442380;
  word_442380 += word_442382;
  if ( word_442382 <= 0 )
  {
    if ( v1 <= 15 )
    {
      result = -word_442382;
      word_442380 = 15;
      word_442382 = -word_442382;
    }
  }
  else if ( v1 >= 255 )
  {
    result = -word_442382;
    word_442380 = 255;
    word_442382 = -word_442382;
  }
  return result;
}
// 442380: using guessed type __int16 word_442380;
// 442382: using guessed type __int16 word_442382;

//----- (004345F0) --------------------------------------------------------
int sub_4345F0()
{
  _DWORD *v0; // ecx
  int result; // eax
  double v2; // st7
  double v3; // st7

  v0 = dword_443D2C;
  result = *((_DWORD *)dword_443D2C + 16032);
  *((_DWORD *)dword_443D2C + 16032) = result + 88;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)result = v0[30];
  v0[30] = result;
  *(_DWORD *)(result + 4) = 3;
  *(_BYTE *)(result + 26) = 0;
  *(_BYTE *)(result + 25) = 0;
  *(_BYTE *)(result + 24) = 0;
  *(_DWORD *)(result + 8) = -1063256064;
  *(_DWORD *)(result + 12) = -1063256064;
  v2 = (double)*((signed int *)dword_443D44 + 2);
  *(_DWORD *)(result + 32) = -1063256064;
  *(_DWORD *)(result + 48) = -1063256064;
  *(float *)(result + 28) = v2;
  *(float *)(result + 52) = (double)*((signed int *)dword_443D44 + 3);
  *(float *)(result + 68) = (double)*((signed int *)dword_443D44 + 2);
  v3 = (double)*((signed int *)dword_443D44 + 3);
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 1065353216;
  *(_DWORD *)(result + 36) = 0;
  *(float *)(result + 72) = v3;
  *(_DWORD *)(result + 40) = 1065353216;
  *(_DWORD *)(result + 56) = 0;
  *(_DWORD *)(result + 60) = 1065353216;
  *(_DWORD *)(result + 76) = 0;
  *(_DWORD *)(result + 80) = 1065353216;
  return result;
}

//----- (00434690) --------------------------------------------------------
int __cdecl sub_434690(unsigned __int8 a1, char a2)
{
  int result; // eax

  LOBYTE(dword_455004) = a1;
  result = a1 - 1;
  byte_455CCC = a2;
  switch ( a1 )
  {
    case 1u:
    case 2u:
    case 4u:
      byte_455CCD = -1;
      break;
    case 5u:
    case 6u:
    case 8u:
      byte_455CCD = 0;
      break;
    default:
      return result;
  }
  return result;
}
// 455004: using guessed type int dword_455004;
// 455CCC: using guessed type char byte_455CCC;
// 455CCD: using guessed type char byte_455CCD;

//----- (004346F0) --------------------------------------------------------
char sub_4346F0()
{
  unsigned __int16 v1; // ax
  char v2; // cl
  int v3; // eax
  _DWORD *v4; // ecx
  int v5; // eax
  double v6; // st7
  double v7; // st7
  _DWORD *v8; // eax
  _DWORD *v9; // esi
  unsigned __int16 v10; // ax

  if ( !(_BYTE)dword_455004 )
    return 0;
  if ( sub_434920() )
  {
    LOBYTE(dword_455004) = 0;
  }
  else if ( !byte_455CA5 )
  {
    switch ( (unsigned __int8)dword_455004 )
    {
      case 1u:
      case 2u:
      case 4u:
        v1 = 14 * (unsigned __int8)dword_455004;
        if ( (unsigned __int8)byte_455CCD > v1 )
        {
          v2 = byte_455CCD - v1;
          goto LABEL_13;
        }
        byte_455CCD = 0;
        break;
      case 5u:
      case 6u:
      case 8u:
        v3 = 14 * ((unsigned __int8)dword_455004 - 1) - 56;
        if ( 255 - (unsigned __int8)byte_455CCD > (unsigned __int16)v3 )
        {
          v2 = v3 + byte_455CCD;
LABEL_13:
          byte_455CCD = v2;
        }
        else
        {
          byte_455CCD = -1;
        }
        break;
      default:
        break;
    }
  }
  v4 = dword_443D2C;
  v5 = *((_DWORD *)dword_443D2C + 16032);
  *((_DWORD *)dword_443D2C + 16032) = v5 + 88;
  *(_DWORD *)(v5 + 4) = 0;
  *(_DWORD *)v5 = v4[30];
  v4[30] = v5;
  *(_DWORD *)(v5 + 4) = 3;
  *(_BYTE *)(v5 + 26) = byte_455CCD;
  *(_BYTE *)(v5 + 25) = byte_455CCD;
  *(_BYTE *)(v5 + 24) = byte_455CCD;
  *(_DWORD *)(v5 + 8) = 0;
  *(_DWORD *)(v5 + 12) = 0;
  v6 = (double)*((signed int *)dword_443D44 + 2);
  *(_DWORD *)(v5 + 32) = 0;
  *(_DWORD *)(v5 + 48) = 0;
  *(float *)(v5 + 28) = v6;
  *(float *)(v5 + 52) = (double)*((signed int *)dword_443D44 + 3);
  *(float *)(v5 + 68) = (double)*((signed int *)dword_443D44 + 2);
  v7 = (double)*((signed int *)dword_443D44 + 3);
  *(_DWORD *)(v5 + 16) = 0;
  *(_DWORD *)(v5 + 20) = 1065353216;
  *(_DWORD *)(v5 + 36) = 0;
  *(float *)(v5 + 72) = v7;
  *(_DWORD *)(v5 + 40) = 1065353216;
  *(_DWORD *)(v5 + 56) = 0;
  *(_DWORD *)(v5 + 60) = 1065353216;
  *(_DWORD *)(v5 + 76) = 0;
  *(_DWORD *)(v5 + 80) = 1065353216;
  *(_DWORD *)(v5 + 4) = 259;
  v8 = dword_443D2C;
  v9 = (_DWORD *)*((_DWORD *)dword_443D2C + 16032);
  *((_DWORD *)dword_443D2C + 16032) = v9 + 3;
  v9[1] = 0;
  *v9 = v8[30];
  v8[30] = v9;
  if ( byte_455CCC )
    v10 = sub_401000(0, 1, *((_DWORD *)dword_443D44 + 2), 0);
  else
    v10 = sub_401000(0, 2, *((_DWORD *)dword_443D44 + 2), 0);
  sub_402EC0((int)v9, 0, 0, v10);
  return dword_455004;
}
// 455004: using guessed type int dword_455004;
// 455CA5: using guessed type char byte_455CA5;
// 455CCC: using guessed type char byte_455CCC;
// 455CCD: using guessed type char byte_455CCD;

//----- (004348E0) --------------------------------------------------------
bool sub_4348E0()
{
  return (_BYTE)dword_455004 && ((unsigned __int8)dword_455004 <= 2u || (_BYTE)dword_455004 == 4);
}
// 455004: using guessed type int dword_455004;

//----- (00434900) --------------------------------------------------------
bool sub_434900()
{
  return (_BYTE)dword_455004
      && (unsigned __int8)dword_455004 >= 5u
      && ((unsigned __int8)dword_455004 <= 6u || (_BYTE)dword_455004 == 8);
}
// 455004: using guessed type int dword_455004;

//----- (00434920) --------------------------------------------------------
bool sub_434920()
{
  return sub_4348E0() && !byte_455CCD || sub_434900() && byte_455CCD == -1;
}
// 455CCD: using guessed type char byte_455CCD;

//----- (00434E10) --------------------------------------------------------
int __cdecl sub_434E10(int a1)
{
  int result; // eax

  dword_454FF0 = a1;
  result = 8 * a1 + 4466368;
  dword_455CD8 = result;
  *(_DWORD *)(result + 4) = 1;
  return result;
}
// 454FF0: using guessed type int dword_454FF0;
// 455CD8: using guessed type int dword_455CD8;

//----- (00434E30) --------------------------------------------------------
int sub_434E30()
{
  int result; // eax

  _cfltcvt_init_27();
  dword_455CEC = _ms_p5_mp_test_fdiv();
  result = _setdefaultprecision();
  __asm { fnclex }
  return result;
}
// 434E48: using guessed type int _cfltcvt_init_27(void);
// 435413: using guessed type int _setdefaultprecision(void);
// 435463: using guessed type int _ms_p5_mp_test_fdiv(void);
// 455CEC: using guessed type int dword_455CEC;

//----- (00434FDF) --------------------------------------------------------
int __cdecl sub_434FDF(char *a1)
{
  return atol(a1);
}

//----- (00435281) --------------------------------------------------------
int __cdecl sub_435281(int a1, int a2)
{
  int v2; // edi
  int v3; // ebx

  _lock_file2(1, &stru_442FB8);
  v2 = _stbuf(&stru_442FB8);
  v3 = _output(&stru_442FB8, a1, (int)&a2);
  _ftbuf(v2, &stru_442FB8);
  _unlock_file2(1, &stru_442FB8);
  return v3;
}
// 4370A5: using guessed type _DWORD __cdecl _lock_file2(_DWORD, _DWORD);
// 4370F7: using guessed type _DWORD __cdecl _unlock_file2(_DWORD, _DWORD);
// 43711A: using guessed type _DWORD __cdecl _stbuf(_DWORD);
// 4371A7: using guessed type _DWORD __cdecl _ftbuf(_DWORD, _DWORD);

//----- (0043841A) --------------------------------------------------------
int __cdecl sub_43841A(int a1, int a2)
{
  return _ld12cvt(a1, a2, &unk_443368);
}
// 4382AE: using guessed type _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD);

//----- (00438430) --------------------------------------------------------
int __cdecl sub_438430(int a1, int a2)
{
  return _ld12cvt(a1, a2, &unk_443380);
}
// 4382AE: using guessed type _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD);

//----- (00438446) --------------------------------------------------------
int __cdecl sub_438446(int a1, int a2)
{
  char v3; // [esp+0h] [ebp-Ch]

  __strgtold12(&v3, &a2, a2, 0, 0, 0, 0);
  return sub_43841A((int)&v3, a1);
}
// 439F9A: using guessed type _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00438473) --------------------------------------------------------
int __cdecl sub_438473(int a1, int a2)
{
  char v3; // [esp+0h] [ebp-Ch]

  __strgtold12(&v3, &a2, a2, 0, 0, 0, 0);
  return sub_438430((int)&v3, a1);
}
// 439F9A: using guessed type _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0043988D) --------------------------------------------------------
int sub_43988D()
{
  return flsall(1);
}
// 439896: using guessed type _DWORD __cdecl flsall(_DWORD);

#error "There were 3 decompilation failure(s) on 599 function(s)"
